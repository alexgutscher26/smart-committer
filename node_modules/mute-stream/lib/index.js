const Stream = require('stream')

class MuteStream extends Stream {
  #isTTY = null

  constructor (opts = {}) {
    super(opts)
    this.writable = this.readable = true
    this.muted = false
    this.on('pipe', this._onpipe)
    this.replace = opts.replace

    // For readline-type situations
    // This much at the start of a line being redrawn after a ctrl char
    // is seen (such as backspace) won't be redrawn as the replacement
    this._prompt = opts.prompt || null
    this._hadControl = false
  }

  #destSrc (key, def) {
    if (this._dest) {
      return this._dest[key]
    }
    if (this._src) {
      return this._src[key]
    }
    return def
  }

  #proxy (method, ...args) {
    if (typeof this._dest?.[method] === 'function') {
      this._dest[method](...args)
    }
    if (typeof this._src?.[method] === 'function') {
      this._src[method](...args)
    }
  }

  get isTTY () {
    if (this.#isTTY !== null) {
      return this.#isTTY
    }
    return this.#destSrc('isTTY', false)
  }

  // basically just get replace the getter/setter with a regular value
  set isTTY (val) {
    this.#isTTY = val
  }

  get rows () {
    return this.#destSrc('rows')
  }

  get columns () {
    return this.#destSrc('columns')
  }

  /**
   * Mutes the current audio or video stream.
   *
   * This method sets the `muted` property to `true`, effectively silencing any audio or muting any video output.
   *
   * @method mute
   * @instance
   * @memberof AudioVideoStream
   */
  mute () {
    this.muted = true
  }

  /**
   * Mutes the current instance of the object.
   *
   * @function
   */
  unmute () {
    this.muted = false
  }

  /**
   * Sets the source of the data stream.
   *
   * @param {string} src - The source data to be set.
   */
  _onpipe (src) {
    this._src = src
  }

  /**
   * Pipes the output of the current stream to another destination stream.
   *
   * @param {WritableStream} dest - The destination stream where data will be piped.
   * @param {Object} [options] - Optional options to pass to the `super.pipe` method.
   * @returns {WritableStream} - The destination stream after piping.
   * @throws {Error} If the destination is not a writable stream.
   *
   * @example
   * const readable = new ReadableStream();
   * const writable = new WritableStream();
   * readable.pipe(writable);
   */
  pipe (dest, options) {
    this._dest = dest
    return super.pipe(dest, options)
  }

  /**
   * Pauses the media playback if there is a source set.
   *
   * @function pause
   * @memberof MediaControl
   * @instance
   * @return {void}
   */
  pause () {
    if (this._src) {
      return this._src.pause()
    }
  }

  /**
   * Resumes the reading of the source stream if it is paused.
   *
   * @throws {Error} If the source stream does not have a `resume` method or if it encounters an error during resuming.
   */
  resume () {
    if (this._src) {
      return this._src.resume()
    }
  }

  /**
   * Emits data to the stream.
   *
   * @param {string} c - The character to be written.
   * @returns {boolean} - Returns true if the character is muted and a prompt is present, otherwise false.
   * @throws {Error} - Throws an error if the input character matches a control sequence.
   */
  write (c) {
    if (this.muted) {
      if (!this.replace) {
        return true
      }
      // eslint-disable-next-line no-control-regex
      if (c.match(/^\u001b/)) {
        if (c.indexOf(this._prompt) === 0) {
          c = c.slice(this._prompt.length)
          c = c.replace(/./g, this.replace)
          c = this._prompt + c
        }
        this._hadControl = true
        return this.emit('data', c)
      } else {
        if (this._prompt && this._hadControl &&
          c.indexOf(this._prompt) === 0) {
          this._hadControl = false
          this.emit('data', this._prompt)
          c = c.slice(this._prompt.length)
        }
        c = c.toString().replace(/./g, this.replace)
      }
    }
    this.emit('data', c)
  }

  /**
   * Emits an 'end' event and optionally processes and emits the input data if not muted.
   *
   * @param {string} [c] - The input data to process. If null or undefined, no data is emitted.
   * @returns {void}
   */
  end (c) {
    if (this.muted) {
      if (c && this.replace) {
        c = c.toString().replace(/./g, this.replace)
      } else {
        c = null
      }
    }
    if (c) {
      this.emit('data', c)
    }
    this.emit('end')
  }

  /**
   * Destroys the current instance by invoking the 'destroy' method on its proxy.
   *
   * @param {...*} args - Any arguments to be passed to the 'destroy' method of the proxy.
   * @returns {*} - The result of calling the 'destroy' method on the proxy.
   * @throws {Error} - If the proxy does not have a 'destroy' method, an error will be thrown.
   *
   * Example:
   * ```javascript
   * instance.destroy('someArgument');
   * ```
   */
  destroy (...args) {
    return this.#proxy('destroy', ...args)
  }

  /**
   * Calls the 'destroySoon' method on the proxy object with the provided arguments.
   *
   * @param {...any} args - Arguments to pass to the 'destroySoon' method.
   * @returns {Promise<void>} A Promise that resolves when the 'destroySoon' method completes.
   * @throws {Error} If an error occurs during the execution of the 'destroySoon' method.
   *
   * @example
   * instance.destroySoon(arg1, arg2)
   */
  destroySoon (...args) {
    return this.#proxy('destroySoon', ...args)
  }

  /**
   * Closes the resource or connection associated with this object.
   *
   * @param {...*} args - Additional arguments required for closing the resource. The specific parameters depend on the implementation.
   * @returns {Promise<void>} A promise that resolves when the resource has been successfully closed.
   * @throws {Error} If an error occurs during the closing process.
   */
  close (...args) {
    return this.#proxy('close', ...args)
  }
}

module.exports = MuteStream
