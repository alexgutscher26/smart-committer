const Stream = require('stream')

class MuteStream extends Stream {
  #isTTY = null

  constructor (opts = {}) {
    super(opts)
    this.writable = this.readable = true
    this.muted = false
    this.on('pipe', this._onpipe)
    this.replace = opts.replace

    // For readline-type situations
    // This much at the start of a line being redrawn after a ctrl char
    // is seen (such as backspace) won't be redrawn as the replacement
    this._prompt = opts.prompt || null
    this._hadControl = false
  }

  #destSrc (key, def) {
    if (this._dest) {
      return this._dest[key]
    }
    if (this._src) {
      return this._src[key]
    }
    return def
  }

  #proxy (method, ...args) {
    if (typeof this._dest?.[method] === 'function') {
      this._dest[method](...args)
    }
    if (typeof this._src?.[method] === 'function') {
      this._src[method](...args)
    }
  }

  get isTTY () {
    if (this.#isTTY !== null) {
      return this.#isTTY
    }
    return this.#destSrc('isTTY', false)
  }

  // basically just get replace the getter/setter with a regular value
  set isTTY (val) {
    this.#isTTY = val
  }

  get rows () {
    return this.#destSrc('rows')
  }

  get columns () {
    return this.#destSrc('columns')
  }

  /**
   * Mutes the audio or video element.
   *
   * @returns {undefined}
   */
  mute () {
    this.muted = true
  }

  /**
   * Sets the muted property of the object to false.
   * This method is used to unmute an object that might have been previously muted.
   *
   * @example
   * // Assuming 'myObject' has a 'muted' property and an 'unmute' method
   * myObject.unmute();
   * console.log(myObject.muted); // Outputs: false
   */
  unmute () {
    this.muted = false
  }

  /**
   * Sets the source of the pipe.
   *
   * @param {string} src - The source to set for the pipe.
   */
  _onpipe (src) {
    this._src = src
  }

  /**
   * Pipes the output of the current stream to another destination stream.
   *
   * @param {Stream} dest - The destination stream to which the output should be piped.
   * @param {Object} options - Optional options for piping, such as `end` which determines whether to call `end()` on the destination stream when the source stream ends.
   * @returns {Stream} - The current stream.
   *
   * @example
   * const readable = new Readable();
   * const writable = new Writable();
   * readable.pipe(writable, { end: false });
   */
  pipe (dest, options) {
    this._dest = dest
    return super.pipe(dest, options)
  }

  /**
   * Pauses the media playback if the source is available.
   *
   * @returns {undefined}
   */
  pause () {
    if (this._src) {
      return this._src.pause()
    }
  }

  resume () {
    if (this._src) {
      return this._src.resume()
    }
  }

  /**
   * Writes data to the output stream. If the stream is muted, it may replace characters or handle control sequences based on the configuration.
   *
   * @param {string} c - The data to be written.
   * @returns {boolean} - Returns true if the character was replaced and the prompt was handled; otherwise, false.
   *
   * If the stream is muted and the character matches a control sequence (starting with '\u001b'), it may replace characters or handle prompts. If the character is not a control sequence but contains the prompt, it may replace characters based on the configuration. The method emits 'data' events for the processed data.
   *
   * @throws {Error} - Throws an error if the input data is invalid.
   */
  write (c) {
    if (this.muted) {
      if (!this.replace) {
        return true
      }
      // eslint-disable-next-line no-control-regex
      if (c.match(/^\u001b/)) {
        if (c.indexOf(this._prompt) === 0) {
          c = c.slice(this._prompt.length)
          c = c.replace(/./g, this.replace)
          c = this._prompt + c
        }
        this._hadControl = true
        return this.emit('data', c)
      } else {
        if (this._prompt && this._hadControl &&
          c.indexOf(this._prompt) === 0) {
          this._hadControl = false
          this.emit('data', this._prompt)
          c = c.slice(this._prompt.length)
        }
        c = c.toString().replace(/./g, this.replace)
      }
    }
    this.emit('data', c)
  }

  /**
   * Emits the 'end' event to indicate that no more data will be emitted.
   *
   * @param {string} [c] - Optional string parameter. If provided and this instance is not muted, the string is replaced using the replace property before emitting.
   * @fires end - Emitted when no more data will be processed or emitted.
   */
  end (c) {
    if (this.muted) {
      if (c && this.replace) {
        c = c.toString().replace(/./g, this.replace)
      } else {
        c = null
      }
    }
    if (c) {
      this.emit('data', c)
    }
    this.emit('end')
  }

  /**
   * Destroys the current instance by calling the 'destroy' method on the proxy object.
   *
   * @param {...*} args - Any arguments to be passed to the 'destroy' method.
   * @returns {void}
   */
  destroy (...args) {
    return this.#proxy('destroy', ...args)
  }

  /**
   * Calls the 'destroySoon' method on the internal proxy object with the provided arguments.
   *
   * @param {...*} args - Arguments to pass to the 'destroySoon' method.
   * @returns {*} - The result of calling the 'destroySoon' method.
   */
  destroySoon (...args) {
    return this.#proxy('destroySoon', ...args)
  }

  /**
   * Closes the current instance or resource.
   *
   * @param {...any} args - Arguments to pass to the underlying `close` method.
   * @returns {Promise<void>} A promise that resolves when the close operation is complete.
   * @throws {Error} If an error occurs during the close operation.
   */
  close (...args) {
    return this.#proxy('close', ...args)
  }
}

module.exports = MuteStream
