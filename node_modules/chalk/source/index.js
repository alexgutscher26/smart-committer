'use strict';
const ansiStyles = require('ansi-styles');
const {stdout: stdoutColor, stderr: stderrColor} = require('supports-color');
const {
	stringReplaceAll,
	stringEncaseCRLFWithFirstIndex
} = require('./util');

const {isArray} = Array;

// `supportsColor.level` â†’ `ansiStyles.color[name]` mapping
const levelMapping = [
	'ansi',
	'ansi',
	'ansi256',
	'ansi16m'
];

const styles = Object.create(null);

const applyOptions = (object, options = {}) => {
	if (options.level && !(Number.isInteger(options.level) && options.level >= 0 && options.level <= 3)) {
		throw new Error('The `level` option should be an integer from 0 to 3');
	}

	// Detect level if not set manually
	const colorLevel = stdoutColor ? stdoutColor.level : 0;
	object.level = options.level === undefined ? colorLevel : options.level;
};

class ChalkClass {
	constructor(options) {
		// eslint-disable-next-line no-constructor-return
		return chalkFactory(options);
	}
}

/**
 * Creates a new instance of the Chalk library with the provided options.
 *
 * @param {Object} [options={}] - The configuration options for the Chalk instance.
 * @returns {Function} A template function that can be used to colorize strings.
 *
 * @throws {Error} Throws an error if `chalk.constructor()` is called.
 *
 * @example
 * const chalk = require('chalk');
 * const myChalk = chalkFactory({ level: 'ansi256' });
 * console.log(myChalk.blue('Hello, world!'));
 */
const chalkFactory = options => {
	const chalk = {};
	applyOptions(chalk, options);

	chalk.template = (...arguments_) => chalkTag(chalk.template, ...arguments_);

	Object.setPrototypeOf(chalk, Chalk.prototype);
	Object.setPrototypeOf(chalk.template, chalk);

	chalk.template.constructor = () => {
		throw new Error('`chalk.constructor()` is deprecated. Use `new chalk.Instance()` instead.');
	};

	chalk.template.Instance = ChalkClass;

	return chalk.template;
};

/**
 * Creates a new instance of the Chalk class with the provided options.
 *
 * @param {Object} [options] - Optional configuration object for customization.
 * @returns {Chalk} - A new instance of the Chalk class.
 *
 * Example:
 * const chalk = new Chalk({ colors: ['red', 'green'] });
 */
function Chalk(options) {
	return chalkFactory(options);
}

for (const [styleName, style] of Object.entries(ansiStyles)) {
	styles[styleName] = {
		get() {
			const builder = createBuilder(this, createStyler(style.open, style.close, this._styler), this._isEmpty);
			Object.defineProperty(this, styleName, {value: builder});
			return builder;
		}
	};
}

styles.visible = {
	get() {
		const builder = createBuilder(this, this._styler, true);
		Object.defineProperty(this, 'visible', {value: builder});
		return builder;
	}
};

const usedModels = ['rgb', 'hex', 'keyword', 'hsl', 'hsv', 'hwb', 'ansi', 'ansi256'];

for (const model of usedModels) {
	styles[model] = {
		get() {
			const {level} = this;
			return function (...arguments_) {
				const styler = createStyler(ansiStyles.color[levelMapping[level]][model](...arguments_), ansiStyles.color.close, this._styler);
				return createBuilder(this, styler, this._isEmpty);
			};
		}
	};
}

for (const model of usedModels) {
	const bgModel = 'bg' + model[0].toUpperCase() + model.slice(1);
	styles[bgModel] = {
		get() {
			const {level} = this;
			return function (...arguments_) {
				const styler = createStyler(ansiStyles.bgColor[levelMapping[level]][model](...arguments_), ansiStyles.bgColor.close, this._styler);
				return createBuilder(this, styler, this._isEmpty);
			};
		}
	};
}

const proto = Object.defineProperties(() => {}, {
	...styles,
	level: {
		enumerable: true,
		get() {
			return this._generator.level;
		},
		set(level) {
			this._generator.level = level;
		}
	}
});

/**
 * Creates a styler object with open and close symbols.
 *
 * @param {string} open - The opening symbol.
 * @param {string} close - The closing symbol.
 * @param {object|undefined} parent - Optional parent styler object. If provided, the new styler will have its open and close symbols prefixed or suffixed by the parent's symbols.
 * @returns {object} A styler object with properties open, close, openAll, closeAll, and parent.
 *
 * @example
 * // Create a styler for parentheses without a parent
 * const styler = createStyler('(', ')');
 * console.log(styler); // { open: '(', close: ')', openAll: '(', closeAll: ')' }
 *
 * // Create a styler with a parent
 * const parentStyler = createStyler('<', '>');
 * const childStyler = createStyler('p', '/p', parentStyler);
 * console.log(childStyler); // { open: 'p', close: '/p', openAll: '<p>', closeAll: '</p>' }
 */
const createStyler = (open, close, parent) => {
	let openAll;
	let closeAll;
	if (parent === undefined) {
		openAll = open;
		closeAll = close;
	} else {
		openAll = parent.openAll + open;
		closeAll = close + parent.closeAll;
	}

	return {
		open,
		close,
		openAll,
		closeAll,
		parent
	};
};

/**
 * Creates a builder function that can apply styling to strings or template literals.
 *
 * @param {Function} self - The current instance context.
 * @param {Function} _styler - A styler function for applying styles.
 * @param {boolean} _isEmpty - Indicates if the builder should be empty initially.
 * @returns {Function} - A builder function that can apply styles to strings or template literals.
 *
 * @example
 * const chalk = require('chalk');
 * const builder = createBuilder(self, chalk, false);
 * console.log(builder.red`2 + 3 = {bold ${2+3}}`);
 */
const createBuilder = (self, _styler, _isEmpty) => {
	/**
	 * A utility function to build styled text using template literals or by concatenating multiple arguments.
	 *
	 * @param {...(Array|string)} arguments_ - The arguments passed to the function. If it's an array with a `raw` property,
	 * it's treated as a template literal, otherwise, it's concatenated as is.
	 * @returns {string} The styled text built from the provided arguments.
	 * @throws {Error} Throws an error if invalid arguments are passed.
	 *
	 * @example
	 * // Using template literals
	 * const chalk = require('chalk');
	 * console.log(builder(chalk.red`2 + 3 = {bold ${2+3}}`)); // Outputs: "2 + 3 = **5**"
	 *
	 * // Concatenating multiple arguments
	 * console.log(builder("Hello", "World")); // Outputs: "Hello World"
	 */
	const builder = (...arguments_) => {
		if (isArray(arguments_[0]) && isArray(arguments_[0].raw)) {
			// Called as a template literal, for example: chalk.red`2 + 3 = {bold ${2+3}}`
			return applyStyle(builder, chalkTag(builder, ...arguments_));
		}

		// Single argument is hot path, implicit coercion is faster than anything
		// eslint-disable-next-line no-implicit-coercion
		return applyStyle(builder, (arguments_.length === 1) ? ('' + arguments_[0]) : arguments_.join(' '));
	};

	// We alter the prototype because we must return a function, but there is
	// no way to create a function with a different prototype
	Object.setPrototypeOf(builder, proto);

	builder._generator = self;
	builder._styler = _styler;
	builder._isEmpty = _isEmpty;

	return builder;
};

/**
 * Applies styling to a given string based on the provided style configuration.
 *
 * @param {object} self - The current context or object that contains styling information.
 * @param {string} string - The input string to which styles need to be applied.
 * @returns {string} - The styled string with applied colors and formatting.
 * @throws {Error} - Throws an error if the string is invalid.
 *
 * Example:
 * const styleConfig = {
 *   openAll: '\x1b[31m',
 *   closeAll: '\x1b[0m'
 * };
 * const styledString = applyStyle({ _styler: styleConfig }, 'Hello, World!');
 * console.log(styledString); // Outputs: "\x1b[31mHello, World!\x1b[0m"
 */
const applyStyle = (self, string) => {
	if (self.level <= 0 || !string) {
		return self._isEmpty ? '' : string;
	}

	let styler = self._styler;

	if (styler === undefined) {
		return string;
	}

	const {openAll, closeAll} = styler;
	if (string.indexOf('\u001B') !== -1) {
		while (styler !== undefined) {
			// Replace any instances already present with a re-opening code
			// otherwise only the part of the string until said closing code
			// will be colored, and the rest will simply be 'plain'.
			string = stringReplaceAll(string, styler.close, styler.open);

			styler = styler.parent;
		}
	}

	// We can move both next actions out of loop, because remaining actions in loop won't have
	// any/visible effect on parts we add here. Close the styling before a linebreak and reopen
	// after next line to fix a bleed issue on macOS: https://github.com/chalk/chalk/pull/92
	const lfIndex = string.indexOf('\n');
	if (lfIndex !== -1) {
		string = stringEncaseCRLFWithFirstIndex(string, closeAll, openAll, lfIndex);
	}

	return openAll + string + closeAll;
};

let template;
/**
 * A function that formats strings using Chalk for styling.
 *
 * @param {Object} chalk - An instance of the Chalk library.
 * @param {...string|string[]} strings - The string template or array of strings to format.
 * @returns {string} - The formatted string.
 * @throws {TypeError} - If the input is not a valid string template.
 *
 * @example
 * const chalk = require('chalk');
 * console.log(chalkTag(chalk, 'Hello {0}', 'World')); // Output: Hello World
 */
const chalkTag = (chalk, ...strings) => {
	const [firstString] = strings;

	if (!isArray(firstString) || !isArray(firstString.raw)) {
		// If chalk() was called by itself or with a string,
		// return the string itself as a string.
		return strings.join(' ');
	}

	const arguments_ = strings.slice(1);
	const parts = [firstString.raw[0]];

	for (let i = 1; i < firstString.length; i++) {
		parts.push(
			String(arguments_[i - 1]).replace(/[{}\\]/g, '\\$&'),
			String(firstString.raw[i])
		);
	}

	if (template === undefined) {
		template = require('./templates');
	}

	return template(chalk, parts.join(''));
};

Object.defineProperties(Chalk.prototype, styles);

const chalk = Chalk(); // eslint-disable-line new-cap
chalk.supportsColor = stdoutColor;
chalk.stderr = Chalk({level: stderrColor ? stderrColor.level : 0}); // eslint-disable-line new-cap
chalk.stderr.supportsColor = stderrColor;

module.exports = chalk;
