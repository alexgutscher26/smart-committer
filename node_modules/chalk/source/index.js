'use strict';
const ansiStyles = require('ansi-styles');
const {stdout: stdoutColor, stderr: stderrColor} = require('supports-color');
const {
	stringReplaceAll,
	stringEncaseCRLFWithFirstIndex
} = require('./util');

const {isArray} = Array;

// `supportsColor.level` â†’ `ansiStyles.color[name]` mapping
const levelMapping = [
	'ansi',
	'ansi',
	'ansi256',
	'ansi16m'
];

const styles = Object.create(null);

/**
 * Applies options to an object, setting the `level` property based on provided or detected values.
 *
 * @param {Object} object - The object to which options will be applied.
 * @param {Object} [options={}] - The options object containing optional settings.
 * @param {number} [options.level] - The level of detail or intensity for the operation. Should be an integer from 0 to 3. If not provided, it defaults to the detected color level.
 * @throws {Error} Throws an error if the `level` option is provided but is not a valid integer between 0 and 3.
 */
const applyOptions = (object, options = {}) => {
	if (options.level && !(Number.isInteger(options.level) && options.level >= 0 && options.level <= 3)) {
		throw new Error('The `level` option should be an integer from 0 to 3');
	}

	// Detect level if not set manually
	const colorLevel = stdoutColor ? stdoutColor.level : 0;
	object.level = options.level === undefined ? colorLevel : options.level;
};

class ChalkClass {
	constructor(options) {
		// eslint-disable-next-line no-constructor-return
		return chalkFactory(options);
	}
}

/**
 * Factory function to create a new instance of Chalk with the given options.
 *
 * @param {Object} options - The configuration options for the Chalk instance.
 * @return {Function} A new instance of Chalk, which is also a function.
 * @throws {Error} Throws an error if `chalk.constructor()` is called.
 */
const chalkFactory = options => {
	const chalk = {};
	applyOptions(chalk, options);

	chalk.template = (...arguments_) => chalkTag(chalk.template, ...arguments_);

	Object.setPrototypeOf(chalk, Chalk.prototype);
	Object.setPrototypeOf(chalk.template, chalk);

	chalk.template.constructor = () => {
		throw new Error('`chalk.constructor()` is deprecated. Use `new chalk.Instance()` instead.');
	};

	chalk.template.Instance = ChalkClass;

	return chalk.template;
};

/**
 * Creates an instance of Chalk with the given options.
 *
 * @param {Object} [options] - Configuration options for the Chalk instance.
 * @returns {Function} - A function that can be used to style strings in the terminal.
 */
function Chalk(options) {
	return chalkFactory(options);
}

for (const [styleName, style] of Object.entries(ansiStyles)) {
	styles[styleName] = {
		get() {
			const builder = createBuilder(this, createStyler(style.open, style.close, this._styler), this._isEmpty);
			Object.defineProperty(this, styleName, {value: builder});
			return builder;
		}
	};
}

styles.visible = {
	get() {
		const builder = createBuilder(this, this._styler, true);
		Object.defineProperty(this, 'visible', {value: builder});
		return builder;
	}
};

const usedModels = ['rgb', 'hex', 'keyword', 'hsl', 'hsv', 'hwb', 'ansi', 'ansi256'];

for (const model of usedModels) {
	styles[model] = {
		get() {
			const {level} = this;
			return function (...arguments_) {
				const styler = createStyler(ansiStyles.color[levelMapping[level]][model](...arguments_), ansiStyles.color.close, this._styler);
				return createBuilder(this, styler, this._isEmpty);
			};
		}
	};
}

for (const model of usedModels) {
	const bgModel = 'bg' + model[0].toUpperCase() + model.slice(1);
	styles[bgModel] = {
		get() {
			const {level} = this;
			return function (...arguments_) {
				const styler = createStyler(ansiStyles.bgColor[levelMapping[level]][model](...arguments_), ansiStyles.bgColor.close, this._styler);
				return createBuilder(this, styler, this._isEmpty);
			};
		}
	};
}

const proto = Object.defineProperties(() => {}, {
	...styles,
	level: {
		enumerable: true,
		get() {
			return this._generator.level;
		},
		set(level) {
			this._generator.level = level;
		}
	}
});

/**
 * Creates a styler object with open and close tags for HTML elements.
 *
 * @param {string} open - The opening tag of the HTML element.
 * @param {string} close - The closing tag of the HTML element.
 * @param {Object} [parent] - An optional parent styler object to inherit from.
 * @returns {Object} A styler object containing the open and close tags, along with inherited properties.
 *
 * Example:
 * const style = createStyler('<div>', '</div>');
 * console.log(style); // Output: { open: '<div>', close: '</div>', openAll: '<div>', closeAll: '</div>', parent: undefined }
 */
const createStyler = (open, close, parent) => {
	let openAll;
	let closeAll;
	if (parent === undefined) {
		openAll = open;
		closeAll = close;
	} else {
		openAll = parent.openAll + open;
		closeAll = close + parent.closeAll;
	}

	return {
		open,
		close,
		openAll,
		closeAll,
		parent
	};
};

/**
 * Creates a builder function that can handle both string concatenation and template literal styling.
 *
 * @param {Object} self - The context for the builder.
 * @param {Function} _styler - A styler function to apply styles.
 * @param {boolean} _isEmpty - Indicates if the builder should be empty.
 * @returns {Function} - The created builder function.
 */
const createBuilder = (self, _styler, _isEmpty) => {
	/**
	 * Constructs a styled string or applies styles to arguments.
	 *
	 * @param {...*} arguments_ - The arguments to process. Can be a template literal with styles, or individual arguments to join and style.
	 * @returns {string} - The styled string.
	 * @example
	 * // Using as a template literal:
	 * const styledString = builder(chalk.red`2 + 3 = {bold ${2+3}}`);
	 *
	 * // Using with individual arguments:
	 * const styledString = builder('Hello', 'world');
	 */
	const builder = (...arguments_) => {
		if (isArray(arguments_[0]) && isArray(arguments_[0].raw)) {
			// Called as a template literal, for example: chalk.red`2 + 3 = {bold ${2+3}}`
			return applyStyle(builder, chalkTag(builder, ...arguments_));
		}

		// Single argument is hot path, implicit coercion is faster than anything
		// eslint-disable-next-line no-implicit-coercion
		return applyStyle(builder, (arguments_.length === 1) ? ('' + arguments_[0]) : arguments_.join(' '));
	};

	// We alter the prototype because we must return a function, but there is
	// no way to create a function with a different prototype
	Object.setPrototypeOf(builder, proto);

	builder._generator = self;
	builder._styler = _styler;
	builder._isEmpty = _isEmpty;

	return builder;
};

/**
 * Applies style to a given string using the provided styler object. Handles nested styling and line breaks.
 *
 * @param {Object} self - The context object that contains the level and styler properties.
 * @param {string} string - The string to which the style should be applied.
 * @returns {string} - The styled string.
 * @throws {Error} - Throws an error if the styler is invalid or if the input string is empty.
 */
const applyStyle = (self, string) => {
	if (self.level <= 0 || !string) {
		return self._isEmpty ? '' : string;
	}

	let styler = self._styler;

	if (styler === undefined) {
		return string;
	}

	const {openAll, closeAll} = styler;
	if (string.indexOf('\u001B') !== -1) {
		while (styler !== undefined) {
			// Replace any instances already present with a re-opening code
			// otherwise only the part of the string until said closing code
			// will be colored, and the rest will simply be 'plain'.
			string = stringReplaceAll(string, styler.close, styler.open);

			styler = styler.parent;
		}
	}

	// We can move both next actions out of loop, because remaining actions in loop won't have
	// any/visible effect on parts we add here. Close the styling before a linebreak and reopen
	// after next line to fix a bleed issue on macOS: https://github.com/chalk/chalk/pull/92
	const lfIndex = string.indexOf('\n');
	if (lfIndex !== -1) {
		string = stringEncaseCRLFWithFirstIndex(string, closeAll, openAll, lfIndex);
	}

	return openAll + string + closeAll;
};

let template;
/**
 * Custom tag function to handle string interpolation with chalk for color formatting.
 *
 * @param {Object} chalk - The Chalk instance for applying styles.
 * @param {...string|string[]} strings - The template literals and substitutions.
 * @returns {string} - The formatted string with applied styles.
 * @throws {TypeError} - If the first argument is not an array or does not contain a `raw` property.
 *
 * @example
 * const chalk = require('chalk');
 * console.log(chalkTag(chalk, 'Hello', '{red}world{reset}'));
 * // Output: Hello \x1B[31mworld\x1B[0m
 */
const chalkTag = (chalk, ...strings) => {
	const [firstString] = strings;

	if (!isArray(firstString) || !isArray(firstString.raw)) {
		// If chalk() was called by itself or with a string,
		// return the string itself as a string.
		return strings.join(' ');
	}

	const arguments_ = strings.slice(1);
	const parts = [firstString.raw[0]];

	for (let i = 1; i < firstString.length; i++) {
		parts.push(
			String(arguments_[i - 1]).replace(/[{}\\]/g, '\\$&'),
			String(firstString.raw[i])
		);
	}

	if (template === undefined) {
		template = require('./templates');
	}

	return template(chalk, parts.join(''));
};

Object.defineProperties(Chalk.prototype, styles);

const chalk = Chalk(); // eslint-disable-line new-cap
chalk.supportsColor = stdoutColor;
chalk.stderr = Chalk({level: stderrColor ? stderrColor.level : 0}); // eslint-disable-line new-cap
chalk.stderr.supportsColor = stderrColor;

module.exports = chalk;
