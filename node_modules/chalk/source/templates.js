'use strict';
const TEMPLATE_REGEX = /(?:\\(u(?:[a-f\d]{4}|\{[a-f\d]{1,6}\})|x[a-f\d]{2}|.))|(?:\{(~)?(\w+(?:\([^)]*\))?(?:\.\w+(?:\([^)]*\))?)*)(?:[ \t]|(?=\r?\n)))|(\})|((?:.|[\r\n\f])+?)/gi;
const STYLE_REGEX = /(?:^|\.)(\w+)(?:\(([^)]*)\))?/g;
const STRING_REGEX = /^(['"])((?:\\.|(?!\1)[^\\])*)\1$/;
const ESCAPE_REGEX = /\\(u(?:[a-f\d]{4}|{[a-f\d]{1,6}})|x[a-f\d]{2}|.)|([^\\])/gi;

const ESCAPES = new Map([
	['n', '\n'],
	['r', '\r'],
	['t', '\t'],
	['b', '\b'],
	['f', '\f'],
	['v', '\v'],
	['0', '\0'],
	['\\', '\\'],
	['e', '\u001B'],
	['a', '\u0007']
]);

/**
 * Unescapes a string by converting escape sequences to their corresponding characters.
 *
 * @param {string} c - The escape sequence to be unescaped.
 * @returns {string} - The unescaped character.
 * @throws {Error} - If the input is not a valid escape sequence.
 *
 * @example
 * // Returns 'A'
 * console.log(unescape('u0041'));
 */
function unescape(c) {
	const u = c[0] === 'u';
	const bracket = c[1] === '{';

	if ((u && !bracket && c.length === 5) || (c[0] === 'x' && c.length === 3)) {
		return String.fromCharCode(parseInt(c.slice(1), 16));
	}

	if (u && bracket) {
		return String.fromCodePoint(parseInt(c.slice(2, -1), 16));
	}

	return ESCAPES.get(c) || c;
}

/**
 * Parses arguments from a string template into an array of numbers or strings.
 *
 * @param {string} name - The name of the style being parsed.
 * @param {string} arguments_ - A comma-separated string of arguments to parse.
 * @returns {Array<number|string>} An array containing parsed numbers and strings.
 * @throws {Error} Throws an error if an invalid argument is encountered.
 */
function parseArguments(name, arguments_) {
	const results = [];
	const chunks = arguments_.trim().split(/\s*,\s*/g);
	let matches;

	for (const chunk of chunks) {
		const number = Number(chunk);
		if (!Number.isNaN(number)) {
			results.push(number);
		} else if ((matches = chunk.match(STRING_REGEX))) {
			results.push(matches[2].replace(ESCAPE_REGEX, (m, escape, character) => escape ? unescape(escape) : character));
		} else {
			throw new Error(`Invalid Chalk template style argument: ${chunk} (in style '${name}')`);
		}
	}

	return results;
}

/**
 * Parses a style string into an array of style rules.
 *
 * @param {string} style - The style string to parse.
 * @returns {Array<Array<string>>>} An array of style rules, where each rule is represented as an array containing the style name and its arguments (if any).
 * @throws {TypeError} If `style` is not a valid string.
 *
 * @example
 * // Returns [['color', 'red'], ['font-size', '12px']]
 * parseStyle('color: red; font-size: 12px;');
 */
function parseStyle(style) {
	STYLE_REGEX.lastIndex = 0;

	const results = [];
	let matches;

	while ((matches = STYLE_REGEX.exec(style)) !== null) {
		const name = matches[1];

		if (matches[2]) {
			const args = parseArguments(name, matches[2]);
			results.push([name].concat(args));
		} else {
			results.push([name]);
		}
	}

	return results;
}

/**
 * Builds and applies styles to a chalk instance based on provided styles layers.
 *
 * @param {Object} chalk - The chalk library instance to apply styles to.
 * @param {Array<Array<Object>>} styles - An array of style layers, each layer contains an array of style objects.
 * @returns {Function} - A new chalk function with applied styles.
 * @throws {Error} - Throws an error if an unknown Chalk style is encountered.
 *
 * Example:
 *   const chalk = require('chalk');
 *   const styles = [
 *     [{ inverse: false, styles: [['bold', 'red'], ['underline']] }],
 *     [{ inverse: true, styles: [['italic', 'green']] }]
 *   ];
 *   const styledChalk = buildStyle(chalk, styles);
 *   console.log(styledChalk('Hello World!'));
 */
function buildStyle(chalk, styles) {
	const enabled = {};

	for (const layer of styles) {
		for (const style of layer.styles) {
			enabled[style[0]] = layer.inverse ? null : style.slice(1);
		}
	}

	let current = chalk;
	for (const [styleName, styles] of Object.entries(enabled)) {
		if (!Array.isArray(styles)) {
			continue;
		}

		if (!(styleName in current)) {
			throw new Error(`Unknown Chalk style: ${styleName}`);
		}

		current = styles.length > 0 ? current[styleName](...styles) : current[styleName];
	}

	return current;
}

module.exports = (chalk, temporary) => {
	const styles = [];
	const chunks = [];
	let chunk = [];

	// eslint-disable-next-line max-params
	temporary.replace(TEMPLATE_REGEX, (m, escapeCharacter, inverse, style, close, character) => {
		if (escapeCharacter) {
			chunk.push(unescape(escapeCharacter));
		} else if (style) {
			const string = chunk.join('');
			chunk = [];
			chunks.push(styles.length === 0 ? string : buildStyle(chalk, styles)(string));
			styles.push({inverse, styles: parseStyle(style)});
		} else if (close) {
			if (styles.length === 0) {
				throw new Error('Found extraneous } in Chalk template literal');
			}

			chunks.push(buildStyle(chalk, styles)(chunk.join('')));
			chunk = [];
			styles.pop();
		} else {
			chunk.push(character);
		}
	});

	chunks.push(chunk.join(''));

	if (styles.length > 0) {
		const errMessage = `Chalk template literal is missing ${styles.length} closing bracket${styles.length === 1 ? '' : 's'} (\`}\`)`;
		throw new Error(errMessage);
	}

	return chunks.join('');
};
