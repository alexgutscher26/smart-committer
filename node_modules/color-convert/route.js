const conversions = require('./conversions');

/*
	This function routes a model to all other models.

	all functions that are routed have a property `.conversion` attached
	to the returned synthetic function. This property is an array
	of strings, each with the steps in between the 'from' and 'to'
	color models (inclusive).

	conversions that are not possible simply are not included.
*/

/**
 * Builds a graph object with models as keys and initial values for distance and parent.
 *
 * @returns {Object} - The constructed graph object.
 *
 * Example:
 * const graph = buildGraph();
 * console.log(graph); // Output will be an object where each model key has 'distance' set to -1 and 'parent' set to null
 */
function buildGraph() {
	const graph = {};
	// https://jsperf.com/object-keys-vs-for-in-with-closure/3
	const models = Object.keys(conversions);

	for (let len = models.length, i = 0; i < len; i++) {
		graph[models[i]] = {
			// http://jsperf.com/1-vs-infinity
			// micro-opt, but this is simple.
			distance: -1,
			parent: null
		};
	}

	return graph;
}

// https://en.wikipedia.org/wiki/Breadth-first_search
/**
 * Calculates the shortest path from the given model using Breadth-First Search (BFS).
 *
 * @param {string} fromModel - The starting model for the BFS traversal.
 * @return {Object} - An object representing the graph with distances and parent nodes.
 */
function deriveBFS(fromModel) {
	const graph = buildGraph();
	const queue = [fromModel]; // Unshift -> queue -> pop

	graph[fromModel].distance = 0;

	while (queue.length) {
		const current = queue.pop();
		const adjacents = Object.keys(conversions[current]);

		for (let len = adjacents.length, i = 0; i < len; i++) {
			const adjacent = adjacents[i];
			const node = graph[adjacent];

			if (node.distance === -1) {
				node.distance = graph[current].distance + 1;
				node.parent = current;
				queue.unshift(adjacent);
			}
		}
	}

	return graph;
}

/**
 * Creates a function that links two functions together by applying the result of the first to the second.
 *
 * @param {Function} from - The function whose output will be used as input for the 'to' function.
 * @param {Function} to - The function that will receive the output of the 'from' function as its input.
 * @returns {Function} A new function that takes arguments and returns the result of applying 'to' to the result of 'from'.
 *
 * @example
 * const addOne = x => x + 1;
 * const multiplyByTwo = x => x * 2;
 * const addOneThenMultiplyByTwo = link(addOne, multiplyByTwo);
 * console.log(addOneThenMultiplyByTwo(5)); // Output: 12
 */
function link(from, to) {
	return function (args) {
		return to(from(args));
	};
}

/**
 * Wraps conversion functions to create a complete path of conversions from the root model to the target model.
 *
 * @param {string} toModel - The target model to convert to.
 * @param {Object} graph - A graph representing the relationship between models and their parent models.
 * @returns {Function} - A function that represents the complete conversion path.
 *
 * @throws {Error} If `toModel` is not a valid key in the `graph`.
 *
 * @example
 * const toModel = 'targetModel';
 * const graph = {
 *   'rootModel': { parent: null },
 *   'intermediateModel': { parent: 'rootModel' },
 *   'targetModel': { parent: 'intermediateModel' }
 * };
 * const conversionFunction = wrapConversion(toModel, graph);
 * console.log(conversionFunction.conversion); // ['intermediateModel', 'targetModel']
 */
function wrapConversion(toModel, graph) {
	const path = [graph[toModel].parent, toModel];
	let fn = conversions[graph[toModel].parent][toModel];

	let cur = graph[toModel].parent;
	while (graph[cur].parent) {
		path.unshift(graph[cur].parent);
		fn = link(conversions[graph[cur].parent][cur], fn);
		cur = graph[cur].parent;
	}

	fn.conversion = path;
	return fn;
}

module.exports = function (fromModel) {
	const graph = deriveBFS(fromModel);
	const conversion = {};

	const models = Object.keys(graph);
	for (let len = models.length, i = 0; i < len; i++) {
		const toModel = models[i];
		const node = graph[toModel];

		if (node.parent === null) {
			// No possible conversion, or this node is the source model.
			continue;
		}

		conversion[toModel] = wrapConversion(toModel, graph);
	}

	return conversion;
};

