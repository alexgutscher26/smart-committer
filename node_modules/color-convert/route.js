const conversions = require('./conversions');

/*
	This function routes a model to all other models.

	all functions that are routed have a property `.conversion` attached
	to the returned synthetic function. This property is an array
	of strings, each with the steps in between the 'from' and 'to'
	color models (inclusive).

	conversions that are not possible simply are not included.
*/

/**
 * Builds a graph object using the keys from the `conversions` object.
 *
 * @returns {Object} A graph object where each key represents a model and has properties for distance and parent.
 */
function buildGraph() {
	const graph = {};
	// https://jsperf.com/object-keys-vs-for-in-with-closure/3
	const models = Object.keys(conversions);

	for (let len = models.length, i = 0; i < len; i++) {
		graph[models[i]] = {
			// http://jsperf.com/1-vs-infinity
			// micro-opt, but this is simple.
			distance: -1,
			parent: null
		};
	}

	return graph;
}

// https://en.wikipedia.org/wiki/Breadth-first_search
/**
 * Performs a breadth-first search (BFS) to derive distances from a given model.
 *
 * @param {string} fromModel - The starting model for the BFS traversal.
 * @returns {Object} - An object representing the graph with distances and parent nodes.
 *
 * @example
 * const result = deriveBFS('startModel');
 * console.log(result);
 */
function deriveBFS(fromModel) {
	const graph = buildGraph();
	const queue = [fromModel]; // Unshift -> queue -> pop

	graph[fromModel].distance = 0;

	while (queue.length) {
		const current = queue.pop();
		const adjacents = Object.keys(conversions[current]);

		for (let len = adjacents.length, i = 0; i < len; i++) {
			const adjacent = adjacents[i];
			const node = graph[adjacent];

			if (node.distance === -1) {
				node.distance = graph[current].distance + 1;
				node.parent = current;
				queue.unshift(adjacent);
			}
		}
	}

	return graph;
}

/**
 * Creates a new function that, when called, will call another function with the results of calling this function.
 *
 * @param {Function} from - The function to be called first. It takes arguments and returns some value.
 * @param {Function} to - The function to be called second. It takes arguments returned by 'from' and returns a final result.
 * @returns {Function} A new function that, when called with arguments, will pass those arguments through 'from', then through 'to', and return the result of 'to'.
 *
 * Example:
 * const double = x => x * 2;
 * const increment = x => x + 1;
 * const doubleThenIncrement = link(double, increment);
 * console.log(doubleThenIncrement(3)); // Outputs: 7
 */
function link(from, to) {
	return function (args) {
		return to(from(args));
	};
}

/**
 * Wraps conversion functions to create a chain of conversions based on a graph structure.
 *
 * @param {string} toModel - The target model for the conversion.
 * @param {Object} graph - A graph object where keys are model names and values contain parent relationships.
 * @returns {Function} - A function that represents the chained conversion, including the path of conversions.
 * @throws {Error} - If a required conversion link is not found in the `conversions` object.
 *
 * @example
 * // Assuming 'graph' and 'toModel' are defined appropriately
 * const resultFn = wrapConversion('targetModel', graph);
 * console.log(resultFn.conversion); // Logs the path of conversions
 */
function wrapConversion(toModel, graph) {
	const path = [graph[toModel].parent, toModel];
	let fn = conversions[graph[toModel].parent][toModel];

	let cur = graph[toModel].parent;
	while (graph[cur].parent) {
		path.unshift(graph[cur].parent);
		fn = link(conversions[graph[cur].parent][cur], fn);
		cur = graph[cur].parent;
	}

	fn.conversion = path;
	return fn;
}

module.exports = function (fromModel) {
	const graph = deriveBFS(fromModel);
	const conversion = {};

	const models = Object.keys(graph);
	for (let len = models.length, i = 0; i < len; i++) {
		const toModel = models[i];
		const node = graph[toModel];

		if (node.parent === null) {
			// No possible conversion, or this node is the source model.
			continue;
		}

		conversion[toModel] = wrapConversion(toModel, graph);
	}

	return conversion;
};

