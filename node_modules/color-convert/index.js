const conversions = require('./conversions');
const route = require('./route');

const convert = {};

const models = Object.keys(conversions);

/**
 * Wraps a function to handle raw arguments.
 *
 * This function takes another function as an argument and returns a new function
 * that wraps the original function. The returned function checks if the first argument
 * is `undefined` or `null`. If it is, the original function is called with no arguments.
 * If the first argument has more than one element, it is considered as an array of arguments,
 * and the original function is called with these arguments. The `.conversion` property
 * from the original function is preserved in the wrapped function if it exists.
 *
 * @param {Function} fn - The function to be wrapped.
 * @return {Function} The wrapped function that handles raw arguments.
 */
function wrapRaw(fn) {
	const wrappedFn = function (...args) {
		const arg0 = args[0];
		if (arg0 === undefined || arg0 === null) {
			return arg0;
		}

		if (arg0.length > 1) {
			args = arg0;
		}

		return fn(args);
	};

	// Preserve .conversion property if there is one
	if ('conversion' in fn) {
		wrappedFn.conversion = fn.conversion;
	}

	return wrappedFn;
}

/**
 * Wraps a function to round the results of its execution.
 *
 * This function takes another function `fn` as an argument and returns a new function
 * that, when called, will execute `fn`, then round any numbers in the result if it is an array.
 *
 * @param {Function} fn - The function to be wrapped.
 * @returns {Function} A new function that wraps the original function with rounding logic.
 */
function wrapRounded(fn) {
	const wrappedFn = function (...args) {
		const arg0 = args[0];

		if (arg0 === undefined || arg0 === null) {
			return arg0;
		}

		if (arg0.length > 1) {
			args = arg0;
		}

		const result = fn(args);

		// We're assuming the result is an array here.
		// see notice in conversions.js; don't use box types
		// in conversion functions.
		if (typeof result === 'object') {
			for (let len = result.length, i = 0; i < len; i++) {
				result[i] = Math.round(result[i]);
			}
		}

		return result;
	};

	// Preserve .conversion property if there is one
	if ('conversion' in fn) {
		wrappedFn.conversion = fn.conversion;
	}

	return wrappedFn;
}

models.forEach(fromModel => {
	convert[fromModel] = {};

	Object.defineProperty(convert[fromModel], 'channels', {value: conversions[fromModel].channels});
	Object.defineProperty(convert[fromModel], 'labels', {value: conversions[fromModel].labels});

	const routes = route(fromModel);
	const routeModels = Object.keys(routes);

	routeModels.forEach(toModel => {
		const fn = routes[toModel];

		convert[fromModel][toModel] = wrapRounded(fn);
		convert[fromModel][toModel].raw = wrapRaw(fn);
	});
});

module.exports = convert;
