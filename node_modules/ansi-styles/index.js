'use strict';

/**
 * Creates a new function that wraps an ANSI color code with an offset.
 *
 * @param {Function} fn - The function to wrap, which returns an ANSI color code.
 * @param {number} offset - The offset to add to the color code.
 * @returns {Function} A new function that takes arguments and returns a string
 *                      with the ANSI escape sequence applied.
 *
 * @example
 * const setRed = wrapAnsi16(colorCode, 30);
 * console.log(setRed('Hello')); // Outputs: \u001B[30mHello\u001B[39m (default color)
 */
const wrapAnsi16 = (fn, offset) => (...args) => {
	const code = fn(...args);
	return `\u001B[${code + offset}m`;
};

/**
 * Wraps an ANSI color function to generate a 256-color code string.
 *
 * @param {Function} fn - The ANSI color function to wrap.
 * @param {number} offset - The offset for the ANSI color codes.
 * @return {string} - The wrapped ANSI color code string.
 *
 * @example
 * const setRed = wrapAnsi256(ansi.red, 0);
 * console.log(setRed('Hello')); // '\u001B[38;5;0mHello\u001B[39m'
 */
const wrapAnsi256 = (fn, offset) => (...args) => {
	const code = fn(...args);
	return `\u001B[${38 + offset};5;${code}m`;
};

/**
 * Wraps an ANSI color function to output 24-bit RGB colors.
 *
 * @function wrapAnsi16m
 * @param {Function} fn - The original ANSI color function.
 * @param {number} offset - The base ANSI color code.
 * @returns {Function} A new function that takes arguments for the original function and returns a string with 24-bit RGB ANSI escape sequence.
 *
 * Example usage:
 * const rgbToAnsi = require('ansi-rgb-to-ansi');
 * const wrapFn = wrapAnsi16m(rgbToAnsi, 0);
 * console.log(wrapFn(255, 0, 0)); // Output: '\u001B[38;2;255;0;0m'
 */
const wrapAnsi16m = (fn, offset) => (...args) => {
	const rgb = fn(...args);
	return `\u001B[${38 + offset};2;${rgb[0]};${rgb[1]};${rgb[2]}m`;
};

/**
 * Converts ANSI escape codes to ANSI escape codes. This function essentially passes through the input unchanged.
 *
 * @param {string} n - The string containing ANSI escape codes.
 * @returns {string} The same string with ANSI escape codes.
 */
const ansi2ansi = n => n;
/**
 * Converts RGB color values to an array format.
 *
 * @param {number} r - The red component of the color (0-255).
 * @param {number} g - The green component of the color (0-255).
 * @param {number} b - The blue component of the color (0-255).
 * @returns {Array<number>} An array containing the RGB values [r, g, b].
 *
 * @example
 * rgb2rgb(255, 165, 0); // returns [255, 165, 0]
 */
const rgb2rgb = (r, g, b) => [r, g, b];

/**
 * Sets a lazy property on an object. The getter function is only called once when the property is accessed for the first time.
 *
 * @param {Object} object - The object to which the lazy property will be added.
 * @param {string} property - The name of the property.
 * @param {Function} get - A function that returns the value of the property when it's accessed for the first time. This function is called only once and the result is cached.
 * @returns {undefined}
 * @throws {TypeError} If `object` is not an object or if `property` is not a string.
 */
const setLazyProperty = (object, property, get) => {
	Object.defineProperty(object, property, {
		get: () => {
			const value = get();

			Object.defineProperty(object, property, {
				value,
				enumerable: true,
				configurable: true
			});

			return value;
		},
		enumerable: true,
		configurable: true
	});
};

/** @type {typeof import('color-convert')} */
let colorConvert;
/**
 * Generates dynamic styles for color conversion based on the provided source and target color spaces.
 *
 * @param {Function} wrap - A function that wraps the color conversion functions with additional logic or formatting.
 * @param {string} targetSpace - The target color space to convert colors to.
 * @param {Function|string} identity - The identity function or string to use for direct color mapping.
 * @param {boolean} isBackground - A boolean indicating whether the styles are for a background color.
 * @returns {Object} An object containing the dynamic styles for each source color space.
 *
 * @example
 * // Example usage of makeDynamicStyles
 * const wrap = (func, offset) => {
 *   return (color) => func(color) + offset;
 * };
 * const targetSpace = 'rgb';
 * const identity = colorConvert.rgb.hex;
 * const isBackground = false;
 * const styles = makeDynamicStyles(wrap, targetSpace, identity, isBackground);
 * console.log(styles);
 */
const makeDynamicStyles = (wrap, targetSpace, identity, isBackground) => {
	if (colorConvert === undefined) {
		colorConvert = require('color-convert');
	}

	const offset = isBackground ? 10 : 0;
	const styles = {};

	for (const [sourceSpace, suite] of Object.entries(colorConvert)) {
		const name = sourceSpace === 'ansi16' ? 'ansi' : sourceSpace;
		if (sourceSpace === targetSpace) {
			styles[name] = wrap(identity, offset);
		} else if (typeof suite === 'object') {
			styles[name] = wrap(suite[targetSpace], offset);
		}
	}

	return styles;
};

/**
 * Assembles styles for terminal output using ANSI escape codes. This function generates an object containing various color and style options.
 * Each color and style is represented as a key with its corresponding open and close escape sequences. The object also includes a 'codes' map for quick lookup of open and close codes.
 *
 * @returns {Object} - An object containing the assembled styles, each accessible via its name.
 *
 * Example usage:
 * const styles = assembleStyles();
 * console.log(styles.color.red.open + "This is red text" + styles.color.red.close);
 */
function assembleStyles() {
	const codes = new Map();
	const styles = {
		modifier: {
			reset: [0, 0],
			// 21 isn't widely supported and 22 does the same thing
			bold: [1, 22],
			dim: [2, 22],
			italic: [3, 23],
			underline: [4, 24],
			inverse: [7, 27],
			hidden: [8, 28],
			strikethrough: [9, 29]
		},
		color: {
			black: [30, 39],
			red: [31, 39],
			green: [32, 39],
			yellow: [33, 39],
			blue: [34, 39],
			magenta: [35, 39],
			cyan: [36, 39],
			white: [37, 39],

			// Bright color
			blackBright: [90, 39],
			redBright: [91, 39],
			greenBright: [92, 39],
			yellowBright: [93, 39],
			blueBright: [94, 39],
			magentaBright: [95, 39],
			cyanBright: [96, 39],
			whiteBright: [97, 39]
		},
		bgColor: {
			bgBlack: [40, 49],
			bgRed: [41, 49],
			bgGreen: [42, 49],
			bgYellow: [43, 49],
			bgBlue: [44, 49],
			bgMagenta: [45, 49],
			bgCyan: [46, 49],
			bgWhite: [47, 49],

			// Bright color
			bgBlackBright: [100, 49],
			bgRedBright: [101, 49],
			bgGreenBright: [102, 49],
			bgYellowBright: [103, 49],
			bgBlueBright: [104, 49],
			bgMagentaBright: [105, 49],
			bgCyanBright: [106, 49],
			bgWhiteBright: [107, 49]
		}
	};

	// Alias bright black as gray (and grey)
	styles.color.gray = styles.color.blackBright;
	styles.bgColor.bgGray = styles.bgColor.bgBlackBright;
	styles.color.grey = styles.color.blackBright;
	styles.bgColor.bgGrey = styles.bgColor.bgBlackBright;

	for (const [groupName, group] of Object.entries(styles)) {
		for (const [styleName, style] of Object.entries(group)) {
			styles[styleName] = {
				open: `\u001B[${style[0]}m`,
				close: `\u001B[${style[1]}m`
			};

			group[styleName] = styles[styleName];

			codes.set(style[0], style[1]);
		}

		Object.defineProperty(styles, groupName, {
			value: group,
			enumerable: false
		});
	}

	Object.defineProperty(styles, 'codes', {
		value: codes,
		enumerable: false
	});

	styles.color.close = '\u001B[39m';
	styles.bgColor.close = '\u001B[49m';

	setLazyProperty(styles.color, 'ansi', () => makeDynamicStyles(wrapAnsi16, 'ansi16', ansi2ansi, false));
	setLazyProperty(styles.color, 'ansi256', () => makeDynamicStyles(wrapAnsi256, 'ansi256', ansi2ansi, false));
	setLazyProperty(styles.color, 'ansi16m', () => makeDynamicStyles(wrapAnsi16m, 'rgb', rgb2rgb, false));
	setLazyProperty(styles.bgColor, 'ansi', () => makeDynamicStyles(wrapAnsi16, 'ansi16', ansi2ansi, true));
	setLazyProperty(styles.bgColor, 'ansi256', () => makeDynamicStyles(wrapAnsi256, 'ansi256', ansi2ansi, true));
	setLazyProperty(styles.bgColor, 'ansi16m', () => makeDynamicStyles(wrapAnsi16m, 'rgb', rgb2rgb, true));

	return styles;
}

// Make the export immutable
Object.defineProperty(module, 'exports', {
	enumerable: true,
	get: assembleStyles
});
