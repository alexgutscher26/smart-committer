var clone = (function() {
'use strict';

/**
 * Clones (copies) an Object using deep copying.
 *
 * This function supports circular references by default. If you are certain there are no circular references in your object, you can save some CPU time by calling `clone(obj, false)`.
 *
 * **Caution:** If `circular` is false and `parent` contains circular references, your program may enter an infinite loop and crash.
 *
 * @param {Object} parent - The object to be cloned.
 * @param {boolean|Object} [circular=true] - Set to true if the object to be cloned may contain circular references. Can also be an object with options: `{ circular: boolean, depth: number, prototype: Object, filter: Function }`.
 * @param {number} [depth=Infinity] - Set to a number if the object is only to be cloned to a particular depth.
 * @param {Object} [prototype] - Sets the prototype to be used when cloning an object. Defaults to `parent.prototype`.
 * @returns {Object} The cloned object.
 *
 * **Example:**
 * ```javascript
 * const original = { a: 1, b: { c: 2 } };
 * const cloned = clone(original);
 * console.log(cloned); // Output: { a: 1, b: { c: 2 } }
 * ```
 */
function clone(parent, circular, depth, prototype) {
  var filter;
  if (typeof circular === 'object') {
    depth = circular.depth;
    prototype = circular.prototype;
    filter = circular.filter;
    circular = circular.circular
  }
  // maintain two arrays for circular references, where corresponding parents
  // and children have the same index
  var allParents = [];
  var allChildren = [];

  var useBuffer = typeof Buffer != 'undefined';

  if (typeof circular == 'undefined')
    circular = true;

  if (typeof depth == 'undefined')
    depth = Infinity;

  // recurse this function so we don't reset allParents and allChildren
  function _clone(parent, depth) {
    // cloning null always returns null
    if (parent === null)
      return null;

    if (depth == 0)
      return parent;

    var child;
    var proto;
    if (typeof parent != 'object') {
      return parent;
    }

    if (clone.__isArray(parent)) {
      child = [];
    } else if (clone.__isRegExp(parent)) {
      child = new RegExp(parent.source, __getRegExpFlags(parent));
      if (parent.lastIndex) child.lastIndex = parent.lastIndex;
    } else if (clone.__isDate(parent)) {
      child = new Date(parent.getTime());
    } else if (useBuffer && Buffer.isBuffer(parent)) {
      if (Buffer.allocUnsafe) {
        // Node.js >= 4.5.0
        child = Buffer.allocUnsafe(parent.length);
      } else {
        // Older Node.js versions
        child = new Buffer(parent.length);
      }
      parent.copy(child);
      return child;
    } else {
      if (typeof prototype == 'undefined') {
        proto = Object.getPrototypeOf(parent);
        child = Object.create(proto);
      }
      else {
        child = Object.create(prototype);
        proto = prototype;
      }
    }

    if (circular) {
      var index = allParents.indexOf(parent);

      if (index != -1) {
        return allChildren[index];
      }
      allParents.push(parent);
      allChildren.push(child);
    }

    for (var i in parent) {
      var attrs;
      if (proto) {
        attrs = Object.getOwnPropertyDescriptor(proto, i);
      }

      if (attrs && attrs.set == null) {
        continue;
      }
      child[i] = _clone(parent[i], depth - 1);
    }

    return child;
  }

  return _clone(parent, depth);
}

/**
 * Simple flat clone using prototype, accepts only objects, usefull for property
 * override on FLAT configuration object (no nested props).
 *
 * USE WITH CAUTION! This may not behave as you wish if you do not know how this
 * works.
 */
clone.clonePrototype = function clonePrototype(parent) {
  if (parent === null)
    return null;

  var c = function () {};
  c.prototype = parent;
  return new c();
};

// private utility functions

/**
 * Converts an object to its string representation using `Object.prototype.toString.call`.
 *
 * @param {any} o - The object to convert.
 * @return {string} - The string representation of the object.
 */
function __objToStr(o) {
  return Object.prototype.toString.call(o);
};
clone.__objToStr = __objToStr;

/**
 * Determines whether the provided value is an instance of Date.
 *
 * @param {any} o - The value to check.
 * @returns {boolean} - True if the value is a Date, false otherwise.
 *
 * @example
 * console.log(__isDate(new Date())); // true
 * console.log(__isDate('2023-10-05')); // false
 */
function __isDate(o) {
  return typeof o === 'object' && __objToStr(o) === '[object Date]';
};
clone.__isDate = __isDate;

/**
 * Determines if the provided object is an array.
 *
 * @param {any} o - The object to check.
 * @returns {boolean} - True if the object is an array, false otherwise.
 *
 * Example:
 *   const arr = [1, 2, 3];
 *   console.log(__isArray(arr)); // true
 */
function __isArray(o) {
  return typeof o === 'object' && __objToStr(o) === '[object Array]';
};
clone.__isArray = __isArray;

function __isRegExp(o) {
  return typeof o === 'object' && __objToStr(o) === '[object RegExp]';
};
clone.__isRegExp = __isRegExp;

/**
 * Extracts and returns the flags from a given regular expression object.
 *
 * @param {RegExp} re - The regular expression object from which to extract flags.
 * @returns {string} A string containing the flags of the regular expression. Possible values include 'g' for global, 'i' for ignore case, and 'm' for multiline.
 * @throws {TypeError} If the input is not a RegExp object.
 *
 * Example:
 * const regex = /foo/gi;
 * console.log(__getRegExpFlags(regex)); // Outputs: "gi"
 */
function __getRegExpFlags(re) {
  var flags = '';
  if (re.global) flags += 'g';
  if (re.ignoreCase) flags += 'i';
  if (re.multiline) flags += 'm';
  return flags;
};
clone.__getRegExpFlags = __getRegExpFlags;

return clone;
})();

if (typeof module === 'object' && module.exports) {
  module.exports = clone;
}
