'use strict';
const readline = require('readline');
const chalk = require('chalk');
const cliCursor = require('cli-cursor');
const cliSpinners = require('cli-spinners');
const logSymbols = require('log-symbols');
const stripAnsi = require('strip-ansi');
const wcwidth = require('wcwidth');
const isInteractive = require('is-interactive');
const isUnicodeSupported = require('is-unicode-supported');
const {BufferListStream} = require('bl');

const TEXT = Symbol('text');
const PREFIX_TEXT = Symbol('prefixText');
const ASCII_ETX_CODE = 0x03; // Ctrl+C emits this code

class StdinDiscarder {
	constructor() {
		this.requests = 0;

		this.mutedStream = new BufferListStream();
		this.mutedStream.pipe(process.stdout);

		const self = this; // eslint-disable-line unicorn/no-this-assignment
		this.ourEmit = function (event, data, ...args) {
			const {stdin} = process;
			if (self.requests > 0 || stdin.emit === self.ourEmit) {
				if (event === 'keypress') { // Fixes readline behavior
					return;
				}

				if (event === 'data' && data.includes(ASCII_ETX_CODE)) {
					process.emit('SIGINT');
				}

				Reflect.apply(self.oldEmit, this, [event, data, ...args]);
			} else {
				Reflect.apply(process.stdin.emit, this, [event, data, ...args]);
			}
		};
	}

	/**
	 * Increments the request count and initiates the realStart method if this is the first request.
	 *
	 * @function start
	 * @memberof SupportedLanguage.JAVASCRIPT
	 */
	start() {
		this.requests++;

		if (this.requests === 1) {
			this.realStart();
		}
	}

	/**
	 * Decrements the request counter and stops the service if no more requests are pending.
	 *
	 * @throws {Error} - Throws an error if `stop` is called more times than `start`.
	 */
	stop() {
		if (this.requests <= 0) {
			throw new Error('`stop` called more times than `start`');
		}

		this.requests--;

		if (this.requests === 0) {
			this.realStop();
		}
	}

	/**
	 * Initializes readline interface to handle input and manage SIGINT events.
	 *
	 * This method sets up a readline interface for reading user input from the standard input stream. It also configures
	 * an event listener for the 'SIGINT' signal (Ctrl+C) to ensure proper handling of interrupt signals, especially in environments
	 * where the default behavior might not be desirable.
	 *
	 * @private
	 */
	realStart() {
		// No known way to make it work reliably on Windows
		if (process.platform === 'win32') {
			return;
		}

		this.rl = readline.createInterface({
			input: process.stdin,
			output: this.mutedStream
		});

		this.rl.on('SIGINT', () => {
			if (process.listenerCount('SIGINT') === 0) {
				process.emit('SIGINT');
			} else {
				this.rl.close();
				process.kill(process.pid, 'SIGINT');
			}
		});
	}

	/**
	 * Closes the readline interface if it's not running on Windows platform.
	 *
	 * @returns {void}
	 */
	realStop() {
		if (process.platform === 'win32') {
			return;
		}

		this.rl.close();
		this.rl = undefined;
	}
}

let stdinDiscarder;

class Ora {
	constructor(options) {
		if (!stdinDiscarder) {
			stdinDiscarder = new StdinDiscarder();
		}

		if (typeof options === 'string') {
			options = {
				text: options
			};
		}

		this.options = {
			text: '',
			color: 'cyan',
			stream: process.stderr,
			discardStdin: true,
			...options
		};

		this.spinner = this.options.spinner;

		this.color = this.options.color;
		this.hideCursor = this.options.hideCursor !== false;
		this.interval = this.options.interval || this.spinner.interval || 100;
		this.stream = this.options.stream;
		this.id = undefined;
		this.isEnabled = typeof this.options.isEnabled === 'boolean' ? this.options.isEnabled : isInteractive({stream: this.stream});
		this.isSilent = typeof this.options.isSilent === 'boolean' ? this.options.isSilent : false;

		// Set *after* `this.stream`
		this.text = this.options.text;
		this.prefixText = this.options.prefixText;
		this.linesToClear = 0;
		this.indent = this.options.indent;
		this.discardStdin = this.options.discardStdin;
		this.isDiscardingStdin = false;
	}

	get indent() {
		return this._indent;
	}

	set indent(indent = 0) {
		if (!(indent >= 0 && Number.isInteger(indent))) {
			throw new Error('The `indent` option must be an integer from 0 and up');
		}

		this._indent = indent;
	}

	/**
	 * Updates the interval value of an object.
	 *
	 * @param {number} interval - The new interval value to set. If undefined, no change is made.
	 */
	_updateInterval(interval) {
		if (interval !== undefined) {
			this.interval = interval;
		}
	}

	get spinner() {
		return this._spinner;
	}

	set spinner(spinner) {
		this.frameIndex = 0;

		if (typeof spinner === 'object') {
			if (spinner.frames === undefined) {
				throw new Error('The given spinner must have a `frames` property');
			}

			this._spinner = spinner;
		} else if (!isUnicodeSupported()) {
			this._spinner = cliSpinners.line;
		} else if (spinner === undefined) {
			// Set default spinner
			this._spinner = cliSpinners.dots;
		} else if (spinner !== 'default' && cliSpinners[spinner]) {
			this._spinner = cliSpinners[spinner];
		} else {
			throw new Error(`There is no built-in spinner named '${spinner}'. See https://github.com/sindresorhus/cli-spinners/blob/main/spinners.json for a full list.`);
		}

		this._updateInterval(this._spinner.interval);
	}

	get text() {
		return this[TEXT];
	}

	set text(value) {
		this[TEXT] = value;
		this.updateLineCount();
	}

	get prefixText() {
		return this[PREFIX_TEXT];
	}

	set prefixText(value) {
		this[PREFIX_TEXT] = value;
		this.updateLineCount();
	}

	get isSpinning() {
		return this.id !== undefined;
	}

	/**
	 * Generates a full prefix text by appending a postfix to the input prefix text.
	 *
	 * @param {string|function} [prefixText=this[PREFIX_TEXT]] - The prefix text or function that returns the prefix text. If not provided, defaults to this[PREFIX_TEXT].
	 * @param {string} [postfix=' '] - The postfix to append to the prefix text. Defaults to a space.
	 * @returns {string} The full prefix text with the postfix appended.
	 *
	 * @example
	 * // Using string as prefixText
	 * getFullPrefixText('Hello', '!'); // returns 'Hello!'
	 *
	 * @example
	 * // Using function as prefixText
	 * const prefixFunction = () => 'Hi';
	 * getFullPrefixText(prefixFunction, ', '); // returns 'Hi, '
	 */
	getFullPrefixText(prefixText = this[PREFIX_TEXT], postfix = ' ') {
		if (typeof prefixText === 'string') {
			return prefixText + postfix;
		}

		if (typeof prefixText === 'function') {
			return prefixText() + postfix;
		}

		return '';
	}

	/**
	 * Updates the line count based on the current stream columns and prefix text.
	 *
	 * This method calculates the number of lines required to display the prefixed text
	 * in a stream with the given columns. It considers the width of each character,
	 * including ANSI escape sequences, for accurate counting.
	 */
	updateLineCount() {
		const columns = this.stream.columns || 80;
		const fullPrefixText = this.getFullPrefixText(this.prefixText, '-');
		this.lineCount = 0;
		for (const line of stripAnsi(fullPrefixText + '--' + this[TEXT]).split('\n')) {
			this.lineCount += Math.max(1, Math.ceil(wcwidth(line) / columns));
		}
	}

	get isEnabled() {
		return this._isEnabled && !this.isSilent;
	}

	set isEnabled(value) {
		if (typeof value !== 'boolean') {
			throw new TypeError('The `isEnabled` option must be a boolean');
		}

		this._isEnabled = value;
	}

	get isSilent() {
		return this._isSilent;
	}

	set isSilent(value) {
		if (typeof value !== 'boolean') {
			throw new TypeError('The `isSilent` option must be a boolean');
		}

		this._isSilent = value;
	}

	/**
	 * Generates the current frame of text for the spinner.
	 *
	 * @returns {string} - The generated frame with optional color and prefix/text.
	 */
	frame() {
		const {frames} = this.spinner;
		let frame = frames[this.frameIndex];

		if (this.color) {
			frame = chalk[this.color](frame);
		}

		this.frameIndex = ++this.frameIndex % frames.length;
		const fullPrefixText = (typeof this.prefixText === 'string' && this.prefixText !== '') ? this.prefixText + ' ' : '';
		const fullText = typeof this.text === 'string' ? ' ' + this.text : '';

		return fullPrefixText + frame + fullText;
	}

	/**
	 * Clears the output stream by moving the cursor up by the number of lines to clear and clearing each line. This method has no effect if the instance is not enabled or if the output stream is not a TTY.
	 *
	 * @returns {Object} - The current instance, allowing for method chaining.
	 */
	clear() {
		if (!this.isEnabled || !this.stream.isTTY) {
			return this;
		}

		for (let i = 0; i < this.linesToClear; i++) {
			if (i > 0) {
				this.stream.moveCursor(0, -1);
			}

			this.stream.clearLine();
			this.stream.cursorTo(this.indent);
		}

		this.linesToClear = 0;

		return this;
	}

	/**
	 * Renders the frame if not silent. Clears the stream, writes the frame to the stream, and updates the number of lines to clear.
	 *
	 * @return {this} - Returns the current instance for method chaining.
	 */
	render() {
		if (this.isSilent) {
			return this;
		}

		this.clear();
		this.stream.write(this.frame());
		this.linesToClear = this.lineCount;

		return this;
	}

	/**
	 * Starts the spinner with the given text if provided.
	 *
	 * @param {string} [text] - The text to display next to the spinner. If not provided, the existing text will be used.
	 * @return {object} - Returns the instance of the spinner for method chaining.
	 *
	 * Example:
	 *   spinner.start('Loading...');
	 */
	start(text) {
		if (text) {
			this.text = text;
		}

		if (this.isSilent) {
			return this;
		}

		if (!this.isEnabled) {
			if (this.text) {
				this.stream.write(`- ${this.text}\n`);
			}

			return this;
		}

		if (this.isSpinning) {
			return this;
		}

		if (this.hideCursor) {
			cliCursor.hide(this.stream);
		}

		if (this.discardStdin && process.stdin.isTTY) {
			this.isDiscardingStdin = true;
			stdinDiscarder.start();
		}

		this.render();
		this.id = setInterval(this.render.bind(this), this.interval);

		return this;
	}

	stop() {
		if (!this.isEnabled) {
			return this;
		}

		clearInterval(this.id);
		this.id = undefined;
		this.frameIndex = 0;
		this.clear();
		if (this.hideCursor) {
			cliCursor.show(this.stream);
		}

		if (this.discardStdin && process.stdin.isTTY && this.isDiscardingStdin) {
			stdinDiscarder.stop();
			this.isDiscardingStdin = false;
		}

		return this;
	}

	/**
	 * Logs a success message with the provided text.
	 *
	 * @param {string} text - The message to log as a success.
	 * @returns {Object} An object containing the success symbol and the text.
	 */
	succeed(text) {
		return this.stopAndPersist({symbol: logSymbols.success, text});
	}

	/**
	 * Logs an error message and persists it.
	 *
	 * @param {string} text - The error message to log and persist.
	 * @returns {Object} An object containing a symbol representing the error and the provided text.
	 *
	 * @example
	 * // Example usage of the fail function
	 * const result = fail("An unexpected error occurred");
	 * console.log(result); // Output: { symbol: logSymbols.error, text: "An unexpected error occurred" }
	 */
	fail(text) {
		return this.stopAndPersist({symbol: logSymbols.error, text});
	}

	/**
	 * Logs a warning message.
	 *
	 * @param {string} text - The text to log as a warning.
	 * @returns {Object} - An object containing the logged symbol and text.
	 * @throws {Error} - Throws an error if the text parameter is not provided or is empty.
	 */
	warn(text) {
		return this.stopAndPersist({symbol: logSymbols.warning, text});
	}

	/**
	 * Logs an informational message with a symbol.
	 *
	 * @param {string} text - The text to log as information.
	 * @returns {Object} - An object containing the log symbol and the logged text.
	 * @throws {Error} - Throws an error if the input text is not provided.
	 */
	info(text) {
		return this.stopAndPersist({symbol: logSymbols.info, text});
	}

	/**
	 * Stops the stream and persists the current text with an optional prefix and symbol.
	 *
	 * @param {Object} [options={}] - The options object to customize the behavior.
	 * @param {string} [options.prefixText] - The prefix text to be added before the text. If not provided, uses the instance's `prefixText`.
	 * @param {string} [options.text] - The text to be persisted. If not provided, uses the instance's `text`.
	 * @param {string} [options.symbol=' '] - The symbol to be added after the prefix and text.
	 *
	 * @returns {SupportedLanguage} The current instance for method chaining.
	 *
	 * @example
	 * // Create an instance of SupportedLanguage
	 * const language = new SupportedLanguage();
	 * language.text = "Hello, world!";
	 *
	 * // Stop the stream and persist with default options
	 * language.stopAndPersist();
	 *
	 * // Stop the stream and persist with custom prefix and symbol
	 * language.stopAndPersist({ prefixText: "Info:", symbol: "*" });
	 */
	stopAndPersist(options = {}) {
		if (this.isSilent) {
			return this;
		}

		const prefixText = options.prefixText || this.prefixText;
		const text = options.text || this.text;
		const fullText = (typeof text === 'string') ? ' ' + text : '';

		this.stop();
		this.stream.write(`${this.getFullPrefixText(prefixText, ' ')}${options.symbol || ' '}${fullText}\n`);

		return this;
	}
}

const oraFactory = function (options) {
	return new Ora(options);
};

module.exports = oraFactory;

module.exports.promise = (action, options) => {
	// eslint-disable-next-line promise/prefer-await-to-then
	if (typeof action.then !== 'function') {
		throw new TypeError('Parameter `action` must be a Promise');
	}

	const spinner = new Ora(options);
	spinner.start();

	(async () => {
		try {
			await action;
			spinner.succeed();
		} catch {
			spinner.fail();
		}
	})();

	return spinner;
};
