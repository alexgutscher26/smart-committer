'use strict';
const readline = require('readline');
const chalk = require('chalk');
const cliCursor = require('cli-cursor');
const cliSpinners = require('cli-spinners');
const logSymbols = require('log-symbols');
const stripAnsi = require('strip-ansi');
const wcwidth = require('wcwidth');
const isInteractive = require('is-interactive');
const isUnicodeSupported = require('is-unicode-supported');
const {BufferListStream} = require('bl');

const TEXT = Symbol('text');
const PREFIX_TEXT = Symbol('prefixText');
const ASCII_ETX_CODE = 0x03; // Ctrl+C emits this code

class StdinDiscarder {
	constructor() {
		this.requests = 0;

		this.mutedStream = new BufferListStream();
		this.mutedStream.pipe(process.stdout);

		const self = this; // eslint-disable-line unicorn/no-this-assignment
		this.ourEmit = function (event, data, ...args) {
			const {stdin} = process;
			if (self.requests > 0 || stdin.emit === self.ourEmit) {
				if (event === 'keypress') { // Fixes readline behavior
					return;
				}

				if (event === 'data' && data.includes(ASCII_ETX_CODE)) {
					process.emit('SIGINT');
				}

				Reflect.apply(self.oldEmit, this, [event, data, ...args]);
			} else {
				Reflect.apply(process.stdin.emit, this, [event, data, ...args]);
			}
		};
	}

	start() {
		this.requests++;

		if (this.requests === 1) {
			this.realStart();
		}
	}

	stop() {
		if (this.requests <= 0) {
			throw new Error('`stop` called more times than `start`');
		}

		this.requests--;

		if (this.requests === 0) {
			this.realStop();
		}
	}

	/**
	 * Initializes a readline interface to handle input and output, ensuring it works reliably on non-Windows platforms.
	 *
	 * This method creates a readline interface with `process.stdin` as the input and a custom stream (`this.mutedStream`) as the output.
	 * It also sets up an event listener for 'SIGINT' signals, which are typically generated when the user presses Ctrl+C.
	 *
	 * If there are no other listeners for 'SIGINT', this method emits the signal to terminate the process gracefully.
	 * Otherwise, it closes the readline interface and kills the process with the same 'SIGINT' signal.
	 *
	 * Note: This method does not work reliably on Windows platforms. The function will simply return if the platform is detected as 'win32'.
	 *
	 * @public
	 */
	realStart() {
		// No known way to make it work reliably on Windows
		if (process.platform === 'win32') {
			return;
		}

		this.rl = readline.createInterface({
			input: process.stdin,
			output: this.mutedStream
		});

		this.rl.on('SIGINT', () => {
			if (process.listenerCount('SIGINT') === 0) {
				process.emit('SIGINT');
			} else {
				this.rl.close();
				process.kill(process.pid, 'SIGINT');
			}
		});
	}

	/**
	 * Closes the readline interface if it is open.
	 *
	 * This method checks if the current process is running on Windows. If so,
	 * it does nothing as readline interfaces are not used on Windows platforms.
	 * Otherwise, it closes the readline interface and sets it to undefined.
	 */
	realStop() {
		if (process.platform === 'win32') {
			return;
		}

		this.rl.close();
		this.rl = undefined;
	}
}

let stdinDiscarder;

class Ora {
	constructor(options) {
		if (!stdinDiscarder) {
			stdinDiscarder = new StdinDiscarder();
		}

		if (typeof options === 'string') {
			options = {
				text: options
			};
		}

		this.options = {
			text: '',
			color: 'cyan',
			stream: process.stderr,
			discardStdin: true,
			...options
		};

		this.spinner = this.options.spinner;

		this.color = this.options.color;
		this.hideCursor = this.options.hideCursor !== false;
		this.interval = this.options.interval || this.spinner.interval || 100;
		this.stream = this.options.stream;
		this.id = undefined;
		this.isEnabled = typeof this.options.isEnabled === 'boolean' ? this.options.isEnabled : isInteractive({stream: this.stream});
		this.isSilent = typeof this.options.isSilent === 'boolean' ? this.options.isSilent : false;

		// Set *after* `this.stream`
		this.text = this.options.text;
		this.prefixText = this.options.prefixText;
		this.linesToClear = 0;
		this.indent = this.options.indent;
		this.discardStdin = this.options.discardStdin;
		this.isDiscardingStdin = false;
	}

	get indent() {
		return this._indent;
	}

	set indent(indent = 0) {
		if (!(indent >= 0 && Number.isInteger(indent))) {
			throw new Error('The `indent` option must be an integer from 0 and up');
		}

		this._indent = indent;
	}

	/**
	 * Updates the interval property of the instance.
	 *
	 * @param {number} [interval] - The new interval value to set. If undefined, the current interval remains unchanged.
	 */
	_updateInterval(interval) {
		if (interval !== undefined) {
			this.interval = interval;
		}
	}

	get spinner() {
		return this._spinner;
	}

	set spinner(spinner) {
		this.frameIndex = 0;

		if (typeof spinner === 'object') {
			if (spinner.frames === undefined) {
				throw new Error('The given spinner must have a `frames` property');
			}

			this._spinner = spinner;
		} else if (!isUnicodeSupported()) {
			this._spinner = cliSpinners.line;
		} else if (spinner === undefined) {
			// Set default spinner
			this._spinner = cliSpinners.dots;
		} else if (spinner !== 'default' && cliSpinners[spinner]) {
			this._spinner = cliSpinners[spinner];
		} else {
			throw new Error(`There is no built-in spinner named '${spinner}'. See https://github.com/sindresorhus/cli-spinners/blob/main/spinners.json for a full list.`);
		}

		this._updateInterval(this._spinner.interval);
	}

	get text() {
		return this[TEXT];
	}

	set text(value) {
		this[TEXT] = value;
		this.updateLineCount();
	}

	get prefixText() {
		return this[PREFIX_TEXT];
	}

	set prefixText(value) {
		this[PREFIX_TEXT] = value;
		this.updateLineCount();
	}

	get isSpinning() {
		return this.id !== undefined;
	}

	/**
	 * Gets the full prefix text by appending a postfix to either a string or the result of a function.
	 *
	 * @param {string|function} [prefixText=this[PREFIX_TEXT]] - The prefix text, which can be a string or a function returning a string. If not provided, defaults to `this[PREFIX_TEXT]`.
	 * @param {string} [postfix=' '] - The postfix string to append after the prefix. Defaults to a space.
	 * @returns {string} - The full prefix text with the postfix appended.
	 *
	 * @example
	 * // Using a string as prefixText
	 * const result1 = getFullPrefixText('Hello');
	 * console.log(result1); // Outputs: "Hello "
	 *
	 * // Using a function returning a string as prefixText
	 * function dynamicPrefix() {
	 *   return 'Dynamic';
	 * }
	 * const result2 = getFullPrefixText(dynamicPrefix);
	 * console.log(result2); // Outputs: "Dynamic "
	 */
	getFullPrefixText(prefixText = this[PREFIX_TEXT], postfix = ' ') {
		if (typeof prefixText === 'string') {
			return prefixText + postfix;
		}

		if (typeof prefixText === 'function') {
			return prefixText() + postfix;
		}

		return '';
	}

	/**
	 * Updates the line count based on the current stream's columns and text content.
	 *
	 * @returns {void}
	 */
	updateLineCount() {
		const columns = this.stream.columns || 80;
		const fullPrefixText = this.getFullPrefixText(this.prefixText, '-');
		this.lineCount = 0;
		for (const line of stripAnsi(fullPrefixText + '--' + this[TEXT]).split('\n')) {
			this.lineCount += Math.max(1, Math.ceil(wcwidth(line) / columns));
		}
	}

	get isEnabled() {
		return this._isEnabled && !this.isSilent;
	}

	set isEnabled(value) {
		if (typeof value !== 'boolean') {
			throw new TypeError('The `isEnabled` option must be a boolean');
		}

		this._isEnabled = value;
	}

	get isSilent() {
		return this._isSilent;
	}

	set isSilent(value) {
		if (typeof value !== 'boolean') {
			throw new TypeError('The `isSilent` option must be a boolean');
		}

		this._isSilent = value;
	}

	/**
	 * Generates the current frame of the spinner with optional text and color.
	 *
	 * @returns {string} - The formatted frame string to be displayed.
	 */
	frame() {
		const {frames} = this.spinner;
		let frame = frames[this.frameIndex];

		if (this.color) {
			frame = chalk[this.color](frame);
		}

		this.frameIndex = ++this.frameIndex % frames.length;
		const fullPrefixText = (typeof this.prefixText === 'string' && this.prefixText !== '') ? this.prefixText + ' ' : '';
		const fullText = typeof this.text === 'string' ? ' ' + this.text : '';

		return fullPrefixText + frame + fullText;
	}

	/**
	 * Clears the lines that have been written to the stream.
	 *
	 * This method is used to clear the lines in the output if the stream is a TTY (terminal)
	 * and the logging is enabled. It moves the cursor up, clears each line, and resets
	 * the cursor position to the specified indentation level.
	 *
	 * @returns {Object} The current instance of the class, allowing for method chaining.
	 */
	clear() {
		if (!this.isEnabled || !this.stream.isTTY) {
			return this;
		}

		for (let i = 0; i < this.linesToClear; i++) {
			if (i > 0) {
				this.stream.moveCursor(0, -1);
			}

			this.stream.clearLine();
			this.stream.cursorTo(this.indent);
		}

		this.linesToClear = 0;

		return this;
	}

	/**
	 * Renders the current state of the object to the output stream if not silent.
	 * Clears any previous lines that need to be cleared before rendering.
	 *
	 * @returns {object} The current instance for method chaining.
	 */
	render() {
		if (this.isSilent) {
			return this;
		}

		this.clear();
		this.stream.write(this.frame());
		this.linesToClear = this.lineCount;

		return this;
	}

	/**
	 * Starts the spinner with the provided text.
	 *
	 * @param {string} [text] - The text to display next to the spinner.
	 * @return {object} - Returns the current instance of the object for method chaining.
	 *
	 * Example:
	 * ```
	 * spinner.start('Loading...');
	 * ```
	 */
	start(text) {
		if (text) {
			this.text = text;
		}

		if (this.isSilent) {
			return this;
		}

		if (!this.isEnabled) {
			if (this.text) {
				this.stream.write(`- ${this.text}\n`);
			}

			return this;
		}

		if (this.isSpinning) {
			return this;
		}

		if (this.hideCursor) {
			cliCursor.hide(this.stream);
		}

		if (this.discardStdin && process.stdin.isTTY) {
			this.isDiscardingStdin = true;
			stdinDiscarder.start();
		}

		this.render();
		this.id = setInterval(this.render.bind(this), this.interval);

		return this;
	}

	/**
	 * Stops any ongoing animation or interval set by the instance.
	 *
	 * If the instance is not currently enabled, it will return immediately without performing any actions.
	 *
	 * @return {Object} The current instance for method chaining.
	 */
	stop() {
		if (!this.isEnabled) {
			return this;
		}

		clearInterval(this.id);
		this.id = undefined;
		this.frameIndex = 0;
		this.clear();
		if (this.hideCursor) {
			cliCursor.show(this.stream);
		}

		if (this.discardStdin && process.stdin.isTTY && this.isDiscardingStdin) {
			stdinDiscarder.stop();
			this.isDiscardingStdin = false;
		}

		return this;
	}

	/**
	 * Logs a success message with the given text.
	 *
	 * @param {string} text - The text to log as a success message.
	 * @returns {Object} - An object containing a symbol and the provided text.
	 */
	succeed(text) {
		return this.stopAndPersist({symbol: logSymbols.success, text});
	}

	/**
	 * Logs an error message and stops the operation, persisting the result.
	 *
	 * @param {string} text - The error message to log.
	 * @returns {Object} - An object containing a symbol indicating an error and the provided text.
	 */
	fail(text) {
		return this.stopAndPersist({symbol: logSymbols.error, text});
	}

	/**
	 * Logs a warning message.
	 *
	 * @param {string} text - The warning message to log.
	 * @returns {object} - An object containing the symbol and text of the logged message.
	 * @throws {Error} - Throws an error if the text is not provided.
	 */
	warn(text) {
		return this.stopAndPersist({symbol: logSymbols.warning, text});
	}

	/**
	 * Logs an informational message with a symbol.
	 *
	 * @param {string} text - The text to log as an informational message.
	 * @returns {Object} - An object containing the log symbol and the text.
	 * @throws {Error} - Throws an error if the input is not a string.
	 */
	info(text) {
		return this.stopAndPersist({symbol: logSymbols.info, text});
	}

	/**
	 * Stops any ongoing stream or operation and persists the current state with an optional text prefix and symbol.
	 *
	 * @param {Object} [options={}] - Configuration options for persisting the state.
	 * @param {string} [options.prefixText] - Additional text to prepend before the main text. Defaults to instance's `prefixText` if not provided.
	 * @param {string} [options.text=''] - The main text to be persisted. If provided, it will be appended with a space.
	 * @param {string} [options.symbol=' '] - A symbol or character to append after the prefix and main text. Defaults to a single space if not provided.
	 * @returns {SupportedLanguage} - Returns the current instance for method chaining.
	 *
	 * @example
	 * // Persist with default settings
	 * language.stopAndPersist();
	 *
	 * // Persist with custom prefixText, text, and symbol
	 * language.stopAndPersist({ prefixText: 'Custom Prefix', text: 'Main Text', symbol: '*' });
	 */
	stopAndPersist(options = {}) {
		if (this.isSilent) {
			return this;
		}

		const prefixText = options.prefixText || this.prefixText;
		const text = options.text || this.text;
		const fullText = (typeof text === 'string') ? ' ' + text : '';

		this.stop();
		this.stream.write(`${this.getFullPrefixText(prefixText, ' ')}${options.symbol || ' '}${fullText}\n`);

		return this;
	}
}

const oraFactory = function (options) {
	return new Ora(options);
};

module.exports = oraFactory;

module.exports.promise = (action, options) => {
	// eslint-disable-next-line promise/prefer-await-to-then
	if (typeof action.then !== 'function') {
		throw new TypeError('Parameter `action` must be a Promise');
	}

	const spinner = new Ora(options);
	spinner.start();

	(async () => {
		try {
			await action;
			spinner.succeed();
		} catch {
			spinner.fail();
		}
	})();

	return spinner;
};
