"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
jest.mock('fs');
//@ts-ignore
const fs_1 = require("fs");
const src_1 = require("../src");
describe(`exists`, () => {
    let statSync;
    let statSyncMock;
    let path;
    beforeEach(() => {
        path = `./path/${Math.random()}`;
        fs_1.addStatSyncMock(statSyncMock = jest.fn(() => statSync()));
    });
    afterEach(() => {
        fs_1.assertMocksUsed();
        statSync = statSyncMock = undefined;
    });
    describe('known errors', () => {
        beforeEach(() => givenStatSyncThrows({ code: 'ENOENT' }));
        it('with type', () => {
            expect(src_1.exists(path, src_1.READABLE)).toBe(false);
        });
        it('with type omitted', () => {
            expect(src_1.exists(path)).toBe(false);
        });
    });
    describe('unknown errors', () => {
        let err;
        beforeEach(() => err = givenStatSyncThrows(new Error('something')));
        it('with type', () => {
            expect(() => src_1.exists(path, src_1.READABLE)).toThrow(err);
        });
        it('with type omitted', () => {
            expect(() => src_1.exists(path)).toThrow(err);
        });
    });
    describe('path is a file', () => {
        beforeEach(() => givenStatSyncIsA('file'));
        existsReturns(true, false, true);
    });
    describe('path is a folder', () => {
        beforeEach(() => givenStatSyncIsA('folder'));
        existsReturns(false, true, true);
    });
    describe('path is unknown', () => {
        beforeEach(() => givenStatSyncIsA('unknown'));
        existsReturns(false, false, false);
    });
    /**
     * Checks if a given path exists as a file, folder, or readable entity, based on the specified type.
     *
     * @param {string} file - The expected result when searching for a file.
     * @param {string} folder - The expected result when searching for a folder.
     * @param {string} readable - The expected result when searching for either a file or a folder.
     */
    function existsReturns(file, folder, readable) {
        it('when searching for a file', () => {
            expect(src_1.exists(path, src_1.FILE)).toBe(file);
        });
        it('when searching for a folder', () => {
            expect(src_1.exists(path, src_1.FOLDER)).toBe(folder);
        });
        it('when searching for either', () => {
            expect(src_1.exists(path, src_1.READABLE)).toBe(readable);
        });
        it('when searching without a type', () => {
            expect(src_1.exists(path)).toBe(readable);
        });
    }
    /**
     * Simulates the behavior of `statSync` by throwing an error.
     *
     * @param {Error} err - The error to be thrown when `statSync` is called.
     * @returns {Error} - The error that was passed as a parameter.
     *
     * @example
     * try {
     *   givenStatSyncThrows(new Error('File not found'));
     * } catch (e) {
     *   console.error(e.message); // Output: File not found
     * }
     */
    function givenStatSyncThrows(err) {
        statSync = () => { throw err; };
        return err;
    }
    /**
     * Creates a mock function for `statSync` that returns a mock object based on the specified type.
     *
     * @param {string} type - The type to determine the mock behavior. Can be 'file' or 'folder'.
     * @returns {Object} A mock object with methods `isFile` and `isDirectory`.
     * @throws {Error} If an unsupported type is provided, throws an error.
     *
     * Example:
     * const mockStat = givenStatSyncIsA('file');
     * console.log(mockStat.isFile()); // true
     * console.log(mockStat.isDirectory()); // false
     */
    function givenStatSyncIsA(type) {
        const mockStat = {
            isFile() { return type === 'file'; },
            isDirectory() { return type === 'folder'; },
        };
        statSync = () => mockStat;
        return mockStat;
    }
});
//# sourceMappingURL=exists.spec.js.map