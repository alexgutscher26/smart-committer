const conversions = require('./conversions');

/*
	This function routes a model to all other models.

	all functions that are routed have a property `.conversion` attached
	to the returned synthetic function. This property is an array
	of strings, each with the steps in between the 'from' and 'to'
	color models (inclusive).

	conversions that are not possible simply are not included.
*/

/**
 * Builds a graph representation of available language conversions.
 *
 * @returns {Object} - A graph object where keys are model names and values are objects containing distance and parent properties.
 *
 * Example usage:
 * const graph = buildGraph();
 * console.log(graph);
 */
function buildGraph() {
	const graph = {};
	// https://jsperf.com/object-keys-vs-for-in-with-closure/3
	const models = Object.keys(conversions);

	for (let len = models.length, i = 0; i < len; i++) {
		graph[models[i]] = {
			// http://jsperf.com/1-vs-infinity
			// micro-opt, but this is simple.
			distance: -1,
			parent: null
		};
	}

	return graph;
}

// https://en.wikipedia.org/wiki/Breadth-first_search
/**
 * Performs a breadth-first search (BFS) to derive distances from a given model.
 *
 * @param {string} fromModel - The starting model for the BFS traversal.
 * @returns {Object} - An object representing the graph with each node's distance and parent.
 */
function deriveBFS(fromModel) {
	const graph = buildGraph();
	const queue = [fromModel]; // Unshift -> queue -> pop

	graph[fromModel].distance = 0;

	while (queue.length) {
		const current = queue.pop();
		const adjacents = Object.keys(conversions[current]);

		for (let len = adjacents.length, i = 0; i < len; i++) {
			const adjacent = adjacents[i];
			const node = graph[adjacent];

			if (node.distance === -1) {
				node.distance = graph[current].distance + 1;
				node.parent = current;
				queue.unshift(adjacent);
			}
		}
	}

	return graph;
}

/**
 * Creates a new function that links two functions together.
 *
 * @param {function} from - The first function to apply.
 * @param {function} to - The second function to apply after the first.
 * @returns {function} A new function that applies 'from' followed by 'to'.
 */
function link(from, to) {
	return function (args) {
		return to(from(args));
	};
}

/**
 * Wraps a conversion function to include the full path of transformations.
 *
 * @param {string} toModel - The target model for conversion.
 * @param {Object} graph - The transformation graph object.
 * @returns {Function} - A wrapped conversion function with an additional 'conversion' property indicating the path of transformations.
 *
 * @example
 * const wrappedFn = wrapConversion('targetModel', transformationGraph);
 * console.log(wrappedFn.conversion); // Output: ['parent1', 'parent2', 'targetModel']
 */
function wrapConversion(toModel, graph) {
	const path = [graph[toModel].parent, toModel];
	let fn = conversions[graph[toModel].parent][toModel];

	let cur = graph[toModel].parent;
	while (graph[cur].parent) {
		path.unshift(graph[cur].parent);
		fn = link(conversions[graph[cur].parent][cur], fn);
		cur = graph[cur].parent;
	}

	fn.conversion = path;
	return fn;
}

module.exports = function (fromModel) {
	const graph = deriveBFS(fromModel);
	const conversion = {};

	const models = Object.keys(graph);
	for (let len = models.length, i = 0; i < len; i++) {
		const toModel = models[i];
		const node = graph[toModel];

		if (node.parent === null) {
			// No possible conversion, or this node is the source model.
			continue;
		}

		conversion[toModel] = wrapConversion(toModel, graph);
	}

	return conversion;
};

