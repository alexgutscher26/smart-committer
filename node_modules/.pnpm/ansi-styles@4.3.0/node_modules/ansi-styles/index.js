'use strict';

/**
 * Wraps an ANSI color function with an offset to generate a new ANSI color code.
 *
 * @param {Function} fn - The ANSI color function to be wrapped.
 * @param {number} offset - The offset to apply to the ANSI color code generated by the wrapped function.
 * @returns {Function} - A new function that, when called with arguments, returns a string prefixed with an ANSI escape sequence for the modified color code.
 *
 * @example
 * const green = wrapAnsi16(ansiColor.green, 20);
 * console.log(green('Hello')); // Outputs: \u001B[34mHello\u001B[0m (assuming ansiColor.green returns 34)
 */
const wrapAnsi16 = (fn, offset) => (...args) => {
	const code = fn(...args);
	return `\u001B[${code + offset}m`;
};

/**
 * Wraps a function that generates an ANSI color code with an offset to produce a new function.
 *
 * @param {Function} fn - The function that generates the base ANSI color code.
 * @param {number} offset - The offset value to be added to the base ANSI color code.
 * @returns {Function} A new function that returns the wrapped ANSI escape sequence.
 */
const wrapAnsi256 = (fn, offset) => (...args) => {
	const code = fn(...args);
	return `\u001B[${38 + offset};5;${code}m`;
};

/**
 * Wraps an ANSI color function with a specific offset to create a new color function.
 *
 * @param {Function} fn - The original ANSI color function that takes RGB values and returns a color code.
 * @param {number} offset - The offset value to be added to the base ANSI color code (e.g., 38 for foreground colors).
 * @returns {Function} A new function that applies the original function with the provided RGB values and combines it with an ANSI escape code based on the specified offset.
 *
 * @example
 * const rgbToAnsi256 = require('rgb-to-ansi');
 * const wrapAnsi16m = (fn, offset) => (...args) => {
 *   const rgb = fn(...args);
 *   return `\u001B[${38 + offset};2;${rgb[0]};${rgb[1]};${rgb[2]}m`;
 * };
 *
 * const redFg = wrapAnsi16m(rgbToAnsi256, 38);
 * console.log(redFg(255, 0, 0)); // Output: "\u001B[38;2;255;0;0m"
 */
const wrapAnsi16m = (fn, offset) => (...args) => {
	const rgb = fn(...args);
	return `\u001B[${38 + offset};2;${rgb[0]};${rgb[1]};${rgb[2]}m`;
};

/**
 * A function that takes a number as input and returns the same number.
 *
 * @param {number} n - The number to return.
 * @returns {number} The same number as the input.
 */
const ansi2ansi = n => n;
/**
 * Converts RGB values to an array representation of those values.
 *
 * @param {number} r - The red component of the color (0-255).
 * @param {number} g - The green component of the color (0-255).
 * @param {number} b - The blue component of the color (0-255).
 * @returns {Array<number>} An array containing the red, green, and blue components of the color.
 *
 * Example:
 * rgb2rgb(255, 165, 0); // Returns [255, 165, 0]
 */
const rgb2rgb = (r, g, b) => [r, g, b];

/**
 * Sets a lazy property on an object. The getter function is called only once when the property is accessed for the first time,
 * and its result is cached.
 *
 * @param {Object} object - The object to which the lazy property will be added.
 * @param {string} property - The name of the property to set.
 * @param {Function} get - A getter function that returns the value to be stored in the property. This function is called only once.
 *
 * @example
 * const obj = {};
 * setLazyProperty(obj, 'foo', () => {
 *   console.log('Computing foo...');
 *   return 'bar';
 * });
 * console.log(obj.foo); // Output: Computing foo... bar
 * console.log(obj.foo); // Output: bar (cached value)
 */
const setLazyProperty = (object, property, get) => {
	Object.defineProperty(object, property, {
		get: () => {
			const value = get();

			Object.defineProperty(object, property, {
				value,
				enumerable: true,
				configurable: true
			});

			return value;
		},
		enumerable: true,
		configurable: true
	});
};

/** @type {typeof import('color-convert')} */
let colorConvert;
/**
 * Generates dynamic styles based on color conversions.
 *
 * @param {Function} wrap - A function to wrap the identity with an offset.
 * @param {string} targetSpace - The target color space for conversion.
 * @param {any} identity - The identity value or reference.
 * @param {boolean} isBackground - Whether the style is for a background.
 * @returns {Object} An object containing styles for different color spaces.
 * @throws {Error} If 'color-convert' module is not found.
 *
 * @example
 * const wrap = (fn, offset) => (...args) => fn(...args) + offset;
 * const targetSpace = 'hsl';
 * const identity = 255;
 * const isBackground = true;
 * console.log(makeDynamicStyles(wrap, targetSpace, identity, isBackground));
 */
const makeDynamicStyles = (wrap, targetSpace, identity, isBackground) => {
	if (colorConvert === undefined) {
		colorConvert = require('color-convert');
	}

	const offset = isBackground ? 10 : 0;
	const styles = {};

	for (const [sourceSpace, suite] of Object.entries(colorConvert)) {
		const name = sourceSpace === 'ansi16' ? 'ansi' : sourceSpace;
		if (sourceSpace === targetSpace) {
			styles[name] = wrap(identity, offset);
		} else if (typeof suite === 'object') {
			styles[name] = wrap(suite[targetSpace], offset);
		}
	}

	return styles;
};

/**
 * Assembles styles for terminal output.
 *
 * This function creates and configures style objects for different terminal color and
 * modifier codes. It sets up properties for opening and closing each style, as well as
 * aliases for certain styles.
 *
 * @returns {Object} - An object containing style properties and methods.
 */
function assembleStyles() {
	const codes = new Map();
	const styles = {
		modifier: {
			reset: [0, 0],
			// 21 isn't widely supported and 22 does the same thing
			bold: [1, 22],
			dim: [2, 22],
			italic: [3, 23],
			underline: [4, 24],
			inverse: [7, 27],
			hidden: [8, 28],
			strikethrough: [9, 29]
		},
		color: {
			black: [30, 39],
			red: [31, 39],
			green: [32, 39],
			yellow: [33, 39],
			blue: [34, 39],
			magenta: [35, 39],
			cyan: [36, 39],
			white: [37, 39],

			// Bright color
			blackBright: [90, 39],
			redBright: [91, 39],
			greenBright: [92, 39],
			yellowBright: [93, 39],
			blueBright: [94, 39],
			magentaBright: [95, 39],
			cyanBright: [96, 39],
			whiteBright: [97, 39]
		},
		bgColor: {
			bgBlack: [40, 49],
			bgRed: [41, 49],
			bgGreen: [42, 49],
			bgYellow: [43, 49],
			bgBlue: [44, 49],
			bgMagenta: [45, 49],
			bgCyan: [46, 49],
			bgWhite: [47, 49],

			// Bright color
			bgBlackBright: [100, 49],
			bgRedBright: [101, 49],
			bgGreenBright: [102, 49],
			bgYellowBright: [103, 49],
			bgBlueBright: [104, 49],
			bgMagentaBright: [105, 49],
			bgCyanBright: [106, 49],
			bgWhiteBright: [107, 49]
		}
	};

	// Alias bright black as gray (and grey)
	styles.color.gray = styles.color.blackBright;
	styles.bgColor.bgGray = styles.bgColor.bgBlackBright;
	styles.color.grey = styles.color.blackBright;
	styles.bgColor.bgGrey = styles.bgColor.bgBlackBright;

	for (const [groupName, group] of Object.entries(styles)) {
		for (const [styleName, style] of Object.entries(group)) {
			styles[styleName] = {
				open: `\u001B[${style[0]}m`,
				close: `\u001B[${style[1]}m`
			};

			group[styleName] = styles[styleName];

			codes.set(style[0], style[1]);
		}

		Object.defineProperty(styles, groupName, {
			value: group,
			enumerable: false
		});
	}

	Object.defineProperty(styles, 'codes', {
		value: codes,
		enumerable: false
	});

	styles.color.close = '\u001B[39m';
	styles.bgColor.close = '\u001B[49m';

	setLazyProperty(styles.color, 'ansi', () => makeDynamicStyles(wrapAnsi16, 'ansi16', ansi2ansi, false));
	setLazyProperty(styles.color, 'ansi256', () => makeDynamicStyles(wrapAnsi256, 'ansi256', ansi2ansi, false));
	setLazyProperty(styles.color, 'ansi16m', () => makeDynamicStyles(wrapAnsi16m, 'rgb', rgb2rgb, false));
	setLazyProperty(styles.bgColor, 'ansi', () => makeDynamicStyles(wrapAnsi16, 'ansi16', ansi2ansi, true));
	setLazyProperty(styles.bgColor, 'ansi256', () => makeDynamicStyles(wrapAnsi256, 'ansi256', ansi2ansi, true));
	setLazyProperty(styles.bgColor, 'ansi16m', () => makeDynamicStyles(wrapAnsi16m, 'rgb', rgb2rgb, true));

	return styles;
}

// Make the export immutable
Object.defineProperty(module, 'exports', {
	enumerable: true,
	get: assembleStyles
});
