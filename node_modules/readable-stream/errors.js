'use strict';

const codes = {};

/**
 * Creates a new error type with a given code, message, and optional base class.
 *
 * @param {string} code - The unique code for the error type.
 * @param {(string|Function)} message - A string or function that returns the error message.
 * @param {Error} [Base=Error] - The base class for the new error type. Defaults to Error if not provided.
 *
 * @example
 * createErrorType('E_INVALID_INPUT', 'Invalid input');
 *
 * @throws {TypeError} If the code is not a string or Base is not an Error instance.
 */
function createErrorType(code, message, Base) {
  if (!Base) {
    Base = Error
  }

  /**
   * Retrieves a message based on the provided arguments.
   *
   * @param {string|Function} message - The message to return or a function that generates the message.
   * @param {*} arg1 - First argument passed to the message function if applicable.
   * @param {*} arg2 - Second argument passed to the message function if applicable.
   * @param {*} arg3 - Third argument passed to the message function if applicable.
   * @returns {string} The resolved message.
   *
   * @example
   * getMessage('Hello, World!');
   * // returns 'Hello, World!'
   *
   * getMessage(() => 'Generated Message');
   * // returns 'Generated Message'
   *
   * getMessage((a, b) => a + b, 1, 2);
   * // returns 3
   */
  function getMessage (arg1, arg2, arg3) {
    if (typeof message === 'string') {
      return message
    } else {
      return message(arg1, arg2, arg3)
    }
  }

  class NodeError extends Base {
    constructor (arg1, arg2, arg3) {
      super(getMessage(arg1, arg2, arg3));
    }
  }

  NodeError.prototype.name = Base.name;
  NodeError.prototype.code = code;

  codes[code] = NodeError;
}

// https://github.com/nodejs/node/blob/v10.8.0/lib/internal/errors.js
/**
 * Generates a human-readable string indicating that a value must be one of several options.
 *
 * @param {Array|string} expected - The expected values. Can be an array of strings or a single value.
 * @param {string} thing - A label describing the thing being checked (e.g., "color", "value").
 * @returns {string} A string indicating that the input must be one of the specified options.
 *
 * @example
 * // Returns 'one of color red, green, or blue'
 * console.log(oneOf(['red', 'green', 'blue'], 'color'));
 *
 * @example
 * // Returns 'of value 10'
 * console.log(oneOf(10, 'value'));
 */
function oneOf(expected, thing) {
  if (Array.isArray(expected)) {
    const len = expected.length;
    expected = expected.map((i) => String(i));
    if (len > 2) {
      return `one of ${thing} ${expected.slice(0, len - 1).join(', ')}, or ` +
             expected[len - 1];
    } else if (len === 2) {
      return `one of ${thing} ${expected[0]} or ${expected[1]}`;
    } else {
      return `of ${thing} ${expected[0]}`;
    }
  } else {
    return `of ${thing} ${String(expected)}`;
  }
}

// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/startsWith
/**
 * Determines if a string begins with the characters of a specified string.
 *
 * @param {string} str - The string to search in.
 * @param {string} search - The string to search for at the start of `str`.
 * @param {number} [pos] - The position in `str` at which to begin searching. Defaults to 0 if not provided or less than 0.
 * @returns {boolean} True if `str` starts with `search`, otherwise false.
 *
 * @example
 * // Returns true
 * startsWith("Hello, world!", "Hello");
 *
 * @example
 * // Returns false
 * startsWith("Hello, world!", "World");
 */
function startsWith(str, search, pos) {
	return str.substr(!pos || pos < 0 ? 0 : +pos, search.length) === search;
}

// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/endsWith
/**
 * Determines whether the string ends with the specified suffix.
 *
 * @param {string} str - The string to search.
 * @param {string} search - The string to search for at the end of the source string.
 * @param {number} [this_len] - Optional. The number of characters at the end of the string to consider.
 * @returns {boolean} - Returns true if the string ends with the specified suffix; otherwise, false.
 *
 * @example
 * // Example usage:
 * const result = endsWith("Hello, world!", "world!");
 * console.log(result); // Output: true
 */
function endsWith(str, search, this_len) {
	if (this_len === undefined || this_len > str.length) {
		this_len = str.length;
	}
	return str.substring(this_len - search.length, this_len) === search;
}

// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/includes
/**
 * Determines if a string contains a specified substring at a given position.
 *
 * @param {string} str - The string to search within.
 * @param {string} search - The substring to search for.
 * @param {number} [start=0] - The starting index of the search. Defaults to 0.
 * @returns {boolean} - Returns true if the substring is found at the specified position, false otherwise.
 *
 * Example:
 * includes("Hello world", "world"); // returns true
 * includes("Hello world", "world", 7); // returns true
 * includes("Hello world", "world", 8); // returns false
 */
function includes(str, search, start) {
  if (typeof start !== 'number') {
    start = 0;
  }

  if (start + search.length > str.length) {
    return false;
  } else {
    return str.indexOf(search, start) !== -1;
  }
}

createErrorType('ERR_INVALID_OPT_VALUE', function (name, value) {
  return 'The value "' + value + '" is invalid for option "' + name + '"'
}, TypeError);
createErrorType('ERR_INVALID_ARG_TYPE', function (name, expected, actual) {
  // determiner: 'must be' or 'must not be'
  let determiner;
  if (typeof expected === 'string' && startsWith(expected, 'not ')) {
    determiner = 'must not be';
    expected = expected.replace(/^not /, '');
  } else {
    determiner = 'must be';
  }

  let msg;
  if (endsWith(name, ' argument')) {
    // For cases like 'first argument'
    msg = `The ${name} ${determiner} ${oneOf(expected, 'type')}`;
  } else {
    const type = includes(name, '.') ? 'property' : 'argument';
    msg = `The "${name}" ${type} ${determiner} ${oneOf(expected, 'type')}`;
  }

  msg += `. Received type ${typeof actual}`;
  return msg;
}, TypeError);
createErrorType('ERR_STREAM_PUSH_AFTER_EOF', 'stream.push() after EOF');
createErrorType('ERR_METHOD_NOT_IMPLEMENTED', function (name) {
  return 'The ' + name + ' method is not implemented'
});
createErrorType('ERR_STREAM_PREMATURE_CLOSE', 'Premature close');
createErrorType('ERR_STREAM_DESTROYED', function (name) {
  return 'Cannot call ' + name + ' after a stream was destroyed';
});
createErrorType('ERR_MULTIPLE_CALLBACK', 'Callback called multiple times');
createErrorType('ERR_STREAM_CANNOT_PIPE', 'Cannot pipe, not readable');
createErrorType('ERR_STREAM_WRITE_AFTER_END', 'write after end');
createErrorType('ERR_STREAM_NULL_VALUES', 'May not write null values to stream', TypeError);
createErrorType('ERR_UNKNOWN_ENCODING', function (arg) {
  return 'Unknown encoding: ' + arg
}, TypeError);
createErrorType('ERR_STREAM_UNSHIFT_AFTER_END_EVENT', 'stream.unshift() after end event');

module.exports.codes = codes;
