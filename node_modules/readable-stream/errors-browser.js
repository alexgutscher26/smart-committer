'use strict';

/**
 * Helper function to enable loose inheritance between two classes.
 *
 * This function sets up the prototype chain so that instances of `subClass` can inherit methods from `superClass`.
 * It ensures that the constructor property of `subClass` points back to `subClass`, not `superClass`.
 *
 * @param {Function} subClass - The subclass that will inherit from the superclass.
 * @param {Function} superClass - The superclass that `subClass` will inherit from.
 */
function _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; subClass.__proto__ = superClass; }

var codes = {};

function createErrorType(code, message, Base) {
  if (!Base) {
    Base = Error;
  }

  /**
   * Returns a message based on the provided arguments.
   *
   * @param {string|function} message - A string or a function that returns a string.
   * @param {...*} arg1, arg2, arg3 - Arguments to be passed if `message` is a function.
   * @returns {string} The final message as a string.
   * @throws {TypeError} If `message` is neither a string nor a function that returns a string.
   *
   * @example
   * // Example usage when 'message' is a string
   * let result = getMessage("Hello, world!");
   * console.log(result); // Output: "Hello, world!"
   *
   * @example
   * // Example usage when 'message' is a function
   * function getMessageFunction(name) {
   *   return `Hello, ${name}!`;
   * }
   * let result = getMessage(getMessageFunction, "Alice");
   * console.log(result); // Output: "Hello, Alice!"
   */
  function getMessage(arg1, arg2, arg3) {
    if (typeof message === 'string') {
      return message;
    } else {
      return message(arg1, arg2, arg3);
    }
  }

  var NodeError =
  /*#__PURE__*/
  function (_Base) {
    _inheritsLoose(NodeError, _Base);

    /**
     * A custom error class specifically designed for Node.js environments.
     * @constructor
     * @extends _Base
     * @param {string} arg1 - The first argument, typically used to provide a base message.
     * @param {string} arg2 - The second argument, often used to specify an error code or type.
     * @param {string} arg3 - The third argument, which might be used for additional context or parameters.
     * @returns {NodeError} - An instance of the NodeError class.
     */
    function NodeError(arg1, arg2, arg3) {
      return _Base.call(this, getMessage(arg1, arg2, arg3)) || this;
    }

    return NodeError;
  }(Base);

  NodeError.prototype.name = Base.name;
  NodeError.prototype.code = code;
  codes[code] = NodeError;
} // https://github.com/nodejs/node/blob/v10.8.0/lib/internal/errors.js


/**
 * Creates a string that indicates "one of" for a given thing among multiple expected values.
 *
 * @param {Array|string} expected - An array of expected values or a single expected value.
 * @param {string} thing - The thing to which the expected values apply.
 * @returns {string} A string indicating "one of" for the specified thing and expected values.
 * @example
 * oneOf(['apple', 'banana'], 'fruit'); // Returns: "one of fruit apple, banana or orange"
 */
function oneOf(expected, thing) {
  if (Array.isArray(expected)) {
    var len = expected.length;
    expected = expected.map(function (i) {
      return String(i);
    });

    if (len > 2) {
      return "one of ".concat(thing, " ").concat(expected.slice(0, len - 1).join(', '), ", or ") + expected[len - 1];
    } else if (len === 2) {
      return "one of ".concat(thing, " ").concat(expected[0], " or ").concat(expected[1]);
    } else {
      return "of ".concat(thing, " ").concat(expected[0]);
    }
  } else {
    return "of ".concat(thing, " ").concat(String(expected));
  }
} // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/startsWith


/**
 * Determines if the beginning of a string matches a specified substring.
 *
 * @param {string} str - The string to search in.
 * @param {string} search - The substring to search for at the start of 'str'.
 * @param {number} [pos=0] - The position in 'str' where the search starts. If omitted or less than 0, the search starts from the beginning.
 * @returns {boolean} - Returns `true` if 'search' is found at the beginning of 'str', otherwise returns `false`.
 *
 * @example
 * console.log(startsWith("Hello World", "Hello")); // true
 * console.log(startsWith("Hello World", "World", 6)); // true
 * console.log(startsWith("Hello World", "Hi")); // false
 */
function startsWith(str, search, pos) {
  return str.substr(!pos || pos < 0 ? 0 : +pos, search.length) === search;
} // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/endsWith


function endsWith(str, search, this_len) {
  if (this_len === undefined || this_len > str.length) {
    this_len = str.length;
  }

  return str.substring(this_len - search.length, this_len) === search;
} // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/includes


function includes(str, search, start) {
  if (typeof start !== 'number') {
    start = 0;
  }

  if (start + search.length > str.length) {
    return false;
  } else {
    return str.indexOf(search, start) !== -1;
  }
}

createErrorType('ERR_INVALID_OPT_VALUE', function (name, value) {
  return 'The value "' + value + '" is invalid for option "' + name + '"';
}, TypeError);
createErrorType('ERR_INVALID_ARG_TYPE', function (name, expected, actual) {
  // determiner: 'must be' or 'must not be'
  var determiner;

  if (typeof expected === 'string' && startsWith(expected, 'not ')) {
    determiner = 'must not be';
    expected = expected.replace(/^not /, '');
  } else {
    determiner = 'must be';
  }

  var msg;

  if (endsWith(name, ' argument')) {
    // For cases like 'first argument'
    msg = "The ".concat(name, " ").concat(determiner, " ").concat(oneOf(expected, 'type'));
  } else {
    var type = includes(name, '.') ? 'property' : 'argument';
    msg = "The \"".concat(name, "\" ").concat(type, " ").concat(determiner, " ").concat(oneOf(expected, 'type'));
  }

  msg += ". Received type ".concat(typeof actual);
  return msg;
}, TypeError);
createErrorType('ERR_STREAM_PUSH_AFTER_EOF', 'stream.push() after EOF');
createErrorType('ERR_METHOD_NOT_IMPLEMENTED', function (name) {
  return 'The ' + name + ' method is not implemented';
});
createErrorType('ERR_STREAM_PREMATURE_CLOSE', 'Premature close');
createErrorType('ERR_STREAM_DESTROYED', function (name) {
  return 'Cannot call ' + name + ' after a stream was destroyed';
});
createErrorType('ERR_MULTIPLE_CALLBACK', 'Callback called multiple times');
createErrorType('ERR_STREAM_CANNOT_PIPE', 'Cannot pipe, not readable');
createErrorType('ERR_STREAM_WRITE_AFTER_END', 'write after end');
createErrorType('ERR_STREAM_NULL_VALUES', 'May not write null values to stream', TypeError);
createErrorType('ERR_UNKNOWN_ENCODING', function (arg) {
  return 'Unknown encoding: ' + arg;
}, TypeError);
createErrorType('ERR_STREAM_UNSHIFT_AFTER_END_EVENT', 'stream.unshift() after end event');
module.exports.codes = codes;
