'use strict';

/**
 * Retrieve all the enumerable properties of an object, including symbols.
 *
 * @param {Object} object - The object from which to retrieve property names.
 * @param {boolean} [enumerableOnly=false] - If true, only return enumerable properties.
 * @returns {Array} An array containing the keys (property names) of the given object.
 * @example
 * const obj = { a: 1, b: 2 };
 * console.log(ownKeys(obj)); // Output: ['a', 'b']
 */
function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }
/**
 * Merges multiple objects into a single target object. This function iterates over each source object,
 * copying properties to the target object. If multiple sources are provided, it processes them in order.
 * For numeric indexed keys, the value from the last source is used.
 *
 * @param {Object} target - The target object that will receive the merged properties.
 * @returns {Object} - The target object with all properties from the sources merged.
 */
function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }
/**
 * Helper function to set a property on an object with default properties if not already present.
 *
 * @param {Object} obj - The target object.
 * @param {*} key - The property key.
 * @param {*} value - The value to set for the property.
 * @returns {Object} - The modified or original object.
 */
function _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
/**
 * Ensures that 'instance' is an instance of 'Constructor'.
 *
 * @private
 * @param {Object} instance - The instance to check.
 * @param {Function} Constructor - The constructor function to verify against.
 * @throws {TypeError} - If 'instance' is not an instance of 'Constructor'.
 */
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
/**
 * Defines properties on an object using descriptors.
 *
 * @private
 * @param {Object} target - The object to define properties on.
 * @param {Array<Object>} props - An array of property descriptors.
 * @returns {void}
 * @throws {TypeError} If `target` is not an object or if `props` is not an array.
 *
 * @example
 * const obj = {};
 * _defineProperties(obj, [
 *   {
 *     key: 'name',
 *     value: 'John',
 *     writable: true,
 *     enumerable: false,
 *     configurable: true
 *   }
 * ]);
 * console.log(obj); // { name: 'John' }
 */
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
/**
 * A utility function to create a class with specified prototype and static properties.
 *
 * @param {Function} Constructor - The constructor function of the class.
 * @param {Array<Object>} [protoProps] - An array of objects defining properties on the class's prototype.
 * @param {Array<Object>} [staticProps] - An array of objects defining properties on the class itself.
 * @returns {Function} - The updated constructor function with applied prototype and static properties.
 */
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return typeof key === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (typeof input !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (typeof res !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
var _require = require('buffer'),
  Buffer = _require.Buffer;
var _require2 = require('util'),
  inspect = _require2.inspect;
var custom = inspect && inspect.custom || 'inspect';
/**
 * Copies data from one Buffer to another.
 *
 * @param {Buffer} src - The source Buffer containing the data to copy.
 * @param {Buffer} target - The target Buffer where the data will be copied.
 * @param {number} offset - The index at which to start copying in the target Buffer.
 * @returns {undefined}
 *
 * @example
 * const src = Buffer.from('Hello, world!', 'utf-8');
 * const target = Buffer.alloc(13);
 * copyBuffer(src, target, 0);
 * console.log(target.toString()); // Outputs: Hello, world!
 *
 * @throws {TypeError} If `src` or `target` is not a Buffer instance.
 * @throws {RangeError} If `offset` is out of bounds for the target Buffer.
 */
function copyBuffer(src, target, offset) {
  Buffer.prototype.copy.call(src, target, offset);
}
module.exports = /*#__PURE__*/function () {
  /**
   * A class representing a list of buffers.
   *
   * @class BufferList
   */
  function BufferList() {
    _classCallCheck(this, BufferList);
    this.head = null;
    this.tail = null;
    this.length = 0;
  }
  _createClass(BufferList, [{
    key: "push",
    value: function push(v) {
      var entry = {
        data: v,
        next: null
      };
      if (this.length > 0) this.tail.next = entry;else this.head = entry;
      this.tail = entry;
      ++this.length;
    }
  }, {
    key: "unshift",
    value: function unshift(v) {
      var entry = {
        data: v,
        next: this.head
      };
      if (this.length === 0) this.tail = entry;
      this.head = entry;
      ++this.length;
    }
  }, {
    key: "shift",
    value: function shift() {
      if (this.length === 0) return;
      var ret = this.head.data;
      if (this.length === 1) this.head = this.tail = null;else this.head = this.head.next;
      --this.length;
      return ret;
    }
  }, {
    key: "clear",
    value: function clear() {
      this.head = this.tail = null;
      this.length = 0;
    }
  }, {
    key: "join",
    value: function join(s) {
      if (this.length === 0) return '';
      var p = this.head;
      var ret = '' + p.data;
      while (p = p.next) ret += s + p.data;
      return ret;
    }
  }, {
    key: "concat",
    value: function concat(n) {
      if (this.length === 0) return Buffer.alloc(0);
      var ret = Buffer.allocUnsafe(n >>> 0);
      var p = this.head;
      var i = 0;
      while (p) {
        copyBuffer(p.data, ret, i);
        i += p.data.length;
        p = p.next;
      }
      return ret;
    }

    // Consumes a specified amount of bytes or characters from the buffered data.
  }, {
    key: "consume",
    value: function consume(n, hasStrings) {
      var ret;
      if (n < this.head.data.length) {
        // `slice` is the same for buffers and strings.
        ret = this.head.data.slice(0, n);
        this.head.data = this.head.data.slice(n);
      } else if (n === this.head.data.length) {
        // First chunk is a perfect match.
        ret = this.shift();
      } else {
        // Result spans more than one buffer.
        ret = hasStrings ? this._getString(n) : this._getBuffer(n);
      }
      return ret;
    }
  }, {
    key: "first",
    value: function first() {
      return this.head.data;
    }

    // Consumes a specified amount of characters from the buffered data.
  }, {
    key: "_getString",
    value: function _getString(n) {
      var p = this.head;
      var c = 1;
      var ret = p.data;
      n -= ret.length;
      while (p = p.next) {
        var str = p.data;
        var nb = n > str.length ? str.length : n;
        if (nb === str.length) ret += str;else ret += str.slice(0, n);
        n -= nb;
        if (n === 0) {
          if (nb === str.length) {
            ++c;
            if (p.next) this.head = p.next;else this.head = this.tail = null;
          } else {
            this.head = p;
            p.data = str.slice(nb);
          }
          break;
        }
        ++c;
      }
      this.length -= c;
      return ret;
    }

    // Consumes a specified amount of bytes from the buffered data.
  }, {
    key: "_getBuffer",
    value: function _getBuffer(n) {
      var ret = Buffer.allocUnsafe(n);
      var p = this.head;
      var c = 1;
      p.data.copy(ret);
      n -= p.data.length;
      while (p = p.next) {
        var buf = p.data;
        var nb = n > buf.length ? buf.length : n;
        buf.copy(ret, ret.length - n, 0, nb);
        n -= nb;
        if (n === 0) {
          if (nb === buf.length) {
            ++c;
            if (p.next) this.head = p.next;else this.head = this.tail = null;
          } else {
            this.head = p;
            p.data = buf.slice(nb);
          }
          break;
        }
        ++c;
      }
      this.length -= c;
      return ret;
    }

    // Make sure the linked list only shows the minimal necessary information.
  }, {
    key: custom,
    value: function value(_, options) {
      return inspect(this, _objectSpread(_objectSpread({}, options), {}, {
        // Only inspect one level.
        depth: 0,
        // It should not recurse.
        customInspect: false
      }));
    }
  }]);
  return BufferList;
}();