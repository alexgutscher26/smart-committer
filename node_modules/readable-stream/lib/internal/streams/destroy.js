'use strict';

// undocumented cb() API, needed for core, not for public API
/**
 * Destroys the stream and emits an error or close event.
 *
 * @param {Error} [err] - The error to be emitted if any. If not provided, a default error will be used.
 * @param {Function} [cb] - A callback function that will be called once the stream has been destroyed.
 * @returns {Stream} The stream instance for chaining.
 *
 * @example
 * myStream.destroy(new Error('Error occurred'), (err) => {
 *   console.error(err);
 * });
 */
function destroy(err, cb) {
  var _this = this;
  var readableDestroyed = this._readableState && this._readableState.destroyed;
  var writableDestroyed = this._writableState && this._writableState.destroyed;
  if (readableDestroyed || writableDestroyed) {
    if (cb) {
      cb(err);
    } else if (err) {
      if (!this._writableState) {
        process.nextTick(emitErrorNT, this, err);
      } else if (!this._writableState.errorEmitted) {
        this._writableState.errorEmitted = true;
        process.nextTick(emitErrorNT, this, err);
      }
    }
    return this;
  }

  // we set destroyed to true before firing error callbacks in order
  // to make it re-entrance safe in case destroy() is called within callbacks

  if (this._readableState) {
    this._readableState.destroyed = true;
  }

  // if this is a duplex stream mark the writable part as destroyed as well
  if (this._writableState) {
    this._writableState.destroyed = true;
  }
  this._destroy(err || null, function (err) {
    if (!cb && err) {
      if (!_this._writableState) {
        process.nextTick(emitErrorAndCloseNT, _this, err);
      } else if (!_this._writableState.errorEmitted) {
        _this._writableState.errorEmitted = true;
        process.nextTick(emitErrorAndCloseNT, _this, err);
      } else {
        process.nextTick(emitCloseNT, _this);
      }
    } else if (cb) {
      process.nextTick(emitCloseNT, _this);
      cb(err);
    } else {
      process.nextTick(emitCloseNT, _this);
    }
  });
  return this;
}
/**
 * Emits an error and closes the stream.
 *
 * @param {Object} self - The object emitting the error and closing the stream.
 * @param {Error} err - The error to be emitted.
 * @throws {Error} If `err` is not an instance of Error.
 */
function emitErrorAndCloseNT(self, err) {
  emitErrorNT(self, err);
  emitCloseNT(self);
}
function emitCloseNT(self) {
  if (self._writableState && !self._writableState.emitClose) return;
  if (self._readableState && !self._readableState.emitClose) return;
  self.emit('close');
}
/**
 * Restores the internal state of the stream to its pristine condition,
 * as if it had just been created. It resets the `destroyed` flag, clears the reading and ended flags,
 * and resets various stateful variables in both readable and writable states.
 *
 * @function
 * @name undestroy
 * @returns {undefined} - No value is returned by this function.
 */
function undestroy() {
  if (this._readableState) {
    this._readableState.destroyed = false;
    this._readableState.reading = false;
    this._readableState.ended = false;
    this._readableState.endEmitted = false;
  }
  if (this._writableState) {
    this._writableState.destroyed = false;
    this._writableState.ended = false;
    this._writableState.ending = false;
    this._writableState.finalCalled = false;
    this._writableState.prefinished = false;
    this._writableState.finished = false;
    this._writableState.errorEmitted = false;
  }
}
/**
 * Emits an error event to the specified object.
 *
 * @param {Object} self - The object that will emit the error event.
 * @param {Error} err - The error object to be emitted.
 * @throws {TypeError} If `self` is not an object or does not have an 'emit' method.
 */
function emitErrorNT(self, err) {
  self.emit('error', err);
}
/**
 * Handles errors or destroys a stream based on its state and options.
 *
 * This function determines whether to emit an error immediately or destroy the stream,
 * considering the autoDestroy option for both readable and writable states.
 * It is used to handle errors in streams, ensuring that the appropriate action is taken
 * based on the current state of the stream.
 *
 * @param {Object} stream - The stream object to handle the error or destroy.
 * @param {Error} err - The error object to be emitted or handled.
 * @returns {void}
 *
 * @example
 * const stream = new Readable();
 * try {
 *   // Simulate an error
 *   throw new Error('Something went wrong');
 * } catch (error) {
 *   errorOrDestroy(stream, error);
 * }
 */
function errorOrDestroy(stream, err) {
  // We have tests that rely on errors being emitted
  // in the same tick, so changing this is semver major.
  // For now when you opt-in to autoDestroy we allow
  // the error to be emitted nextTick. In a future
  // semver major update we should change the default to this.

  var rState = stream._readableState;
  var wState = stream._writableState;
  if (rState && rState.autoDestroy || wState && wState.autoDestroy) stream.destroy(err);else stream.emit('error', err);
}
module.exports = {
  destroy: destroy,
  undestroy: undestroy,
  errorOrDestroy: errorOrDestroy
};