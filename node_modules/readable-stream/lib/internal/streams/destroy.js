'use strict';

// undocumented cb() API, needed for core, not for public API
/**
 * Destroys the stream and emits an error if one was provided.
 *
 * @param {Error} [err] - The error to emit. If not provided, no error is emitted.
 * @param {Function} [cb] - The callback function to call after the destroy process completes. If provided, the close event will be emitted before the callback is called.
 * @returns {Stream} This stream instance.
 *
 * @example
 * stream.destroy(new Error('Something went wrong'));
 */
function destroy(err, cb) {
  var _this = this;
  var readableDestroyed = this._readableState && this._readableState.destroyed;
  var writableDestroyed = this._writableState && this._writableState.destroyed;
  if (readableDestroyed || writableDestroyed) {
    if (cb) {
      cb(err);
    } else if (err) {
      if (!this._writableState) {
        process.nextTick(emitErrorNT, this, err);
      } else if (!this._writableState.errorEmitted) {
        this._writableState.errorEmitted = true;
        process.nextTick(emitErrorNT, this, err);
      }
    }
    return this;
  }

  // we set destroyed to true before firing error callbacks in order
  // to make it re-entrance safe in case destroy() is called within callbacks

  if (this._readableState) {
    this._readableState.destroyed = true;
  }

  // if this is a duplex stream mark the writable part as destroyed as well
  if (this._writableState) {
    this._writableState.destroyed = true;
  }
  this._destroy(err || null, function (err) {
    if (!cb && err) {
      if (!_this._writableState) {
        process.nextTick(emitErrorAndCloseNT, _this, err);
      } else if (!_this._writableState.errorEmitted) {
        _this._writableState.errorEmitted = true;
        process.nextTick(emitErrorAndCloseNT, _this, err);
      } else {
        process.nextTick(emitCloseNT, _this);
      }
    } else if (cb) {
      process.nextTick(emitCloseNT, _this);
      cb(err);
    } else {
      process.nextTick(emitCloseNT, _this);
    }
  });
  return this;
}
function emitErrorAndCloseNT(self, err) {
  emitErrorNT(self, err);
  emitCloseNT(self);
}
/**
 * Emits the 'close' event if both readable and writable streams have finished emitting close events.
 *
 * @param {Object} self - The current instance of the stream or object.
 */
function emitCloseNT(self) {
  if (self._writableState && !self._writableState.emitClose) return;
  if (self._readableState && !self._readableState.emitClose) return;
  self.emit('close');
}
/**
 * Restores the read and write states of an object that has been destroyed.
 * This function sets various state flags to their initial values, effectively
 * bringing back a previously destroyed object's functionality. It is typically used
 * in scenarios where an object needs to be re-initialized after being destroyed,
 * for example, during error handling or when recovering from a previous failure.
 *
 * @returns {undefined}
 */
function undestroy() {
  if (this._readableState) {
    this._readableState.destroyed = false;
    this._readableState.reading = false;
    this._readableState.ended = false;
    this._readableState.endEmitted = false;
  }
  if (this._writableState) {
    this._writableState.destroyed = false;
    this._writableState.ended = false;
    this._writableState.ending = false;
    this._writableState.finalCalled = false;
    this._writableState.prefinished = false;
    this._writableState.finished = false;
    this._writableState.errorEmitted = false;
  }
}
/**
 * Emits an error event to the specified object.
 *
 * @param {Object} self - The object that will emit the error event.
 * @param {Error} err - The error object to be emitted.
 */
function emitErrorNT(self, err) {
  self.emit('error', err);
}
/**
 * Handles errors or destroys the stream based on autoDestroy settings.
 *
 * This function manages how errors are handled in streams. If either the readable or writable state of the stream has `autoDestroy` enabled,
 * it will destroy the stream and emit the error. Otherwise, it will simply emit the error without destroying the stream.
 *
 * @param {Stream} stream - The stream instance to handle.
 * @param {Error} err - The error object to handle or emit.
 * @returns {void}
 * @throws {Error} If an error occurs during the handling process.
 */
function errorOrDestroy(stream, err) {
  // We have tests that rely on errors being emitted
  // in the same tick, so changing this is semver major.
  // For now when you opt-in to autoDestroy we allow
  // the error to be emitted nextTick. In a future
  // semver major update we should change the default to this.

  var rState = stream._readableState;
  var wState = stream._writableState;
  if (rState && rState.autoDestroy || wState && wState.autoDestroy) stream.destroy(err);else stream.emit('error', err);
}
module.exports = {
  destroy: destroy,
  undestroy: undestroy,
  errorOrDestroy: errorOrDestroy
};