// Ported from https://github.com/mafintosh/pump with
// permission from the author, Mathias Buus (@mafintosh).

'use strict';

var eos;
/**
 * Creates a function that is executed only once. Subsequent calls to the function will return undefined.
 *
 * @param {Function} callback - The function to be executed once.
 * @returns {Function} A new function that, when called for the first time, executes `callback` and returns its result.
 Any subsequent calls will return undefined without executing `callback`.
 */
function once(callback) {
  var called = false;
  return function () {
    if (called) return;
    called = true;
    callback.apply(void 0, arguments);
  };
}
var _require$codes = require('../../../errors').codes,
  ERR_MISSING_ARGS = _require$codes.ERR_MISSING_ARGS,
  ERR_STREAM_DESTROYED = _require$codes.ERR_STREAM_DESTROYED;
/**
 * A utility function that rethrows an error if it is provided.
 *
 * @param {Error} [err] - The error to rethrow. If not provided, the function does nothing.
 */
function noop(err) {
  // Rethrow the error if it exists to avoid swallowing it
  if (err) throw err;
}
/**
 * Determines if the provided stream is an HTTP request.
 *
 * @param {any} stream - The stream to check.
 * @returns {boolean} - True if the stream is an HTTP request, false otherwise.
 *
 * @example
 * const http = require('http');
 * const req = http.request('http://example.com', (res) => {
 *   console.log(isRequest(req)); // true
 * });
 */
function isRequest(stream) {
  return stream.setHeader && typeof stream.abort === 'function';
}
/**
 * Creates a function to destroy a stream when called. The returned function will
 * call the provided callback with any error that occurs during destruction.
 *
 * @param {Stream} stream - The stream to be destroyed.
 * @param {boolean} reading - Whether the stream should be considered as being read from.
 * @param {boolean} writing - Whether the stream should be considered as being written to.
 * @param {Function} callback - The function to call when the stream is destroyed or an error occurs.
 * @returns {Function} A function that can be called to destroy the stream.
 *
 * @throws {ERR_STREAM_DESTROYED} If the stream has already been destroyed.
 * @example
 * const destroyFunc = destroyer(myStream, true, false, (err) => {
 *   if (err) console.error('Error destroying stream:', err);
 * });
 * myStream.pipe(destination);
 * myStream.on('end', () => destroyFunc());
 */
function destroyer(stream, reading, writing, callback) {
  callback = once(callback);
  var closed = false;
  stream.on('close', function () {
    closed = true;
  });
  if (eos === undefined) eos = require('./end-of-stream');
  eos(stream, {
    readable: reading,
    writable: writing
  }, function (err) {
    if (err) return callback(err);
    closed = true;
    callback();
  });
  var destroyed = false;
  return function (err) {
    if (closed) return;
    if (destroyed) return;
    destroyed = true;

    // request.destroy just do .end - .abort is what we want
    if (isRequest(stream)) return stream.abort();
    if (typeof stream.destroy === 'function') return stream.destroy();
    callback(err || new ERR_STREAM_DESTROYED('pipe'));
  };
}
/**
 * Executes the provided function.
 *
 * @param {Function} fn - The function to be executed.
 * @throws {TypeError} If `fn` is not a function.
 */
function call(fn) {
  fn();
}
/**
 * Pipes data from one stream to another.
 *
 * @param {ReadableStream} from - The source stream that provides the data.
 * @param {WritableStream} to - The destination stream that receives the data.
 * @returns {WritableStream} The writable stream which is connected to the destination.
 *
 * @example
 * const readable = new ReadableStream();
 * const writable = new WritableStream();
 * pipe(readable, writable);
 */
function pipe(from, to) {
  return from.pipe(to);
}
/**
 * Removes and returns the callback function from the end of an array of streams if present.
 *
 * @param {Array} streams - The array containing stream objects and possibly a callback function at the end.
 * @returns {Function|no-op} - If a callback function is found, it is removed and returned. Otherwise, a no-op function is returned.
 */
function popCallback(streams) {
  if (!streams.length) return noop;
  if (typeof streams[streams.length - 1] !== 'function') return noop;
  return streams.pop();
}
/**
 * Creates a pipeline of streams. This function takes multiple stream arguments,
 * processes them sequentially, and invokes the callback with any errors encountered.
 *
 * @param {...ReadableStream|WritableStream} streams - One or more ReadableStream or WritableStream objects to be pipelined.
 * @returns {Promise} - A promise that resolves when all streams have been processed successfully,
 *                      or rejects if an error occurs.
 * @throws {ERR_MISSING_ARGS} - Throws an error if fewer than two streams are provided.
 *
 * @example
 * const fs = require('fs');
 * const zlib = require('zlib');
 *
 * pipeline(
 *   fs.createReadStream('input.txt'),
 *   zlib.createGzip(),
 *   fs.createWriteStream('output.gz')
 * ).then(() => {
 *   console.log('Pipeline completed successfully.');
 * }).catch(err => {
 *   console.error('Error in pipeline:', err);
 * });
 */
function pipeline() {
  for (var _len = arguments.length, streams = new Array(_len), _key = 0; _key < _len; _key++) {
    streams[_key] = arguments[_key];
  }
  var callback = popCallback(streams);
  if (Array.isArray(streams[0])) streams = streams[0];
  if (streams.length < 2) {
    throw new ERR_MISSING_ARGS('streams');
  }
  var error;
  var destroys = streams.map(function (stream, i) {
    var reading = i < streams.length - 1;
    var writing = i > 0;
    return destroyer(stream, reading, writing, function (err) {
      if (!error) error = err;
      if (err) destroys.forEach(call);
      if (reading) return;
      destroys.forEach(call);
      callback(error);
    });
  });
  return streams.reduce(pipe);
}
module.exports = pipeline;