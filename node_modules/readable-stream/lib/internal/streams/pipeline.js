// Ported from https://github.com/mafintosh/pump with
// permission from the author, Mathias Buus (@mafintosh).

'use strict';

var eos;
/**
 * Creates a function that can only be called one time. Subsequent calls will have no effect.
 *
 * @param {Function} callback - The function to be executed once.
 * @returns {Function} - A new function that, when invoked, will call the original `callback` function
 *                       only if it has not been called before. If called again, it will do nothing.
 */
function once(callback) {
  var called = false;
  return function () {
    if (called) return;
    called = true;
    callback.apply(void 0, arguments);
  };
}
var _require$codes = require('../../../errors').codes,
  ERR_MISSING_ARGS = _require$codes.ERR_MISSING_ARGS,
  ERR_STREAM_DESTROYED = _require$codes.ERR_STREAM_DESTROYED;
/**
 * A no-operation function that rethrows any error it receives.
 *
 * @param {Error} [err] - The error to rethrow. If undefined, the function does nothing.
 */
function noop(err) {
  // Rethrow the error if it exists to avoid swallowing it
  if (err) throw err;
}
function isRequest(stream) {
  return stream.setHeader && typeof stream.abort === 'function';
}
/**
 * Destroys a stream when it is no longer needed.
 *
 * @param {stream.Stream} stream - The stream to destroy.
 * @param {boolean} reading - Indicates whether the readable side of the stream should be destroyed.
 * @param {boolean} writing - Indicates whether the writable side of the stream should be destroyed.
 * @param {Function} callback - A callback function that is called once the stream is destroyed or an error occurs.
 * @returns {Function} A function that can be used to destroy the stream manually if needed.
 *
 * @example
 * const destroyerFn = destroyer(inputStream, true, false, (err) => {
 *   if (err) console.error('Error destroying stream:', err);
 * });
 * // Later, you can call destroyerFn() to destroy the stream manually.
 */
function destroyer(stream, reading, writing, callback) {
  callback = once(callback);
  var closed = false;
  stream.on('close', function () {
    closed = true;
  });
  if (eos === undefined) eos = require('./end-of-stream');
  eos(stream, {
    readable: reading,
    writable: writing
  }, function (err) {
    if (err) return callback(err);
    closed = true;
    callback();
  });
  var destroyed = false;
  return function (err) {
    if (closed) return;
    if (destroyed) return;
    destroyed = true;

    // request.destroy just do .end - .abort is what we want
    if (isRequest(stream)) return stream.abort();
    if (typeof stream.destroy === 'function') return stream.destroy();
    callback(err || new ERR_STREAM_DESTROYED('pipe'));
  };
}
/**
 * Executes the provided function.
 *
 * @param {Function} fn - The function to execute.
 */
function call(fn) {
  fn();
}
/**
 * Pipes data from one stream to another.
 *
 * @param {Object} from - The source stream from which data is read.
 * @param {Object} to - The destination stream to which data is written.
 * @returns {Object} - The destination stream that receives the data.
 * @throws {Error} - If either `from` or `to` is not a valid stream object.
 *
 * Example usage:
 *   const readableStream = fs.createReadStream('file.txt');
 *   const writableStream = fs.createWriteStream('output.txt');
 *   pipe(readableStream, writableStream);
 */
function pipe(from, to) {
  return from.pipe(to);
}
/**
 * Retrieves the last callback function from an array of streams if it exists; otherwise returns a no-op function.
 *
 * @param {Array} streams - The array containing streams and callbacks.
 * @returns {Function} - The last element in the array if it is a function, or a no-op function otherwise.
 *
 * Example usage:
 * const result = popCallback([1, 2, () => console.log('callback')]);
 * console.log(result()); // Outputs: callback
 */
function popCallback(streams) {
  if (!streams.length) return noop;
  if (typeof streams[streams.length - 1] !== 'function') return noop;
  return streams.pop();
}
/**
 * Combines multiple streams into a single readable stream and processes them using provided callbacks.
 *
 * @param {...*} streams - Variable arguments representing the streams to be combined.
 * @returns {Stream} A new stream that represents the combination of all input streams.
 * @throws {ERR_MISSING_ARGS} If fewer than two streams are provided.
 */
function pipeline() {
  for (var _len = arguments.length, streams = new Array(_len), _key = 0; _key < _len; _key++) {
    streams[_key] = arguments[_key];
  }
  var callback = popCallback(streams);
  if (Array.isArray(streams[0])) streams = streams[0];
  if (streams.length < 2) {
    throw new ERR_MISSING_ARGS('streams');
  }
  var error;
  var destroys = streams.map(function (stream, i) {
    var reading = i < streams.length - 1;
    var writing = i > 0;
    return destroyer(stream, reading, writing, function (err) {
      if (!error) error = err;
      if (err) destroys.forEach(call);
      if (reading) return;
      destroys.forEach(call);
      callback(error);
    });
  });
  return streams.reduce(pipe);
}
module.exports = pipeline;