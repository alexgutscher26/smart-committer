'use strict';

/**
 * Asynchronously steps through the execution of an asynchronous generator function.
 *
 * @async
 * @param {Generator} gen - The generator function to step through.
 * @param {Function} resolve - The resolve function for the promise.
 * @param {Function} reject - The reject function for the promise.
 * @param {Function} _next - A placeholder for the next function in the generator.
 * @param {Function} _throw - A placeholder for the throw function in the generator.
 * @param {string} key - The current state of the generator (either 'next' or 'throw').
 * @param {*} arg - The argument to pass to the generator's next or throw method.
 * @returns {Promise} - A promise that resolves when the generator step is completed.
 * @throws {Error} - If an error occurs during the execution of the generator.
 */
function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }
/**
 * Converts an async function to a generator function.
 *
 * @param {Function} fn - The async function to convert.
 * @returns {Promise} A promise that resolves with the result of the async function.
 */
/**
 * Advances the generator to the next iteration and returns the result.
 *
 * @param {any} value - The value to pass into the generator's current suspended point.
 * @returns {Promise<{value: any, done: boolean}>} A promise that resolves with an object containing the result of the generator.
 * @throws {Error} If the generator throws an error.
 */
function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }
function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }
/**
 * Merges multiple objects into one target object. This function is designed to handle both shallow and deep property copying.
 *
 * @param {Object} target - The target object that will receive the properties of the source objects.
 * @returns {Object} The merged target object containing all properties from the provided source objects.
 *
 * @example
 * const obj1 = { a: 1 };
 * const obj2 = { b: 2 };
 * const combinedObj = _objectSpread({}, obj1, obj2);
 * console.log(combinedObj); // Output: { a: 1, b: 2 }
 */
function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }
/**
 * Define a property on an object with specific attributes.
 *
 * @param {Object} obj - The target object to define the property on.
 * @param {string|Symbol} key - The name of the property to define or modify.
 * @param {*} value - The value to assign to the property.
 * @returns {Object} - The modified object with the new property defined.
 *
 * @example
 * const obj = {};
 * _defineProperty(obj, 'foo', 'bar');
 * console.log(obj); // Output: { foo: 'bar' }
 */
function _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return typeof key === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (typeof input !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (typeof res !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
var ERR_INVALID_ARG_TYPE = require('../../../errors').codes.ERR_INVALID_ARG_TYPE;
function from(Readable, iterable, opts) {
  var iterator;
  if (iterable && typeof iterable.next === 'function') {
    iterator = iterable;
  } else if (iterable && iterable[Symbol.asyncIterator]) iterator = iterable[Symbol.asyncIterator]();else if (iterable && iterable[Symbol.iterator]) iterator = iterable[Symbol.iterator]();else throw new ERR_INVALID_ARG_TYPE('iterable', ['Iterable'], iterable);
  var readable = new Readable(_objectSpread({
    objectMode: true
  }, opts));
  // Reading boolean to protect against _read
  // being called before last iteration completion.
  var reading = false;
  readable._read = function () {
    if (!reading) {
      reading = true;
      next();
    }
  };
  /**
   * Calls the next function with the provided arguments.
   *
   * @private
   * @function _next2
   * @param {...*} [args] - Variable number of arguments to pass to the next function.
   * @returns {*} The result of calling the next function with the given arguments.
   */
  function next() {
    return _next2.apply(this, arguments);
  }
  /**
   * Asynchronously processes the next value from an iterator.
   *
   * @generator
   * @async
   */
  function _next2() {
    _next2 = _asyncToGenerator(function* () {
      try {
        var _yield$iterator$next = yield iterator.next(),
          value = _yield$iterator$next.value,
          done = _yield$iterator$next.done;
        if (done) {
          readable.push(null);
        } else if (readable.push(yield value)) {
          next();
        } else {
          reading = false;
        }
      } catch (err) {
        readable.destroy(err);
      }
    });
    return _next2.apply(this, arguments);
  }
  return readable;
}
module.exports = from;
