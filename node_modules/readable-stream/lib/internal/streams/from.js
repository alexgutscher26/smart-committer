'use strict';

/**
 * Helper function used by generator functions to manage asynchronous operations.
 *
 * @param {Object} gen - The generator object.
 * @param {Function} resolve - The function to call when the operation is successful.
 * @param {Function} reject - The function to call if an error occurs during the operation.
 * @param {Function} _next - The next method of the generator.
 * @param {Function} _throw - The throw method of the generator.
 * @param {string} key - The current state in the generator's execution.
 * @param {*} arg - The argument to pass to the generator's next or throw method.
 * @returns {void}
 *
 * @throws {Error} If an error occurs during the operation.
 */
function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }
/**
 * Converts an async function to a generator function that returns a Promise.
 *
 * @param {Function} fn - The async function to convert.
 * @returns {Promise} A Promise that resolves or rejects based on the execution of the async function.
 */
/**
 * Asynchronously handles the next step of a generator function.
 *
 * @private
 * @param {any} value - The value to pass to the generator's next method.
 * @returns {Promise<any>} A promise that resolves with the result of the generator's next method.
 * @throws {Error} If an error occurs during the execution of the generator.
 */
/**
 * Throws an error asynchronously.
 *
 * @param {Error} err - The error to throw.
 */
function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }
/**
 * Returns an array of a given object's own enumerable and non-enumerable properties.
 *
 * @param {Object} object - The object whose own property names are to be returned.
 * @param {boolean} [enumerableOnly=false] - If true, only the enumerable properties will be returned.
 * @returns {Array} An array of strings representing the property names of the given object.
 *
 * @example
 * const obj = { a: 1, b: 2 };
 * console.log(ownKeys(obj)); // ['a', 'b']
 *
 * @example
 * const sym = Symbol('key');
 * const obj = { [sym]: 3, c: 4 };
 * Object.defineProperty(obj, 'c', { enumerable: false });
 * console.log(ownKeys(obj)); // ['Symbol(key)', 'c']
 */
function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }
/**
 * Merges multiple objects into a single object using the spread operator.
 *
 * @param {Object} target - The target object to which properties will be merged.
 * @param {...Object} sources - One or more source objects whose properties will be copied to the target object.
 * @returns {Object} - The target object with properties from all source objects merged.
 *
 * @example
 * const obj1 = { a: 1 };
 * const obj2 = { b: 2 };
 * const result = _objectSpread(obj1, obj2);
 * console.log(result); // Output: { a: 1, b: 2 }
 */
function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }
/**
 * Helper function to define properties on an object.
 * @param {Object} obj - The target object.
 * @param {string} key - The property key.
 * @param {*} value - The value to set for the property.
 * @returns {Object} - The modified object with the new or updated property.
 */
function _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
/**
 * Converts an argument to a property key.
 *
 * @private
 * @param {*} arg - The argument to convert.
 * @returns {string|symbol} - The converted property key as either a string or symbol.
 * @throws {TypeError} - If the conversion results in a non-primitive type other than null.
 *
 * @example
 * // Example usage:
 * const key = _toPropertyKey(42);
 * console.log(key); // Output: '42'
 *
 * const symbolKey = _toPropertyKey(Symbol('test'));
 * console.log(symbolKey); // Output: Symbol(test)
 */
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return typeof key === "symbol" ? key : String(key); }
/**
 * Converts an object to its primitive value using the specified hint.
 *
 * @param {Object} input - The object to convert to a primitive value.
 * @param {string} [hint="default"] - The type of primitive value to return. Can be "string" or "number".
 * @returns {*} The primitive value of the object.
 * @throws {TypeError} If the result of calling the `@@toPrimitive` method is not a primitive value.
 *
 * Example:
 * ```javascript
 * const obj = {
 *   [Symbol.toPrimitive]: function(hint) {
 *     return hint === "number" ? 42 : "forty-two";
 *   }
 * };
 * console.log(_toPrimitive(obj, "string")); // Output: "forty-two"
 * console.log(_toPrimitive(obj, "number")); // Output: 42
 * ```
 */
function _toPrimitive(input, hint) { if (typeof input !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (typeof res !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
var ERR_INVALID_ARG_TYPE = require('../../../errors').codes.ERR_INVALID_ARG_TYPE;
function from(Readable, iterable, opts) {
  var iterator;
  if (iterable && typeof iterable.next === 'function') {
    iterator = iterable;
  } else if (iterable && iterable[Symbol.asyncIterator]) iterator = iterable[Symbol.asyncIterator]();else if (iterable && iterable[Symbol.iterator]) iterator = iterable[Symbol.iterator]();else throw new ERR_INVALID_ARG_TYPE('iterable', ['Iterable'], iterable);
  var readable = new Readable(_objectSpread({
    objectMode: true
  }, opts));
  // Reading boolean to protect against _read
  // being called before last iteration completion.
  var reading = false;
  readable._read = function () {
    if (!reading) {
      reading = true;
      next();
    }
  };
  /**
   * Calls the internal method _next2 with the provided arguments.
   *
   * @function
   * @private
   * @param {...*} arguments - Any number of arguments to pass to _next2.
   * @returns {*} The result of calling _next2 with the provided arguments.
   */
  function next() {
    return _next2.apply(this, arguments);
  }
  /**
   * Asynchronously processes the next item from an iterator and handles it accordingly.
   * This function is intended to be used within a generator that manages reading from a readable stream.
   *
   * @generator
   * @async
   */
  function _next2() {
    _next2 = _asyncToGenerator(function* () {
      try {
        var _yield$iterator$next = yield iterator.next(),
          value = _yield$iterator$next.value,
          done = _yield$iterator$next.done;
        if (done) {
          readable.push(null);
        } else if (readable.push(yield value)) {
          next();
        } else {
          reading = false;
        }
      } catch (err) {
        readable.destroy(err);
      }
    });
    return _next2.apply(this, arguments);
  }
  return readable;
}
module.exports = from;
