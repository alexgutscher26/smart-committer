/**
  @license
                                 Apache License
                         Version 2.0, January 2004
                      http://www.apache.org/licenses/

 TERMS AND CONDITIONS FOR USE, REPRODUCTION, AND DISTRIBUTION

 1. Definitions.

    "License" shall mean the terms and conditions for use, reproduction,
    and distribution as defined by Sections 1 through 9 of this document.

    "Licensor" shall mean the copyright owner or entity authorized by
    the copyright owner that is granting the License.

    "Legal Entity" shall mean the union of the acting entity and all
    other entities that control, are controlled by, or are under common
    control with that entity. For the purposes of this definition,
    "control" means (i) the power, direct or indirect, to cause the
    direction or management of such entity, whether by contract or
    otherwise, or (ii) ownership of fifty percent (50%) or more of the
    outstanding shares, or (iii) beneficial ownership of such entity.

    "You" (or "Your") shall mean an individual or Legal Entity
    exercising permissions granted by this License.

    "Source" form shall mean the preferred form for making modifications,
    including but not limited to software source code, documentation
    source, and configuration files.

    "Object" form shall mean any form resulting from mechanical
    transformation or translation of a Source form, including but
    not limited to compiled object code, generated documentation,
    and conversions to other media types.

    "Work" shall mean the work of authorship, whether in Source or
    Object form, made available under the License, as indicated by a
    copyright notice that is included in or attached to the work
    (an example is provided in the Appendix below).

    "Derivative Works" shall mean any work, whether in Source or Object
    form, that is based on (or derived from) the Work and for which the
    editorial revisions, annotations, elaborations, or other modifications
    represent, as a whole, an original work of authorship. For the purposes
    of this License, Derivative Works shall not include works that remain
    separable from, or merely link (or bind by name) to the interfaces of,
    the Work and Derivative Works thereof.

    "Contribution" shall mean any work of authorship, including
    the original version of the Work and any modifications or additions
    to that Work or Derivative Works thereof, that is intentionally
    submitted to Licensor for inclusion in the Work by the copyright owner
    or by an individual or Legal Entity authorized to submit on behalf of
    the copyright owner. For the purposes of this definition, "submitted"
    means any form of electronic, verbal, or written communication sent
    to the Licensor or its representatives, including but not limited to
    communication on electronic mailing lists, source code control systems,
    and issue tracking systems that are managed by, or on behalf of, the
    Licensor for the purpose of discussing and improving the Work, but
    excluding communication that is conspicuously marked or otherwise
    designated in writing by the copyright owner as "Not a Contribution."

    "Contributor" shall mean Licensor and any individual or Legal Entity
    on behalf of whom a Contribution has been received by Licensor and
    subsequently incorporated within the Work.

 2. Grant of Copyright License. Subject to the terms and conditions of
    this License, each Contributor hereby grants to You a perpetual,
    worldwide, non-exclusive, no-charge, royalty-free, irrevocable
    copyright license to reproduce, prepare Derivative Works of,
    publicly display, publicly perform, sublicense, and distribute the
    Work and such Derivative Works in Source or Object form.

 3. Grant of Patent License. Subject to the terms and conditions of
    this License, each Contributor hereby grants to You a perpetual,
    worldwide, non-exclusive, no-charge, royalty-free, irrevocable
    (except as stated in this section) patent license to make, have made,
    use, offer to sell, sell, import, and otherwise transfer the Work,
    where such license applies only to those patent claims licensable
    by such Contributor that are necessarily infringed by their
    Contribution(s) alone or by combination of their Contribution(s)
    with the Work to which such Contribution(s) was submitted. If You
    institute patent litigation against any entity (including a
    cross-claim or counterclaim in a lawsuit) alleging that the Work
    or a Contribution incorporated within the Work constitutes direct
    or contributory patent infringement, then any patent licenses
    granted to You under this License for that Work shall terminate
    as of the date such litigation is filed.

 4. Redistribution. You may reproduce and distribute copies of the
    Work or Derivative Works thereof in any medium, with or without
    modifications, and in Source or Object form, provided that You
    meet the following conditions:

    (a) You must give any other recipients of the Work or
        Derivative Works a copy of this License; and

    (b) You must cause any modified files to carry prominent notices
        stating that You changed the files; and

    (c) You must retain, in the Source form of any Derivative Works
        that You distribute, all copyright, patent, trademark, and
        attribution notices from the Source form of the Work,
        excluding those notices that do not pertain to any part of
        the Derivative Works; and

    (d) If the Work includes a "NOTICE" text file as part of its
        distribution, then any Derivative Works that You distribute must
        include a readable copy of the attribution notices contained
        within such NOTICE file, excluding those notices that do not
        pertain to any part of the Derivative Works, in at least one
        of the following places: within a NOTICE text file distributed
        as part of the Derivative Works; within the Source form or
        documentation, if provided along with the Derivative Works; or,
        within a display generated by the Derivative Works, if and
        wherever such third-party notices normally appear. The contents
        of the NOTICE file are for informational purposes only and
        do not modify the License. You may add Your own attribution
        notices within Derivative Works that You distribute, alongside
        or as an addendum to the NOTICE text from the Work, provided
        that such additional attribution notices cannot be construed
        as modifying the License.

    You may add Your own copyright statement to Your modifications and
    may provide additional or different license terms and conditions
    for use, reproduction, or distribution of Your modifications, or
    for any such Derivative Works as a whole, provided Your use,
    reproduction, and distribution of the Work otherwise complies with
    the conditions stated in this License.

 5. Submission of Contributions. Unless You explicitly state otherwise,
    any Contribution intentionally submitted for inclusion in the Work
    by You to the Licensor shall be under the terms and conditions of
    this License, without any additional terms or conditions.
    Notwithstanding the above, nothing herein shall supersede or modify
    the terms of any separate license agreement you may have executed
    with Licensor regarding such Contributions.

 6. Trademarks. This License does not grant permission to use the trade
    names, trademarks, service marks, or product names of the Licensor,
    except as required for reasonable and customary use in describing the
    origin of the Work and reproducing the content of the NOTICE file.

 7. Disclaimer of Warranty. Unless required by applicable law or
    agreed to in writing, Licensor provides the Work (and each
    Contributor provides its Contributions) on an "AS IS" BASIS,
    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or
    implied, including, without limitation, any warranties or conditions
    of TITLE, NON-INFRINGEMENT, MERCHANTABILITY, or FITNESS FOR A
    PARTICULAR PURPOSE. You are solely responsible for determining the
    appropriateness of using or redistributing the Work and assume any
    risks associated with Your exercise of permissions under this License.

 8. Limitation of Liability. In no event and under no legal theory,
    whether in tort (including negligence), contract, or otherwise,
    unless required by applicable law (such as deliberate and grossly
    negligent acts) or agreed to in writing, shall any Contributor be
    liable to You for damages, including any direct, indirect, special,
    incidental, or consequential damages of any character arising as a
    result of this License or out of the use or inability to use the
    Work (including but not limited to damages for loss of goodwill,
    work stoppage, computer failure or malfunction, or any and all
    other commercial damages or losses), even if such Contributor
    has been advised of the possibility of such damages.

 9. Accepting Warranty or Additional Liability. While redistributing
    the Work or Derivative Works thereof, You may choose to offer,
    and charge a fee for, acceptance of support, warranty, indemnity,
    or other liability obligations and/or rights consistent with this
    License. However, in accepting such obligations, You may act only
    on Your own behalf and on Your sole responsibility, not on behalf
    of any other Contributor, and only if You agree to indemnify,
    defend, and hold each Contributor harmless for any liability
    incurred by, or claims asserted against, such Contributor by reason
    of your accepting any such warranty or additional liability.

 END OF TERMS AND CONDITIONS

 APPENDIX: How to apply the Apache License to your work.

    To apply the Apache License to your work, attach the following
    boilerplate notice, with the fields enclosed by brackets "[]"
    replaced with your own identifying information. (Don't include
    the brackets!)  The text should be enclosed in the appropriate
    comment syntax for the file format. We also recommend that a
    file or class name and description of purpose be included on the
    same "printed page" as the copyright notice for easier
    identification within third-party archives.

 Copyright (c) 2015-2018 Google, Inc., Netflix, Inc., Microsoft Corp. and contributors

 Licensed under the Apache License, Version 2.0 (the "License");
 you may not use this file except in compliance with the License.
 You may obtain a copy of the License at

     http://www.apache.org/licenses/LICENSE-2.0

 Unless required by applicable law or agreed to in writing, software
 distributed under the License is distributed on an "AS IS" BASIS,
 WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 See the License for the specific language governing permissions and
 limitations under the License.
 

 **/
/**
  @license
                                 Apache License
                         Version 2.0, January 2004
                      http://www.apache.org/licenses/

 TERMS AND CONDITIONS FOR USE, REPRODUCTION, AND DISTRIBUTION

 1. Definitions.

    "License" shall mean the terms and conditions for use, reproduction,
    and distribution as defined by Sections 1 through 9 of this document.

    "Licensor" shall mean the copyright owner or entity authorized by
    the copyright owner that is granting the License.

    "Legal Entity" shall mean the union of the acting entity and all
    other entities that control, are controlled by, or are under common
    control with that entity. For the purposes of this definition,
    "control" means (i) the power, direct or indirect, to cause the
    direction or management of such entity, whether by contract or
    otherwise, or (ii) ownership of fifty percent (50%) or more of the
    outstanding shares, or (iii) beneficial ownership of such entity.

    "You" (or "Your") shall mean an individual or Legal Entity
    exercising permissions granted by this License.

    "Source" form shall mean the preferred form for making modifications,
    including but not limited to software source code, documentation
    source, and configuration files.

    "Object" form shall mean any form resulting from mechanical
    transformation or translation of a Source form, including but
    not limited to compiled object code, generated documentation,
    and conversions to other media types.

    "Work" shall mean the work of authorship, whether in Source or
    Object form, made available under the License, as indicated by a
    copyright notice that is included in or attached to the work
    (an example is provided in the Appendix below).

    "Derivative Works" shall mean any work, whether in Source or Object
    form, that is based on (or derived from) the Work and for which the
    editorial revisions, annotations, elaborations, or other modifications
    represent, as a whole, an original work of authorship. For the purposes
    of this License, Derivative Works shall not include works that remain
    separable from, or merely link (or bind by name) to the interfaces of,
    the Work and Derivative Works thereof.

    "Contribution" shall mean any work of authorship, including
    the original version of the Work and any modifications or additions
    to that Work or Derivative Works thereof, that is intentionally
    submitted to Licensor for inclusion in the Work by the copyright owner
    or by an individual or Legal Entity authorized to submit on behalf of
    the copyright owner. For the purposes of this definition, "submitted"
    means any form of electronic, verbal, or written communication sent
    to the Licensor or its representatives, including but not limited to
    communication on electronic mailing lists, source code control systems,
    and issue tracking systems that are managed by, or on behalf of, the
    Licensor for the purpose of discussing and improving the Work, but
    excluding communication that is conspicuously marked or otherwise
    designated in writing by the copyright owner as "Not a Contribution."

    "Contributor" shall mean Licensor and any individual or Legal Entity
    on behalf of whom a Contribution has been received by Licensor and
    subsequently incorporated within the Work.

 2. Grant of Copyright License. Subject to the terms and conditions of
    this License, each Contributor hereby grants to You a perpetual,
    worldwide, non-exclusive, no-charge, royalty-free, irrevocable
    copyright license to reproduce, prepare Derivative Works of,
    publicly display, publicly perform, sublicense, and distribute the
    Work and such Derivative Works in Source or Object form.

 3. Grant of Patent License. Subject to the terms and conditions of
    this License, each Contributor hereby grants to You a perpetual,
    worldwide, non-exclusive, no-charge, royalty-free, irrevocable
    (except as stated in this section) patent license to make, have made,
    use, offer to sell, sell, import, and otherwise transfer the Work,
    where such license applies only to those patent claims licensable
    by such Contributor that are necessarily infringed by their
    Contribution(s) alone or by combination of their Contribution(s)
    with the Work to which such Contribution(s) was submitted. If You
    institute patent litigation against any entity (including a
    cross-claim or counterclaim in a lawsuit) alleging that the Work
    or a Contribution incorporated within the Work constitutes direct
    or contributory patent infringement, then any patent licenses
    granted to You under this License for that Work shall terminate
    as of the date such litigation is filed.

 4. Redistribution. You may reproduce and distribute copies of the
    Work or Derivative Works thereof in any medium, with or without
    modifications, and in Source or Object form, provided that You
    meet the following conditions:

    (a) You must give any other recipients of the Work or
        Derivative Works a copy of this License; and

    (b) You must cause any modified files to carry prominent notices
        stating that You changed the files; and

    (c) You must retain, in the Source form of any Derivative Works
        that You distribute, all copyright, patent, trademark, and
        attribution notices from the Source form of the Work,
        excluding those notices that do not pertain to any part of
        the Derivative Works; and

    (d) If the Work includes a "NOTICE" text file as part of its
        distribution, then any Derivative Works that You distribute must
        include a readable copy of the attribution notices contained
        within such NOTICE file, excluding those notices that do not
        pertain to any part of the Derivative Works, in at least one
        of the following places: within a NOTICE text file distributed
        as part of the Derivative Works; within the Source form or
        documentation, if provided along with the Derivative Works; or,
        within a display generated by the Derivative Works, if and
        wherever such third-party notices normally appear. The contents
        of the NOTICE file are for informational purposes only and
        do not modify the License. You may add Your own attribution
        notices within Derivative Works that You distribute, alongside
        or as an addendum to the NOTICE text from the Work, provided
        that such additional attribution notices cannot be construed
        as modifying the License.

    You may add Your own copyright statement to Your modifications and
    may provide additional or different license terms and conditions
    for use, reproduction, or distribution of Your modifications, or
    for any such Derivative Works as a whole, provided Your use,
    reproduction, and distribution of the Work otherwise complies with
    the conditions stated in this License.

 5. Submission of Contributions. Unless You explicitly state otherwise,
    any Contribution intentionally submitted for inclusion in the Work
    by You to the Licensor shall be under the terms and conditions of
    this License, without any additional terms or conditions.
    Notwithstanding the above, nothing herein shall supersede or modify
    the terms of any separate license agreement you may have executed
    with Licensor regarding such Contributions.

 6. Trademarks. This License does not grant permission to use the trade
    names, trademarks, service marks, or product names of the Licensor,
    except as required for reasonable and customary use in describing the
    origin of the Work and reproducing the content of the NOTICE file.

 7. Disclaimer of Warranty. Unless required by applicable law or
    agreed to in writing, Licensor provides the Work (and each
    Contributor provides its Contributions) on an "AS IS" BASIS,
    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or
    implied, including, without limitation, any warranties or conditions
    of TITLE, NON-INFRINGEMENT, MERCHANTABILITY, or FITNESS FOR A
    PARTICULAR PURPOSE. You are solely responsible for determining the
    appropriateness of using or redistributing the Work and assume any
    risks associated with Your exercise of permissions under this License.

 8. Limitation of Liability. In no event and under no legal theory,
    whether in tort (including negligence), contract, or otherwise,
    unless required by applicable law (such as deliberate and grossly
    negligent acts) or agreed to in writing, shall any Contributor be
    liable to You for damages, including any direct, indirect, special,
    incidental, or consequential damages of any character arising as a
    result of this License or out of the use or inability to use the
    Work (including but not limited to damages for loss of goodwill,
    work stoppage, computer failure or malfunction, or any and all
    other commercial damages or losses), even if such Contributor
    has been advised of the possibility of such damages.

 9. Accepting Warranty or Additional Liability. While redistributing
    the Work or Derivative Works thereof, You may choose to offer,
    and charge a fee for, acceptance of support, warranty, indemnity,
    or other liability obligations and/or rights consistent with this
    License. However, in accepting such obligations, You may act only
    on Your own behalf and on Your sole responsibility, not on behalf
    of any other Contributor, and only if You agree to indemnify,
    defend, and hold each Contributor harmless for any liability
    incurred by, or claims asserted against, such Contributor by reason
    of your accepting any such warranty or additional liability.

 END OF TERMS AND CONDITIONS

 APPENDIX: How to apply the Apache License to your work.

    To apply the Apache License to your work, attach the following
    boilerplate notice, with the fields enclosed by brackets "[]"
    replaced with your own identifying information. (Don't include
    the brackets!)  The text should be enclosed in the appropriate
    comment syntax for the file format. We also recommend that a
    file or class name and description of purpose be included on the
    same "printed page" as the copyright notice for easier
    identification within third-party archives.

 Copyright (c) 2015-2018 Google, Inc., Netflix, Inc., Microsoft Corp. and contributors

 Licensed under the Apache License, Version 2.0 (the "License");
 you may not use this file except in compliance with the License.
 You may obtain a copy of the License at

     http://www.apache.org/licenses/LICENSE-2.0

 Unless required by applicable law or agreed to in writing, software
 distributed under the License is distributed on an "AS IS" BASIS,
 WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 See the License for the specific language governing permissions and
 limitations under the License.
 

 **/
(function (global, factory) {
    typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :
    typeof define === 'function' && define.amd ? define('rxjs', ['exports'], factory) :
    (factory((global.rxjs = {})));
}(this, (function (exports) { 'use strict';

    /*! *****************************************************************************
    Copyright (c) Microsoft Corporation.

    Permission to use, copy, modify, and/or distribute this software for any
    purpose with or without fee is hereby granted.

    THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
    REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
    AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
    INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
    LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
    OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
    PERFORMANCE OF THIS SOFTWARE.
    ***************************************************************************** */
    /* global Reflect, Promise */

    var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };

    /**
     * A utility function to enable inheritance between classes in JavaScript.
     *
     * @param {Function} d - The derived class constructor.
     * @param {Function} b - The base class constructor.
     * @throws {TypeError} If `b` is not a constructor or null.
     */
    function __extends(d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        /**
         * Initializes a new instance of an object with a specific constructor.
         *
         * @class
         */
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    }

    var __assign = function() {
        __assign = Object.assign || function __assign(t) {
            for (var s, i = 1, n = arguments.length; i < n; i++) {
                s = arguments[i];
                for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
            }
            return t;
        };
        return __assign.apply(this, arguments);
    };

    function __rest(s, e) {
        var t = {};
        for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
            t[p] = s[p];
        if (s != null && typeof Object.getOwnPropertySymbols === "function")
            for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
                if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                    t[p[i]] = s[p[i]];
            }
        return t;
    }

    /**
     * A helper function to enable asynchronous execution using generators. This is often used in JavaScript to simplify async/await syntax.
     *
     * @param {Object} thisArg - The `this` value for the generator function.
     * @param {Array} _arguments - An array of arguments passed to the generator function.
     * @param {PromiseConstructor} P - A Promise constructor, typically `Promise`.
     * @param {GeneratorFunction} generator - The generator function that will be executed asynchronously.
     * @returns {Promise} - A Promise that resolves or rejects based on the execution of the generator function.
     *
     * @example
     * const myAsyncFunction = async () => {
     *   return 'Hello, world!';
     * };
     * __awaiter(this, [], Promise, myAsyncFunction).then(value => console.log(value));
     */
    function __awaiter(thisArg, _arguments, P, generator) {
        /**
         * Adapts the given value to an instance of P or creates a new P instance with the value.
         *
         * @param {any} value - The value to be adapted or used in creating a new P instance.
         * @returns {P} A new instance of P containing the value, or the original P instance if it already is.
         */
        function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
        return new (P || (P = Promise))(function (resolve, reject) {
            /**
             * A helper function used to handle the resolution of a promise.
             *
             * @param {any} value - The value to be passed to the next step in the generator.
             * @throws {Error} If an error occurs during the execution of the generator's next method.
             */
            function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
            /**
             * Handles rejection of a promise or generator step.
             *
             * @param {any} value - The value to be passed to the generator's throw method.
             * @returns {void}
             *
             * @throws {Error} If an error occurs during the process.
             */
            function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
            /**
             * Handles the result of an asynchronous operation.
             *
             * @param {Object} result - The result object from the async operation.
             * @throws {Error} If the 'result' object is not properly formatted.
             */
            function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
            step((generator = generator.apply(thisArg, _arguments || [])).next());
        });
    }

    /**
     * Generator function utility.
     *
     * This internal method is used to create a generator object that can yield values
     * one at a time. It handles the state management and error propagation for generators.
     *
     * @param {Object} thisArg - The context in which the generator will run.
     * @param {Function} body - The body function of the generator, containing yield statements.
     * @returns {Object} A generator object with methods `next`, `throw`, and `return`.
     */
    function __generator(thisArg, body) {
        var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
        return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
        /**
         * Creates a function that can be used to chain steps in a sequence.
         *
         * @param {number} n - A numeric value representing the step number.
         * @returns {function} - A function that takes another function (v) and returns an array containing 'n' and 'v'.
         */
        function verb(n) { return function (v) { return step([n, v]); }; }
        /**
         * Handles the execution of a generator function.
         *
         * @param {Array} op - The operation array containing the opcode and value.
         * @returns {Object} An object with `value` and `done` properties indicating the current state of the generator.
         * @throws {TypeError} If the generator is already executing.
         */
        function step(op) {
            if (f) throw new TypeError("Generator is already executing.");
            while (_) try {
                if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
                if (y = 0, t) op = [op[0] & 2, t.value];
                switch (op[0]) {
                    case 0: case 1: t = op; break;
                    case 4: _.label++; return { value: op[1], done: false };
                    case 5: _.label++; y = op[1]; op = [0]; continue;
                    case 7: op = _.ops.pop(); _.trys.pop(); continue;
                    default:
                        if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                        if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                        if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                        if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                        if (t[2]) _.ops.pop();
                        _.trys.pop(); continue;
                }
                op = body.call(thisArg, _);
            } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
            if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
        }
    }

    /**
     * Returns an iterator object that yields values from the given iterable object.
     *
     * @param {Iterable} o - The iterable object to create an iterator for.
     * @returns {Iterator} An iterator object that yields values from the iterable.
     * @throws {TypeError} If the input is not iterable and Symbol.iterator is not defined.
     *
     * @example
     * const arr = [1, 2, 3];
     * const iterator = __values(arr);
     * console.log(iterator.next().value); // 1
     * console.log(iterator.next().value); // 2
     * console.log(iterator.next().value); // 3
     * console.log(iterator.next().done); // true
     */
    function __values(o) {
        var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
        if (m) return m.call(o);
        if (o && typeof o.length === "number") return {
            next: function () {
                if (o && i >= o.length) o = void 0;
                return { value: o && o[i++], done: !o };
            }
        };
        throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
    }

    /**
     * Reads elements from an iterable object up to a specified number of elements.
     *
     * @param {Iterable} o - The iterable object to read elements from.
     * @param {number|undefined} n - The maximum number of elements to read. If undefined, all elements are read.
     * @returns {Array} An array containing the elements read from the iterable.
     * @throws {Error} Throws an error if reading the iterable encounters an issue.
     */
    function __read(o, n) {
        var m = typeof Symbol === "function" && o[Symbol.iterator];
        if (!m) return o;
        var i = m.call(o), r, ar = [], e;
        try {
            while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
        }
        catch (error) { e = { error: error }; }
        finally {
            try {
                if (r && !r.done && (m = i["return"])) m.call(i);
            }
            finally { if (e) throw e.error; }
        }
        return ar;
    }

    /**
     * Merges two arrays into one by copying elements from the second array to the first array.
     *
     * @param {Array} to - The target array that will be appended with elements from `from`.
     * @param {Array} from - The source array whose elements will be copied to `to`.
     * @param {boolean} [pack] - If true, additional logic for copying might be applied.
     * @returns {Array} - The merged array resulting from concatenating `to` and `from`.
     *
     * @example
     * var array1 = [1, 2];
     * var array2 = [3, 4];
     * var result = __spreadArray(array1, array2);
     * console.log(result); // Output: [1, 2, 3, 4]
     */
    function __spreadArray(to, from, pack) {
        if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
            if (ar || !(i in from)) {
                if (!ar) ar = Array.prototype.slice.call(from, 0, i);
                ar[i] = from[i];
            }
        }
        return to.concat(ar || Array.prototype.slice.call(from));
    }

    /**
     * Helper function to handle awaited values within async generators.
     *
     * @param {any} v - The value to wrap in an awaitable object.
     * @returns {__await} An instance of __await wrapping the given value.
     */
    function __await(v) {
        return this instanceof __await ? (this.v = v, this) : new __await(v);
    }

    /**
     * Helper function for creating async generators.
     *
     * This function is used to create an async generator from a generator function.
     * It handles the asynchronous iteration protocol and manages the state of the generator.
     *
     * @param {any} thisArg - The `this` value to be used when calling the generator function.
     * @param {Array} _arguments - An array of arguments to pass to the generator function.
     * @param {Function} generator - The generator function that yields values asynchronously.
     * @returns {Object} An object representing the async generator.
     * @throws {TypeError} If `Symbol.asyncIterator` is not defined.
     */
    function __asyncGenerator(thisArg, _arguments, generator) {
        if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
        var g = generator.apply(thisArg, _arguments || []), i, q = [];
        return i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () { return this; }, i;
        /**
         * A function used to handle verbs or actions in a language-specific context.
         *
         * @param {string} n - The name of the verb or action to be handled.
         */
        function verb(n) { if (g[n]) i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }
        /**
         * Handles the resumption of a generator function step.
         *
         * @param {number} n - The index of the generator function to execute.
         * @param {*} v - The value to pass to the generator function.
         * @throws {Error} - If an error occurs during the execution of the generator function.
         */
        function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }
        /**
         * Processes the result of an asynchronous operation.
         *
         * @param {Object} r - The result object containing the value to process.
         * @throws {Error} - Throws an error if the value is not an instance of __await or the settle function fails.
         */
        function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }
        /**
         * Resumes the execution of a generator with the provided value.
         *
         * @param {any} value - The value to pass back to the generator.
         */
        function fulfill(value) { resume("next", value); }
        /**
         * Rejects the current promise with the given value.
         *
         * @param {*} value - The value to reject the promise with.
         * @returns {void}
         */
        function reject(value) { resume("throw", value); }
        /**
         * Settles a function with a value and resumes the next queued operation if available.
         *
         * @param {Function} f - The function to be settled with a value.
         * @param {*} v - The value to pass to the function `f`.
         */
        function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }
    }

    /**
     * Helper function to handle asynchronous iteration over an iterable object.
     * This function is used internally by the JavaScript runtime to support asynchronous for-loops and other related constructs.
     *
     * @param {Object} o - The iterable object to be iterated over asynchronously.
     * @returns {Object} An iterator object that implements the AsyncIterator protocol.
     * @throws {TypeError} Throws a TypeError if `Symbol.asyncIterator` is not defined.
     */
    function __asyncValues(o) {
        if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
        var m = o[Symbol.asyncIterator], i;
        return m ? m.call(o) : (o = typeof __values === "function" ? __values(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () { return this; }, i);
        /**
         * A function to handle verbs in a language-specific manner.
         *
         * @param {string} n - The name of the verb to handle.
         * @returns {undefined}
         */
        function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }
        /**
         * Settles a promise with the given resolve function, reject function, done flag, and value.
         *
         * @param {Function} resolve - The resolve function to be called when the promise is resolved.
         * @param {Function} reject - The reject function to be called when the promise is rejected.
         * @param {boolean} d - A boolean indicating whether the promise is done (true) or not (false).
         * @param {*} v - The value to resolve the promise with, which will be wrapped in a Promise if it's not already one.
         * @return {void}
         */
        function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }
    }

    /**
     * Determines if the provided value is a function.
     *
     * @param {*} value - The value to check.
     * @returns {boolean} - Returns true if the value is a function, false otherwise.
     *
     * @example
     * // Example usage:
     * console.log(isFunction(function(){})); // Output: true
     * console.log(isFunction('not a function')); // Output: false
     */
    function isFunction(value) {
        return typeof value === 'function';
    }

    /**
     * Creates a new error class using a provided implementation function.
     *
     * @param {Function} createImpl - A function that takes a super constructor and returns the new error constructor.
     * @returns {Function} The newly created error constructor.
     *
     * @example
     * const CustomError = createErrorClass(function(superConstructor) {
     *     return function(message) {
     *         superConstructor.call(this);
     *         this.message = message;
     *     };
     * });
     */
    function createErrorClass(createImpl) {
        var _super = function (instance) {
            Error.call(instance);
            instance.stack = new Error().stack;
        };
        var ctorFunc = createImpl(_super);
        ctorFunc.prototype = Object.create(Error.prototype);
        ctorFunc.prototype.constructor = ctorFunc;
        return ctorFunc;
    }

    var UnsubscriptionError = createErrorClass(function (_super) {
        return function UnsubscriptionErrorImpl(errors) {
            _super(this);
            this.message = errors
                ? errors.length + " errors occurred during unsubscription:\n" + errors.map(function (err, i) { return i + 1 + ") " + err.toString(); }).join('\n  ')
                : '';
            this.name = 'UnsubscriptionError';
            this.errors = errors;
        };
    });

    /**
     * Removes an item from an array if it exists.
     *
     * @param {Array} arr - The array from which to remove the item.
     * @param {*} item - The item to remove from the array.
     */
    function arrRemove(arr, item) {
        if (arr) {
            var index = arr.indexOf(item);
            0 <= index && arr.splice(index, 1);
        }
    }

    var Subscription = (function () {
        function Subscription(initialTeardown) {
            this.initialTeardown = initialTeardown;
            this.closed = false;
            this._parentage = null;
            this._finalizers = null;
        }
        Subscription.prototype.unsubscribe = function () {
            var e_1, _a, e_2, _b;
            var errors;
            if (!this.closed) {
                this.closed = true;
                var _parentage = this._parentage;
                if (_parentage) {
                    this._parentage = null;
                    if (Array.isArray(_parentage)) {
                        try {
                            for (var _parentage_1 = __values(_parentage), _parentage_1_1 = _parentage_1.next(); !_parentage_1_1.done; _parentage_1_1 = _parentage_1.next()) {
                                var parent_1 = _parentage_1_1.value;
                                parent_1.remove(this);
                            }
                        }
                        catch (e_1_1) { e_1 = { error: e_1_1 }; }
                        finally {
                            try {
                                if (_parentage_1_1 && !_parentage_1_1.done && (_a = _parentage_1.return)) _a.call(_parentage_1);
                            }
                            finally { if (e_1) throw e_1.error; }
                        }
                    }
                    else {
                        _parentage.remove(this);
                    }
                }
                var initialFinalizer = this.initialTeardown;
                if (isFunction(initialFinalizer)) {
                    try {
                        initialFinalizer();
                    }
                    catch (e) {
                        errors = e instanceof UnsubscriptionError ? e.errors : [e];
                    }
                }
                var _finalizers = this._finalizers;
                if (_finalizers) {
                    this._finalizers = null;
                    try {
                        for (var _finalizers_1 = __values(_finalizers), _finalizers_1_1 = _finalizers_1.next(); !_finalizers_1_1.done; _finalizers_1_1 = _finalizers_1.next()) {
                            var finalizer = _finalizers_1_1.value;
                            try {
                                execFinalizer(finalizer);
                            }
                            catch (err) {
                                errors = errors !== null && errors !== void 0 ? errors : [];
                                if (err instanceof UnsubscriptionError) {
                                    errors = __spreadArray(__spreadArray([], __read(errors)), __read(err.errors));
                                }
                                else {
                                    errors.push(err);
                                }
                            }
                        }
                    }
                    catch (e_2_1) { e_2 = { error: e_2_1 }; }
                    finally {
                        try {
                            if (_finalizers_1_1 && !_finalizers_1_1.done && (_b = _finalizers_1.return)) _b.call(_finalizers_1);
                        }
                        finally { if (e_2) throw e_2.error; }
                    }
                }
                if (errors) {
                    throw new UnsubscriptionError(errors);
                }
            }
        };
        Subscription.prototype.add = function (teardown) {
            var _a;
            if (teardown && teardown !== this) {
                if (this.closed) {
                    execFinalizer(teardown);
                }
                else {
                    if (teardown instanceof Subscription) {
                        if (teardown.closed || teardown._hasParent(this)) {
                            return;
                        }
                        teardown._addParent(this);
                    }
                    (this._finalizers = (_a = this._finalizers) !== null && _a !== void 0 ? _a : []).push(teardown);
                }
            }
        };
        Subscription.prototype._hasParent = function (parent) {
            var _parentage = this._parentage;
            return _parentage === parent || (Array.isArray(_parentage) && _parentage.includes(parent));
        };
        Subscription.prototype._addParent = function (parent) {
            var _parentage = this._parentage;
            this._parentage = Array.isArray(_parentage) ? (_parentage.push(parent), _parentage) : _parentage ? [_parentage, parent] : parent;
        };
        Subscription.prototype._removeParent = function (parent) {
            var _parentage = this._parentage;
            if (_parentage === parent) {
                this._parentage = null;
            }
            else if (Array.isArray(_parentage)) {
                arrRemove(_parentage, parent);
            }
        };
        Subscription.prototype.remove = function (teardown) {
            var _finalizers = this._finalizers;
            _finalizers && arrRemove(_finalizers, teardown);
            if (teardown instanceof Subscription) {
                teardown._removeParent(this);
            }
        };
        Subscription.EMPTY = (function () {
            var empty = new Subscription();
            empty.closed = true;
            return empty;
        })();
        return Subscription;
    }());
    var EMPTY_SUBSCRIPTION = Subscription.EMPTY;
    function isSubscription(value) {
        return (value instanceof Subscription ||
            (value && 'closed' in value && isFunction(value.remove) && isFunction(value.add) && isFunction(value.unsubscribe)));
    }
    /**
     * Executes or unsubscribes from a finalizer based on its type.
     *
     * @param {Function|Object} finalizer - The finalizer to execute or unsubscribe from. If it's a function, it will be executed directly. If it's an object with an `unsubscribe` method, that method will be called instead.
     * @throws {TypeError} If the finalizer is neither a function nor an object with an `unsubscribe` method.
     */
    function execFinalizer(finalizer) {
        if (isFunction(finalizer)) {
            finalizer();
        }
        else {
            finalizer.unsubscribe();
        }
    }

    var config = {
        onUnhandledError: null,
        onStoppedNotification: null,
        Promise: undefined,
        useDeprecatedSynchronousErrorHandling: false,
        useDeprecatedNextContext: false,
    };

    var timeoutProvider = {
        setTimeout: function (handler, timeout) {
            var args = [];
            for (var _i = 2; _i < arguments.length; _i++) {
                args[_i - 2] = arguments[_i];
            }
            var delegate = timeoutProvider.delegate;
            if (delegate === null || delegate === void 0 ? void 0 : delegate.setTimeout) {
                return delegate.setTimeout.apply(delegate, __spreadArray([handler, timeout], __read(args)));
            }
            return setTimeout.apply(void 0, __spreadArray([handler, timeout], __read(args)));
        },
        clearTimeout: function (handle) {
            var delegate = timeoutProvider.delegate;
            return ((delegate === null || delegate === void 0 ? void 0 : delegate.clearTimeout) || clearTimeout)(handle);
        },
        delegate: undefined,
    };

    /**
     * Handles unhandled errors by either invoking a user-provided error handler or throwing the error again.
     *
     * @param {Error} err - The error that occurred and was not handled.
     */
    function reportUnhandledError(err) {
        timeoutProvider.setTimeout(function () {
            var onUnhandledError = config.onUnhandledError;
            if (onUnhandledError) {
                onUnhandledError(err);
            }
            else {
                throw err;
            }
        });
    }

    /**
     * A no-operation function that does nothing.
     *
     * @return {undefined} This function returns undefined by default.
     */
    function noop() { }

    var COMPLETE_NOTIFICATION = (function () { return createNotification('C', undefined, undefined); })();
    /**
     * Creates and returns an error notification.
     *
     * @param {Error} error - The error object to include in the notification.
     * @returns {Notification} - A notification object with type 'E' and the provided error.
     * @throws {TypeError} - If the input is not an Error object.
     *
     * Example:
     *   try {
     *       // Some code that may throw an error
     *   } catch (err) {
     *       const notification = errorNotification(err);
     *       console.log(notification);
     *   }
     */
    function errorNotification(error) {
        return createNotification('E', undefined, error);
    }
    /**
     * Creates the next notification with the specified value.
     *
     * @param {string} value - The value to set for the notification.
     * @return {Object} - The created notification object.
     */
    function nextNotification(value) {
        return createNotification('N', value, undefined);
    }
    function createNotification(kind, value, error) {
        return {
            kind: kind,
            value: value,
            error: error,
        };
    }

    var context = null;
    /**
     * Executes a callback function within an error context. This is used to handle errors asynchronously or synchronously based on the configuration.
     *
     * @param {function} cb - The callback function to be executed.
     * @returns {void}
     *
     * @throws {Error} - Throws an error if an exception occurs during the execution of the callback, unless it is handled within the callback itself.
     *
     * @example
     * errorContext(() => {
     *     try {
     *         // Some operation that might throw an error
     *         throw new Error('An error occurred');
     *     } catch (e) {
     *         // Handle the error
     *         console.error(e);
     *     }
     * });
     *
     * @note This function is used to ensure that errors are not lost when using synchronous error handling and when dealing with asynchronous operations.
     */
    function errorContext(cb) {
        if (config.useDeprecatedSynchronousErrorHandling) {
            var isRoot = !context;
            if (isRoot) {
                context = { errorThrown: false, error: null };
            }
            cb();
            if (isRoot) {
                var _a = context, errorThrown = _a.errorThrown, error = _a.error;
                context = null;
                if (errorThrown) {
                    throw error;
                }
            }
        }
        else {
            cb();
        }
    }
    /**
     * Captures an error and handles it according to the configuration settings and context provided.
     *
     * @param {Error} err - The error object that needs to be captured.
     */
    function captureError(err) {
        if (config.useDeprecatedSynchronousErrorHandling && context) {
            context.errorThrown = true;
            context.error = err;
        }
    }

    var Subscriber = (function (_super) {
        __extends(Subscriber, _super);
        /**
         * A class representing a subscriber in an observer pattern. This class manages subscriptions and provides methods to interact with the destination observer.
         *
         * @constructor
         * @param {Object} [destination=EMPTY_OBSERVER] - The destination object that the subscriber will communicate with. If not provided, it defaults to `EMPTY_OBSERVER`.
         */
        function Subscriber(destination) {
            var _this = _super.call(this) || this;
            _this.isStopped = false;
            if (destination) {
                _this.destination = destination;
                if (isSubscription(destination)) {
                    destination.add(_this);
                }
            }
            else {
                _this.destination = EMPTY_OBSERVER;
            }
            return _this;
        }
        Subscriber.create = function (next, error, complete) {
            return new SafeSubscriber(next, error, complete);
        };
        Subscriber.prototype.next = function (value) {
            if (this.isStopped) {
                handleStoppedNotification(nextNotification(value), this);
            }
            else {
                this._next(value);
            }
        };
        Subscriber.prototype.error = function (err) {
            if (this.isStopped) {
                handleStoppedNotification(errorNotification(err), this);
            }
            else {
                this.isStopped = true;
                this._error(err);
            }
        };
        Subscriber.prototype.complete = function () {
            if (this.isStopped) {
                handleStoppedNotification(COMPLETE_NOTIFICATION, this);
            }
            else {
                this.isStopped = true;
                this._complete();
            }
        };
        Subscriber.prototype.unsubscribe = function () {
            if (!this.closed) {
                this.isStopped = true;
                _super.prototype.unsubscribe.call(this);
                this.destination = null;
            }
        };
        Subscriber.prototype._next = function (value) {
            this.destination.next(value);
        };
        Subscriber.prototype._error = function (err) {
            try {
                this.destination.error(err);
            }
            finally {
                this.unsubscribe();
            }
        };
        Subscriber.prototype._complete = function () {
            try {
                this.destination.complete();
            }
            finally {
                this.unsubscribe();
            }
        };
        return Subscriber;
    }(Subscription));
    var _bind = Function.prototype.bind;
    /**
     * Binds a function to an object, creating a new function that has its 'this' keyword set to the provided object.
     *
     * @param {Function} fn - The function to bind.
     * @param {*} thisArg - The value to be used as the 'this' keyword when the function is called.
     * @returns {Function} - A new function with the 'this' keyword bound to the provided object.
     * @throws {TypeError} - If `fn` is not a function, a TypeError will be thrown.
     *
     * @example
     * function greet(name) {
     *   return "Hello, " + name + "! I am " + this.name;
     * }
     *
     * const person = { name: 'Alice' };
     * const greetPerson = bind(greet, person);
     * console.log(greetPerson('Bob')); // Output: "Hello, Bob! I am Alice"
     */
    function bind(fn, thisArg) {
        return _bind.call(fn, thisArg);
    }
    var ConsumerObserver = (function () {
        /**
         * A class that wraps a partial observer to provide full observer functionality.
         *
         * @class ConsumerObserver
         * @param {Object} partialObserver - An object containing some of the methods required for an observer.
         */
        function ConsumerObserver(partialObserver) {
            this.partialObserver = partialObserver;
        }
        ConsumerObserver.prototype.next = function (value) {
            var partialObserver = this.partialObserver;
            if (partialObserver.next) {
                try {
                    partialObserver.next(value);
                }
                catch (error) {
                    handleUnhandledError(error);
                }
            }
        };
        ConsumerObserver.prototype.error = function (err) {
            var partialObserver = this.partialObserver;
            if (partialObserver.error) {
                try {
                    partialObserver.error(err);
                }
                catch (error) {
                    handleUnhandledError(error);
                }
            }
            else {
                handleUnhandledError(err);
            }
        };
        ConsumerObserver.prototype.complete = function () {
            var partialObserver = this.partialObserver;
            if (partialObserver.complete) {
                try {
                    partialObserver.complete();
                }
                catch (error) {
                    handleUnhandledError(error);
                }
            }
        };
        return ConsumerObserver;
    }());
    var SafeSubscriber = (function (_super) {
        __extends(SafeSubscriber, _super);
        /**
         * Creates a safe subscriber from an observer or partial observer functions.
         *
         * @param {Function | Object} [observerOrNext] - The observer object or function to handle next, error, and complete events.
         * @param {Function} [error] - The error handler function.
         * @param {Function} [complete] - The completion handler function.
         * @returns {Subscriber} A new subscriber instance.
         *
         * @example
         * // Using a full observer object
         * const subscriber = SafeSubscriber({
         *   next: (value) => console.log(value),
         *   error: (error) => console.error(error),
         *   complete: () => console.log('Completed')
         * });
         *
         * @example
         * // Using individual callback functions
         * const subscriber = SafeSubscriber(
         *   (value) => console.log(value),
         *   (error) => console.error(error),
         *   () => console.log('Completed')
         * );
         */
        function SafeSubscriber(observerOrNext, error, complete) {
            var _this = _super.call(this) || this;
            var partialObserver;
            if (isFunction(observerOrNext) || !observerOrNext) {
                partialObserver = {
                    next: (observerOrNext !== null && observerOrNext !== void 0 ? observerOrNext : undefined),
                    error: error !== null && error !== void 0 ? error : undefined,
                    complete: complete !== null && complete !== void 0 ? complete : undefined,
                };
            }
            else {
                var context_1;
                if (_this && config.useDeprecatedNextContext) {
                    context_1 = Object.create(observerOrNext);
                    context_1.unsubscribe = function () { return _this.unsubscribe(); };
                    partialObserver = {
                        next: observerOrNext.next && bind(observerOrNext.next, context_1),
                        error: observerOrNext.error && bind(observerOrNext.error, context_1),
                        complete: observerOrNext.complete && bind(observerOrNext.complete, context_1),
                    };
                }
                else {
                    partialObserver = observerOrNext;
                }
            }
            _this.destination = new ConsumerObserver(partialObserver);
            return _this;
        }
        return SafeSubscriber;
    }(Subscriber));
    /**
     * Handles an unhandled error according to the configuration settings.
     *
     * This function determines how to process an error that has not been caught by any try-catch block. It uses the configuration option `useDeprecatedSynchronousErrorHandling` to decide whether to capture or report the error synchronously.
     *
     * @param {Error} error - The unhandled error object to be processed.
     * @return {void}
     * @throws {Error} If an error occurs during processing, it will be thrown.
     *
     * Example usage:
     * try {
     *   // Some code that may throw an error
     * } catch (e) {
     *   handleUnhandledError(e);
     * }
     */
    function handleUnhandledError(error) {
        if (config.useDeprecatedSynchronousErrorHandling) {
            captureError(error);
        }
        else {
            reportUnhandledError(error);
        }
    }
    /**
     * Default error handler function that throws the error.
     *
     * @param {Error} err - The error object to be thrown.
     * @throws {Error} - Always throws the input error.
     */
    function defaultErrorHandler(err) {
        throw err;
    }
    /**
     * Handles a stopped notification by invoking the configured onStoppedNotification function after a delay.
     *
     * @param {Object} notification - The notification object that was stopped.
     * @param {Object} subscriber - The subscriber that received the stopped notification.
     * @throws {Error} - If there is an error in executing the configured onStoppedNotification function.
     */
    function handleStoppedNotification(notification, subscriber) {
        var onStoppedNotification = config.onStoppedNotification;
        onStoppedNotification && timeoutProvider.setTimeout(function () { return onStoppedNotification(notification, subscriber); });
    }
    var EMPTY_OBSERVER = {
        closed: true,
        next: noop,
        error: defaultErrorHandler,
        complete: noop,
    };

    var observable = (function () { return (typeof Symbol === 'function' && Symbol.observable) || '@@observable'; })();

    /**
     * Returns the value that was passed to it.
     *
     * @param {*} x - The value to return.
     * @returns {*} The same value that was passed as an argument.
     *
     * Example usage:
     * identity("hello") returns "hello"
     * identity(123) returns 123
     */
    function identity(x) {
        return x;
    }

    /**
     * Creates a function that returns the result of calling each function
     * in sequence with the arguments provided to the resulting function.
     *
     * @param {...Function} fns - A variable number of functions to be executed sequentially.
     * @returns {Function} A new function that takes any number of arguments and applies them to the functions in order, returning the final result.
     *
     * Example usage:
     * const addOne = (x) => x + 1;
     * const multiplyByTwo = (x) => x * 2;
     * const pipeResult = pipe(addOne, multiplyByTwo);
     * console.log(pipeResult(3)); // Outputs: 8
     */
    function pipe() {
        var fns = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            fns[_i] = arguments[_i];
        }
        return pipeFromArray(fns);
    }
    /**
     * Creates a function that applies a list of functions in sequence to an input value.
     *
     * @param {Function[]} fns - An array of functions to be executed in order.
     * @returns {Function} A new function that takes an input and sequentially applies each function in the provided array.
     *
     * @example
     * const addTwo = x => x + 2;
     * const multiplyByThree = x => x * 3;
     * const result = pipeFromArray([addTwo, multiplyByThree])(4); // Output: 18
     */
    function pipeFromArray(fns) {
        if (fns.length === 0) {
            return identity;
        }
        if (fns.length === 1) {
            return fns[0];
        }
        return function piped(input) {
            return fns.reduce(function (prev, fn) { return fn(prev); }, input);
        };
    }

    var Observable = (function () {
        /**
         * A class representing an observable sequence of events or values.
         *
         * @class
         * @param {Function} subscribe - The function to call when a new subscription is made. This function should return an object with an unsubscribe method.
         */
        function Observable(subscribe) {
            if (subscribe) {
                this._subscribe = subscribe;
            }
        }
        Observable.prototype.lift = function (operator) {
            var observable$$1 = new Observable();
            observable$$1.source = this;
            observable$$1.operator = operator;
            return observable$$1;
        };
        Observable.prototype.subscribe = function (observerOrNext, error, complete) {
            var _this = this;
            var subscriber = isSubscriber(observerOrNext) ? observerOrNext : new SafeSubscriber(observerOrNext, error, complete);
            errorContext(function () {
                var _a = _this, operator = _a.operator, source = _a.source;
                subscriber.add(operator
                    ?
                        operator.call(subscriber, source)
                    : source
                        ?
                            _this._subscribe(subscriber)
                        :
                            _this._trySubscribe(subscriber));
            });
            return subscriber;
        };
        Observable.prototype._trySubscribe = function (sink) {
            try {
                return this._subscribe(sink);
            }
            catch (err) {
                sink.error(err);
            }
        };
        Observable.prototype.forEach = function (next, promiseCtor) {
            var _this = this;
            promiseCtor = getPromiseCtor(promiseCtor);
            return new promiseCtor(function (resolve, reject) {
                var subscriber = new SafeSubscriber({
                    next: function (value) {
                        try {
                            next(value);
                        }
                        catch (err) {
                            reject(err);
                            subscriber.unsubscribe();
                        }
                    },
                    error: reject,
                    complete: resolve,
                });
                _this.subscribe(subscriber);
            });
        };
        Observable.prototype._subscribe = function (subscriber) {
            var _a;
            return (_a = this.source) === null || _a === void 0 ? void 0 : _a.subscribe(subscriber);
        };
        Observable.prototype[observable] = function () {
            return this;
        };
        Observable.prototype.pipe = function () {
            var operations = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                operations[_i] = arguments[_i];
            }
            return pipeFromArray(operations)(this);
        };
        Observable.prototype.toPromise = function (promiseCtor) {
            var _this = this;
            promiseCtor = getPromiseCtor(promiseCtor);
            return new promiseCtor(function (resolve, reject) {
                var value;
                _this.subscribe(function (x) { return (value = x); }, function (err) { return reject(err); }, function () { return resolve(value); });
            });
        };
        Observable.create = function (subscribe) {
            return new Observable(subscribe);
        };
        return Observable;
    }());
    /**
     * Retrieves a promise constructor, prioritizing the provided one if available, then falling back to a configuration-based one.
     *
     * @param {Function} [promiseCtor] - The user-provided promise constructor function. If not provided or is null/undefined, the function will fallback to using `config.Promise`.
     * @returns {PromiseConstructor} - A promise constructor function.
     */
    function getPromiseCtor(promiseCtor) {
        var _a;
        return (_a = promiseCtor !== null && promiseCtor !== void 0 ? promiseCtor : config.Promise) !== null && _a !== void 0 ? _a : Promise;
    }
    function isObserver(value) {
        return value && isFunction(value.next) && isFunction(value.error) && isFunction(value.complete);
    }
    /**
     * Checks if the provided value is an instance of Subscriber or if it satisfies the conditions to be considered a subscriber.
     *
     * @param {*} value - The value to check.
     * @return {boolean} Returns true if the value is an instance of Subscriber or meets the subscriber criteria, false otherwise.
     */
    function isSubscriber(value) {
        return (value && value instanceof Subscriber) || (isObserver(value) && isSubscription(value));
    }

    /**
     * Determines if the provided source object has a `lift` method.
     *
     * @param {any} source - The source object to check for the `lift` method.
     * @returns {boolean} - Returns true if the source object has a `lift` method, false otherwise.
     *
     * Example:
     *   const obj = {
     *       lift: function() {}
     *   };
     *   console.log(hasLift(obj)); // Output: true
     */
    function hasLift(source) {
        return isFunction(source === null || source === void 0 ? void 0 : source.lift);
    }
    /**
     * Applies an initialization function to a source observable, handling errors gracefully.
     *
     * @param {Function} init - A function that takes the lifted source and the current context as arguments and returns a value.
     * @returns {Function} A new function that can be applied to an observable source.
     * @throws {TypeError} If the source is not of a recognized Observable type, a TypeError will be thrown.
     *
     * @example
     * const myObservable = Rx.Observable.from([1, 2, 3]);
     * const operatedObservable = operate((source, context) => {
     *   return source.map(x => x * 2);
     * })(myObservable);
     * operatedObservable.subscribe(console.log); // Outputs: 2, 4, 6
     */
    function operate(init) {
        return function (source) {
            if (hasLift(source)) {
                return source.lift(function (liftedSource) {
                    try {
                        return init(liftedSource, this);
                    }
                    catch (err) {
                        this.error(err);
                    }
                });
            }
            throw new TypeError('Unable to lift unknown Observable type');
        };
    }

    /**
     * Creates an instance of OperatorSubscriber, which is used to handle the lifecycle of an observable subscription.
     *
     * @param {Subscription} destination - The subscription object that represents the observable's observer.
     * @param {Function} onNext - A callback function that is called when a value is emitted by the observable.
     * @param {Function} onComplete - A callback function that is called when the observable completes.
     * @param {Function} onError - A callback function that is called when an error occurs during the observable's execution.
     * @param {Function} onFinalize - A callback function that is called when the subscription is finalized, regardless of whether it completed normally or with an error.
     * @returns {OperatorSubscriber} An instance of OperatorSubscriber configured with the provided callbacks.
     */
    function createOperatorSubscriber(destination, onNext, onComplete, onError, onFinalize) {
        return new OperatorSubscriber(destination, onNext, onComplete, onError, onFinalize);
    }
    var OperatorSubscriber = (function (_super) {
        __extends(OperatorSubscriber, _super);
        /**
         * A class that extends an Observer to provide additional functionality,
         * such as handling errors and finalization logic.
         *
         * @constructor
         * @param {Observer} destination - The observer to which notifications are sent.
         * @param {function(value)} onNext - Callback for successful values.
         * @param {function} onComplete - Callback for completion notification.
         * @param {function(error)} onError - Callback for error handling.
         * @param {function} onFinalize - Optional callback for finalization logic.
         * @param {boolean} shouldUnsubscribe - Flag to determine if the subscriber should unsubscribe.
         */
        function OperatorSubscriber(destination, onNext, onComplete, onError, onFinalize, shouldUnsubscribe) {
            var _this = _super.call(this, destination) || this;
            _this.onFinalize = onFinalize;
            _this.shouldUnsubscribe = shouldUnsubscribe;
            _this._next = onNext
                ? function (value) {
                    try {
                        onNext(value);
                    }
                    catch (err) {
                        destination.error(err);
                    }
                }
                : _super.prototype._next;
            _this._error = onError
                ? function (err) {
                    try {
                        onError(err);
                    }
                    catch (err) {
                        destination.error(err);
                    }
                    finally {
                        this.unsubscribe();
                    }
                }
                : _super.prototype._error;
            _this._complete = onComplete
                ? function () {
                    try {
                        onComplete();
                    }
                    catch (err) {
                        destination.error(err);
                    }
                    finally {
                        this.unsubscribe();
                    }
                }
                : _super.prototype._complete;
            return _this;
        }
        OperatorSubscriber.prototype.unsubscribe = function () {
            var _a;
            if (!this.shouldUnsubscribe || this.shouldUnsubscribe()) {
                var closed_1 = this.closed;
                _super.prototype.unsubscribe.call(this);
                !closed_1 && ((_a = this.onFinalize) === null || _a === void 0 ? void 0 : _a.call(this));
            }
        };
        return OperatorSubscriber;
    }(Subscriber));

    /**
     * Returns an observable that only connects to the source observable when there is at least one subscriber,
     * and disconnects from the source observable when all subscribers have unsubscribed.
     *
     * @returns {Observable<T>} An observable with reference counting behavior.
     */
    function refCount() {
        return operate(function (source, subscriber) {
            var connection = null;
            source._refCount++;
            var refCounter = createOperatorSubscriber(subscriber, undefined, undefined, undefined, function () {
                if (!source || source._refCount <= 0 || 0 < --source._refCount) {
                    connection = null;
                    return;
                }
                var sharedConnection = source._connection;
                var conn = connection;
                connection = null;
                if (sharedConnection && (!conn || sharedConnection === conn)) {
                    sharedConnection.unsubscribe();
                }
                subscriber.unsubscribe();
            });
            source.subscribe(refCounter);
            if (!refCounter.closed) {
                connection = source.connect();
            }
        });
    }

    var ConnectableObservable = (function (_super) {
        __extends(ConnectableObservable, _super);
        function ConnectableObservable(source, subjectFactory) {
            var _this = _super.call(this) || this;
            _this.source = source;
            _this.subjectFactory = subjectFactory;
            _this._subject = null;
            _this._refCount = 0;
            _this._connection = null;
            if (hasLift(source)) {
                _this.lift = source.lift;
            }
            return _this;
        }
        ConnectableObservable.prototype._subscribe = function (subscriber) {
            return this.getSubject().subscribe(subscriber);
        };
        ConnectableObservable.prototype.getSubject = function () {
            var subject = this._subject;
            if (!subject || subject.isStopped) {
                this._subject = this.subjectFactory();
            }
            return this._subject;
        };
        ConnectableObservable.prototype._teardown = function () {
            this._refCount = 0;
            var _connection = this._connection;
            this._subject = this._connection = null;
            _connection === null || _connection === void 0 ? void 0 : _connection.unsubscribe();
        };
        ConnectableObservable.prototype.connect = function () {
            var _this = this;
            var connection = this._connection;
            if (!connection) {
                connection = this._connection = new Subscription();
                var subject_1 = this.getSubject();
                connection.add(this.source.subscribe(createOperatorSubscriber(subject_1, undefined, function () {
                    _this._teardown();
                    subject_1.complete();
                }, function (err) {
                    _this._teardown();
                    subject_1.error(err);
                }, function () { return _this._teardown(); })));
                if (connection.closed) {
                    this._connection = null;
                    connection = Subscription.EMPTY;
                }
            }
            return connection;
        };
        ConnectableObservable.prototype.refCount = function () {
            return refCount()(this);
        };
        return ConnectableObservable;
    }(Observable));

    var performanceTimestampProvider = {
        now: function () {
            return (performanceTimestampProvider.delegate || performance).now();
        },
        delegate: undefined,
    };

    var animationFrameProvider = {
        schedule: function (callback) {
            var request = requestAnimationFrame;
            var cancel = cancelAnimationFrame;
            var delegate = animationFrameProvider.delegate;
            if (delegate) {
                request = delegate.requestAnimationFrame;
                cancel = delegate.cancelAnimationFrame;
            }
            var handle = request(function (timestamp) {
                cancel = undefined;
                callback(timestamp);
            });
            return new Subscription(function () { return cancel === null || cancel === void 0 ? void 0 : cancel(handle); });
        },
        requestAnimationFrame: function () {
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                args[_i] = arguments[_i];
            }
            var delegate = animationFrameProvider.delegate;
            return ((delegate === null || delegate === void 0 ? void 0 : delegate.requestAnimationFrame) || requestAnimationFrame).apply(void 0, __spreadArray([], __read(args)));
        },
        cancelAnimationFrame: function () {
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                args[_i] = arguments[_i];
            }
            var delegate = animationFrameProvider.delegate;
            return ((delegate === null || delegate === void 0 ? void 0 : delegate.cancelAnimationFrame) || cancelAnimationFrame).apply(void 0, __spreadArray([], __read(args)));
        },
        delegate: undefined,
    };

    /**
     * Provides an array of animation frames based on the given timestamp provider or defaults to a predefined set of frames.
     *
     * @param {Function} [timestampProvider] - A function that returns the current time in milliseconds. If not provided, uses default animation frames.
     * @returns {Array<number>} An array of numbers representing animation frames.
     * @throws {TypeError} If `timestampProvider` is provided but is not a function.
     *
     * @example
     * // Using a timestamp provider
     * const customFrames = animationFrames(() => Date.now());
     * console.log(customFrames);
     *
     * @example
     * // Using default frames
     * const defaultFrames = animationFrames();
     * console.log(defaultFrames);
     */
    function animationFrames(timestampProvider) {
        return timestampProvider ? animationFramesFactory(timestampProvider) : DEFAULT_ANIMATION_FRAMES;
    }
    /**
     * Creates an Observable that emits animation frames.
     *
     * @param {Function} [timestampProvider=performanceTimestampProvider] - A function that provides the current timestamp. Defaults to `performanceTimestampProvider`.
     * @returns {Observable<Object>} An Observable that emits objects containing the current timestamp and elapsed time since the start of the animation frame sequence.
     */
    function animationFramesFactory(timestampProvider) {
        return new Observable(function (subscriber) {
            var provider = timestampProvider || performanceTimestampProvider;
            var start = provider.now();
            var id = 0;
            var run = function () {
                if (!subscriber.closed) {
                    id = animationFrameProvider.requestAnimationFrame(function (timestamp) {
                        id = 0;
                        var now = provider.now();
                        subscriber.next({
                            timestamp: timestampProvider ? now : timestamp,
                            elapsed: now - start,
                        });
                        run();
                    });
                }
            };
            run();
            return function () {
                if (id) {
                    animationFrameProvider.cancelAnimationFrame(id);
                }
            };
        });
    }
    var DEFAULT_ANIMATION_FRAMES = animationFramesFactory();

    var ObjectUnsubscribedError = createErrorClass(function (_super) {
        return function ObjectUnsubscribedErrorImpl() {
            _super(this);
            this.name = 'ObjectUnsubscribedError';
            this.message = 'object unsubscribed';
        };
    });

    var Subject = (function (_super) {
        __extends(Subject, _super);
        /**
         * Represents an observable sequence with a subject.
         * @class Subject
         */
        function Subject() {
            var _this = _super.call(this) || this;
            _this.closed = false;
            _this.currentObservers = null;
            _this.observers = [];
            _this.isStopped = false;
            _this.hasError = false;
            _this.thrownError = null;
            return _this;
        }
        Subject.prototype.lift = function (operator) {
            var subject = new AnonymousSubject(this, this);
            subject.operator = operator;
            return subject;
        };
        Subject.prototype._throwIfClosed = function () {
            if (this.closed) {
                throw new ObjectUnsubscribedError();
            }
        };
        Subject.prototype.next = function (value) {
            var _this = this;
            errorContext(function () {
                var e_1, _a;
                _this._throwIfClosed();
                if (!_this.isStopped) {
                    if (!_this.currentObservers) {
                        _this.currentObservers = Array.from(_this.observers);
                    }
                    try {
                        for (var _b = __values(_this.currentObservers), _c = _b.next(); !_c.done; _c = _b.next()) {
                            var observer = _c.value;
                            observer.next(value);
                        }
                    }
                    catch (e_1_1) { e_1 = { error: e_1_1 }; }
                    finally {
                        try {
                            if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
                        }
                        finally { if (e_1) throw e_1.error; }
                    }
                }
            });
        };
        Subject.prototype.error = function (err) {
            var _this = this;
            errorContext(function () {
                _this._throwIfClosed();
                if (!_this.isStopped) {
                    _this.hasError = _this.isStopped = true;
                    _this.thrownError = err;
                    var observers = _this.observers;
                    while (observers.length) {
                        observers.shift().error(err);
                    }
                }
            });
        };
        Subject.prototype.complete = function () {
            var _this = this;
            errorContext(function () {
                _this._throwIfClosed();
                if (!_this.isStopped) {
                    _this.isStopped = true;
                    var observers = _this.observers;
                    while (observers.length) {
                        observers.shift().complete();
                    }
                }
            });
        };
        Subject.prototype.unsubscribe = function () {
            this.isStopped = this.closed = true;
            this.observers = this.currentObservers = null;
        };
        Object.defineProperty(Subject.prototype, "observed", {
            get: function () {
                var _a;
                return ((_a = this.observers) === null || _a === void 0 ? void 0 : _a.length) > 0;
            },
            enumerable: false,
            configurable: true
        });
        Subject.prototype._trySubscribe = function (subscriber) {
            this._throwIfClosed();
            return _super.prototype._trySubscribe.call(this, subscriber);
        };
        Subject.prototype._subscribe = function (subscriber) {
            this._throwIfClosed();
            this._checkFinalizedStatuses(subscriber);
            return this._innerSubscribe(subscriber);
        };
        Subject.prototype._innerSubscribe = function (subscriber) {
            var _this = this;
            var _a = this, hasError = _a.hasError, isStopped = _a.isStopped, observers = _a.observers;
            if (hasError || isStopped) {
                return EMPTY_SUBSCRIPTION;
            }
            this.currentObservers = null;
            observers.push(subscriber);
            return new Subscription(function () {
                _this.currentObservers = null;
                arrRemove(observers, subscriber);
            });
        };
        Subject.prototype._checkFinalizedStatuses = function (subscriber) {
            var _a = this, hasError = _a.hasError, thrownError = _a.thrownError, isStopped = _a.isStopped;
            if (hasError) {
                subscriber.error(thrownError);
            }
            else if (isStopped) {
                subscriber.complete();
            }
        };
        Subject.prototype.asObservable = function () {
            var observable = new Observable();
            observable.source = this;
            return observable;
        };
        Subject.create = function (destination, source) {
            return new AnonymousSubject(destination, source);
        };
        return Subject;
    }(Observable));
    var AnonymousSubject = (function (_super) {
        __extends(AnonymousSubject, _super);
        /**
         * Represents an object that is both a source of observable values and an observer. It can receive and emit items.
         *
         * @constructor
         * @param {Observer} destination - The observer to which the subject sends notifications.
         * @param {Observable} source - The observable from which the subject receives data.
         */
        function AnonymousSubject(destination, source) {
            var _this = _super.call(this) || this;
            _this.destination = destination;
            _this.source = source;
            return _this;
        }
        AnonymousSubject.prototype.next = function (value) {
            var _a, _b;
            (_b = (_a = this.destination) === null || _a === void 0 ? void 0 : _a.next) === null || _b === void 0 ? void 0 : _b.call(_a, value);
        };
        AnonymousSubject.prototype.error = function (err) {
            var _a, _b;
            (_b = (_a = this.destination) === null || _a === void 0 ? void 0 : _a.error) === null || _b === void 0 ? void 0 : _b.call(_a, err);
        };
        AnonymousSubject.prototype.complete = function () {
            var _a, _b;
            (_b = (_a = this.destination) === null || _a === void 0 ? void 0 : _a.complete) === null || _b === void 0 ? void 0 : _b.call(_a);
        };
        AnonymousSubject.prototype._subscribe = function (subscriber) {
            var _a, _b;
            return (_b = (_a = this.source) === null || _a === void 0 ? void 0 : _a.subscribe(subscriber)) !== null && _b !== void 0 ? _b : EMPTY_SUBSCRIPTION;
        };
        return AnonymousSubject;
    }(Subject));

    var BehaviorSubject = (function (_super) {
        __extends(BehaviorSubject, _super);
        /**
         * A class that represents a value that can change over time. It provides a way to observe the current value and receive updates whenever it changes.
         *
         * @class BehaviorSubject
         * @param {any} _value - The initial value of the subject.
         */
        function BehaviorSubject(_value) {
            var _this = _super.call(this) || this;
            _this._value = _value;
            return _this;
        }
        Object.defineProperty(BehaviorSubject.prototype, "value", {
            get: function () {
                return this.getValue();
            },
            enumerable: false,
            configurable: true
        });
        BehaviorSubject.prototype._subscribe = function (subscriber) {
            var subscription = _super.prototype._subscribe.call(this, subscriber);
            !subscription.closed && subscriber.next(this._value);
            return subscription;
        };
        BehaviorSubject.prototype.getValue = function () {
            var _a = this, hasError = _a.hasError, thrownError = _a.thrownError, _value = _a._value;
            if (hasError) {
                throw thrownError;
            }
            this._throwIfClosed();
            return _value;
        };
        BehaviorSubject.prototype.next = function (value) {
            _super.prototype.next.call(this, (this._value = value));
        };
        return BehaviorSubject;
    }(Subject));

    var dateTimestampProvider = {
        now: function () {
            return (dateTimestampProvider.delegate || Date).now();
        },
        delegate: undefined,
    };

    var ReplaySubject = (function (_super) {
        __extends(ReplaySubject, _super);
        /**
         * A Subject that stores a replay of a specified number of values from the most recent Observable it's subscribed to.
         *
         * @class ReplaySubject
         * @extends Subject
         * @constructor
         * @param {number} [bufferSize=Infinity] - The maximum number of values to store in the buffer.
         * @param {number} [windowTime=Infinity] - The maximum time span to store values for, in milliseconds. If Infinity, all values are stored.
         * @param {Function} [timestampProvider=function() { return Date.now(); }] - A function that returns the current timestamp.
         */
        function ReplaySubject(_bufferSize, _windowTime, _timestampProvider) {
            if (_bufferSize === void 0) { _bufferSize = Infinity; }
            if (_windowTime === void 0) { _windowTime = Infinity; }
            if (_timestampProvider === void 0) { _timestampProvider = dateTimestampProvider; }
            var _this = _super.call(this) || this;
            _this._bufferSize = _bufferSize;
            _this._windowTime = _windowTime;
            _this._timestampProvider = _timestampProvider;
            _this._buffer = [];
            _this._infiniteTimeWindow = true;
            _this._infiniteTimeWindow = _windowTime === Infinity;
            _this._bufferSize = Math.max(1, _bufferSize);
            _this._windowTime = Math.max(1, _windowTime);
            return _this;
        }
        ReplaySubject.prototype.next = function (value) {
            var _a = this, isStopped = _a.isStopped, _buffer = _a._buffer, _infiniteTimeWindow = _a._infiniteTimeWindow, _timestampProvider = _a._timestampProvider, _windowTime = _a._windowTime;
            if (!isStopped) {
                _buffer.push(value);
                !_infiniteTimeWindow && _buffer.push(_timestampProvider.now() + _windowTime);
            }
            this._trimBuffer();
            _super.prototype.next.call(this, value);
        };
        ReplaySubject.prototype._subscribe = function (subscriber) {
            this._throwIfClosed();
            this._trimBuffer();
            var subscription = this._innerSubscribe(subscriber);
            var _a = this, _infiniteTimeWindow = _a._infiniteTimeWindow, _buffer = _a._buffer;
            var copy = _buffer.slice();
            for (var i = 0; i < copy.length && !subscriber.closed; i += _infiniteTimeWindow ? 1 : 2) {
                subscriber.next(copy[i]);
            }
            this._checkFinalizedStatuses(subscriber);
            return subscription;
        };
        ReplaySubject.prototype._trimBuffer = function () {
            var _a = this, _bufferSize = _a._bufferSize, _timestampProvider = _a._timestampProvider, _buffer = _a._buffer, _infiniteTimeWindow = _a._infiniteTimeWindow;
            var adjustedBufferSize = (_infiniteTimeWindow ? 1 : 2) * _bufferSize;
            _bufferSize < Infinity && adjustedBufferSize < _buffer.length && _buffer.splice(0, _buffer.length - adjustedBufferSize);
            if (!_infiniteTimeWindow) {
                var now = _timestampProvider.now();
                var last = 0;
                for (var i = 1; i < _buffer.length && _buffer[i] <= now; i += 2) {
                    last = i;
                }
                last && _buffer.splice(0, last + 1);
            }
        };
        return ReplaySubject;
    }(Subject));

    var AsyncSubject = (function (_super) {
        __extends(AsyncSubject, _super);
        /**
         * Represents an object that can hold multiple values and asynchronously emit them to subscribed observers.
         *
         * @constructor
         */
        function AsyncSubject() {
            var _this = _super !== null && _super.apply(this, arguments) || this;
            _this._value = null;
            _this._hasValue = false;
            _this._isComplete = false;
            return _this;
        }
        AsyncSubject.prototype._checkFinalizedStatuses = function (subscriber) {
            var _a = this, hasError = _a.hasError, _hasValue = _a._hasValue, _value = _a._value, thrownError = _a.thrownError, isStopped = _a.isStopped, _isComplete = _a._isComplete;
            if (hasError) {
                subscriber.error(thrownError);
            }
            else if (isStopped || _isComplete) {
                _hasValue && subscriber.next(_value);
                subscriber.complete();
            }
        };
        AsyncSubject.prototype.next = function (value) {
            if (!this.isStopped) {
                this._value = value;
                this._hasValue = true;
            }
        };
        AsyncSubject.prototype.complete = function () {
            var _a = this, _hasValue = _a._hasValue, _value = _a._value, _isComplete = _a._isComplete;
            if (!_isComplete) {
                this._isComplete = true;
                _hasValue && _super.prototype.next.call(this, _value);
                _super.prototype.complete.call(this);
            }
        };
        return AsyncSubject;
    }(Subject));

    var Action = (function (_super) {
        __extends(Action, _super);
        /**
         * Represents an action that can be scheduled and executed.
         *
         * @constructor
         * @param {Scheduler} scheduler - The scheduler instance responsible for managing the execution of actions.
         * @param {Function} work - The function representing the task to be performed.
         */
        function Action(scheduler, work) {
            return _super.call(this) || this;
        }
        Action.prototype.schedule = function (state, delay) {
            if (delay === void 0) { delay = 0; }
            return this;
        };
        return Action;
    }(Subscription));

    var intervalProvider = {
        setInterval: function (handler, timeout) {
            var args = [];
            for (var _i = 2; _i < arguments.length; _i++) {
                args[_i - 2] = arguments[_i];
            }
            var delegate = intervalProvider.delegate;
            if (delegate === null || delegate === void 0 ? void 0 : delegate.setInterval) {
                return delegate.setInterval.apply(delegate, __spreadArray([handler, timeout], __read(args)));
            }
            return setInterval.apply(void 0, __spreadArray([handler, timeout], __read(args)));
        },
        clearInterval: function (handle) {
            var delegate = intervalProvider.delegate;
            return ((delegate === null || delegate === void 0 ? void 0 : delegate.clearInterval) || clearInterval)(handle);
        },
        delegate: undefined,
    };

    var AsyncAction = (function (_super) {
        __extends(AsyncAction, _super);
        /**
         * Represents an asynchronous action that can be scheduled and executed later.
         *
         * @class
         * @extends SchedulerAction
         * @param {Scheduler} scheduler - The scheduler instance to use for managing the execution of the work function.
         * @param {Function} work - The work function to execute asynchronously.
         */
        function AsyncAction(scheduler, work) {
            var _this = _super.call(this, scheduler, work) || this;
            _this.scheduler = scheduler;
            _this.work = work;
            _this.pending = false;
            return _this;
        }
        AsyncAction.prototype.schedule = function (state, delay) {
            var _a;
            if (delay === void 0) { delay = 0; }
            if (this.closed) {
                return this;
            }
            this.state = state;
            var id = this.id;
            var scheduler = this.scheduler;
            if (id != null) {
                this.id = this.recycleAsyncId(scheduler, id, delay);
            }
            this.pending = true;
            this.delay = delay;
            this.id = (_a = this.id) !== null && _a !== void 0 ? _a : this.requestAsyncId(scheduler, this.id, delay);
            return this;
        };
        AsyncAction.prototype.requestAsyncId = function (scheduler, _id, delay) {
            if (delay === void 0) { delay = 0; }
            return intervalProvider.setInterval(scheduler.flush.bind(scheduler, this), delay);
        };
        AsyncAction.prototype.recycleAsyncId = function (_scheduler, id, delay) {
            if (delay === void 0) { delay = 0; }
            if (delay != null && this.delay === delay && this.pending === false) {
                return id;
            }
            if (id != null) {
                intervalProvider.clearInterval(id);
            }
            return undefined;
        };
        AsyncAction.prototype.execute = function (state, delay) {
            if (this.closed) {
                return new Error('executing a cancelled action');
            }
            this.pending = false;
            var error = this._execute(state, delay);
            if (error) {
                return error;
            }
            else if (this.pending === false && this.id != null) {
                this.id = this.recycleAsyncId(this.scheduler, this.id, null);
            }
        };
        AsyncAction.prototype._execute = function (state, _delay) {
            var errored = false;
            var errorValue;
            try {
                this.work(state);
            }
            catch (e) {
                errored = true;
                errorValue = e ? e : new Error('Scheduled action threw falsy error');
            }
            if (errored) {
                this.unsubscribe();
                return errorValue;
            }
        };
        AsyncAction.prototype.unsubscribe = function () {
            if (!this.closed) {
                var _a = this, id = _a.id, scheduler = _a.scheduler;
                var actions = scheduler.actions;
                this.work = this.state = this.scheduler = null;
                this.pending = false;
                arrRemove(actions, this);
                if (id != null) {
                    this.id = this.recycleAsyncId(scheduler, id, null);
                }
                this.delay = null;
                _super.prototype.unsubscribe.call(this);
            }
        };
        return AsyncAction;
    }(Action));

    var nextHandle = 1;
    var resolved;
    var activeHandles = {};
    /**
     * Finds and clears an active handle from the `activeHandles` object.
     *
     * @param {string} handle - The handle to be found and cleared.
     * @returns {boolean} - Returns true if the handle was found and cleared, false otherwise.
     */
    function findAndClearHandle(handle) {
        if (handle in activeHandles) {
            delete activeHandles[handle];
            return true;
        }
        return false;
    }
    var Immediate = {
        setImmediate: function (cb) {
            var handle = nextHandle++;
            activeHandles[handle] = true;
            if (!resolved) {
                resolved = Promise.resolve();
            }
            resolved.then(function () { return findAndClearHandle(handle) && cb(); });
            return handle;
        },
        clearImmediate: function (handle) {
            findAndClearHandle(handle);
        },
    };

    var setImmediate = Immediate.setImmediate, clearImmediate = Immediate.clearImmediate;
    var immediateProvider = {
        setImmediate: function () {
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                args[_i] = arguments[_i];
            }
            var delegate = immediateProvider.delegate;
            return ((delegate === null || delegate === void 0 ? void 0 : delegate.setImmediate) || setImmediate).apply(void 0, __spreadArray([], __read(args)));
        },
        clearImmediate: function (handle) {
            var delegate = immediateProvider.delegate;
            return ((delegate === null || delegate === void 0 ? void 0 : delegate.clearImmediate) || clearImmediate)(handle);
        },
        delegate: undefined,
    };

    var AsapAction = (function (_super) {
        __extends(AsapAction, _super);
        /**
         * Represents an action that should be executed as soon as possible by the scheduler.
         *
         * @constructor
         * @param {Scheduler} scheduler - The scheduler responsible for executing this action.
         * @param {Function} work - The function representing the work to be executed.
         */
        function AsapAction(scheduler, work) {
            var _this = _super.call(this, scheduler, work) || this;
            _this.scheduler = scheduler;
            _this.work = work;
            return _this;
        }
        AsapAction.prototype.requestAsyncId = function (scheduler, id, delay) {
            if (delay === void 0) { delay = 0; }
            if (delay !== null && delay > 0) {
                return _super.prototype.requestAsyncId.call(this, scheduler, id, delay);
            }
            scheduler.actions.push(this);
            return scheduler._scheduled || (scheduler._scheduled = immediateProvider.setImmediate(scheduler.flush.bind(scheduler, undefined)));
        };
        AsapAction.prototype.recycleAsyncId = function (scheduler, id, delay) {
            var _a;
            if (delay === void 0) { delay = 0; }
            if (delay != null ? delay > 0 : this.delay > 0) {
                return _super.prototype.recycleAsyncId.call(this, scheduler, id, delay);
            }
            var actions = scheduler.actions;
            if (id != null && ((_a = actions[actions.length - 1]) === null || _a === void 0 ? void 0 : _a.id) !== id) {
                immediateProvider.clearImmediate(id);
                if (scheduler._scheduled === id) {
                    scheduler._scheduled = undefined;
                }
            }
            return undefined;
        };
        return AsapAction;
    }(AsyncAction));

    var Scheduler = (function () {
        /**
         * Constructs a new Scheduler instance.
         *
         * @constructor
         * @param {Function} schedulerActionCtor - The constructor function for creating SchedulerAction instances.
         * @param {function(): number} [now=Scheduler.now] - A function that returns the current time in milliseconds. Defaults to `Scheduler.now` if not provided.
         */
        function Scheduler(schedulerActionCtor, now) {
            if (now === void 0) { now = Scheduler.now; }
            this.schedulerActionCtor = schedulerActionCtor;
            this.now = now;
        }
        Scheduler.prototype.schedule = function (work, delay, state) {
            if (delay === void 0) { delay = 0; }
            return new this.schedulerActionCtor(this, work).schedule(state, delay);
        };
        Scheduler.now = dateTimestampProvider.now;
        return Scheduler;
    }());

    var AsyncScheduler = (function (_super) {
        __extends(AsyncScheduler, _super);
        /** @class
         * The `AsyncScheduler` class is designed to schedule actions asynchronously. It extends the base `Scheduler` class.
         *
         * @constructor
         * Creates a new instance of `AsyncScheduler`.
         *
         * @param {Function} SchedulerAction - A function that defines what action should be performed.
         * @param {Function} [now=Scheduler.now] - An optional function to retrieve the current time. Defaults to `Scheduler.now`.
         */
        function AsyncScheduler(SchedulerAction, now) {
            if (now === void 0) { now = Scheduler.now; }
            var _this = _super.call(this, SchedulerAction, now) || this;
            _this.actions = [];
            _this._active = false;
            return _this;
        }
        AsyncScheduler.prototype.flush = function (action) {
            var actions = this.actions;
            if (this._active) {
                actions.push(action);
                return;
            }
            var error;
            this._active = true;
            do {
                if ((error = action.execute(action.state, action.delay))) {
                    break;
                }
            } while ((action = actions.shift()));
            this._active = false;
            if (error) {
                while ((action = actions.shift())) {
                    action.unsubscribe();
                }
                throw error;
            }
        };
        return AsyncScheduler;
    }(Scheduler));

    var AsapScheduler = (function (_super) {
        __extends(AsapScheduler, _super);
        /**
         * Constructs an instance of AsapScheduler.
         *
         * @class
         */
        function AsapScheduler() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        AsapScheduler.prototype.flush = function (action) {
            this._active = true;
            var flushId = this._scheduled;
            this._scheduled = undefined;
            var actions = this.actions;
            var error;
            action = action || actions.shift();
            do {
                if ((error = action.execute(action.state, action.delay))) {
                    break;
                }
            } while ((action = actions[0]) && action.id === flushId && actions.shift());
            this._active = false;
            if (error) {
                while ((action = actions[0]) && action.id === flushId && actions.shift()) {
                    action.unsubscribe();
                }
                throw error;
            }
        };
        return AsapScheduler;
    }(AsyncScheduler));

    var asapScheduler = new AsapScheduler(AsapAction);
    var asap = asapScheduler;

    var asyncScheduler = new AsyncScheduler(AsyncAction);
    var async = asyncScheduler;

    var QueueAction = (function (_super) {
        __extends(QueueAction, _super);
        /**
         * Represents an action that can be queued for execution by a scheduler.
         *
         * @constructor
         * @param {Scheduler} scheduler - The scheduler responsible for executing the work.
         * @param {Function} work - The function representing the task to be executed.
         */
        function QueueAction(scheduler, work) {
            var _this = _super.call(this, scheduler, work) || this;
            _this.scheduler = scheduler;
            _this.work = work;
            return _this;
        }
        QueueAction.prototype.schedule = function (state, delay) {
            if (delay === void 0) { delay = 0; }
            if (delay > 0) {
                return _super.prototype.schedule.call(this, state, delay);
            }
            this.delay = delay;
            this.state = state;
            this.scheduler.flush(this);
            return this;
        };
        QueueAction.prototype.execute = function (state, delay) {
            return delay > 0 || this.closed ? _super.prototype.execute.call(this, state, delay) : this._execute(state, delay);
        };
        QueueAction.prototype.requestAsyncId = function (scheduler, id, delay) {
            if (delay === void 0) { delay = 0; }
            if ((delay != null && delay > 0) || (delay == null && this.delay > 0)) {
                return _super.prototype.requestAsyncId.call(this, scheduler, id, delay);
            }
            scheduler.flush(this);
            return 0;
        };
        return QueueAction;
    }(AsyncAction));

    var QueueScheduler = (function (_super) {
        __extends(QueueScheduler, _super);
        /**
         * Constructs an instance of QueueScheduler.
         *
         * @class
         */
        function QueueScheduler() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        return QueueScheduler;
    }(AsyncScheduler));

    var queueScheduler = new QueueScheduler(QueueAction);
    var queue = queueScheduler;

    var AnimationFrameAction = (function (_super) {
        __extends(AnimationFrameAction, _super);
        /**
         * Represents an action that is scheduled to run during the next animation frame.
         * @class
         * @param {Object} scheduler - The scheduler responsible for managing the execution of actions.
         * @param {Function} work - The function representing the work to be executed during the animation frame.
         */
        function AnimationFrameAction(scheduler, work) {
            var _this = _super.call(this, scheduler, work) || this;
            _this.scheduler = scheduler;
            _this.work = work;
            return _this;
        }
        AnimationFrameAction.prototype.requestAsyncId = function (scheduler, id, delay) {
            if (delay === void 0) { delay = 0; }
            if (delay !== null && delay > 0) {
                return _super.prototype.requestAsyncId.call(this, scheduler, id, delay);
            }
            scheduler.actions.push(this);
            return scheduler._scheduled || (scheduler._scheduled = animationFrameProvider.requestAnimationFrame(function () { return scheduler.flush(undefined); }));
        };
        AnimationFrameAction.prototype.recycleAsyncId = function (scheduler, id, delay) {
            var _a;
            if (delay === void 0) { delay = 0; }
            if (delay != null ? delay > 0 : this.delay > 0) {
                return _super.prototype.recycleAsyncId.call(this, scheduler, id, delay);
            }
            var actions = scheduler.actions;
            if (id != null && id === scheduler._scheduled && ((_a = actions[actions.length - 1]) === null || _a === void 0 ? void 0 : _a.id) !== id) {
                animationFrameProvider.cancelAnimationFrame(id);
                scheduler._scheduled = undefined;
            }
            return undefined;
        };
        return AnimationFrameAction;
    }(AsyncAction));

    var AnimationFrameScheduler = (function (_super) {
        __extends(AnimationFrameScheduler, _super);
        /**
         * Represents a scheduler that uses `requestAnimationFrame` to execute tasks at the next repaint.
         *
         * @class AnimationFrameScheduler
         */
        function AnimationFrameScheduler() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        AnimationFrameScheduler.prototype.flush = function (action) {
            this._active = true;
            var flushId;
            if (action) {
                flushId = action.id;
            }
            else {
                flushId = this._scheduled;
                this._scheduled = undefined;
            }
            var actions = this.actions;
            var error;
            action = action || actions.shift();
            do {
                if ((error = action.execute(action.state, action.delay))) {
                    break;
                }
            } while ((action = actions[0]) && action.id === flushId && actions.shift());
            this._active = false;
            if (error) {
                while ((action = actions[0]) && action.id === flushId && actions.shift()) {
                    action.unsubscribe();
                }
                throw error;
            }
        };
        return AnimationFrameScheduler;
    }(AsyncScheduler));

    var animationFrameScheduler = new AnimationFrameScheduler(AnimationFrameAction);
    var animationFrame = animationFrameScheduler;

    var VirtualTimeScheduler = (function (_super) {
        __extends(VirtualTimeScheduler, _super);
        /**
         * Creates a new instance of the VirtualTimeScheduler class with optional schedulerActionCtor and maxFrames parameters.
         *
         * @constructor
         * @param {Function} [schedulerActionCtor=VirtualAction] - A constructor function for creating scheduler actions. Defaults to VirtualAction if not provided.
         * @param {number} [maxFrames=Infinity] - The maximum number of frames that the scheduler can run before it stops. Defaults to Infinity if not provided.
         */
        function VirtualTimeScheduler(schedulerActionCtor, maxFrames) {
            if (schedulerActionCtor === void 0) { schedulerActionCtor = VirtualAction; }
            if (maxFrames === void 0) { maxFrames = Infinity; }
            var _this = _super.call(this, schedulerActionCtor, function () { return _this.frame; }) || this;
            _this.maxFrames = maxFrames;
            _this.frame = 0;
            _this.index = -1;
            return _this;
        }
        VirtualTimeScheduler.prototype.flush = function () {
            var _a = this, actions = _a.actions, maxFrames = _a.maxFrames;
            var error;
            var action;
            while ((action = actions[0]) && action.delay <= maxFrames) {
                actions.shift();
                this.frame = action.delay;
                if ((error = action.execute(action.state, action.delay))) {
                    break;
                }
            }
            if (error) {
                while ((action = actions.shift())) {
                    action.unsubscribe();
                }
                throw error;
            }
        };
        VirtualTimeScheduler.frameTimeFactor = 10;
        return VirtualTimeScheduler;
    }(AsyncScheduler));
    var VirtualAction = (function (_super) {
        __extends(VirtualAction, _super);
        /**
         * Represents a virtual action that can be scheduled and executed by a scheduler.
         *
         * @class VirtualAction
         * @extends {SchedulerAction}
         * @param {Object} scheduler - The scheduler to which the action belongs.
         * @param {Function} work - The function to execute when the action is triggered.
         * @param {number} [index=++scheduler.index] - The index of the action within the scheduler. If not provided, it defaults to the next available index in the scheduler.
         */
        function VirtualAction(scheduler, work, index) {
            if (index === void 0) { index = (scheduler.index += 1); }
            var _this = _super.call(this, scheduler, work) || this;
            _this.scheduler = scheduler;
            _this.work = work;
            _this.index = index;
            _this.active = true;
            _this.index = scheduler.index = index;
            return _this;
        }
        VirtualAction.prototype.schedule = function (state, delay) {
            if (delay === void 0) { delay = 0; }
            if (Number.isFinite(delay)) {
                if (!this.id) {
                    return _super.prototype.schedule.call(this, state, delay);
                }
                this.active = false;
                var action = new VirtualAction(this.scheduler, this.work);
                this.add(action);
                return action.schedule(state, delay);
            }
            else {
                return Subscription.EMPTY;
            }
        };
        VirtualAction.prototype.requestAsyncId = function (scheduler, id, delay) {
            if (delay === void 0) { delay = 0; }
            this.delay = scheduler.frame + delay;
            var actions = scheduler.actions;
            actions.push(this);
            actions.sort(VirtualAction.sortActions);
            return 1;
        };
        VirtualAction.prototype.recycleAsyncId = function (scheduler, id, delay) {
            if (delay === void 0) { delay = 0; }
            return undefined;
        };
        VirtualAction.prototype._execute = function (state, delay) {
            if (this.active === true) {
                return _super.prototype._execute.call(this, state, delay);
            }
        };
        VirtualAction.sortActions = function (a, b) {
            if (a.delay === b.delay) {
                if (a.index === b.index) {
                    return 0;
                }
                else if (a.index > b.index) {
                    return 1;
                }
                else {
                    return -1;
                }
            }
            else if (a.delay > b.delay) {
                return 1;
            }
            else {
                return -1;
            }
        };
        return VirtualAction;
    }(AsyncAction));

    var EMPTY = new Observable(function (subscriber) { return subscriber.complete(); });
    /**
     * Returns an empty scheduler or a specific scheduler if provided.
     *
     * @param {Scheduler} [scheduler] - The scheduler to return. If not provided, returns the default EMPTY scheduler.
     * @returns {Scheduler} - The scheduler that was passed in, or the default EMPTY scheduler if none was provided.
     */
    function empty(scheduler) {
        return scheduler ? emptyScheduled(scheduler) : EMPTY;
    }
    /**
     * Creates an Observable that emits no items to the Observer and immediately emits a complete notification.
     *
     * @function emptyScheduled
     * @param {Object} scheduler - The scheduler to use for scheduling the completion.
     * @returns {Observable} An Observable that emits no items but completes immediately upon subscription.
     */
    function emptyScheduled(scheduler) {
        return new Observable(function (subscriber) { return scheduler.schedule(function () { return subscriber.complete(); }); });
    }

    function isScheduler(value) {
        return value && isFunction(value.schedule);
    }

    /**
     * Returns the last element of an array.
     *
     * @param {Array} arr - The array from which to return the last element.
     * @returns {*} The last element of the array.
     * @throws {Error} If the input is not an array or if the array is empty.
     * @example
     * last([1, 2, 3]); // returns 3
     */
    function last(arr) {
        return arr[arr.length - 1];
    }
    /**
     * Returns the last element of the arguments if it is a function; otherwise, returns undefined.
     *
     * @param {Array} args - The array of arguments to process.
     * @returns {Function|undefined} - The last argument if it's a function, otherwise undefined.
     */
    function popResultSelector(args) {
        return isFunction(last(args)) ? args.pop() : undefined;
    }
    /**
     * Removes and returns the last element from the array if it is a scheduler, otherwise returns undefined.
     *
     * @param {Array} args - The array to operate on.
     * @returns {(Object|undefined)} - The removed scheduler object if present, otherwise undefined.
     */
    function popScheduler(args) {
        return isScheduler(last(args)) ? args.pop() : undefined;
    }
    /**
     * Retrieves the last element of an array if it is a number; otherwise, returns a default value.
     *
     * @param {Array} args - The array from which to retrieve the last number.
     * @param {*} defaultValue - The value to return if the last element is not a number.
     * @returns {*} - The last number in the array or the provided default value.
     *
     * @example
     * // Returns 5 as it's the last number in the array
     * popNumber([1, 2, 'a', 3, 4, 5]);
     *
     * @example
     * // Returns 'default' as no numbers are present in the array
     * popNumber(['a', 'b', 'c'], 'default');
     */
    function popNumber(args, defaultValue) {
        return typeof last(args) === 'number' ? args.pop() : defaultValue;
    }

    var isArrayLike = (function (x) { return x && typeof x.length === 'number' && typeof x !== 'function'; });

    /**
     * Determines if the provided value is a promise.
     *
     * @param {*} value - The value to check.
     * @returns {boolean} - Returns true if the value is a promise, false otherwise.
     *
     * Example usage:
     * console.log(isPromise(Promise.resolve())); // true
     * console.log(isPromise({ then: () => {} })); // true
     * console.log(isPromise('Not a promise')); // false
     */
    function isPromise(value) {
        return isFunction(value === null || value === void 0 ? void 0 : value.then);
    }

    /**
     * Determines if the provided input is an interop observable.
     *
     * @param {any} input - The input to check for interop observability.
     * @returns {boolean} - True if the input is an interop observable, false otherwise.
     *
     * An interop observable is one that has a `Symbol.observable` method.
     */
    function isInteropObservable(input) {
        return isFunction(input[observable]);
    }

    function isAsyncIterable(obj) {
        return Symbol.asyncIterator && isFunction(obj === null || obj === void 0 ? void 0 : obj[Symbol.asyncIterator]);
    }

    /**
     * Creates a TypeError indicating that an invalid type was provided where a stream or iterable is expected.
     *
     * @param {any} input - The input value that caused the error.
     * @returns {TypeError} A TypeError object with a message indicating the nature of the invalid input.
     * @example
     * try {
     *   createInvalidObservableTypeError("string");
     * } catch (error) {
     *   console.error(error.message); // Output: You provided 'string' where a stream was expected. You can provide an Observable, Promise, ReadableStream, Array, AsyncIterable, or Iterable.
     * }
     */
    function createInvalidObservableTypeError(input) {
        return new TypeError("You provided " + (input !== null && typeof input === 'object' ? 'an invalid object' : "'" + input + "'") + " where a stream was expected. You can provide an Observable, Promise, ReadableStream, Array, AsyncIterable, or Iterable.");
    }

    /**
     * Retrieves the symbol iterator or a fallback string if not available.
     *
     * @returns {string} - The symbol iterator (Symbol.iterator) or a fallback string ('@@iterator').
     */
    function getSymbolIterator() {
        if (typeof Symbol !== 'function' || !Symbol.iterator) {
            return '@@iterator';
        }
        return Symbol.iterator;
    }
    var iterator = getSymbolIterator();

    /**
     * Determines if an input is iterable.
     *
     * @param {any} input - The input to check for iterability.
     * @returns {boolean} - True if the input is iterable, false otherwise.
     * @example
     * console.log(isIterable([1, 2, 3])); // true
     * console.log(isIterable('hello')); // true
     * console.log(isIterable(null));    // false
     */
    function isIterable(input) {
        return isFunction(input === null || input === void 0 ? void 0 : input[iterator]);
    }

    function readableStreamLikeToAsyncGenerator(readableStream) {
        return __asyncGenerator(this, arguments, function readableStreamLikeToAsyncGenerator_1() {
            var reader, _a, value, done;
            return __generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        reader = readableStream.getReader();
                        _b.label = 1;
                    case 1:
                        _b.trys.push([1, , 9, 10]);
                        _b.label = 2;
                    case 2:
                        return [4, __await(reader.read())];
                    case 3:
                        _a = _b.sent(), value = _a.value, done = _a.done;
                        if (!done) return [3, 5];
                        return [4, __await(void 0)];
                    case 4: return [2, _b.sent()];
                    case 5: return [4, __await(value)];
                    case 6: return [4, _b.sent()];
                    case 7:
                        _b.sent();
                        return [3, 2];
                    case 8: return [3, 10];
                    case 9:
                        reader.releaseLock();
                        return [7];
                    case 10: return [2];
                }
            });
        });
    }
    function isReadableStreamLike(obj) {
        return isFunction(obj === null || obj === void 0 ? void 0 : obj.getReader);
    }

    /**
     * Converts an input into an Observable. This function is used internally to handle different types of inputs that can produce Observables.
     *
     * @param {any} input - The input to be converted into an Observable.
     * @returns {Observable} - An Observable representing the input.
     * @throws {Error} - Throws an error if the input type is not supported.
     *
     * @example
     * // Convert a Promise into an Observable
     * const observableFromPromise = innerFrom(Promise.resolve(42));
     *
     * @example
     * // Convert an array-like object into an Observable
     * const observableFromArrayLike = innerFrom({ length: 3, 0: 'a', 1: 'b', 2: 'c' });
     */
    function innerFrom(input) {
        if (input instanceof Observable) {
            return input;
        }
        if (input != null) {
            if (isInteropObservable(input)) {
                return fromInteropObservable(input);
            }
            if (isArrayLike(input)) {
                return fromArrayLike(input);
            }
            if (isPromise(input)) {
                return fromPromise(input);
            }
            if (isAsyncIterable(input)) {
                return fromAsyncIterable(input);
            }
            if (isIterable(input)) {
                return fromIterable(input);
            }
            if (isReadableStreamLike(input)) {
                return fromReadableStreamLike(input);
            }
        }
        throw createInvalidObservableTypeError(input);
    }
    function fromInteropObservable(obj) {
        return new Observable(function (subscriber) {
            var obs = obj[observable]();
            if (isFunction(obs.subscribe)) {
                return obs.subscribe(subscriber);
            }
            throw new TypeError('Provided object does not correctly implement Symbol.observable');
        });
    }
    function fromArrayLike(array) {
        return new Observable(function (subscriber) {
            for (var i = 0; i < array.length && !subscriber.closed; i++) {
                subscriber.next(array[i]);
            }
            subscriber.complete();
        });
    }
    function fromPromise(promise) {
        return new Observable(function (subscriber) {
            promise
                .then(function (value) {
                if (!subscriber.closed) {
                    subscriber.next(value);
                    subscriber.complete();
                }
            }, function (err) { return subscriber.error(err); })
                .then(null, reportUnhandledError);
        });
    }
    function fromIterable(iterable) {
        return new Observable(function (subscriber) {
            var e_1, _a;
            try {
                for (var iterable_1 = __values(iterable), iterable_1_1 = iterable_1.next(); !iterable_1_1.done; iterable_1_1 = iterable_1.next()) {
                    var value = iterable_1_1.value;
                    subscriber.next(value);
                    if (subscriber.closed) {
                        return;
                    }
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (iterable_1_1 && !iterable_1_1.done && (_a = iterable_1.return)) _a.call(iterable_1);
                }
                finally { if (e_1) throw e_1.error; }
            }
            subscriber.complete();
        });
    }
    /**
     * Creates an Observable that emits values from an async iterable.
     *
     * @param {AsyncIterable} asyncIterable - The async iterable to convert into an Observable.
     * @returns {Observable} An Observable that emits the values from the async iterable.
     * @throws {Error} If an error occurs during the processing of the async iterable, it will be emitted through the Observable's error channel.
     *
     * Example usage:
     * const asyncIterable = (async function* () {
     *   yield 1;
     *   yield 2;
     * })();
     * const observable = fromAsyncIterable(asyncIterable);
     * observable.subscribe({
     *   next: value => console.log(value),
     *   error: err => console.error(err),
     *   complete: () => console.log('Done')
     * });
     */
    function fromAsyncIterable(asyncIterable) {
        return new Observable(function (subscriber) {
            process(asyncIterable, subscriber).catch(function (err) { return subscriber.error(err); });
        });
    }
    /**
     * Converts a ReadableStream-like object to an AsyncIterable that can be used with fromAsyncIterable.
     *
     * @param {ReadableStream} readableStream - The ReadableStream-like object to convert.
     * @returns {AsyncIterable} An AsyncIterable representation of the ReadableStream-like object.
     * @throws {TypeError} If the input is not a valid ReadableStream-like object.
     */
    function fromReadableStreamLike(readableStream) {
        return fromAsyncIterable(readableStreamLikeToAsyncGenerator(readableStream));
    }
    /**
     * Asynchronously processes each value from an async iterable and emits it to a subscriber.
     *
     * @param {AsyncIterable<T>} asyncIterable - The async iterable to process.
     * @param {Subscriber<T>} subscriber - The subscriber to emit values to.
     * @returns {void} - This function does not return any value.
     * @throws {Error} - If an error occurs during processing, it is thrown.
     *
     * @example
     * const asyncIterable = (async function* () {
     *   yield 1;
     *   yield 2;
     * })();
     * const subscriber = {
     *   next(value) {
     *     console.log(value);
     *   },
     *   complete() {
     *     console.log('Completed');
     *   },
     *   error(error) {
     *     console.error(error);
     *   }
     * };
     *
     * process(asyncIterable, subscriber);
     */
    function process(asyncIterable, subscriber) {
        var asyncIterable_1, asyncIterable_1_1;
        var e_2, _a;
        return __awaiter(this, void 0, void 0, function () {
            var value, e_2_1;
            return __generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        _b.trys.push([0, 5, 6, 11]);
                        asyncIterable_1 = __asyncValues(asyncIterable);
                        _b.label = 1;
                    case 1: return [4, asyncIterable_1.next()];
                    case 2:
                        if (!(asyncIterable_1_1 = _b.sent(), !asyncIterable_1_1.done)) return [3, 4];
                        value = asyncIterable_1_1.value;
                        subscriber.next(value);
                        if (subscriber.closed) {
                            return [2];
                        }
                        _b.label = 3;
                    case 3: return [3, 1];
                    case 4: return [3, 11];
                    case 5:
                        e_2_1 = _b.sent();
                        e_2 = { error: e_2_1 };
                        return [3, 11];
                    case 6:
                        _b.trys.push([6, , 9, 10]);
                        if (!(asyncIterable_1_1 && !asyncIterable_1_1.done && (_a = asyncIterable_1.return))) return [3, 8];
                        return [4, _a.call(asyncIterable_1)];
                    case 7:
                        _b.sent();
                        _b.label = 8;
                    case 8: return [3, 10];
                    case 9:
                        if (e_2) throw e_2.error;
                        return [7];
                    case 10: return [7];
                    case 11:
                        subscriber.complete();
                        return [2];
                }
            });
        });
    }

    /**
     * Executes a work function at a specified delay with an optional repeat option.
     *
     * @param {Subscription} parentSubscription - The parent subscription to add the schedule subscription to.
     * @param {Scheduler} scheduler - The scheduler to use for scheduling the work.
     * @param {Function} work - The function to execute.
     * @param {number} [delay=0] - The delay in milliseconds before executing the work. Default is 0.
     * @param {boolean} [repeat=false] - Whether to repeat the execution of the work. Default is false.
     * @returns {Subscription|null} - Returns a subscription if not repeating, otherwise returns null.
     *
     * @example
     * const parentSub = new Subscription();
     * const scheduler = getScheduler();
     * executeSchedule(parentSub, scheduler, () => console.log('Task executed'), 1000, true);
     */
    function executeSchedule(parentSubscription, scheduler, work, delay, repeat) {
        if (delay === void 0) { delay = 0; }
        if (repeat === void 0) { repeat = false; }
        var scheduleSubscription = scheduler.schedule(function () {
            work();
            if (repeat) {
                parentSubscription.add(this.schedule(null, delay));
            }
            else {
                this.unsubscribe();
            }
        }, delay);
        parentSubscription.add(scheduleSubscription);
        if (!repeat) {
            return scheduleSubscription;
        }
    }

    /**
     * Observes each event emitted by the source Observable on a given scheduler.
     *
     * <img src="https://raw.githubusercontent.com/ReactiveX/rxjs/master/assets/scheduler.png" width="100%">
     *
     * @param {SchedulerLike} scheduler - The scheduler to schedule the emissions of the source Observable on.
     * @param {number} [delay=0] - A delay time in milliseconds before the first emission is scheduled. Defaults to 0.
     * @returns {Observable<T>} An Observable that emits the same values as the source Observable, but with each event emitted on the specified scheduler.
     *
     * Example:
     * ```
     * const observable = of(1, 2, 3).pipe(observeOn(asyncScheduler));
     * observable.subscribe(value => console.log(value));
     * // Output will be logged asynchronously after all values have been emitted
     * ```
     */
    function observeOn(scheduler, delay) {
        if (delay === void 0) { delay = 0; }
        return operate(function (source, subscriber) {
            source.subscribe(createOperatorSubscriber(subscriber, function (value) { return executeSchedule(subscriber, scheduler, function () { return subscriber.next(value); }, delay); }, function () { return executeSchedule(subscriber, scheduler, function () { return subscriber.complete(); }, delay); }, function (err) { return executeSchedule(subscriber, scheduler, function () { return subscriber.error(err); }, delay); }));
        });
    }

    /**
     * Creates an observable that subscribes to another observable using the specified scheduler after a given delay.
     *
     * @function subscribeOn
     * @param {Scheduler} scheduler - The scheduler to use for scheduling the subscription of the source observable.
     * @param {number} [delay=0] - The time in milliseconds before the subscription is scheduled. Default is 0.
     * @returns {Observable} A new observable that will subscribe to the source observable using the specified scheduler after the delay.
     *
     * @throws {Error} Throws an error if the scheduler is not provided.
     *
     * @example
     * const source = of(1, 2, 3);
     * const scheduler = asapScheduler;
     * const delayedSource$ = subscribeOn(source, scheduler, 500);
     * delayedSource$.subscribe(x => console.log(x)); // Logs the numbers after a delay of 500ms
     */
    function subscribeOn(scheduler, delay) {
        if (delay === void 0) { delay = 0; }
        return operate(function (source, subscriber) {
            subscriber.add(scheduler.schedule(function () { return source.subscribe(subscriber); }, delay));
        });
    }

    function scheduleObservable(input, scheduler) {
        return innerFrom(input).pipe(subscribeOn(scheduler), observeOn(scheduler));
    }

    function schedulePromise(input, scheduler) {
        return innerFrom(input).pipe(subscribeOn(scheduler), observeOn(scheduler));
    }

    function scheduleArray(input, scheduler) {
        return new Observable(function (subscriber) {
            var i = 0;
            return scheduler.schedule(function () {
                if (i === input.length) {
                    subscriber.complete();
                }
                else {
                    subscriber.next(input[i++]);
                    if (!subscriber.closed) {
                        this.schedule();
                    }
                }
            });
        });
    }

    function scheduleIterable(input, scheduler) {
        return new Observable(function (subscriber) {
            var iterator$$1;
            executeSchedule(subscriber, scheduler, function () {
                iterator$$1 = input[iterator]();
                executeSchedule(subscriber, scheduler, function () {
                    var _a;
                    var value;
                    var done;
                    try {
                        (_a = iterator$$1.next(), value = _a.value, done = _a.done);
                    }
                    catch (err) {
                        subscriber.error(err);
                        return;
                    }
                    if (done) {
                        subscriber.complete();
                    }
                    else {
                        subscriber.next(value);
                    }
                }, 0, true);
            });
            return function () { return isFunction(iterator$$1 === null || iterator$$1 === void 0 ? void 0 : iterator$$1.return) && iterator$$1.return(); };
        });
    }

    /**
     * Schedules an async iterable to emit its values asynchronously using a specified scheduler.
     *
     * @param {AsyncIterable} input - The async iterable to be scheduled for emission.
     * @param {Scheduler} scheduler - The scheduler used to manage the timing of emissions.
     * @returns {Observable} An observable that emits the values from the input async iterable.
     * @throws {Error} If the input is null or undefined.
     *
     * @example
     * const iterable = (async function* () {
     *   yield 'Hello';
     *   yield 'World';
     * })();
     *
     * const scheduler = new Scheduler();
     * scheduleAsyncIterable(iterable, scheduler).subscribe({
     *   next: console.log,
     *   complete: () => console.log('Done')
     * });
     */
    function scheduleAsyncIterable(input, scheduler) {
        if (!input) {
            throw new Error('Iterable cannot be null');
        }
        return new Observable(function (subscriber) {
            executeSchedule(subscriber, scheduler, function () {
                var iterator = input[Symbol.asyncIterator]();
                executeSchedule(subscriber, scheduler, function () {
                    iterator.next().then(function (result) {
                        if (result.done) {
                            subscriber.complete();
                        }
                        else {
                            subscriber.next(result.value);
                        }
                    });
                }, 0, true);
            });
        });
    }

    function scheduleReadableStreamLike(input, scheduler) {
        return scheduleAsyncIterable(readableStreamLikeToAsyncGenerator(input), scheduler);
    }

    /**
     * Schedules an observable or promise to execute on the specified scheduler.
     *
     * @param {any} input - The input to schedule. Can be an observable, promise, array-like object, iterable, readable stream like object, or async iterable.
     * @param {SchedulerLike} scheduler - The scheduler on which to schedule the execution of the input.
     * @returns {SubscriptionLike} A subscription that can be used to cancel the scheduled execution.
     *
     * @throws {InvalidObservableTypeError} If the input is not a supported type.
     */
    function scheduled(input, scheduler) {
        if (input != null) {
            if (isInteropObservable(input)) {
                return scheduleObservable(input, scheduler);
            }
            if (isArrayLike(input)) {
                return scheduleArray(input, scheduler);
            }
            if (isPromise(input)) {
                return schedulePromise(input, scheduler);
            }
            if (isAsyncIterable(input)) {
                return scheduleAsyncIterable(input, scheduler);
            }
            if (isIterable(input)) {
                return scheduleIterable(input, scheduler);
            }
            if (isReadableStreamLike(input)) {
                return scheduleReadableStreamLike(input, scheduler);
            }
        }
        throw createInvalidObservableTypeError(input);
    }

    /**
     * Converts an input into an observable sequence using the specified scheduler or the default scheduler if none is provided.
     *
     * @param {any} input - The input to convert. Can be any value that can be converted into an observable.
     * @param {SchedulerLike | undefined} [scheduler] - Optional scheduler to use for scheduling the observables produced by the conversion.
     * @returns {Observable<any>} An observable sequence representing the input, scheduled according to the provided scheduler or the default scheduler.
     *
     * @example
     * // Using the default scheduler
     * from([1, 2, 3]).subscribe(x => console.log(x));
     *
     * // Using a custom scheduler
     * const customScheduler = new AsyncScheduler();
     * from([1, 2, 3], customScheduler).subscribe(x => console.log(x));
     */
    function from(input, scheduler) {
        return scheduler ? scheduled(input, scheduler) : innerFrom(input);
    }

    function of() {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
        }
        var scheduler = popScheduler(args);
        return from(args, scheduler);
    }

    /**
     * Creates an Observable that emits an error when subscribed to.
     *
     * This function takes either an error object or an error factory function. If the input is a function, it will be called to produce the error when subscribed to. Otherwise, the error object itself is used.
     *
     * @param {Error|Function} errorOrErrorFactory - The error object or function that produces the error.
     * @param {Scheduler} [scheduler] - Scheduler to use for scheduling the emission of the error.
     * @returns {Observable} An Observable that emits an error when subscribed to.
     *
     * Example usage:
     * const error = new Error('Something went wrong');
     * throwError(error).subscribe(
     *   () => console.log('This will not be called'),
     *   (err) => console.error(err.message) // Output: 'Something went wrong'
     * );
     */
    function throwError(errorOrErrorFactory, scheduler) {
        var errorFactory = isFunction(errorOrErrorFactory) ? errorOrErrorFactory : function () { return errorOrErrorFactory; };
        var init = function (subscriber) { return subscriber.error(errorFactory()); };
        return new Observable(scheduler ? function (subscriber) { return scheduler.schedule(init, 0, subscriber); } : init);
    }

    (function (NotificationKind) {
        NotificationKind["NEXT"] = "N";
        NotificationKind["ERROR"] = "E";
        NotificationKind["COMPLETE"] = "C";
    })(exports.NotificationKind || (exports.NotificationKind = {}));
    var Notification = (function () {
        function Notification(kind, value, error) {
            this.kind = kind;
            this.value = value;
            this.error = error;
            this.hasValue = kind === 'N';
        }
        Notification.prototype.observe = function (observer) {
            return observeNotification(this, observer);
        };
        Notification.prototype.do = function (nextHandler, errorHandler, completeHandler) {
            var _a = this, kind = _a.kind, value = _a.value, error = _a.error;
            return kind === 'N' ? nextHandler === null || nextHandler === void 0 ? void 0 : nextHandler(value) : kind === 'E' ? errorHandler === null || errorHandler === void 0 ? void 0 : errorHandler(error) : completeHandler === null || completeHandler === void 0 ? void 0 : completeHandler();
        };
        Notification.prototype.accept = function (nextOrObserver, error, complete) {
            var _a;
            return isFunction((_a = nextOrObserver) === null || _a === void 0 ? void 0 : _a.next)
                ? this.observe(nextOrObserver)
                : this.do(nextOrObserver, error, complete);
        };
        Notification.prototype.toObservable = function () {
            var _a = this, kind = _a.kind, value = _a.value, error = _a.error;
            var result = kind === 'N'
                ?
                    of(value)
                :
                    kind === 'E'
                        ?
                            throwError(function () { return error; })
                        :
                            kind === 'C'
                                ?
                                    EMPTY
                                :
                                    0;
            if (!result) {
                throw new TypeError("Unexpected notification kind " + kind);
            }
            return result;
        };
        Notification.createNext = function (value) {
            return new Notification('N', value);
        };
        Notification.createError = function (err) {
            return new Notification('E', undefined, err);
        };
        Notification.createComplete = function () {
            return Notification.completeNotification;
        };
        Notification.completeNotification = new Notification('C');
        return Notification;
    }());
    /**
     * Observes a notification and calls the appropriate method on the observer based on the notification type.
     *
     * @param {Object} notification - The notification object to be observed.
     * @param {Object} observer - The observer object that will handle the notification.
     * @throws {TypeError} If the notification is invalid and does not contain a 'kind' property of type string.
     */
    function observeNotification(notification, observer) {
        var _a, _b, _c;
        var _d = notification, kind = _d.kind, value = _d.value, error = _d.error;
        if (typeof kind !== 'string') {
            throw new TypeError('Invalid notification, missing "kind"');
        }
        kind === 'N' ? (_a = observer.next) === null || _a === void 0 ? void 0 : _a.call(observer, value) : kind === 'E' ? (_b = observer.error) === null || _b === void 0 ? void 0 : _b.call(observer, error) : (_c = observer.complete) === null || _c === void 0 ? void 0 : _c.call(observer);
    }

    function isObservable(obj) {
        return !!obj && (obj instanceof Observable || (isFunction(obj.lift) && isFunction(obj.subscribe)));
    }

    var EmptyError = createErrorClass(function (_super) {
        return function EmptyErrorImpl() {
            _super(this);
            this.name = 'EmptyError';
            this.message = 'no elements in sequence';
        };
    });

    function lastValueFrom(source, config) {
        var hasConfig = typeof config === 'object';
        return new Promise(function (resolve, reject) {
            var _hasValue = false;
            var _value;
            source.subscribe({
                next: function (value) {
                    _value = value;
                    _hasValue = true;
                },
                error: reject,
                complete: function () {
                    if (_hasValue) {
                        resolve(_value);
                    }
                    else if (hasConfig) {
                        resolve(config.defaultValue);
                    }
                    else {
                        reject(new EmptyError());
                    }
                },
            });
        });
    }

    /**
     * Returns the first value emitted by an Observable or a default value if no values are emitted.
     *
     * @param {Observable} source - The observable to subscribe to.
     * @param {Object} [config] - Configuration object for the function.
     * @param {any} config.defaultValue - Default value to return if no values are emitted from the source.
     * @return {Promise<any>} A promise that resolves with the first value or the default value, or rejects with an error.
     *
     * @example
     * const observable = Rx.Observable.of(10, 20, 30);
     * firstValueFrom(observable).then(value => {
     *     console.log(value); // Output: 10
     * });
     */
    function firstValueFrom(source, config) {
        var hasConfig = typeof config === 'object';
        return new Promise(function (resolve, reject) {
            var subscriber = new SafeSubscriber({
                next: function (value) {
                    resolve(value);
                    subscriber.unsubscribe();
                },
                error: reject,
                complete: function () {
                    if (hasConfig) {
                        resolve(config.defaultValue);
                    }
                    else {
                        reject(new EmptyError());
                    }
                },
            });
            source.subscribe(subscriber);
        });
    }

    var ArgumentOutOfRangeError = createErrorClass(function (_super) {
        return function ArgumentOutOfRangeErrorImpl() {
            _super(this);
            this.name = 'ArgumentOutOfRangeError';
            this.message = 'argument out of range';
        };
    });

    var NotFoundError = createErrorClass(function (_super) {
        return function NotFoundErrorImpl(message) {
            _super(this);
            this.name = 'NotFoundError';
            this.message = message;
        };
    });

    var SequenceError = createErrorClass(function (_super) {
        return function SequenceErrorImpl(message) {
            _super(this);
            this.name = 'SequenceError';
            this.message = message;
        };
    });

    /**
     * Checks if the provided value is a valid JavaScript Date object.
     *
     * @param {any} value - The value to check.
     * @returns {boolean} True if the value is a valid Date object and not NaN, otherwise false.
     *
     * @example
     * isValidDate(new Date()); // true
     * isValidDate('2023-10-05'); // false
     */
    function isValidDate(value) {
        return value instanceof Date && !isNaN(value);
    }

    var TimeoutError = createErrorClass(function (_super) {
        return function TimeoutErrorImpl(info) {
            if (info === void 0) { info = null; }
            _super(this);
            this.message = 'Timeout has occurred';
            this.name = 'TimeoutError';
            this.info = info;
        };
    });
    /**
     * Creates an observable that emits values from the source observable within a specified time frame.
     *
     * @param {Object|number} config - Configuration object containing 'first' and/or 'each' properties, or a number representing the initial delay.
     * @param {Object} [schedulerArg=asyncScheduler] - Scheduler used to manage timing of events. Defaults to `asyncScheduler`.
     * @returns {Observable} An observable that emits values from the source observable within the specified time frame.
     *
     * @throws {TypeError} If no timeout is provided in the configuration.
     */
    function timeout(config, schedulerArg) {
        var _a = (isValidDate(config) ? { first: config } : typeof config === 'number' ? { each: config } : config), first = _a.first, each = _a.each, _b = _a.with, _with = _b === void 0 ? timeoutErrorFactory : _b, _c = _a.scheduler, scheduler = _c === void 0 ? schedulerArg !== null && schedulerArg !== void 0 ? schedulerArg : asyncScheduler : _c, _d = _a.meta, meta = _d === void 0 ? null : _d;
        if (first == null && each == null) {
            throw new TypeError('No timeout provided.');
        }
        return operate(function (source, subscriber) {
            var originalSourceSubscription;
            var timerSubscription;
            var lastValue = null;
            var seen = 0;
            var startTimer = function (delay) {
                timerSubscription = executeSchedule(subscriber, scheduler, function () {
                    try {
                        originalSourceSubscription.unsubscribe();
                        innerFrom(_with({
                            meta: meta,
                            lastValue: lastValue,
                            seen: seen,
                        })).subscribe(subscriber);
                    }
                    catch (err) {
                        subscriber.error(err);
                    }
                }, delay);
            };
            originalSourceSubscription = source.subscribe(createOperatorSubscriber(subscriber, function (value) {
                timerSubscription === null || timerSubscription === void 0 ? void 0 : timerSubscription.unsubscribe();
                seen++;
                subscriber.next((lastValue = value));
                each > 0 && startTimer(each);
            }, undefined, undefined, function () {
                if (!(timerSubscription === null || timerSubscription === void 0 ? void 0 : timerSubscription.closed)) {
                    timerSubscription === null || timerSubscription === void 0 ? void 0 : timerSubscription.unsubscribe();
                }
                lastValue = null;
            }));
            !seen && startTimer(first != null ? (typeof first === 'number' ? first : +first - scheduler.now()) : each);
        });
    }
    /**
     * Creates an instance of TimeoutError with the provided information.
     *
     * @param {Object} info - An object containing details about the timeout error.
     * @throws {TimeoutError} - Throws a new instance of TimeoutError.
     */
    function timeoutErrorFactory(info) {
        throw new TimeoutError(info);
    }

    function map(project, thisArg) {
        return operate(function (source, subscriber) {
            var index = 0;
            source.subscribe(createOperatorSubscriber(subscriber, function (value) {
                subscriber.next(project.call(thisArg, value, index++));
            }));
        });
    }

    var isArray = Array.isArray;
    /**
     * Calls a function with the provided arguments, either as an array or as individual arguments.
     *
     * @param {Function} fn - The function to be called.
     * @param {Array|*} args - An array of arguments for the function or individual arguments separated by commas.
     * @returns {*} The result of calling the function with the provided arguments.
     * @throws {TypeError} If `fn` is not a function.
     *
     * @example
     * function sum(a, b) {
     *   return a + b;
     * }
     *
     * const result = callOrApply(sum, [2, 3]);
     * console.log(result); // Output: 5
     */
    function callOrApply(fn, args) {
        return isArray(args) ? fn.apply(void 0, __spreadArray([], __read(args))) : fn(args);
    }
    /**
     * Creates a function that maps over an array or single argument, applying the provided function to each element.
     *
     * @param {Function} fn - The function to apply to each element of the array or single argument.
     * @return {Function} A new function that takes an array or single argument and applies `fn` to each element.
     * @throws {TypeError} If `fn` is not a function.
     *
     * Example:
     * const increment = (x) => x + 1;
     * const mapIncrement = mapOneOrManyArgs(increment);
     * console.log(mapIncrement([1, 2, 3])); // [2, 3, 4]
     * console.log(mapIncrement(5)); // 6
     */
    function mapOneOrManyArgs(fn) {
        return map(function (args) { return callOrApply(fn, args); });
    }

    /**
     * Binds callback internals to handle different types of callbacks and schedulers.
     *
     * @param {boolean} isNodeStyle - Indicates if the callback follows Node.js error-first style.
     * @param {Function} callbackFunc - The callback function to be bound.
     * @param {(Observable|Function)} [resultSelector] - An Observable or a result selector function.
     * @param {Scheduler} [scheduler] - A scheduler to control when values are emitted.
     * @returns {Function} - A new function with the callback internals bound.
     *
     * @example
     * const boundCallback = bindCallbackInternals(true, (err, data) => {
     *     if (err) console.error(err);
     *     else console.log(data);
     * });
     * boundCallback(null, 'data');
     */
    function bindCallbackInternals(isNodeStyle, callbackFunc, resultSelector, scheduler) {
        if (resultSelector) {
            if (isScheduler(resultSelector)) {
                scheduler = resultSelector;
            }
            else {
                return function () {
                    var args = [];
                    for (var _i = 0; _i < arguments.length; _i++) {
                        args[_i] = arguments[_i];
                    }
                    return bindCallbackInternals(isNodeStyle, callbackFunc, scheduler)
                        .apply(this, args)
                        .pipe(mapOneOrManyArgs(resultSelector));
                };
            }
        }
        if (scheduler) {
            return function () {
                var args = [];
                for (var _i = 0; _i < arguments.length; _i++) {
                    args[_i] = arguments[_i];
                }
                return bindCallbackInternals(isNodeStyle, callbackFunc)
                    .apply(this, args)
                    .pipe(subscribeOn(scheduler), observeOn(scheduler));
            };
        }
        return function () {
            var _this = this;
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                args[_i] = arguments[_i];
            }
            var subject = new AsyncSubject();
            var uninitialized = true;
            return new Observable(function (subscriber) {
                var subs = subject.subscribe(subscriber);
                if (uninitialized) {
                    uninitialized = false;
                    var isAsync_1 = false;
                    var isComplete_1 = false;
                    callbackFunc.apply(_this, __spreadArray(__spreadArray([], __read(args)), [
                        function () {
                            var results = [];
                            for (var _i = 0; _i < arguments.length; _i++) {
                                results[_i] = arguments[_i];
                            }
                            if (isNodeStyle) {
                                var err = results.shift();
                                if (err != null) {
                                    subject.error(err);
                                    return;
                                }
                            }
                            subject.next(1 < results.length ? results : results[0]);
                            isComplete_1 = true;
                            if (isAsync_1) {
                                subject.complete();
                            }
                        },
                    ]));
                    if (isComplete_1) {
                        subject.complete();
                    }
                    isAsync_1 = true;
                }
                return subs;
            });
        };
    }

    /**
     * Binds a callback function to an observable sequence using specified result selector and scheduler.
     *
     * @function
     * @param {Function} callbackFunc - The callback function to be bound.
     * @param {Function} [resultSelector] - An optional function to transform the output value before it is returned.
     * @param {Scheduler} [scheduler] - An optional scheduler to schedule the execution of the callback.
     * @returns {Observable} - An observable sequence that will invoke the provided callback function with the transformed output value.
     *
     * @example
     * // Example usage
     * const boundCallback = bindCallback(() => console.log('Callback executed'), (result) => `Result: ${result}`);
     * boundCallback.of(42).subscribe();
     */
    function bindCallback(callbackFunc, resultSelector, scheduler) {
        return bindCallbackInternals(false, callbackFunc, resultSelector, scheduler);
    }

    /**
     * Binds a Node.js-style callback function to an Observable.
     *
     * @param {Function} callbackFunc - The Node.js-style callback function to be bound.
     * @param {function(result: any): any} [resultSelector] - A selector that takes the result from the callback and returns a new value.
     * @param {SchedulerLike} [scheduler] - An optional Scheduler to schedule the emission of values.
     * @returns {Observable<any>} An Observable that emits the results of the callback function.
     *
     * Example:
     *   const callback = (err, result) => {
     *     if (err) throw err;
     *     console.log(result);
     *   };
     *   const observable = bindNodeCallback(callback);
     *   observable.subscribe();
     */
    function bindNodeCallback(callbackFunc, resultSelector, scheduler) {
        return bindCallbackInternals(true, callbackFunc, resultSelector, scheduler);
    }

    var isArray$1 = Array.isArray;
    var getPrototypeOf = Object.getPrototypeOf, objectProto = Object.prototype, getKeys = Object.keys;
    /**
     * Processes arguments to either an array or an object into an array of values and corresponding keys if applicable.
     *
     * @param {any[]} args - The input arguments, which can be a single array or an object.
     * @returns {{args: any[], keys: string[]}} An object containing the processed arguments as an array (`args`) and their corresponding keys (if applicable).
     * @throws {Error} Throws an error if the input is neither an array nor an object.
     *
     * @example
     * // Example with an array
     * const resultArray = argsArgArrayOrObject(['a', 'b', 'c']);
     * console.log(resultArray); // Output: { args: ['a', 'b', 'c'], keys: null }
     *
     * @example
     * // Example with an object
     * const resultObject = argsArgArrayOrObject({ x: 1, y: 2 });
     * console.log(resultObject); // Output: { args: [1, 2], keys: ['x', 'y'] }
     */
    function argsArgArrayOrObject(args) {
        if (args.length === 1) {
            var first_1 = args[0];
            if (isArray$1(first_1)) {
                return { args: first_1, keys: null };
            }
            if (isPOJO(first_1)) {
                var keys = getKeys(first_1);
                return {
                    args: keys.map(function (key) { return first_1[key]; }),
                    keys: keys,
                };
            }
        }
        return { args: args, keys: null };
    }
    /**
     * Determines if the provided object is a Plain Old JavaScript Object (POJO).
     *
     * @param {Object} obj - The object to check.
     * @returns {boolean} - Returns `true` if the object is a POJO, otherwise `false`.
     */
    function isPOJO(obj) {
        return obj && typeof obj === 'object' && getPrototypeOf(obj) === objectProto;
    }

    /**
     * Creates an object by mapping keys to corresponding values.
     *
     * @param {string[]} keys - An array of string keys for the new object.
     * @param {*}[] values - An array of values corresponding to each key in `keys`.
     * @returns {Object} An object with properties mapped from `keys` and `values`.
     * @throws {Error} If the lengths of `keys` and `values` do not match.
     *
     * @example
     * // Returns { a: 1, b: 2 }
     * createObject(['a', 'b'], [1, 2]);
     */
    function createObject(keys, values) {
        return keys.reduce(function (result, key, i) { return ((result[key] = values[i]), result); }, {});
    }

    /**
     * Combines multiple observables into one observable that emits the latest values from each of them.
     *
     * @param {...*} args - An array of observables or a single observable. If an object is provided, it can include 'observables' and 'keys' properties.
     * @returns {Observable} - An observable that emits an object containing the latest values from the input observables.
     * @throws {Error} - Throws an error if no observables are provided or if the arguments are invalid.
     *
     * @example
     * const obs1 = of(1, 2, 3);
     * const obs2 = of('a', 'b');
     * combineLatest(obs1, obs2).subscribe(console.log); // { '0': 3, '1': 'b' }
     */
    function combineLatest() {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
        }
        var scheduler = popScheduler(args);
        var resultSelector = popResultSelector(args);
        var _a = argsArgArrayOrObject(args), observables = _a.args, keys = _a.keys;
        if (observables.length === 0) {
            return from([], scheduler);
        }
        var result = new Observable(combineLatestInit(observables, scheduler, keys
            ?
                function (values) { return createObject(keys, values); }
            :
                identity));
        return resultSelector ? result.pipe(mapOneOrManyArgs(resultSelector)) : result;
    }
    /**
     * Initializes a CombineLatest operator with observables, scheduler, and an optional value transform function.
     *
     * @param {Array<Observable<any>>} observables - Array of observables to combine.
     * @param {SchedulerLike | undefined} scheduler - Scheduler for asynchronous operations. Defaults to the current scheduler.
     * @param {function(Array<any>): any} [valueTransform=identity] - Function to transform the combined values before emitting. Defaults to identity.
     * @returns {function(subscriber: Subscriber): void} - A function that sets up the subscription logic.
     *
     * @throws {Error} If observables array is empty or contains non-observable elements.
     */
    function combineLatestInit(observables, scheduler, valueTransform) {
        if (valueTransform === void 0) { valueTransform = identity; }
        return function (subscriber) {
            maybeSchedule(scheduler, function () {
                var length = observables.length;
                var values = new Array(length);
                var active = length;
                var remainingFirstValues = length;
                var _loop_1 = function (i) {
                    maybeSchedule(scheduler, function () {
                        var source = from(observables[i], scheduler);
                        var hasFirstValue = false;
                        source.subscribe(createOperatorSubscriber(subscriber, function (value) {
                            values[i] = value;
                            if (!hasFirstValue) {
                                hasFirstValue = true;
                                remainingFirstValues--;
                            }
                            if (!remainingFirstValues) {
                                subscriber.next(valueTransform(values.slice()));
                            }
                        }, function () {
                            if (!--active) {
                                subscriber.complete();
                            }
                        }));
                    }, subscriber);
                };
                for (var i = 0; i < length; i++) {
                    _loop_1(i);
                }
            }, subscriber);
        };
    }
    /**
     * Schedules an execution if a scheduler is provided, otherwise executes immediately.
     *
     * @param {Scheduler} [scheduler] - The scheduler to use for executing the task. If not provided, the task will be executed immediately.
     * @param {Function} execute - The function that needs to be executed.
     * @param {Subscription} subscription - The subscription associated with the execution.
     * @throws {Error} Throws an error if the scheduler is invalid or if there are issues during scheduling.
     */
    function maybeSchedule(scheduler, execute, subscription) {
        if (scheduler) {
            executeSchedule(subscription, scheduler, execute);
        }
        else {
            execute();
        }
    }

    /**
     * Merges multiple observable sequences into one by subscribing to them concurrently and emitting their values as they arrive.
     *
     * @param {Observable} source - The source observable that emits the observables to be merged.
     * @param {function(value: any): Observable} project - A function that transforms each value from the source observable into an observable.
     * @param {number} concurrent - Maximum number of inner subscriptions allowed at the same time.
     * @param {boolean} expand - If true, emits values from each inner subscription on the outer subscriber.
     * @param {function(value: any)} [onBeforeNext] - Optional function to be called before emitting a value from an inner observable.
     * @param {SchedulerLike} [innerSubScheduler] - Scheduler used for scheduling inner subscriptions.
     * @param {function()} [additionalFinalizer] - Optional finalizer function to be called when the subscription completes or errors.
     *
     * @returns {Subscription} A subscription that can be used to unsubscribe from the merged observables.
     *
     * @example
     * // Merge two observables and emit values concurrently
     * const source$ = of(1, 2);
     * const merged$ = mergeInternals(source$, value => of(value * 2), 2);
     * merged$.subscribe(console.log); // Output: 2, 4
     */
    function mergeInternals(source, subscriber, project, concurrent, onBeforeNext, expand, innerSubScheduler, additionalFinalizer) {
        var buffer = [];
        var active = 0;
        var index = 0;
        var isComplete = false;
        var checkComplete = function () {
            if (isComplete && !buffer.length && !active) {
                subscriber.complete();
            }
        };
        var outerNext = function (value) { return (active < concurrent ? doInnerSub(value) : buffer.push(value)); };
        var doInnerSub = function (value) {
            expand && subscriber.next(value);
            active++;
            var innerComplete = false;
            innerFrom(project(value, index++)).subscribe(createOperatorSubscriber(subscriber, function (innerValue) {
                onBeforeNext === null || onBeforeNext === void 0 ? void 0 : onBeforeNext(innerValue);
                if (expand) {
                    outerNext(innerValue);
                }
                else {
                    subscriber.next(innerValue);
                }
            }, function () {
                innerComplete = true;
            }, undefined, function () {
                if (innerComplete) {
                    try {
                        active--;
                        var _loop_1 = function () {
                            var bufferedValue = buffer.shift();
                            if (innerSubScheduler) {
                                executeSchedule(subscriber, innerSubScheduler, function () { return doInnerSub(bufferedValue); });
                            }
                            else {
                                doInnerSub(bufferedValue);
                            }
                        };
                        while (buffer.length && active < concurrent) {
                            _loop_1();
                        }
                        checkComplete();
                    }
                    catch (err) {
                        subscriber.error(err);
                    }
                }
            }));
        };
        source.subscribe(createOperatorSubscriber(subscriber, outerNext, function () {
            isComplete = true;
            checkComplete();
        }));
        return function () {
            additionalFinalizer === null || additionalFinalizer === void 0 ? void 0 : additionalFinalizer();
        };
    }

    /**
     * Projects each element of an Observable to an Observable, then merges all of these Observables concurrently or in series.
     *
     * @template {any} T - The type of the source elements.
     * @template {any} R - The type of the result elements.
     * @param {ObservableInput<T> | ((value: T, index: number) => ObservableInput<R>)} project - A function that receives an item and its index from the source Observable and returns an Observable to merge.
     * @param {number} [concurrent=Infinity] - The maximum number of input Observables being subscribed to concurrently. If not provided, all input Observables are merged simultaneously.
     * @returns {Observable<R>} An Observable that emits items from each Observable returned by the project function as they complete.
     *
     * @example
     * const source = from([1, 2, 3]);
     * const result = source.pipe(mergeMap(x => interval(500).pipe(take(x))));
     * result.subscribe(console.log);
     */
    function mergeMap(project, resultSelector, concurrent) {
        if (concurrent === void 0) { concurrent = Infinity; }
        if (isFunction(resultSelector)) {
            return mergeMap(function (a, i) { return map(function (b, ii) { return resultSelector(a, b, i, ii); })(innerFrom(project(a, i))); }, concurrent);
        }
        else if (typeof resultSelector === 'number') {
            concurrent = resultSelector;
        }
        return operate(function (source, subscriber) { return mergeInternals(source, subscriber, project, concurrent); });
    }

    /**
     * Merges all elements from an observable sequence into a single array, optionally executing in parallel up to a specified number of concurrent operations.
     *
     * @param {number} [concurrent=Infinity] - The maximum number of concurrent operations to perform. Defaults to infinity, meaning all operations are performed concurrently.
     * @return {Observable<Array<T>>} An observable sequence containing a single element: an array with all the elements from the input observables.
     *
     * Example:
     * const source = mergeAll([of(1, 2), of(3, 4)], 2);
     * source.subscribe(console.log); // Logs [1, 2, 3, 4]
     */
    function mergeAll(concurrent) {
        if (concurrent === void 0) { concurrent = Infinity; }
        return mergeMap(identity, concurrent);
    }

    /**
     * Merges all elements of an array into a single string, separated by commas.
     *
     * @param {Array} arr - The array to be merged.
     * @returns {string} A string containing all elements of the array joined by commas.
     * @throws {TypeError} If the input is not an array.
     *
     * @example
     * concatAll(['apple', 'banana', 'cherry']); // returns 'apple,banana,cherry'
     */
    function concatAll() {
        return mergeAll(1);
    }

    /**
     * Joins multiple sequences of elements into one sequence by concatenating them.
     *
     * @param {...Array} args - Variable arguments representing arrays to concatenate.
     * @return {Observable} An Observable that emits the concatenated result of all input arrays.
     */
    function concat() {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
        }
        return concatAll()(from(args, popScheduler(args)));
    }

    /**
     * Creates an Observable that defers creation until it is subscribed to.
     *
     * @param {function(): Observable} observableFactory - A factory function that returns an Observable when called.
     * @returns {Observable} An Observable that will invoke the provided factory function when a subscription occurs.
     */
    function defer(observableFactory) {
        return new Observable(function (subscriber) {
            innerFrom(observableFactory()).subscribe(subscriber);
        });
    }

    var DEFAULT_CONFIG = {
        connector: function () { return new Subject(); },
        resetOnDisconnect: true,
    };
    /**
     * Creates an observable that connects to a source when subscribed to, using a provided connector function.
     *
     * @param {Observable} source - The source observable to which the connection will be established.
     * @param {Object} [config={connector: DEFAULT_CONFIG.connector, resetOnDisconnect: true}] - Configuration options for the connection.
     * @param {Function} config.connector - A function that returns an observable used to connect to the source.
     * @param {boolean} [config.resetOnDisconnect=true] - Whether to reset the connector when the connection is closed.
     * @returns {Observable} An observable that manages the connection to the source.
     *
     * @example
     * const config = {
     *   connector: () => Rx.Observable.interval(1000),
     *   resetOnDisconnect: false
     * };
     * const connectableObservable = connectable(Rx.Observable.empty(), config);
     */
    function connectable(source, config) {
        if (config === void 0) { config = DEFAULT_CONFIG; }
        var connection = null;
        var connector = config.connector, _a = config.resetOnDisconnect, resetOnDisconnect = _a === void 0 ? true : _a;
        var subject = connector();
        var result = new Observable(function (subscriber) {
            return subject.subscribe(subscriber);
        });
        result.connect = function () {
            if (!connection || connection.closed) {
                connection = defer(function () { return source; }).subscribe(subject);
                if (resetOnDisconnect) {
                    connection.add(function () { return (subject = connector()); });
                }
            }
            return connection;
        };
        return result;
    }

    function forkJoin() {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
        }
        var resultSelector = popResultSelector(args);
        var _a = argsArgArrayOrObject(args), sources = _a.args, keys = _a.keys;
        var result = new Observable(function (subscriber) {
            var length = sources.length;
            if (!length) {
                subscriber.complete();
                return;
            }
            var values = new Array(length);
            var remainingCompletions = length;
            var remainingEmissions = length;
            var _loop_1 = function (sourceIndex) {
                var hasValue = false;
                innerFrom(sources[sourceIndex]).subscribe(createOperatorSubscriber(subscriber, function (value) {
                    if (!hasValue) {
                        hasValue = true;
                        remainingEmissions--;
                    }
                    values[sourceIndex] = value;
                }, function () { return remainingCompletions--; }, undefined, function () {
                    if (!remainingCompletions || !hasValue) {
                        if (!remainingEmissions) {
                            subscriber.next(keys ? createObject(keys, values) : values);
                        }
                        subscriber.complete();
                    }
                }));
            };
            for (var sourceIndex = 0; sourceIndex < length; sourceIndex++) {
                _loop_1(sourceIndex);
            }
        });
        return resultSelector ? result.pipe(mapOneOrManyArgs(resultSelector)) : result;
    }

    var nodeEventEmitterMethods = ['addListener', 'removeListener'];
    var eventTargetMethods = ['addEventListener', 'removeEventListener'];
    var jqueryMethods = ['on', 'off'];
    function fromEvent(target, eventName, options, resultSelector) {
        if (isFunction(options)) {
            resultSelector = options;
            options = undefined;
        }
        if (resultSelector) {
            return fromEvent(target, eventName, options).pipe(mapOneOrManyArgs(resultSelector));
        }
        var _a = __read(isEventTarget(target)
            ? eventTargetMethods.map(function (methodName) { return function (handler) { return target[methodName](eventName, handler, options); }; })
            :
                isNodeStyleEventEmitter(target)
                    ? nodeEventEmitterMethods.map(toCommonHandlerRegistry(target, eventName))
                    : isJQueryStyleEventEmitter(target)
                        ? jqueryMethods.map(toCommonHandlerRegistry(target, eventName))
                        : [], 2), add = _a[0], remove = _a[1];
        if (!add) {
            if (isArrayLike(target)) {
                return mergeMap(function (subTarget) { return fromEvent(subTarget, eventName, options); })(innerFrom(target));
            }
        }
        if (!add) {
            throw new TypeError('Invalid event target');
        }
        return new Observable(function (subscriber) {
            var handler = function () {
                var args = [];
                for (var _i = 0; _i < arguments.length; _i++) {
                    args[_i] = arguments[_i];
                }
                return subscriber.next(1 < args.length ? args : args[0]);
            };
            add(handler);
            return function () { return remove(handler); };
        });
    }
    /**
     * Creates a function that registers an event handler for a specified event on a target object.
     *
     * @param {Object} target - The object that will have the event handler registered.
     * @param {string} eventName - The name of the event to handle.
     * @returns {function(string): function(function(*): undefined)} A function that takes a method name and returns another function
     * that registers an event handler. The innermost function takes the actual handler function as its parameter.
     *
     * @example
     * const registry = toCommonHandlerRegistry(myObject, 'click');
     * registry('handleClick')(function(event) {
     *   console.log('Button clicked:', event);
     * });
     */
    function toCommonHandlerRegistry(target, eventName) {
        return function (methodName) { return function (handler) { return target[methodName](eventName, handler); }; };
    }
    function isNodeStyleEventEmitter(target) {
        return isFunction(target.addListener) && isFunction(target.removeListener);
    }
    function isJQueryStyleEventEmitter(target) {
        return isFunction(target.on) && isFunction(target.off);
    }
    function isEventTarget(target) {
        return isFunction(target.addEventListener) && isFunction(target.removeEventListener);
    }

    function fromEventPattern(addHandler, removeHandler, resultSelector) {
        if (resultSelector) {
            return fromEventPattern(addHandler, removeHandler).pipe(mapOneOrManyArgs(resultSelector));
        }
        return new Observable(function (subscriber) {
            var handler = function () {
                var e = [];
                for (var _i = 0; _i < arguments.length; _i++) {
                    e[_i] = arguments[_i];
                }
                return subscriber.next(e.length === 1 ? e[0] : e);
            };
            var retValue = addHandler(handler);
            return isFunction(removeHandler) ? function () { return removeHandler(handler, retValue); } : undefined;
        });
    }

    /**
     * Generates an observable sequence from a seed value, an iterator function, and a condition function.
     *
     * @param {Object|number|string|Array} initialStateOrOptions - The initial state or options for the generator.
     * @param {Function} [condition] - A function that determines whether to continue iterating.
     * @param {Function} iterate - A function that produces the next state from the current state.
     * @param {Function} [resultSelector=identity] - A function that selects the result value from the current state.
     * @param {Scheduler} [scheduler] - The scheduler to use for scheduling the iteration.
     * @returns {Observable} An observable sequence produced by the generator.
     *
     * @example
     * // Example usage:
     * const source = generate(0, x => x < 10, x => x + 1, x => x * 2);
     * source.subscribe(x => console.log(x));
     * // Output: 0, 4, 8, 12, 16, 20, 24, 28, 32
     *
     * @exception {Error} Throws an error if the initial state or options are invalid.
     */
    function generate(initialStateOrOptions, condition, iterate, resultSelectorOrScheduler, scheduler) {
        var _a, _b;
        var resultSelector;
        var initialState;
        if (arguments.length === 1) {
            (_a = initialStateOrOptions, initialState = _a.initialState, condition = _a.condition, iterate = _a.iterate, _b = _a.resultSelector, resultSelector = _b === void 0 ? identity : _b, scheduler = _a.scheduler);
        }
        else {
            initialState = initialStateOrOptions;
            if (!resultSelectorOrScheduler || isScheduler(resultSelectorOrScheduler)) {
                resultSelector = identity;
                scheduler = resultSelectorOrScheduler;
            }
            else {
                resultSelector = resultSelectorOrScheduler;
            }
        }
        /**
         * Generates a sequence of results based on a state machine pattern.
         *
         * @generator
         * @yields {*} - The result selected from the current state using `resultSelector`.
         * @throws {Error} - If `iterate` function returns an invalid state.
         */
        function gen() {
            var state;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        state = initialState;
                        _a.label = 1;
                    case 1:
                        if (!(!condition || condition(state))) return [3, 4];
                        return [4, resultSelector(state)];
                    case 2:
                        _a.sent();
                        _a.label = 3;
                    case 3:
                        state = iterate(state);
                        return [3, 1];
                    case 4: return [2];
                }
            });
        }
        return defer((scheduler
            ?
                function () { return scheduleIterable(gen(), scheduler); }
            :
                gen));
    }

    /**
     * Evaluates a condition and returns one of two results based on its value.
     *
     * @function
     * @param {Function} condition - A function that returns a boolean value.
     * @param {*} trueResult - The result to return if the condition is true.
     * @param {*} falseResult - The result to return if the condition is false.
     * @returns {*} - The result of trueResult or falseResult based on the condition's evaluation.
     * @throws {Error} - Throws an error if the condition function does not return a boolean value.
     *
     * @example
     * const isLoggedIn = () => true;
     * const result = iif(isLoggedIn, 'Welcome', 'Login Required');
     * console.log(result); // Outputs: Welcome
     */
    function iif(condition, trueResult, falseResult) {
        return defer(function () { return (condition() ? trueResult : falseResult); });
    }

    /**
     * Creates an Observable that emits a sequence of numbers after dueTime, starting from 0.
     *
     * @param {number} [dueTime=0] - The time in milliseconds before the first value is emitted.
     * @param {number|SchedulerLike} [intervalOrScheduler=-1] - The interval between emissions or a scheduler to use for scheduling the emission of values.
     * @param {SchedulerLike} [scheduler=async] - The scheduler to run on.
     * @returns {Observable<number>} An Observable that emits a sequence of numbers starting from 0.
     *
     * @example
     * // Emit every second, starting after 1000ms
     * const subscription = timer(1000, 1000).subscribe(value => console.log(value));
     */
    function timer(dueTime, intervalOrScheduler, scheduler) {
        if (dueTime === void 0) { dueTime = 0; }
        if (scheduler === void 0) { scheduler = async; }
        var intervalDuration = -1;
        if (intervalOrScheduler != null) {
            if (isScheduler(intervalOrScheduler)) {
                scheduler = intervalOrScheduler;
            }
            else {
                intervalDuration = intervalOrScheduler;
            }
        }
        return new Observable(function (subscriber) {
            var due = isValidDate(dueTime) ? +dueTime - scheduler.now() : dueTime;
            if (due < 0) {
                due = 0;
            }
            var n = 0;
            return scheduler.schedule(function () {
                if (!subscriber.closed) {
                    subscriber.next(n++);
                    if (0 <= intervalDuration) {
                        this.schedule(undefined, intervalDuration);
                    }
                    else {
                        subscriber.complete();
                    }
                }
            }, due);
        });
    }

    /**
     * Creates an Observable that emits sequential numbers every specified period of time,
     * starting from zero.
     *
     * @function
     * @name interval
     * @param {number} [period=0] - The period at which to emit numbers, in milliseconds. Default is 0 (no delay).
     * @param {SchedulerLike} [scheduler=asyncScheduler] - The scheduler on which to schedule the emissions.
     * @returns {Observable<number>} An Observable that emits sequential numbers every specified period.
     *
     * @example
     * // Example usage:
     * const subscription = interval(1000).subscribe(x => console.log(x));
     * // Output: 0, 1, 2, ...
     */
    function interval(period, scheduler) {
        if (period === void 0) { period = 0; }
        if (scheduler === void 0) { scheduler = asyncScheduler; }
        if (period < 0) {
            period = 0;
        }
        return timer(period, period, scheduler);
    }

    function merge() {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
        }
        var scheduler = popScheduler(args);
        var concurrent = popNumber(args, Infinity);
        var sources = args;
        return !sources.length
            ?
                EMPTY
            : sources.length === 1
                ?
                    innerFrom(sources[0])
                :
                    mergeAll(concurrent)(from(sources, scheduler));
    }

    var NEVER = new Observable(noop);
    /**
     * Returns the constant representing the "never" language.
     *
     * @returns {string} The string 'NEVER' representing the "never" language.
     */
    function never() {
        return NEVER;
    }

    var isArray$2 = Array.isArray;
    /**
     * Converts an array of arguments into a flat array if it contains only one argument which is an array.
     *
     * @param {any[]} args - The array of arguments to be processed.
     * @returns {any[]} A flat array containing the elements of the single array argument, or the original arguments array if no such condition is met.
     * @example
     * // Returns [1, 2, 3]
     * argsOrArgArray([[1, 2, 3]])
     *
     * @example
     * // Returns [1, 2, 3]
     * argsOrArgArray([1, 2, 3])
     */
    function argsOrArgArray(args) {
        return args.length === 1 && isArray$2(args[0]) ? args[0] : args;
    }

    /**
     * Creates an Observable that mirrors the source Observable, but switches to a fallback Observable if an error occurs.
     *
     * @param {...Observable} sources - A variable number of Observable sequences that will be subscribed to in sequence.
     * @returns {Observable} An Observable that emits all elements from the first successfully subscribing Observable,
     * or continues with each subsequent one until one succeeds.
     */
    function onErrorResumeNext() {
        var sources = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            sources[_i] = arguments[_i];
        }
        var nextSources = argsOrArgArray(sources);
        return new Observable(function (subscriber) {
            var sourceIndex = 0;
            var subscribeNext = function () {
                if (sourceIndex < nextSources.length) {
                    var nextSource = void 0;
                    try {
                        nextSource = innerFrom(nextSources[sourceIndex++]);
                    }
                    catch (err) {
                        subscribeNext();
                        return;
                    }
                    var innerSubscriber = new OperatorSubscriber(subscriber, undefined, noop, noop);
                    nextSource.subscribe(innerSubscriber);
                    innerSubscriber.add(subscribeNext);
                }
                else {
                    subscriber.complete();
                }
            };
            subscribeNext();
        });
    }

    /**
     * Converts an object into an observable sequence of [key, value] pairs.
     *
     * @param {Object} obj - The object to convert.
     * @param {Scheduler} scheduler - Scheduler used for scheduling the enumeration.
     * @returns {Observable} An observable sequence containing the key-value pairs from the object.
     */
    function pairs(obj, scheduler) {
        return from(Object.entries(obj), scheduler);
    }

    /**
     * Creates a new function that negates the result of the provided predicate function.
     *
     * @param {Function} pred - The predicate function to be negated. It should take three arguments: value, index, and thisArg.
     * @param {*} [thisArg] - Optional. The value to use as `this` when executing `pred`.
     * @returns {Function} A new function that returns the negation of the result from `pred`.
     *
     * @example
     * const isEven = (x) => x % 2 === 0;
     * const isOdd = not(isEven);
     * console.log(isOdd(3)); // true
     */
    function not(pred, thisArg) {
        return function (value, index) { return !pred.call(thisArg, value, index); };
    }

    /**
     * Filters the values emitted by an Observable based on a predicate function.
     *
     * @param {function} predicate - A function that determines whether to include an item in the output sequence.
     *   The function is called with three arguments:
     *   - `value`: The current value being processed.
     *   - `index`: The (zero-based) index of the current value in the source sequence.
     *   - `thisArg`: An optional object to which the `this` keyword will be bound when calling the predicate function.
     * @param {any} [thisArg] - A value to use as `this` when executing the predicate function.
     * @returns {Observable} - An Observable that emits only those items from the source Observable for which the predicate function returns `true`.
     *
     * Example:
     *   filter(function (value) {
     *     return value % 2 === 0;
     *   })
     */
    function filter(predicate, thisArg) {
        return operate(function (source, subscriber) {
            var index = 0;
            source.subscribe(createOperatorSubscriber(subscriber, function (value) { return predicate.call(thisArg, value, index++) && subscriber.next(value); }));
        });
    }

    /**
     * Partitions an array into two arrays based on a predicate function.
     *
     * @param {Array} source - The array to be partitioned.
     * @param {Function} predicate - A function that determines the partition criteria. It is called for each element in the array, and returns true or false.
     * @param {*} thisArg - Optional value to use as `this` when executing `predicate`.
     * @returns {[Array, Array]} An array containing two arrays: the first array contains elements for which the predicate returned true, and the second contains elements for which it returned false.
     *
     * @example
     * partition([1, 2, 3, 4], x => x % 2 === 0);
     * // returns [[2, 4], [1, 3]]
     */
    function partition(source, predicate, thisArg) {
        return [filter(predicate, thisArg)(innerFrom(source)), filter(not(predicate, thisArg))(innerFrom(source))];
    }

    /**
     * Creates an observable that emits the first emitted value from any of the provided observables,
     * or waits until all of them have emitted at least one value before emitting the first.
     *
     * @param {...*} sources - An array or arguments object containing Observable instances.
     * @returns {Observable} - The resulting Observable that emits values based on the race condition logic.
     */
    function race() {
        var sources = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            sources[_i] = arguments[_i];
        }
        sources = argsOrArgArray(sources);
        return sources.length === 1 ? innerFrom(sources[0]) : new Observable(raceInit(sources));
    }
    /**
     * Creates an observable that subscribes to multiple sources and emits the first emitted value from any of the sources.
     *
     * @param {Array<Observable>} sources - An array of observables to race against each other.
     * @returns {Observable} An observable that emits the first value from any of the provided observables.
     * @throws {Error} If no sources are provided or if sources is not an array.
     */
    function raceInit(sources) {
        return function (subscriber) {
            var subscriptions = [];
            var _loop_1 = function (i) {
                subscriptions.push(innerFrom(sources[i]).subscribe(createOperatorSubscriber(subscriber, function (value) {
                    if (subscriptions) {
                        for (var s = 0; s < subscriptions.length; s++) {
                            s !== i && subscriptions[s].unsubscribe();
                        }
                        subscriptions = null;
                    }
                    subscriber.next(value);
                })));
            };
            for (var i = 0; subscriptions && !subscriber.closed && i < sources.length; i++) {
                _loop_1(i);
            }
        };
    }

    /**
     * Generates an observable sequence that produces a sequence of integral numbers within a specified range.
     *
     * @param {number} start The value of the first integer in the sequence. If not specified, defaults to 0.
     * @param {number} count The total number of sequential integers to generate.
     * @param {IScheduler} scheduler An optional scheduler to use for scheduling the emission of values.
     * @returns {Observable<number>} An observable sequence that emits a range of integral numbers.
     *
     * @example
     * // Generate an observable that emits the numbers 0 through 4
     * var observable = range(5);
     *
     * @example
     * // Generate an observable that emits the numbers 1 through 3 using a custom scheduler
     * var observable = range(1, 3, myCustomScheduler);
     */
    function range(start, count, scheduler) {
        if (count == null) {
            count = start;
            start = 0;
        }
        if (count <= 0) {
            return EMPTY;
        }
        var end = count + start;
        return new Observable(scheduler
            ?
                function (subscriber) {
                    var n = start;
                    return scheduler.schedule(function () {
                        if (n < end) {
                            subscriber.next(n++);
                            this.schedule();
                        }
                        else {
                            subscriber.complete();
                        }
                    });
                }
            :
                function (subscriber) {
                    var n = start;
                    while (n < end && !subscriber.closed) {
                        subscriber.next(n++);
                    }
                    subscriber.complete();
                });
    }

    /**
     * Creates an observable that utilizes a resource factory to create a result,
     * which is then converted into another observable. This allows for the creation of observables
     * from resources in a modular and reusable way.
     *
     * @param {function} resourceFactory - A function that returns a resource.
     * @param {function} observableFactory - A function that takes a resource and returns an observable or a falsy value.
     * @returns {Observable} An observable that emits the result of the observableFactory function.
     *
     * @example
     * const resourceFactory = () => new MyResource();
     * const observableFactory = (resource) => from(resource.getData());
     * const myObservable = using(resourceFactory, observableFactory);
     */
    function using(resourceFactory, observableFactory) {
        return new Observable(function (subscriber) {
            var resource = resourceFactory();
            var result = observableFactory(resource);
            var source = result ? innerFrom(result) : EMPTY;
            source.subscribe(subscriber);
            return function () {
                if (resource) {
                    resource.unsubscribe();
                }
            };
        });
    }

    function zip() {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
        }
        var resultSelector = popResultSelector(args);
        var sources = argsOrArgArray(args);
        return sources.length
            ? new Observable(function (subscriber) {
                var buffers = sources.map(function () { return []; });
                var completed = sources.map(function () { return false; });
                subscriber.add(function () {
                    buffers = completed = null;
                });
                var _loop_1 = function (sourceIndex) {
                    innerFrom(sources[sourceIndex]).subscribe(createOperatorSubscriber(subscriber, function (value) {
                        buffers[sourceIndex].push(value);
                        if (buffers.every(function (buffer) { return buffer.length; })) {
                            var result = buffers.map(function (buffer) { return buffer.shift(); });
                            subscriber.next(resultSelector ? resultSelector.apply(void 0, __spreadArray([], __read(result))) : result);
                            if (buffers.some(function (buffer, i) { return !buffer.length && completed[i]; })) {
                                subscriber.complete();
                            }
                        }
                    }, function () {
                        completed[sourceIndex] = true;
                        !buffers[sourceIndex].length && subscriber.complete();
                    }));
                };
                for (var sourceIndex = 0; !subscriber.closed && sourceIndex < sources.length; sourceIndex++) {
                    _loop_1(sourceIndex);
                }
                return function () {
                    buffers = completed = null;
                };
            })
            : EMPTY;
    }

    /**
     * Creates an operator function that audits emissions from the source observable based on the provided duration selector.
     *
     * @param {function(value: any): Observable<any>} durationSelector - A function that takes a value and returns an Observable, which specifies the duration for which the current value should be emitted before moving to the next one.
     * @returns {OperatorFunction<any, any>} An operator function that can be used with observables to audit their emissions.
     *
     * @example
     * import { of } from 'rxjs';
     * import { audit } from 'rxjs/operators';
     *
     * const source$ = of(1, 2, 3);
     * source$.pipe(audit(value => of(value).delay(500))).subscribe(console.log); // Emits values with a delay of 500ms
     */
    function audit(durationSelector) {
        return operate(function (source, subscriber) {
            var hasValue = false;
            var lastValue = null;
            var durationSubscriber = null;
            var isComplete = false;
            var endDuration = function () {
                durationSubscriber === null || durationSubscriber === void 0 ? void 0 : durationSubscriber.unsubscribe();
                durationSubscriber = null;
                if (hasValue) {
                    hasValue = false;
                    var value = lastValue;
                    lastValue = null;
                    subscriber.next(value);
                }
                isComplete && subscriber.complete();
            };
            var cleanupDuration = function () {
                durationSubscriber = null;
                isComplete && subscriber.complete();
            };
            source.subscribe(createOperatorSubscriber(subscriber, function (value) {
                hasValue = true;
                lastValue = value;
                if (!durationSubscriber) {
                    innerFrom(durationSelector(value)).subscribe((durationSubscriber = createOperatorSubscriber(subscriber, endDuration, cleanupDuration)));
                }
            }, function () {
                isComplete = true;
                (!hasValue || !durationSubscriber || durationSubscriber.closed) && subscriber.complete();
            }));
        });
    }

    /**
     * Creates an Observable that emits a single number value after a specified duration of time, with the given scheduler.
     *
     * @param {number} duration - The amount of time to wait before emitting a value, in milliseconds.
     * @param {SchedulerLike} [scheduler=asyncScheduler] - Scheduler to use for scheduling the emission of the value.
     * @returns {Observable<number>} An Observable that emits a single number value after the specified duration of time.
     *
     * Example:
     * ```javascript
     * import { auditTime } from 'rxjs';
     * import { asyncScheduler } from 'rxjs/scheduler/async';
     *
     * const observable = auditTime(1000, asyncScheduler);
     * observable.subscribe(value => {
     *   console.log('Value emitted after 1 second:', value);
     * });
     * ```
     */
    function auditTime(duration, scheduler) {
        if (scheduler === void 0) { scheduler = asyncScheduler; }
        return audit(function () { return timer(duration, scheduler); });
    }

    /**
     * Buffers values from an observable until a notifier emits a value, then emits the buffered values.
     *
     * @param {Observable<any>} closingNotifier - An observable that triggers the emission of the current buffer.
     * @returns {Observable<Array<any>>} An observable emitting arrays of buffered values.
     */
    function buffer(closingNotifier) {
        return operate(function (source, subscriber) {
            var currentBuffer = [];
            source.subscribe(createOperatorSubscriber(subscriber, function (value) { return currentBuffer.push(value); }, function () {
                subscriber.next(currentBuffer);
                subscriber.complete();
            }));
            innerFrom(closingNotifier).subscribe(createOperatorSubscriber(subscriber, function () {
                var b = currentBuffer;
                currentBuffer = [];
                subscriber.next(b);
            }, noop));
            return function () {
                currentBuffer = null;
            };
        });
    }

    /**
     * Splits an observable sequence of values into arrays of elements, each of size `bufferSize`.
     * A new array is created every `startBufferEvery` elements.
     *
     * @param {number} bufferSize - The maximum number of items in each buffer before emitting.
     * @param {number} [startBufferEvery=bufferSize] - The interval at which to start a new buffer. If not provided, it defaults to the `bufferSize`.
     * @returns {Observable<Array<T>>} An observable that emits arrays of values from the source sequence.
     *
     * @example
     * // Example usage:
     * const source$ = of(1, 2, 3, 4, 5, 6);
     * const buffered$ = bufferCount(2, 3);
     * buffered$.subscribe(buffer => console.log(buffer));
     * // Output: [1, 2], [4, 5]
     */
    function bufferCount(bufferSize, startBufferEvery) {
        if (startBufferEvery === void 0) { startBufferEvery = null; }
        startBufferEvery = startBufferEvery !== null && startBufferEvery !== void 0 ? startBufferEvery : bufferSize;
        return operate(function (source, subscriber) {
            var buffers = [];
            var count = 0;
            source.subscribe(createOperatorSubscriber(subscriber, function (value) {
                var e_1, _a, e_2, _b;
                var toEmit = null;
                if (count++ % startBufferEvery === 0) {
                    buffers.push([]);
                }
                try {
                    for (var buffers_1 = __values(buffers), buffers_1_1 = buffers_1.next(); !buffers_1_1.done; buffers_1_1 = buffers_1.next()) {
                        var buffer = buffers_1_1.value;
                        buffer.push(value);
                        if (bufferSize <= buffer.length) {
                            toEmit = toEmit !== null && toEmit !== void 0 ? toEmit : [];
                            toEmit.push(buffer);
                        }
                    }
                }
                catch (e_1_1) { e_1 = { error: e_1_1 }; }
                finally {
                    try {
                        if (buffers_1_1 && !buffers_1_1.done && (_a = buffers_1.return)) _a.call(buffers_1);
                    }
                    finally { if (e_1) throw e_1.error; }
                }
                if (toEmit) {
                    try {
                        for (var toEmit_1 = __values(toEmit), toEmit_1_1 = toEmit_1.next(); !toEmit_1_1.done; toEmit_1_1 = toEmit_1.next()) {
                            var buffer = toEmit_1_1.value;
                            arrRemove(buffers, buffer);
                            subscriber.next(buffer);
                        }
                    }
                    catch (e_2_1) { e_2 = { error: e_2_1 }; }
                    finally {
                        try {
                            if (toEmit_1_1 && !toEmit_1_1.done && (_b = toEmit_1.return)) _b.call(toEmit_1);
                        }
                        finally { if (e_2) throw e_2.error; }
                    }
                }
            }, function () {
                var e_3, _a;
                try {
                    for (var buffers_2 = __values(buffers), buffers_2_1 = buffers_2.next(); !buffers_2_1.done; buffers_2_1 = buffers_2.next()) {
                        var buffer = buffers_2_1.value;
                        subscriber.next(buffer);
                    }
                }
                catch (e_3_1) { e_3 = { error: e_3_1 }; }
                finally {
                    try {
                        if (buffers_2_1 && !buffers_2_1.done && (_a = buffers_2.return)) _a.call(buffers_2);
                    }
                    finally { if (e_3) throw e_3.error; }
                }
                subscriber.complete();
            }, undefined, function () {
                buffers = null;
            }));
        });
    }

    /**
     * Buffers values from the source observable for a specified time span or interval.
     *
     * @param {number} bufferTimeSpan - The time span (in milliseconds) to wait before emitting buffered values.
     * @returns {Observable<Array<T>>} - An observable that emits arrays of buffered values.
     *
     * @example
     * import { from } from 'rxjs';
     * import { bufferTime } from 'rxjs/operators';
     *
     * const source$ = from([1, 2, 3, 4, 5]);
     * const buffered$ = source$.pipe(bufferTime(1000));
     * buffered$.subscribe(console.log);
     */
    function bufferTime(bufferTimeSpan) {
        var _a, _b;
        var otherArgs = [];
        for (var _i = 1; _i < arguments.length; _i++) {
            otherArgs[_i - 1] = arguments[_i];
        }
        var scheduler = (_a = popScheduler(otherArgs)) !== null && _a !== void 0 ? _a : asyncScheduler;
        var bufferCreationInterval = (_b = otherArgs[0]) !== null && _b !== void 0 ? _b : null;
        var maxBufferSize = otherArgs[1] || Infinity;
        return operate(function (source, subscriber) {
            var bufferRecords = [];
            var restartOnEmit = false;
            var emit = function (record) {
                var buffer = record.buffer, subs = record.subs;
                subs.unsubscribe();
                arrRemove(bufferRecords, record);
                subscriber.next(buffer);
                restartOnEmit && startBuffer();
            };
            var startBuffer = function () {
                if (bufferRecords) {
                    var subs = new Subscription();
                    subscriber.add(subs);
                    var buffer = [];
                    var record_1 = {
                        buffer: buffer,
                        subs: subs,
                    };
                    bufferRecords.push(record_1);
                    executeSchedule(subs, scheduler, function () { return emit(record_1); }, bufferTimeSpan);
                }
            };
            if (bufferCreationInterval !== null && bufferCreationInterval >= 0) {
                executeSchedule(subscriber, scheduler, startBuffer, bufferCreationInterval, true);
            }
            else {
                restartOnEmit = true;
            }
            startBuffer();
            var bufferTimeSubscriber = createOperatorSubscriber(subscriber, function (value) {
                var e_1, _a;
                var recordsCopy = bufferRecords.slice();
                try {
                    for (var recordsCopy_1 = __values(recordsCopy), recordsCopy_1_1 = recordsCopy_1.next(); !recordsCopy_1_1.done; recordsCopy_1_1 = recordsCopy_1.next()) {
                        var record = recordsCopy_1_1.value;
                        var buffer = record.buffer;
                        buffer.push(value);
                        maxBufferSize <= buffer.length && emit(record);
                    }
                }
                catch (e_1_1) { e_1 = { error: e_1_1 }; }
                finally {
                    try {
                        if (recordsCopy_1_1 && !recordsCopy_1_1.done && (_a = recordsCopy_1.return)) _a.call(recordsCopy_1);
                    }
                    finally { if (e_1) throw e_1.error; }
                }
            }, function () {
                while (bufferRecords === null || bufferRecords === void 0 ? void 0 : bufferRecords.length) {
                    subscriber.next(bufferRecords.shift().buffer);
                }
                bufferTimeSubscriber === null || bufferTimeSubscriber === void 0 ? void 0 : bufferTimeSubscriber.unsubscribe();
                subscriber.complete();
                subscriber.unsubscribe();
            }, undefined, function () { return (bufferRecords = null); });
            source.subscribe(bufferTimeSubscriber);
        });
    }

    /**
     * Creates an operator that buffers values from the source observable until a specified opening selector emits,
     * then emits the buffered values. When the closing selector emits, the current buffer is emitted and a new one starts.
     *
     * @param {Observable} openings - Observable to start buffering upon emission.
     * @param {Function} closingSelector - Function that returns an observable for each buffered value to complete the buffer.
     * @returns {OperatorFunction} Operator function to apply to the source observable.
     */
    function bufferToggle(openings, closingSelector) {
        return operate(function (source, subscriber) {
            var buffers = [];
            innerFrom(openings).subscribe(createOperatorSubscriber(subscriber, function (openValue) {
                var buffer = [];
                buffers.push(buffer);
                var closingSubscription = new Subscription();
                var emitBuffer = function () {
                    arrRemove(buffers, buffer);
                    subscriber.next(buffer);
                    closingSubscription.unsubscribe();
                };
                closingSubscription.add(innerFrom(closingSelector(openValue)).subscribe(createOperatorSubscriber(subscriber, emitBuffer, noop)));
            }, noop));
            source.subscribe(createOperatorSubscriber(subscriber, function (value) {
                var e_1, _a;
                try {
                    for (var buffers_1 = __values(buffers), buffers_1_1 = buffers_1.next(); !buffers_1_1.done; buffers_1_1 = buffers_1.next()) {
                        var buffer = buffers_1_1.value;
                        buffer.push(value);
                    }
                }
                catch (e_1_1) { e_1 = { error: e_1_1 }; }
                finally {
                    try {
                        if (buffers_1_1 && !buffers_1_1.done && (_a = buffers_1.return)) _a.call(buffers_1);
                    }
                    finally { if (e_1) throw e_1.error; }
                }
            }, function () {
                while (buffers.length > 0) {
                    subscriber.next(buffers.shift());
                }
                subscriber.complete();
            }));
        });
    }

    /**
     * Buffers values from the source observable until a closing selector emits a value,
     * then emits the buffered values followed by the latest value from the closing selector.
     *
     * @param {function(): Observable<any>} closingSelector - A function that returns an Observable which, when emitted, closes the current buffer and starts a new one.
     * @returns {Observable<T[]>} An Observable that emits arrays of buffered values whenever the closing selector emits a value.
     */
    function bufferWhen(closingSelector) {
        return operate(function (source, subscriber) {
            var buffer = null;
            var closingSubscriber = null;
            var openBuffer = function () {
                closingSubscriber === null || closingSubscriber === void 0 ? void 0 : closingSubscriber.unsubscribe();
                var b = buffer;
                buffer = [];
                b && subscriber.next(b);
                innerFrom(closingSelector()).subscribe((closingSubscriber = createOperatorSubscriber(subscriber, openBuffer, noop)));
            };
            openBuffer();
            source.subscribe(createOperatorSubscriber(subscriber, function (value) { return buffer === null || buffer === void 0 ? void 0 : buffer.push(value); }, function () {
                buffer && subscriber.next(buffer);
                subscriber.complete();
            }, undefined, function () { return (buffer = closingSubscriber = null); }));
        });
    }

    /**
     * Catches errors emitted by an Observable and provides a fallback value or another Observable to emit on error.
     *
     * @param {function(error: any): (ObservableInput<any>|void)} selector - A function that takes the error as an argument and returns an Observable, Promise, or value that will be used in place of the original Observable.
     * @returns {Observable<T>} An Observable that emits the same values as the source Observable, but switches to a fallback Observable if an error occurs.
     *
     * @example
     * import { from } from 'rxjs';
     * import { catchError, map } from 'rxjs/operators';
     *
     * const source$ = from([1, 2, 3, 4]);
     * const fallback$ = from(['a', 'b']);
     *
     * const result$ = source$.pipe(
     *   map(x => {
     *     if (x === 2) throw new Error('Error at index 2');
     *     return x;
     *   }),
     *   catchError(err => fallback$)
     * );
     *
     * result$.subscribe(value => console.log(value));
     * // Output: 1, a, b
     */
    function catchError(selector) {
        return operate(function (source, subscriber) {
            var innerSub = null;
            var syncUnsub = false;
            var handledResult;
            innerSub = source.subscribe(createOperatorSubscriber(subscriber, undefined, undefined, function (err) {
                handledResult = innerFrom(selector(err, catchError(selector)(source)));
                if (innerSub) {
                    innerSub.unsubscribe();
                    innerSub = null;
                    handledResult.subscribe(subscriber);
                }
                else {
                    syncUnsub = true;
                }
            }));
            if (syncUnsub) {
                innerSub.unsubscribe();
                innerSub = null;
                handledResult.subscribe(subscriber);
            }
        });
    }

    /**
     * A utility function to scan over the source observable and accumulate values using an accumulator function.
     *
     * @param {function} accumulator - The function used to accumulate values from the source. It takes three arguments: the current state, the next value, and the index of the value.
     * @param {*} seed - The initial state for accumulation.
     * @param {boolean} hasSeed - Indicates if an initial state is provided.
     * @param {boolean} emitOnNext - Whether to emit the accumulated state on each next emission from the source.
     * @param {boolean} emitBeforeComplete - Whether to emit the final accumulated state before completing the observable.
     *
     * @returns {function} - A function that takes a source observable and a subscriber, and returns an operator subscriber.
     *
     * @example
     * const source = rxjs.of(1, 2, 3);
     * const accumulator = (state, value) => state + value;
     * const result$ = source.pipe(scanInternals(accumulator, 0, true, true, true));
     * result$.subscribe(console.log); // Output: 1, 3, 6
     */
    function scanInternals(accumulator, seed, hasSeed, emitOnNext, emitBeforeComplete) {
        return function (source, subscriber) {
            var hasState = hasSeed;
            var state = seed;
            var index = 0;
            source.subscribe(createOperatorSubscriber(subscriber, function (value) {
                var i = index++;
                state = hasState
                    ?
                        accumulator(state, value, i)
                    :
                        ((hasState = true), value);
                emitOnNext && subscriber.next(state);
            }, emitBeforeComplete &&
                (function () {
                    hasState && subscriber.next(state);
                    subscriber.complete();
                })));
        };
    }

    /**
     * Reduces an array or iterable to a single value by applying a function to each element.
     *
     * @param {Function} accumulator - A function that takes the accumulated value and the current item as arguments and returns the new accumulated value.
     * @param {*} seed - The initial value for the accumulator.
     * @returns {*} The final accumulated value after processing all elements.
     * @throws {Error} If the array is empty and no seed is provided, an error will be thrown.
     *
     * @example
     * // Summing numbers in an array
     * const sum = reduce((acc, num) => acc + num, 0, [1, 2, 3, 4]);
     * console.log(sum); // Output: 10
     */
    function reduce(accumulator, seed) {
        return operate(scanInternals(accumulator, seed, arguments.length >= 2, false, true));
    }

    var arrReducer = function (arr, value) { return (arr.push(value), arr); };
    function toArray() {
        return operate(function (source, subscriber) {
            reduce(arrReducer, [])(source).subscribe(subscriber);
        });
    }

    /**
     * Joins all internal sources using a provided join function.
     *
     * @function joinAllInternals
     * @param {Function} joinFn - A function that takes an array of sources and returns an observable.
     * @param {Function|undefined} [project] - An optional projection function to transform the output. If not provided, the identity function is used.
     * @returns {Observable} - An observable that emits the result of applying the join function and optionally the project function.
     *
     * @example
     * const sources = [source1$, source2$];
     * const joined = joinAllInternals((sources) => forkJoin(sources), (result) => result.map(item => item.toUpperCase()));
     * joined.subscribe(console.log);
     */
    function joinAllInternals(joinFn, project) {
        return pipe(toArray(), mergeMap(function (sources) { return joinFn(sources); }), project ? mapOneOrManyArgs(project) : identity);
    }

    function combineLatestAll(project) {
        return joinAllInternals(combineLatest, project);
    }

    var combineAll = combineLatestAll;

    /**
     * Combines multiple observables to return an observable that emits an array containing the latest values from each input observable.
     *
     * @param {...Observable} args - An array of observables or individual observables to be combined.
     * @returns {Observable<Array>} An observable that emits an array containing the latest values from all input observables.
     *
     * @example
     * // Combine two observables and log their latest values as they change
     * combineLatest([observable1$, observable2$]).subscribe(values => {
     *   console.log('Latest values:', values);
     * });
     */
    function combineLatest$1() {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
        }
        var resultSelector = popResultSelector(args);
        return resultSelector
            ? pipe(combineLatest$1.apply(void 0, __spreadArray([], __read(args))), mapOneOrManyArgs(resultSelector))
            : operate(function (source, subscriber) {
                combineLatestInit(__spreadArray([source], __read(argsOrArgArray(args))))(subscriber);
            });
    }

    function combineLatestWith() {
        var otherSources = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            otherSources[_i] = arguments[_i];
        }
        return combineLatest$1.apply(void 0, __spreadArray([], __read(otherSources)));
    }

    /**
     * Applies a function to each value produced by an Observable, where the function returns an Observable,
     * and then merges all of these inner Observables in a way that allows only one inner Observable to emit at a time.
     *
     * @param {Observable<T>|function(value:T):Observable<U>} project - A function that takes a value emitted by the source Observable
     * and returns an Observable. If it returns an Observable, then `concatMap` will subscribe to it immediately.
     * If it returns something other than an Observable, `concatMap` will wrap it in an Observable and then subscribe to it.
     * @param {number} [concurrent=1] - Maximum number of input Observables being subscribed to concurrently. Defaults to 1.
     * @return {Observable<U>} An Observable that emits the results from applying the specified function to each item emitted by
     * the source Observable and merging all of the inner Observables.
     *
     * Example:
     * ```javascript
     * const source$ = Rx.Observable.interval(1000).take(5);
     * source$.concatMap(i => Rx.Observable.timer(i * 200)).subscribe(console.log);
     * // Output: 0, 1, 3, 6, 10
     * ```
     *
     * Throws an error if `project` is not a function.
     */
    function concatMap(project, resultSelector) {
        return isFunction(resultSelector) ? mergeMap(project, resultSelector, 1) : mergeMap(project, 1);
    }

    /**
     * Projects each element of an observable sequence into a new form by incorporating the element's index.
     *
     * @param {Observable} innerObservable - The Observable to project each element into.
     * @param {(value: any, index: number) => Observable} [resultSelector] - A function that returns an Observable for each element in the input sequence.
     * @returns {Observable} An observable sequence whose elements are the result of invoking the transform function on each element of the input sequence and then mapping each resulting observable sequence into a single observable sequence.
     *
     * @example
     * var source = Rx.Observable.range(0, 3);
     * var result = source.concatMapTo(Rx.Observable.just('X'), (x) => 'Value: ' + x);
     * result.subscribe(x => console.log(x));
     * // Output:
     * // Value: 0
     * // Value: 1
     * // Value: 2
     */
    function concatMapTo(innerObservable, resultSelector) {
        return isFunction(resultSelector) ? concatMap(function () { return innerObservable; }, resultSelector) : concatMap(function () { return innerObservable; });
    }

    function concat$1() {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
        }
        var scheduler = popScheduler(args);
        return operate(function (source, subscriber) {
            concatAll()(from(__spreadArray([source], __read(args)), scheduler)).subscribe(subscriber);
        });
    }

    /**
     * Joins multiple arrays into one array.
     *
     * @param {...Array} otherSources - The arrays to join with the primary array.
     * @returns {Array} A new array containing all elements from the primary and provided arrays.
     */
    function concatWith() {
        var otherSources = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            otherSources[_i] = arguments[_i];
        }
        return concat$1.apply(void 0, __spreadArray([], __read(otherSources)));
    }

    function fromSubscribable(subscribable) {
        return new Observable(function (subscriber) { return subscribable.subscribe(subscriber); });
    }

    var DEFAULT_CONFIG$1 = {
        connector: function () { return new Subject(); },
    };
    /**
     * Connects a source observable to a subject using the provided connector function from the configuration.
     *
     * @param {Function} selector - A function that takes an observable and returns a new observable.
     * @param {Object} [config=DEFAULT_CONFIG$1] - Configuration object containing the connector function.
     * @returns {Observable} - An observable connected to the subject.
     */
    function connect(selector, config) {
        if (config === void 0) { config = DEFAULT_CONFIG$1; }
        var connector = config.connector;
        return operate(function (source, subscriber) {
            var subject = connector();
            innerFrom(selector(fromSubscribable(subject))).subscribe(subscriber);
            subscriber.add(source.subscribe(subject));
        });
    }

    /**
     * Counts elements that pass the test implemented by the provided predicate function.
     *
     * @param {function} predicate - A function that tests each element of the array. The return value is a Boolean indicating whether the element should be included in the final count.
     * @returns {number} The count of elements for which the predicate returns true.
     *
     * @example
     * const numbers = [1, 2, 3, 4, 5];
     * const evenCount = count(numbers, (num) => num % 2 === 0);
     * console.log(evenCount); // Output: 2
     */
    function count(predicate) {
        return reduce(function (total, value, i) { return (!predicate || predicate(value, i) ? total + 1 : total); }, 0);
    }

    /**
     * Debounces the emissions from an observable by waiting for a specified duration after each emission before allowing another emission.
     *
     * @param {Observable<any>} durationSelector - An observable that determines the duration to wait for before emitting the next value.
     * @returns {OperatorFunction<any, any>} - An operator function that debounces emissions based on the provided duration selector.
     */
    function debounce(durationSelector) {
        return operate(function (source, subscriber) {
            var hasValue = false;
            var lastValue = null;
            var durationSubscriber = null;
            var emit = function () {
                durationSubscriber === null || durationSubscriber === void 0 ? void 0 : durationSubscriber.unsubscribe();
                durationSubscriber = null;
                if (hasValue) {
                    hasValue = false;
                    var value = lastValue;
                    lastValue = null;
                    subscriber.next(value);
                }
            };
            source.subscribe(createOperatorSubscriber(subscriber, function (value) {
                durationSubscriber === null || durationSubscriber === void 0 ? void 0 : durationSubscriber.unsubscribe();
                hasValue = true;
                lastValue = value;
                durationSubscriber = createOperatorSubscriber(subscriber, emit, noop);
                innerFrom(durationSelector(value)).subscribe(durationSubscriber);
            }, function () {
                emit();
                subscriber.complete();
            }, undefined, function () {
                lastValue = durationSubscriber = null;
            }));
        });
    }

    /**
     * Debounces emissions from the source observable by waiting for a specified duration of time between consecutive emissions before emitting the latest value.
     *
     * @param {number} dueTime - The minimum amount of time to wait between consecutive emissions, in milliseconds.
     * @param {SchedulerLike | undefined} scheduler - The scheduler on which to perform the debouncing. Defaults to asyncScheduler.
     * @returns {Observable<T>} An observable that emits values from the source after a debounce period has passed since the last emission.
     */
    function debounceTime(dueTime, scheduler) {
        if (scheduler === void 0) { scheduler = asyncScheduler; }
        return operate(function (source, subscriber) {
            var activeTask = null;
            var lastValue = null;
            var lastTime = null;
            var emit = function () {
                if (activeTask) {
                    activeTask.unsubscribe();
                    activeTask = null;
                    var value = lastValue;
                    lastValue = null;
                    subscriber.next(value);
                }
            };
            /**
             * Schedules an emission to occur when the idle time has been reached.
             *
             * @return {void}
             */
            function emitWhenIdle() {
                var targetTime = lastTime + dueTime;
                var now = scheduler.now();
                if (now < targetTime) {
                    activeTask = this.schedule(undefined, targetTime - now);
                    subscriber.add(activeTask);
                    return;
                }
                emit();
            }
            source.subscribe(createOperatorSubscriber(subscriber, function (value) {
                lastValue = value;
                lastTime = scheduler.now();
                if (!activeTask) {
                    activeTask = scheduler.schedule(emitWhenIdle, dueTime);
                    subscriber.add(activeTask);
                }
            }, function () {
                emit();
                subscriber.complete();
            }, undefined, function () {
                lastValue = activeTask = null;
            }));
        });
    }

    /**
     * Returns an Observable that emits the elements of the source Observable,
     * or a specified default value if the source Observable is empty.
     *
     * @param {any} defaultValue - The value to emit if the source Observable is empty.
     * @returns {Observable<any>} An Observable that emits the elements of the source Observable, or the default value if it's empty.
     *
     * Example:
     * const source$ = from([]);
     * const result$ = defaultIfEmpty('Default Value')(source$);
     * result$.subscribe(console.log); // Output: Default Value
     */
    function defaultIfEmpty(defaultValue) {
        return operate(function (source, subscriber) {
            var hasValue = false;
            source.subscribe(createOperatorSubscriber(subscriber, function (value) {
                hasValue = true;
                subscriber.next(value);
            }, function () {
                if (!hasValue) {
                    subscriber.next(defaultValue);
                }
                subscriber.complete();
            }));
        });
    }

    /**
     * Creates an operator that emits a specified number of values from the source Observable.
     *
     * @param {number} count - The maximum number of values to emit from the source Observable before completing.
     * @returns {function} A function that, when called with an Observable, returns a new Observable that emits
     * up to `count` values from the source Observable and then completes.
     *
     * @example
     * const observable = Rx.Observable.interval(1000);
     * const limitedObservable = take.call(this, 5)(observable);
     * limitedObservable.subscribe(value => console.log(value));
     * // Output: 0, 1, 2, 3, 4
     *
     * @throws {Error} If `count` is not a positive integer.
     */
    function take(count) {
        return count <= 0
            ?
                function () { return EMPTY; }
            : operate(function (source, subscriber) {
                var seen = 0;
                source.subscribe(createOperatorSubscriber(subscriber, function (value) {
                    if (++seen <= count) {
                        subscriber.next(value);
                        if (count <= seen) {
                            subscriber.complete();
                        }
                    }
                }));
            });
    }

    /**
     * Ignores elements emitted by an observable.
     *
     * This operator does not emit any values from the source observable to the subscriber. It effectively "drops" all emitted values, making it useful for scenarios where you want to prevent side effects or further processing of emitted items without unsubscribing from the original source.
     *
     * @return {Observable} An empty observable that never emits any values.
     */
    function ignoreElements() {
        return operate(function (source, subscriber) {
            source.subscribe(createOperatorSubscriber(subscriber, noop));
        });
    }

    /**
     * Maps a given value to the result of a function call.
     *
     * @param {any} value - The value to be mapped.
     * @returns {function} A function that returns the input value when called.
     *
     * @example
     * const getValue = mapTo('Hello, World!');
     * console.log(getValue()); // Output: 'Hello, World!'
     */
    function mapTo(value) {
        return map(function () { return value; });
    }

    /**
     * Delays the emission of items from the source observable based on a selector function that returns an Observable for each emitted item.
     *
     * @param {Function} delayDurationSelector - A function that receives an item and its index, and returns an Observable whose duration to wait before emitting the current item.
     * @param {Observable} [subscriptionDelay] - An optional Observable that, when it emits any value, causes subscription to start immediately but without sending values until the original source has emitted a value.
     * @returns {Observable<T>} A new observable that delays items based on the specified selector function and optional subscription delay.
     *
     * Example:
     * ```javascript
     * const source$ = of(1, 2, 3);
     * const delayedSource$ = source$.pipe(delayWhen(value => timer(value * 1000)));
     * delayedSource$.subscribe(console.log); // Output: 1 after 1 second, 2 after 2 seconds, 3 after 3 seconds
     * ```
     */
    function delayWhen(delayDurationSelector, subscriptionDelay) {
        if (subscriptionDelay) {
            return function (source) {
                return concat(subscriptionDelay.pipe(take(1), ignoreElements()), source.pipe(delayWhen(delayDurationSelector)));
            };
        }
        return mergeMap(function (value, index) { return innerFrom(delayDurationSelector(value, index)).pipe(take(1), mapTo(value)); });
    }

    /**
     * Schedules an Observable to emit after some or all of the time.
     *
     * <p>This is useful for simulating a delay in your observable sequences.
     * Example usage includes mocking network requests, waiting before executing certain logic,
     * or simply adding delays in your observables for testing purposes.</p>
     *
     * @param {number} due - The time to delay the emission of items from the source Observable.
     * @param {SchedulerLike} [scheduler=asyncScheduler] - Scheduler to run delay timers on.
     * Default scheduler is asyncScheduler.
     * @returns {Observable<T>} An Observable that emits the same values as the source Observable,
     * but delayed by the specified time period.
     */
    function delay(due, scheduler) {
        if (scheduler === void 0) { scheduler = asyncScheduler; }
        var duration = timer(due, scheduler);
        return delayWhen(function () { return duration; });
    }

    /**
     * Transforms an Observable of Notifications into an Observable of values by emitting only those notifications that are of type `next`.
     *
     * @returns {Observable} An Observable that emits only the values from notifications of type `next` emitted by the source Observable.
     */
    function dematerialize() {
        return operate(function (source, subscriber) {
            source.subscribe(createOperatorSubscriber(subscriber, function (notification) { return observeNotification(notification, subscriber); }));
        });
    }

    /**
     * Filters an Observable to only allow distinct values based on a specified key selector.
     *
     * @param {function(value: T): any} [keySelector] - A function that extracts the key to check for uniqueness. If not provided, the value itself is used.
     * @param {Observable<any>} [flushes] - An Observable that triggers the reset of the distinct keys set.
     * @returns {Observable<T>} - An Observable that emits only distinct values based on the specified key selector.
     *
     * Example:
     * ```
     * const source = from([1, 2, 2, 3, 4, 4]);
     * const distinctValues$ = source.pipe(distinct());
     * distinctValues$.subscribe(console.log);
     * // Output: 1, 2, 3, 4
     * ```
     */
    function distinct(keySelector, flushes) {
        return operate(function (source, subscriber) {
            var distinctKeys = new Set();
            source.subscribe(createOperatorSubscriber(subscriber, function (value) {
                var key = keySelector ? keySelector(value) : value;
                if (!distinctKeys.has(key)) {
                    distinctKeys.add(key);
                    subscriber.next(value);
                }
            }));
            flushes && innerFrom(flushes).subscribe(createOperatorSubscriber(subscriber, function () { return distinctKeys.clear(); }, noop));
        });
    }

    function distinctUntilChanged(comparator, keySelector) {
        if (keySelector === void 0) { keySelector = identity; }
        comparator = comparator !== null && comparator !== void 0 ? comparator : defaultCompare;
        return operate(function (source, subscriber) {
            var previousKey;
            var first = true;
            source.subscribe(createOperatorSubscriber(subscriber, function (value) {
                var currentKey = keySelector(value);
                if (first || !comparator(previousKey, currentKey)) {
                    first = false;
                    previousKey = currentKey;
                    subscriber.next(value);
                }
            }));
        });
    }
    /**
     * Compares two values using strict equality (===).
     *
     * @param {any} a - The first value to compare.
     * @param {any} b - The second value to compare.
     * @returns {boolean} - Returns `true` if the values are strictly equal, otherwise `false`.
     */
    function defaultCompare(a, b) {
        return a === b;
    }

    /**
     * Creates an operator that returns only distinct values based on a key from the source observable.
     * If the value at the specified key has changed between emissions, it will pass the new value through.
     * Otherwise, it will ignore subsequent emissions with the same key value.
     *
     * @param {string} key - The property key to use for comparison.
     * @param {Function} [compare] - An optional function to compare two values. If not provided,
     *                               strict equality (===) is used.
     * @returns {Observable} - A new observable that emits distinct values based on the specified key.
     *
     * @example
     * // Example of using distinctUntilKeyChanged with a simple comparison
     * const source = from([{ id: 1, name: 'Alice' }, { id: 2, name: 'Bob' }, { id: 2, name: 'Charlie' }]);
     * const result = source.pipe(distinctUntilKeyChanged('id'));
     * // result will emit: [{ id: 1, name: 'Alice' }, { id: 2, name: 'Bob' }]
     *
     * @example
     * // Example of using distinctUntilKeyChanged with a custom comparison function
     * const source = from([{ id: 1, value: 'A' }, { id: 2, value: 'B' }, { id: 2, value: 'a' }]);
     * const result = source.pipe(distinctUntilKeyChanged('value', (x, y) => x.toLowerCase() === y.toLowerCase()));
     * // result will emit: [{ id: 1, value: 'A' }, { id: 2, value: 'B' }]
     */
    function distinctUntilKeyChanged(key, compare) {
        return distinctUntilChanged(function (x, y) { return (compare ? compare(x[key], y[key]) : x[key] === y[key]); });
    }

    /**
     * Throws an error if the source observable does not emit any values before completing.
     *
     * @param {Function} [errorFactory=defaultErrorFactory] - A function that returns the error to be thrown. Defaults to a default error factory.
     * @returns {Observable<T>} - An Observable that throws an error if it completes without emitting any values.
     */
    function throwIfEmpty(errorFactory) {
        if (errorFactory === void 0) { errorFactory = defaultErrorFactory; }
        return operate(function (source, subscriber) {
            var hasValue = false;
            source.subscribe(createOperatorSubscriber(subscriber, function (value) {
                hasValue = true;
                subscriber.next(value);
            }, function () { return (hasValue ? subscriber.complete() : subscriber.error(errorFactory())); }));
        });
    }
    /**
     * Creates an instance of the EmptyError class.
     *
     * @returns {EmptyError} An instance of the EmptyError class.
     *
     * Example usage:
     * const error = defaultErrorFactory();
     * console.log(error); // Output will depend on the implementation of EmptyError
     */
    function defaultErrorFactory() {
        return new EmptyError();
    }

    /**
     * Retrieves an element at a specified index from an observable sequence. If no such element is found, returns a default value.
     *
     * @param {number} index - The zero-based index of the element to retrieve.
     * @param {*} [defaultValue] - The default value to return if the element does not exist.
     * @returns {Observable<T>} An observable sequence containing the element at the specified index or a default value if not found.
     *
     * @throws {ArgumentOutOfRangeError} If the provided index is less than 0.
     *
     * @example
     * // Assuming 'source$' is an observable sequence
     * const result$ = source$.pipe(elementAt(2, 'default'));
     */
    function elementAt(index, defaultValue) {
        if (index < 0) {
            throw new ArgumentOutOfRangeError();
        }
        var hasDefaultValue = arguments.length >= 2;
        return function (source) {
            return source.pipe(filter(function (v, i) { return i === index; }), take(1), hasDefaultValue ? defaultIfEmpty(defaultValue) : throwIfEmpty(function () { return new ArgumentOutOfRangeError(); }));
        };
    }

    /**
     * Creates a function that concatenates an array of values to the source observable.
     *
     * @function endWith
     * @param {...*} values - The values to concatenate to the source observable.
     * @returns {Function} A function that takes an observable (source) and returns a new observable that emits all items from the source followed by the given values.
     */
    function endWith() {
        var values = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            values[_i] = arguments[_i];
        }
        return function (source) { return concat(source, of.apply(void 0, __spreadArray([], __read(values)))); };
    }

    function every(predicate, thisArg) {
        return operate(function (source, subscriber) {
            var index = 0;
            source.subscribe(createOperatorSubscriber(subscriber, function (value) {
                if (!predicate.call(thisArg, value, index++, source)) {
                    subscriber.next(false);
                    subscriber.complete();
                }
            }, function () {
                subscriber.next(true);
                subscriber.complete();
            }));
        });
    }

    /**
     * Projects each source value to an Observable which is merged into the output Observable only if the previous projected Observable has completed.
     *
     * @param {function(value: T, index: number): ObservableInput<U>} project - A function that returns an Observable for each item emitted by the source Observable.
     * @param {function(outerValue: T, innerValue: U, outerIndex: number, innerIndex: number): any} [resultSelector] - An optional function to map the values from the outer and inner observables into a new value.
     * @returns {Observable<U | R>} - The Observable that merges the results of calling the project function for each item emitted by the source Observable.
     *
     * @throws {TypeError} If 'project' is not a function.
     *
     * @example
     * // Example 1: Basic usage without resultSelector
     * const source = from([1, 2, 3]);
     * const project = (x) => of(x * x);
     * exhaustMap(project).subscribe(console.log); // Logs: 1, 4, 9
     *
     * @example
     * // Example 2: Using resultSelector to merge values from outer and inner observables
     * const source = from([1, 2, 3]);
     * const project = (x) => of(x * x);
     * const resultSelector = (outerValue, innerValue) => outerValue + ' -> ' + innerValue;
     * exhaustMap(project, resultSelector).subscribe(console.log); // Logs: "1 -> 1", "2 -> 4", "3 -> 9"
     */
    function exhaustMap(project, resultSelector) {
        if (resultSelector) {
            return function (source) {
                return source.pipe(exhaustMap(function (a, i) { return innerFrom(project(a, i)).pipe(map(function (b, ii) { return resultSelector(a, b, i, ii); })); }));
            };
        }
        return operate(function (source, subscriber) {
            var index = 0;
            var innerSub = null;
            var isComplete = false;
            source.subscribe(createOperatorSubscriber(subscriber, function (outerValue) {
                if (!innerSub) {
                    innerSub = createOperatorSubscriber(subscriber, undefined, function () {
                        innerSub = null;
                        isComplete && subscriber.complete();
                    });
                    innerFrom(project(outerValue, index++)).subscribe(innerSub);
                }
            }, function () {
                isComplete = true;
                !innerSub && subscriber.complete();
            }));
        });
    }

    /**
     * Exhausts all emissions from an Observable using the identity function.
     *
     * @returns {Observable} An Observable that emits all values from the source Observable.
     */
    function exhaustAll() {
        return exhaustMap(identity);
    }

    var exhaust = exhaustAll;

    /**
     * Expands each item emitted by an Observable using a selector function.
     *
     * This operator applies a given project function to each value emitted by the source Observable,
     * and then merges the results into a single observable sequence that emits these projected values.
     * If concurrent is specified, the number of concurrency levels allowed for executing the project function
     * concurrently. Defaults to Infinity if not provided.
     *
     * @param {function(value: T): Observable} project - A function that accepts an item emitted by the source Observable and returns an Observable.
     * @param {number} [concurrent=Infinity] - Maximum number of input Observables being subscribed to concurrently.
     * @param {Scheduler} [scheduler] - Optional scheduler to schedule the subscription process.
     *
     * @returns {Observable} An Observable that emits items projected from the source Observable using the project function.
     */
    function expand(project, concurrent, scheduler) {
        if (concurrent === void 0) { concurrent = Infinity; }
        concurrent = (concurrent || 0) < 1 ? Infinity : concurrent;
        return operate(function (source, subscriber) {
            return mergeInternals(source, subscriber, project, concurrent, undefined, true, scheduler);
        });
    }

    /**
     * Completes the execution of an observable sequence by calling a callback function when all elements have been processed.
     *
     * @param {function} callback - The callback function to be called after the observable completes.
     * @return {Observable} - An Observable that will complete after the callback is executed.
     */
    function finalize(callback) {
        return operate(function (source, subscriber) {
            try {
                source.subscribe(subscriber);
            }
            finally {
                subscriber.add(callback);
            }
        });
    }

    /**
     * Searches through an iterable using a predicate function to find an element that matches the specified condition.
     *
     * @param {Function} predicate - A function that is called for each element in the iterable. It should return `true` if the current element satisfies the condition, otherwise `false`.
     * @param {*} [thisArg] - The value of `this` to be used when executing the predicate function.
     * @returns {*} The first element in the iterable that satisfies the condition specified by the predicate. Returns `undefined` if no such element is found.
     *
     * @throws {TypeError} If `predicate` is not a function.
     *
     * @example
     * const array = [1, 2, 3, 4];
     * const result = find(element => element > 2);
     * console.log(result); // Output: 3
     */
    function find(predicate, thisArg) {
        return operate(createFind(predicate, thisArg, 'value'));
    }
    /**
     * Creates an operator function that finds the first element in a stream that satisfies a predicate.
     *
     * @param {function} predicate - The predicate function to test each element.
     * @param {*} [thisArg] - The value of `this` for the predicate function.
     * @param {'value' | 'index'} [emit='value'] - Determines whether to emit the index or the value when a match is found.
     * @returns {function} A function that takes a source observable and returns an operator subscriber.
     *
     * @example
     * const stream$ = of(1, 2, 3, 4);
     * const findOperator = createFind(x => x > 2, undefined, 'index');
     * const result$ = stream$.pipe(findOperator);
     * // result$ will emit [3] and complete
     */
    function createFind(predicate, thisArg, emit) {
        var findIndex = emit === 'index';
        return function (source, subscriber) {
            var index = 0;
            source.subscribe(createOperatorSubscriber(subscriber, function (value) {
                var i = index++;
                if (predicate.call(thisArg, value, i, source)) {
                    subscriber.next(findIndex ? i : value);
                    subscriber.complete();
                }
            }, function () {
                subscriber.next(findIndex ? -1 : undefined);
                subscriber.complete();
            }));
        };
    }

    /**
     * Searches for the index of an element in an array that satisfies a provided testing function.
     *
     * @param {Function} predicate - A function to test each element of the array. It should return true if the current element is found, and false otherwise.
     * @param {*} [thisArg] - Optional value to use as `this` when executing the `predicate`.
     * @returns {number} The index of the first element that satisfies the provided testing function, or -1 if no elements satisfy the testing function.
     *
     * @example
     * const array = [5, 12, 8, 130, 44];
     * const index = findIndex(element => element > 10);
     * console.log(index); // Output: 1
     */
    function findIndex(predicate, thisArg) {
        return operate(createFind(predicate, thisArg, 'index'));
    }

    /**
     * Returns an Observable that emits the first item emitted by the source Observable that satisfies a specified condition.
     *
     * @param {function|undefined} predicate - A function that defines the condition for emitting items. If not provided, the first item is emitted.
     * @param {*} defaultValue - The default value to emit if no item satisfies the condition.
     * @returns {Observable} An Observable that emits either the first item satisfying the condition or a default value.
     *
     * @example
     * const source$ = from([1, 2, 3, 4]);
     * const result$ = source$.pipe(first(x => x > 2));
     * result$.subscribe(console.log); // Output: 3
     */
    function first(predicate, defaultValue) {
        var hasDefaultValue = arguments.length >= 2;
        return function (source) {
            return source.pipe(predicate ? filter(function (v, i) { return predicate(v, i, source); }) : identity, take(1), hasDefaultValue ? defaultIfEmpty(defaultValue) : throwIfEmpty(function () { return new EmptyError(); }));
        };
    }

    /**
     * Groups the source observable's emissions by a key selector function and optionally
     * handles each group with an optional duration or connector.
     *
     * @param {function} keySelector - A function that extracts a key from each emitted value.
     * @param {Object|function} [elementOrOptions] - An object containing options for grouping, including 'duration', 'element', and 'connector'.
     * @param {Observable} [duration] - An observable representing the duration for which a group remains open before completing.
     * @param {function} [connector] - A function that returns an observable to use as the subject for each group.
     * @returns {Observable} An observable that emits GroupedObservables, each containing emissions that share the same key.
     *
     * @example
     * // Example usage of groupBy with a duration
     * source.pipe(groupBy(value => value.key, null, timer(500)))
     * .subscribe(group => {
     *   console.log('Group Key:', group.key);
     *   group.subscribe(val => console.log('Value:', val));
     * });
     */
    function groupBy(keySelector, elementOrOptions, duration, connector) {
        return operate(function (source, subscriber) {
            var element;
            if (!elementOrOptions || typeof elementOrOptions === 'function') {
                element = elementOrOptions;
            }
            else {
                (duration = elementOrOptions.duration, element = elementOrOptions.element, connector = elementOrOptions.connector);
            }
            var groups = new Map();
            var notify = function (cb) {
                groups.forEach(cb);
                cb(subscriber);
            };
            var handleError = function (err) { return notify(function (consumer) { return consumer.error(err); }); };
            var activeGroups = 0;
            var teardownAttempted = false;
            var groupBySourceSubscriber = new OperatorSubscriber(subscriber, function (value) {
                try {
                    var key_1 = keySelector(value);
                    var group_1 = groups.get(key_1);
                    if (!group_1) {
                        groups.set(key_1, (group_1 = connector ? connector() : new Subject()));
                        var grouped = createGroupedObservable(key_1, group_1);
                        subscriber.next(grouped);
                        if (duration) {
                            var durationSubscriber_1 = createOperatorSubscriber(group_1, function () {
                                group_1.complete();
                                durationSubscriber_1 === null || durationSubscriber_1 === void 0 ? void 0 : durationSubscriber_1.unsubscribe();
                            }, undefined, undefined, function () { return groups.delete(key_1); });
                            groupBySourceSubscriber.add(innerFrom(duration(grouped)).subscribe(durationSubscriber_1));
                        }
                    }
                    group_1.next(element ? element(value) : value);
                }
                catch (err) {
                    handleError(err);
                }
            }, function () { return notify(function (consumer) { return consumer.complete(); }); }, handleError, function () { return groups.clear(); }, function () {
                teardownAttempted = true;
                return activeGroups === 0;
            });
            source.subscribe(groupBySourceSubscriber);
            /**
             * Creates an observable that groups items based on a specified key.
             *
             * @param {string} key - The key to group the items by.
             * @param {Object} groupSubject - The subject used for grouping.
             * @returns {Observable} - An observable representing the grouped data.
             */
            function createGroupedObservable(key, groupSubject) {
                var result = new Observable(function (groupSubscriber) {
                    activeGroups++;
                    var innerSub = groupSubject.subscribe(groupSubscriber);
                    return function () {
                        innerSub.unsubscribe();
                        --activeGroups === 0 && teardownAttempted && groupBySourceSubscriber.unsubscribe();
                    };
                });
                result.key = key;
                return result;
            }
        });
    }

    function isEmpty() {
        return operate(function (source, subscriber) {
            source.subscribe(createOperatorSubscriber(subscriber, function () {
                subscriber.next(false);
                subscriber.complete();
            }, function () {
                subscriber.next(true);
                subscriber.complete();
            }));
        });
    }

    /**
     * Creates an operator function that buffers values from the source observable until it completes,
     * then emits the last 'count' values.
     *
     * @param {number} count - The number of values to buffer and emit at the end of the sequence.
     * @returns {function} An operator function that can be used with observables.
     * @throws {Error} Throws an error if 'count' is less than or equal to 0.
     */
    function takeLast(count) {
        return count <= 0
            ? function () { return EMPTY; }
            : operate(function (source, subscriber) {
                var buffer = [];
                source.subscribe(createOperatorSubscriber(subscriber, function (value) {
                    buffer.push(value);
                    count < buffer.length && buffer.shift();
                }, function () {
                    var e_1, _a;
                    try {
                        for (var buffer_1 = __values(buffer), buffer_1_1 = buffer_1.next(); !buffer_1_1.done; buffer_1_1 = buffer_1.next()) {
                            var value = buffer_1_1.value;
                            subscriber.next(value);
                        }
                    }
                    catch (e_1_1) { e_1 = { error: e_1_1 }; }
                    finally {
                        try {
                            if (buffer_1_1 && !buffer_1_1.done && (_a = buffer_1.return)) _a.call(buffer_1);
                        }
                        finally { if (e_1) throw e_1.error; }
                    }
                    subscriber.complete();
                }, undefined, function () {
                    buffer = null;
                }));
            });
    }

    /**
     * Returns an Observable that emits only the last item emitted by the source Observable.
     *
     * @param {function|undefined} [predicate] - A function to test each value before emitting it. If not provided, the last value is emitted.
     * @param {*} [defaultValue] - The default value to emit if no values satisfy the predicate.
     * @returns {Observable} An Observable that emits only the last item that meets the condition or a default value if none do.
     *
     * @example
     * const observable = of(1, 2, 3, 4);
     * const result = observable.pipe(last$1(x => x % 2 === 0));
     * // Output: 4
     *
     * @example
     * const observable = empty();
     * const result = observable.pipe(last$1(undefined, 'No values'));
     * // Output: No values
     */
    function last$1(predicate, defaultValue) {
        var hasDefaultValue = arguments.length >= 2;
        return function (source) {
            return source.pipe(predicate ? filter(function (v, i) { return predicate(v, i, source); }) : identity, takeLast(1), hasDefaultValue ? defaultIfEmpty(defaultValue) : throwIfEmpty(function () { return new EmptyError(); }));
        };
    }

    /**
     * Creates an Observable that emits notifications from the source Observable whenever a notification is emitted.
     *
     * @function
     * @returns {Observable} An Observable that emits notifications from the source Observable.
     */
    function materialize() {
        return operate(function (source, subscriber) {
            source.subscribe(createOperatorSubscriber(subscriber, function (value) {
                subscriber.next(Notification.createNext(value));
            }, function () {
                subscriber.next(Notification.createComplete());
                subscriber.complete();
            }, function (err) {
                subscriber.next(Notification.createError(err));
                subscriber.complete();
            }));
        });
    }

    /**
     * Returns the maximum element of an array or the result of applying a comparer function to elements.
     *
     * @param {Function} [comparer] - A function that takes two arguments and returns a negative, zero, or positive number depending on their values. If not provided, the default is to compare elements directly.
     * @returns {*} The maximum element found in the array or the result of applying the comparer function.
     *
     * @example
     * max([1, 2, 3]); // Returns 3
     * max(['apple', 'banana', 'cherry'], (a, b) => a.length - b.length); // Returns 'banana'
     */
    function max(comparer) {
        return reduce(isFunction(comparer) ? function (x, y) { return (comparer(x, y) > 0 ? x : y); } : function (x, y) { return (x > y ? x : y); });
    }

    var flatMap = mergeMap;

    /**
     * Projects each source value to an Observable which is merged in the output Observable.
     *
     * @template T The type of the first Observable's elements.
     * @template R The type of the result elements.
     * @param {ObservableInput<R>|((value: T, index: number) => ObservableInput<R>)} innerObservable An observable to which each source element is mapped before being merged into the output Observable.
     * @param {(outerValue: T, innerValue: R, outerIndex: number, innerIndex: number) => R} [resultSelector] A function that produces an result from values emitted by the source and inner observables.
     * @param {number} [concurrent=Infinity] Maximum number of input Observables being subscribed to concurrently.
     * @returns {Observable<R>} An Observable that emits results after combining the source observable with the projected observable.
     *
     * @example
     * import { of } from 'rxjs';
     * import { mergeMapTo } from 'rxjs/operators';
     *
     * const source$ = of(1, 2, 3);
     * const innerObservable$ = of('a', 'b');
     *
     * const result$ = source$.pipe(
     *   mergeMapTo(innerObservable$, (value, index) => `${value}-${index}`)
     * );
     *
     * result$.subscribe(console.log); // Outputs: "1-0", "2-1", "3-2"
     */
    function mergeMapTo(innerObservable, resultSelector, concurrent) {
        if (concurrent === void 0) { concurrent = Infinity; }
        if (isFunction(resultSelector)) {
            return mergeMap(function () { return innerObservable; }, resultSelector, concurrent);
        }
        if (typeof resultSelector === 'number') {
            concurrent = resultSelector;
        }
        return mergeMap(function () { return innerObservable; }, concurrent);
    }

    /**
     * Merges each value from the source observable with an accumulator function to produce a new value for each emission.
     *
     * @param {function(state, value, index)} accumulator - The accumulator function used to combine the seed and current values.
     * @param {*} [seed] - The initial state passed to the accumulator. Defaults to `null`.
     * @param {number} [concurrent=Infinity] - The maximum number of concurrent subscriptions to allow. Defaults to `Infinity`.
     * @returns {Observable<T>} An Observable that emits the accumulated value for each emission.
     *
     * @example
     * // Merging with an accumulator function and initial seed
     * const source$ = of(1, 2, 3);
     * const result$ = mergeScan((acc, value) => acc + value, 0);
     * result$.subscribe(console.log); // Logs: 1, 3, 6
     */
    function mergeScan(accumulator, seed, concurrent) {
        if (concurrent === void 0) { concurrent = Infinity; }
        return operate(function (source, subscriber) {
            var state = seed;
            return mergeInternals(source, subscriber, function (value, index) { return accumulator(state, value, index); }, concurrent, function (value) {
                state = value;
            }, false, undefined, function () { return (state = null); });
        });
    }

    function merge$1() {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
        }
        var scheduler = popScheduler(args);
        var concurrent = popNumber(args, Infinity);
        return operate(function (source, subscriber) {
            mergeAll(concurrent)(from(__spreadArray([source], __read(args)), scheduler)).subscribe(subscriber);
        });
    }

    /**
     * Merges multiple source objects into a single object.
     *
     * @param {...Object} otherSources - The source objects to be merged with the target object.
     * @return {Object} A new object that is the result of merging all provided source objects.
     */
    function mergeWith() {
        var otherSources = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            otherSources[_i] = arguments[_i];
        }
        return merge$1.apply(void 0, __spreadArray([], __read(otherSources)));
    }

    /**
     * Returns the minimum value from an iterable based on a provided comparer function.
     *
     * @param {Function} comparer - A function that takes two arguments and returns a negative, zero,
     * or positive number depending on whether the first argument is less than, equal to, or greater
     * than the second argument. If no comparer is provided, the default comparison is used.
     * @returns {*} The minimum value found in the iterable.
     *
     * @example
     * const numbers = [5, 3, 9, 1];
     * const minNumber = min(numbers); // Returns 1
     *
     * @example
     * const strings = ['apple', 'banana', 'cherry'];
     * const minLengthString = min(strings, (a, b) => a.length - b.length); // Returns 'apple'
     */
    function min(comparer) {
        return reduce(isFunction(comparer) ? function (x, y) { return (comparer(x, y) < 0 ? x : y); } : function (x, y) { return (x < y ? x : y); });
    }

    /**
     * Multicasts the source Observable to multiple subscribers within an optional selector function.
     * This allows you to share the emissions of one Observable among many Observers.
     *
     * @param {Observable|function} subjectOrSubjectFactory - The Observable to multicast or a factory function that returns it.
     * @param {function} [selector] - Optional selector function for creating ConnectableObservables. Receives the created ConnectableObservable as an argument and should return a new ConnectableObservable.
     * @returns {ConnectableObservable|function} If selector is provided, returns a function that takes an Observable and returns a new ConnectableObservable. Otherwise, returns a new ConnectableObservable.
     *
     * @example
     * // Example usage without selector
     * const source = of(1, 2, 3);
     * const connectable = multicast(source);
     * connectable.subscribe(x => console.log('Subscriber 1:', x));
     * connectable.subscribe(x => console.log('Subscriber 2:', x));
     *
     * @example
     * // Example usage with selector
     * const source = of(1, 2, 3);
     * const connectableFactory = multicast(source, subject => new BehaviorSubject(subject.getValue()));
     * connectableFactory.subscribe(x => console.log('Subscriber 1:', x));
     * connectableFactory.subscribe(x => console.log('Subscriber 2:', x));
     */
    function multicast(subjectOrSubjectFactory, selector) {
        var subjectFactory = isFunction(subjectOrSubjectFactory) ? subjectOrSubjectFactory : function () { return subjectOrSubjectFactory; };
        if (isFunction(selector)) {
            return connect(selector, {
                connector: subjectFactory,
            });
        }
        return function (source) { return new ConnectableObservable(source, subjectFactory); };
    }

    /**
     * Creates a function that returns an Observable that emits all items emitted by the source Observable,
     * then continues with another observable sequence if an error occurs.
     *
     * @function
     * @param {...*} sources - The observables to be merged after the source observable completes, or another observable sequence.
     * @returns {Function} - A function that takes an observable and returns a new observable that behaves as described.
     */
    function onErrorResumeNextWith() {
        var sources = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            sources[_i] = arguments[_i];
        }
        var nextSources = argsOrArgArray(sources);
        return function (source) { return onErrorResumeNext.apply(void 0, __spreadArray([source], __read(nextSources))); };
    }
    var onErrorResumeNext$1 = onErrorResumeNextWith;

    /**
     * Creates an operator that emits pairs of consecutive values from the source observable.
     *
     * @returns {Observable<Array<T>>>} An observable that emits arrays containing pairs of consecutive values.
     * @example
     * // Example usage of pairwise
     * const source$ = of(1, 2, 3, 4);
     * source$.pipe(pairwise()).subscribe(console.log); // Output: [1, 2], [2, 3], [3, 4]
     */
    function pairwise() {
        return operate(function (source, subscriber) {
            var prev;
            var hasPrev = false;
            source.subscribe(createOperatorSubscriber(subscriber, function (value) {
                var p = prev;
                prev = value;
                hasPrev && subscriber.next([p, value]);
                hasPrev = true;
            }));
        });
    }

    /**
     * Plucks properties from an array of objects based on the provided property names.
     *
     * @param {...string} properties - The names of the properties to pluck.
     * @returns {Function} A function that takes an array of objects and returns a new array with the plucked values.
     * @throws {Error} Throws an error if the list of properties is empty.
     * @example
     * const data = [{a: 1, b: 2}, {a: 3, b: 4}];
     * const result = pluck('a', 'b')(data); // [{a: 1, b: 2}, {a: 3, b: 4}]
     */
    function pluck() {
        var properties = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            properties[_i] = arguments[_i];
        }
        var length = properties.length;
        if (length === 0) {
            throw new Error('list of properties cannot be empty.');
        }
        return map(function (x) {
            var currentProp = x;
            for (var i = 0; i < length; i++) {
                var p = currentProp === null || currentProp === void 0 ? void 0 : currentProp[properties[i]];
                if (typeof p !== 'undefined') {
                    currentProp = p;
                }
                else {
                    return undefined;
                }
            }
            return currentProp;
        });
    }

    /**
     * Publishes a source observable to multiple subscribers by applying an optional selector function.
     *
     * @param {function|undefined} [selector] - A function that modifies the source observable's values before they are published.
     * @returns {function(source: Observable): Observable} - A function that takes an observable and returns a new observable that is multicast using the provided selector or a default multicast subject if no selector is given.
     *
     * Example usage:
     * const source$ = of(1, 2, 3);
     * const published$ = publish()(source$);
     * published$.subscribe(console.log); // Logs: 1, 2, 3
     */
    function publish(selector) {
        return selector ? function (source) { return connect(selector)(source); } : function (source) { return multicast(new Subject())(source); };
    }

    /**
     * Creates an observable that starts emitting the initial value immediately
     * upon subscription and then mirrors the source observable's emissions.
     *
     * @param {any} initialValue - The initial value to emit when the observable is subscribed.
     * @returns {function} A function that takes a source observable and returns a new ConnectableObservable.
     *
     * @example
     * const subject = publishBehavior(0);
     * const subscription1 = subject.subscribe(console.log); // Logs: 0
     * const subscription2 = subject.subscribe(console.log); // Also logs: 0 immediately
     * source$.subscribe(subject.connect()); // Connects the source to the subject and emits subsequent values
     */
    function publishBehavior(initialValue) {
        return function (source) {
            var subject = new BehaviorSubject(initialValue);
            return new ConnectableObservable(source, function () { return subject; });
        };
    }

    /**
     * Creates an operator function that emits all values from the source observable but only once when the observable completes.
     *
     * @return {function(source: Observable): ConnectableObservable} A function that takes a source observable and returns a connectable observable that emits all values from the source observable but only once when it completes.
     */
    function publishLast() {
        return function (source) {
            var subject = new AsyncSubject();
            return new ConnectableObservable(source, function () { return subject; });
        };
    }

    /**
     * Creates an operator that buffers incoming observable values until it receives a notification from another observable (`notifier`), at which point it emits the buffered items and begins buffering new values.
     *
     * @param {number} bufferSize - The maximum number of emissions to buffer before releasing them according to the scheduling of `windowTime`.
     * @param {number} windowTime - The window of time allowed between `next()` calls from the source observable to determine if it should emit its buffered items.
     * @param {(function(): Observable<any>)|SchedulerLike} [selectorOrScheduler] - An optional function or scheduler that determines when to emit buffered items and how to buffer new values. If a function, it returns an Observable that will cause `publishReplay` to emit buffered items and start buffering again when the returned Observable emits. If a SchedulerLike, it schedules the emission of buffered items according to the given scheduler.
     * @param {function(): number} [timestampProvider] - A function that provides the current timestamp. This is used to determine the time window for buffer eviction based on `windowTime`.
     *
     * @returns {Observable<T>} An Observable that emits buffered values when the `notifier` Observable emits, and then continues buffering new values.
     */
    function publishReplay(bufferSize, windowTime, selectorOrScheduler, timestampProvider) {
        if (selectorOrScheduler && !isFunction(selectorOrScheduler)) {
            timestampProvider = selectorOrScheduler;
        }
        var selector = isFunction(selectorOrScheduler) ? selectorOrScheduler : undefined;
        return function (source) { return multicast(new ReplaySubject(bufferSize, windowTime, timestampProvider), selector)(source); };
    }

    function raceWith() {
        var otherSources = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            otherSources[_i] = arguments[_i];
        }
        return !otherSources.length
            ? identity
            : operate(function (source, subscriber) {
                raceInit(__spreadArray([source], __read(otherSources)))(subscriber);
            });
    }

    /**
     * Creates an Observable that repeats the given source Observable a specified number of times.
     * If the count is not provided or is set to Infinity, the Observable will emit values from the source indefinitely.
     *
     * @param {number|RepeatConfig} [countOrConfig=Infinity] - The number of times to repeat the source. If an object is provided,
     * it should contain a `count` property with the number of repetitions and an optional `delay` property specifying the delay between repetitions.
     * @returns {Observable<T>} An Observable that emits values from the source repeatedly for the specified count or indefinitely if not specified.
     *
     * @example
     * // Repeats the value 'hello' 3 times
     * of('hello').pipe(repeat(3)).subscribe(console.log);
     * // Output: hello, hello, hello
     *
     * @example
     * // Repeats values from an interval every 1 second for 5 times
     * range(1, 6).pipe(
     *   repeat({ count: 5, delay: 1000 })
     * ).subscribe(console.log);
     * // Output: 1 to 6 repeated 5 times with a delay of 1 second between each repetition
     */
    function repeat(countOrConfig) {
        var _a;
        var count = Infinity;
        var delay;
        if (countOrConfig != null) {
            if (typeof countOrConfig === 'object') {
                (_a = countOrConfig.count, count = _a === void 0 ? Infinity : _a, delay = countOrConfig.delay);
            }
            else {
                count = countOrConfig;
            }
        }
        return count <= 0
            ? function () { return EMPTY; }
            : operate(function (source, subscriber) {
                var soFar = 0;
                var sourceSub;
                var resubscribe = function () {
                    sourceSub === null || sourceSub === void 0 ? void 0 : sourceSub.unsubscribe();
                    sourceSub = null;
                    if (delay != null) {
                        var notifier = typeof delay === 'number' ? timer(delay) : innerFrom(delay(soFar));
                        var notifierSubscriber_1 = createOperatorSubscriber(subscriber, function () {
                            notifierSubscriber_1.unsubscribe();
                            subscribeToSource();
                        });
                        notifier.subscribe(notifierSubscriber_1);
                    }
                    else {
                        subscribeToSource();
                    }
                };
                var subscribeToSource = function () {
                    var syncUnsub = false;
                    sourceSub = source.subscribe(createOperatorSubscriber(subscriber, undefined, function () {
                        if (++soFar < count) {
                            if (sourceSub) {
                                resubscribe();
                            }
                            else {
                                syncUnsub = true;
                            }
                        }
                        else {
                            subscriber.complete();
                        }
                    }));
                    if (syncUnsub) {
                        resubscribe();
                    }
                };
                subscribeToSource();
            });
    }

    function repeatWhen(notifier) {
        return operate(function (source, subscriber) {
            var innerSub;
            var syncResub = false;
            var completions$;
            var isNotifierComplete = false;
            var isMainComplete = false;
            var checkComplete = function () { return isMainComplete && isNotifierComplete && (subscriber.complete(), true); };
            var getCompletionSubject = function () {
                if (!completions$) {
                    completions$ = new Subject();
                    innerFrom(notifier(completions$)).subscribe(createOperatorSubscriber(subscriber, function () {
                        if (innerSub) {
                            subscribeForRepeatWhen();
                        }
                        else {
                            syncResub = true;
                        }
                    }, function () {
                        isNotifierComplete = true;
                        checkComplete();
                    }));
                }
                return completions$;
            };
            var subscribeForRepeatWhen = function () {
                isMainComplete = false;
                innerSub = source.subscribe(createOperatorSubscriber(subscriber, undefined, function () {
                    isMainComplete = true;
                    !checkComplete() && getCompletionSubject().next();
                }));
                if (syncResub) {
                    innerSub.unsubscribe();
                    innerSub = null;
                    syncResub = false;
                    subscribeForRepeatWhen();
                }
            };
            subscribeForRepeatWhen();
        });
    }

    /**
     * Creates an operator that retries the source Observable multiple times if it fails.
     *
     * @param {number|RetryConfig} configOrCount - The number of retries or a RetryConfig object.
     * @return {OperatorFunction<T, T>} An operator function that applies the retry logic to the source Observable.
     * @throws {Error} If all retries fail and an error is thrown.
     */
    function retry(configOrCount) {
        if (configOrCount === void 0) { configOrCount = Infinity; }
        var config;
        if (configOrCount && typeof configOrCount === 'object') {
            config = configOrCount;
        }
        else {
            config = {
                count: configOrCount,
            };
        }
        var _a = config.count, count = _a === void 0 ? Infinity : _a, delay = config.delay, _b = config.resetOnSuccess, resetOnSuccess = _b === void 0 ? false : _b;
        return count <= 0
            ? identity
            : operate(function (source, subscriber) {
                var soFar = 0;
                var innerSub;
                var subscribeForRetry = function () {
                    var syncUnsub = false;
                    innerSub = source.subscribe(createOperatorSubscriber(subscriber, function (value) {
                        if (resetOnSuccess) {
                            soFar = 0;
                        }
                        subscriber.next(value);
                    }, undefined, function (err) {
                        if (soFar++ < count) {
                            var resub_1 = function () {
                                if (innerSub) {
                                    innerSub.unsubscribe();
                                    innerSub = null;
                                    subscribeForRetry();
                                }
                                else {
                                    syncUnsub = true;
                                }
                            };
                            if (delay != null) {
                                var notifier = typeof delay === 'number' ? timer(delay) : innerFrom(delay(err, soFar));
                                var notifierSubscriber_1 = createOperatorSubscriber(subscriber, function () {
                                    notifierSubscriber_1.unsubscribe();
                                    resub_1();
                                }, function () {
                                    subscriber.complete();
                                });
                                notifier.subscribe(notifierSubscriber_1);
                            }
                            else {
                                resub_1();
                            }
                        }
                        else {
                            subscriber.error(err);
                        }
                    }));
                    if (syncUnsub) {
                        innerSub.unsubscribe();
                        innerSub = null;
                        subscribeForRetry();
                    }
                };
                subscribeForRetry();
            });
    }

    /**
     * Returns an observable that will resubscribe to its source observable upon error,
     * using the provided notifier function to determine when to retry.
     *
     * @param {function(errors$: Observable<any>): Observable<any>} notifier - A function that takes an observable of errors and returns an observable that determines when to retry.
     * @returns {Observable<T>} An observable that resubscribes to its source upon error based on the provided notifier.
     *
     * Example usage:
     * const result = retryWhen((errors) => errors.pipe(delay(1000)));
     */
    function retryWhen(notifier) {
        return operate(function (source, subscriber) {
            var innerSub;
            var syncResub = false;
            var errors$;
            var subscribeForRetryWhen = function () {
                innerSub = source.subscribe(createOperatorSubscriber(subscriber, undefined, undefined, function (err) {
                    if (!errors$) {
                        errors$ = new Subject();
                        innerFrom(notifier(errors$)).subscribe(createOperatorSubscriber(subscriber, function () {
                            return innerSub ? subscribeForRetryWhen() : (syncResub = true);
                        }));
                    }
                    if (errors$) {
                        errors$.next(err);
                    }
                }));
                if (syncResub) {
                    innerSub.unsubscribe();
                    innerSub = null;
                    syncResub = false;
                    subscribeForRetryWhen();
                }
            };
            subscribeForRetryWhen();
        });
    }

    /**
     * Creates an operator function that samples values from the source observable at specified intervals.
     *
     * @param {Observable} notifier - The observable that triggers sampling of values from the source observable.
     * @return {OperatorFunction<any, any>} An operator function that returns a new observable which emits sampled values.
     */
    function sample(notifier) {
        return operate(function (source, subscriber) {
            var hasValue = false;
            var lastValue = null;
            source.subscribe(createOperatorSubscriber(subscriber, function (value) {
                hasValue = true;
                lastValue = value;
            }));
            innerFrom(notifier).subscribe(createOperatorSubscriber(subscriber, function () {
                if (hasValue) {
                    hasValue = false;
                    var value = lastValue;
                    lastValue = null;
                    subscriber.next(value);
                }
            }, noop));
        });
    }

    /**
     * Samples an Observable by emitting only the last value emitted within specified time periods.
     *
     * @param {number} period - The sampling rate in milliseconds.
     * @param {SchedulerLike} [scheduler=asyncScheduler] - Scheduler to run sampling timer on.
     * @returns {Observable<T>} An Observable that emits the last value from the source Observable within each specified time period.
     *
     * Example:
     * const observable = of(1, 2, 3, 4, 5);
     * const sampledObservable = sampleTime(2000)(observable);
     * // sampledObservable will emit values: [3], [5] (assuming the sampling starts at time 0)
     */
    function sampleTime(period, scheduler) {
        if (scheduler === void 0) { scheduler = asyncScheduler; }
        return sample(interval(period, scheduler));
    }

    /**
     * Scans through an accumulator using internal operations to process a seed value.
     *
     * @param {Array} accumulator - The array to accumulate the results into.
     * @param {*} seed - The initial value to start the accumulation with.
     * @returns {*|undefined} - Returns the final accumulated result or undefined if no seed is provided and accumulator is empty.
     * @throws {Error} - Throws an error if the arguments are invalid types.
     *
     * @example
     * const accumulator = [];
     * const result = scan(accumulator, 1);
     * console.log(result); // Output: [1]
     */
    function scan(accumulator, seed) {
        return operate(scanInternals(accumulator, seed, arguments.length >= 2, true));
    }

    function sequenceEqual(compareTo, comparator) {
        if (comparator === void 0) { comparator = function (a, b) { return a === b; }; }
        return operate(function (source, subscriber) {
            var aState = createState();
            var bState = createState();
            var emit = function (isEqual) {
                subscriber.next(isEqual);
                subscriber.complete();
            };
            var createSubscriber = function (selfState, otherState) {
                var sequenceEqualSubscriber = createOperatorSubscriber(subscriber, function (a) {
                    var buffer = otherState.buffer, complete = otherState.complete;
                    if (buffer.length === 0) {
                        complete ? emit(false) : selfState.buffer.push(a);
                    }
                    else {
                        !comparator(a, buffer.shift()) && emit(false);
                    }
                }, function () {
                    selfState.complete = true;
                    var complete = otherState.complete, buffer = otherState.buffer;
                    complete && emit(buffer.length === 0);
                    sequenceEqualSubscriber === null || sequenceEqualSubscriber === void 0 ? void 0 : sequenceEqualSubscriber.unsubscribe();
                });
                return sequenceEqualSubscriber;
            };
            source.subscribe(createSubscriber(aState, bState));
            innerFrom(compareTo).subscribe(createSubscriber(bState, aState));
        });
    }
    /**
     * Creates an initial state object with a buffer array and a complete boolean flag.
     *
     * @returns {Object} - An object representing the initial state.
     */
    function createState() {
        return {
            buffer: [],
            complete: false,
        };
    }

    /**
     * Creates an observable that shares the same underlying implementation as the source observable,
     * but only subscribes to it when there is at least one subscriber.
     *
     * @param {Object} [options] - Optional configuration options for the share operator.
     * @param {Function} [options.connector=() => new Subject()] - A factory function that returns a connector subject.
     * @param {boolean} [options.resetOnError=true] - Whether to reset when an error occurs.
     * @param {boolean} [options.resetOnComplete=true] - Whether to reset when the observable completes.
     * @param {boolean} [options.resetOnRefCountZero=true] - Whether to reset when the reference count reaches zero.
     *
     * @return {Function} A function that takes an observable as input and returns a new observable
     * which shares the same underlying implementation but only subscribes to the source when necessary.
     */
    function share(options) {
        if (options === void 0) { options = {}; }
        var _a = options.connector, connector = _a === void 0 ? function () { return new Subject(); } : _a, _b = options.resetOnError, resetOnError = _b === void 0 ? true : _b, _c = options.resetOnComplete, resetOnComplete = _c === void 0 ? true : _c, _d = options.resetOnRefCountZero, resetOnRefCountZero = _d === void 0 ? true : _d;
        return function (wrapperSource) {
            var connection;
            var resetConnection;
            var subject;
            var refCount = 0;
            var hasCompleted = false;
            var hasErrored = false;
            var cancelReset = function () {
                resetConnection === null || resetConnection === void 0 ? void 0 : resetConnection.unsubscribe();
                resetConnection = undefined;
            };
            var reset = function () {
                cancelReset();
                connection = subject = undefined;
                hasCompleted = hasErrored = false;
            };
            var resetAndUnsubscribe = function () {
                var conn = connection;
                reset();
                conn === null || conn === void 0 ? void 0 : conn.unsubscribe();
            };
            return operate(function (source, subscriber) {
                refCount++;
                if (!hasErrored && !hasCompleted) {
                    cancelReset();
                }
                var dest = (subject = subject !== null && subject !== void 0 ? subject : connector());
                subscriber.add(function () {
                    refCount--;
                    if (refCount === 0 && !hasErrored && !hasCompleted) {
                        resetConnection = handleReset(resetAndUnsubscribe, resetOnRefCountZero);
                    }
                });
                dest.subscribe(subscriber);
                if (!connection &&
                    refCount > 0) {
                    connection = new SafeSubscriber({
                        next: function (value) { return dest.next(value); },
                        error: function (err) {
                            hasErrored = true;
                            cancelReset();
                            resetConnection = handleReset(reset, resetOnError, err);
                            dest.error(err);
                        },
                        complete: function () {
                            hasCompleted = true;
                            cancelReset();
                            resetConnection = handleReset(reset, resetOnComplete);
                            dest.complete();
                        },
                    });
                    innerFrom(source).subscribe(connection);
                }
            })(wrapperSource);
        };
    }
    /**
     * Handles the reset operation based on the 'on' parameter.
     *
     * @param {Function} reset - The function to call when resetting.
     * @param {boolean} on - Determines whether to trigger the reset or not. If `true`, resets immediately; if `false`, does nothing. If omitted, behaves like a subscription with cleanup.
     * @param {...*} args - Additional arguments to pass to the 'on' function if it is called.
     *
     * @returns {void|Subscription} - Returns `undefined` if resetting immediately or `Subscription` if used as a subscription with cleanup.
     */
    function handleReset(reset, on) {
        var args = [];
        for (var _i = 2; _i < arguments.length; _i++) {
            args[_i - 2] = arguments[_i];
        }
        if (on === true) {
            reset();
            return;
        }
        if (on === false) {
            return;
        }
        var onSubscriber = new SafeSubscriber({
            next: function () {
                onSubscriber.unsubscribe();
                reset();
            },
        });
        return innerFrom(on.apply(void 0, __spreadArray([], __read(args)))).subscribe(onSubscriber);
    }

    /**
     * Creates an operator that shares a single subscription to the source Observable among multiple subscribers,
     * replaying all or a portion of past emissions to new subscribers.
     *
     * @param {Object|number} configOrBufferSize - Configuration object or buffer size.
     * @param {number} [configOrBufferSize.bufferSize=Infinity] - Maximum number of previous emissions to replay to new subscribers. If not provided, defaults to Infinity.
     * @param {number} [configOrBufferSize.windowTime=Infinity] - Time window over which to replay past emissions. If not provided, defaults to Infinity.
     * @param {SchedulerLike} [configOrBufferSize.scheduler] - Scheduler on which to run the operator. If not provided, uses the default scheduler.
     * @param {number} [windowTime=Infinity] - Time window over which to replay past emissions. If `configOrBufferSize` is an object and `windowTime` is not specified, defaults to Infinity.
     * @param {SchedulerLike} [scheduler] - Scheduler on which to run the operator. If `configOrBufferSize` is an object and `scheduler` is not specified, uses the default scheduler.
     * @returns {Observable} An Observable that shares a single subscription to the source, replaying the emissions as configured.
     *
     * @example
     * // Example usage with a buffer size of 3 and window time of 100ms
     * const observable = interval(50).take(8);
     * const sharedObservable = observable.pipe(shareReplay({ bufferSize: 3, windowTime: 100 }));
     *
     * sharedObservable.subscribe(console.log); // Logs the last 3 emissions (3, 4, 5) and then continues logging new emissions
     */
    function shareReplay(configOrBufferSize, windowTime, scheduler) {
        var _a, _b, _c;
        var bufferSize;
        var refCount = false;
        if (configOrBufferSize && typeof configOrBufferSize === 'object') {
            (_a = configOrBufferSize.bufferSize, bufferSize = _a === void 0 ? Infinity : _a, _b = configOrBufferSize.windowTime, windowTime = _b === void 0 ? Infinity : _b, _c = configOrBufferSize.refCount, refCount = _c === void 0 ? false : _c, scheduler = configOrBufferSize.scheduler);
        }
        else {
            bufferSize = (configOrBufferSize !== null && configOrBufferSize !== void 0 ? configOrBufferSize : Infinity);
        }
        return share({
            connector: function () { return new ReplaySubject(bufferSize, windowTime, scheduler); },
            resetOnError: true,
            resetOnComplete: false,
            resetOnRefCountZero: refCount,
        });
    }

    /** @function
     * Filters an observable to only pass through one value that satisfies the provided predicate. If no such value is found or more than one is found, it errors out.
     *
     * @param {Function} predicate - A function that determines if a value should be passed through. It receives the value, its index in the sequence, and the source observable as arguments.
     * @returns {Observable<any>} An Observable that emits the first value satisfying the predicate or an error if the condition is not met.
     *
     * @throws {SequenceError} - If more than one matching value is found.
     * @throws {NotFoundError} - If no matching values are found and at least one value has been seen.
     * @throws {EmptyError} - If no values have been seen.
     *
     * @example
     * const source = from([1, 2, 3, 4]);
     * source.pipe(single(x => x === 3)).subscribe(console.log); // Output: 3
     */
    function single(predicate) {
        return operate(function (source, subscriber) {
            var hasValue = false;
            var singleValue;
            var seenValue = false;
            var index = 0;
            source.subscribe(createOperatorSubscriber(subscriber, function (value) {
                seenValue = true;
                if (!predicate || predicate(value, index++, source)) {
                    hasValue && subscriber.error(new SequenceError('Too many matching values'));
                    hasValue = true;
                    singleValue = value;
                }
            }, function () {
                if (hasValue) {
                    subscriber.next(singleValue);
                    subscriber.complete();
                }
                else {
                    subscriber.error(seenValue ? new NotFoundError('No matching values') : new EmptyError());
                }
            }));
        });
    }

    /**
     * Skips a specified number of elements in an array or collection based on their index.
     *
     * @param {number} count - The number of elements to skip from the beginning of the array.
     * @returns {Function} A function that, when called with an array, returns a new array containing all elements except the first 'count' elements.
     *
     * Example:
     * const data = [10, 20, 30, 40, 50];
     * const skipFirstTwo = skip(2);
     * console.log(skipFirstTwo(data)); // Output: [30, 40, 50]
     */
    function skip(count) {
        return filter(function (_, index) { return count <= index; });
    }

    /**
     * Skips the last `skipCount` items emitted by an observable sequence.
     *
     * @param {number} skipCount - The number of items to skip from the end.
     * @returns {Observable<T>} An observable sequence skipping the last `skipCount` items.
     */
    function skipLast(skipCount) {
        return skipCount <= 0
            ?
                identity
            : operate(function (source, subscriber) {
                var ring = new Array(skipCount);
                var seen = 0;
                source.subscribe(createOperatorSubscriber(subscriber, function (value) {
                    var valueIndex = seen++;
                    if (valueIndex < skipCount) {
                        ring[valueIndex] = value;
                    }
                    else {
                        var index = valueIndex % skipCount;
                        var oldValue = ring[index];
                        ring[index] = value;
                        subscriber.next(oldValue);
                    }
                }));
                return function () {
                    ring = null;
                };
            });
    }

    /**
     * Returns an Observable that skips values emitted by the source Observable until a notifier Observable emits a value.
     *
     * @param {Observable} notifier - The Observable to listen for. When this Observable emits, it will stop skipping values from the source Observable.
     * @returns {Observable} An Observable that skips values from the source until `notifier` emits.
     */
    function skipUntil(notifier) {
        return operate(function (source, subscriber) {
            var taking = false;
            var skipSubscriber = createOperatorSubscriber(subscriber, function () {
                skipSubscriber === null || skipSubscriber === void 0 ? void 0 : skipSubscriber.unsubscribe();
                taking = true;
            }, noop);
            innerFrom(notifier).subscribe(skipSubscriber);
            source.subscribe(createOperatorSubscriber(subscriber, function (value) { return taking && subscriber.next(value); }));
        });
    }

    /** @function skipWhile
     * Creates an operator function that skips values from the source observable until the predicate returns false for the first time.
     *
     * @param {Function} predicate - A function to test each value emitted by the source. It takes two arguments:
     *   - {any} value - The current value being processed.
     *   - {number} index - The zero-based index of the current value.
     * @returns {Observable} An observable that skips values until the predicate returns false, then emits all subsequent values.
     */
    function skipWhile(predicate) {
        return operate(function (source, subscriber) {
            var taking = false;
            var index = 0;
            source.subscribe(createOperatorSubscriber(subscriber, function (value) { return (taking || (taking = !predicate(value, index++))) && subscriber.next(value); }));
        });
    }

    /**
     * Creates an observable sequence by concatenating the provided value with the source observable sequence.
     *
     * @param {...*} values - The value(s) to prepend to the source observable sequence.
     * @returns {Observable} An observable sequence that starts with the provided values followed by the elements of the source sequence.
     */
    function startWith() {
        var values = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            values[_i] = arguments[_i];
        }
        var scheduler = popScheduler(values);
        return operate(function (source, subscriber) {
            (scheduler ? concat(values, source, scheduler) : concat(values, source)).subscribe(subscriber);
        });
    }

    /**
     * Maps each value from the source observable to an inner observable, then flattens the emissions of those inner observables into a single observable.
     *
     * @param {Function} project - A function that takes the outer value and its index as arguments and returns an inner observable.
     * @param {Function} [resultSelector] - (Optional) A function to map the values emitted by the inner observables.
     * @returns {Observable} An Observable that emits the results of applying the `project` function to each value from the source, flattened into a single stream.
     *
     * @example
     * // Example usage:
     * const source$ = rxjs.from([1, 2, 3]);
     * const result$ = source$.pipe(rxjs.operators.switchMap(value => rxjs.of(`Value: ${value}`)));
     * result$.subscribe(console.log); // Output: Value: 1, Value: 2, Value: 3
     */
    function switchMap(project, resultSelector) {
        return operate(function (source, subscriber) {
            var innerSubscriber = null;
            var index = 0;
            var isComplete = false;
            var checkComplete = function () { return isComplete && !innerSubscriber && subscriber.complete(); };
            source.subscribe(createOperatorSubscriber(subscriber, function (value) {
                innerSubscriber === null || innerSubscriber === void 0 ? void 0 : innerSubscriber.unsubscribe();
                var innerIndex = 0;
                var outerIndex = index++;
                innerFrom(project(value, outerIndex)).subscribe((innerSubscriber = createOperatorSubscriber(subscriber, function (innerValue) { return subscriber.next(resultSelector ? resultSelector(value, innerValue, outerIndex, innerIndex++) : innerValue); }, function () {
                    innerSubscriber = null;
                    checkComplete();
                })));
            }, function () {
                isComplete = true;
                checkComplete();
            }));
        });
    }

    /**
     * Switches all elements of an Observable sequence to the most recent Observable sequence emitted by this selector.
     *
     * @returns {Observable} An Observable that emits items from the most recently selected Observable sequence.
     */
    function switchAll() {
        return switchMap(identity);
    }

    /**
     * Projects each source value to an Observable which is merged in the output Observable, resulting in an Observable that emits items from inner Observables emitted by the source Observable.
     *
     * @param {Observable} innerObservable - An Observable to replace each value from the source Observable.
     * @param {function|undefined} [resultSelector] - A function that takes one argument (the value from the source Observable) and returns an Observable. If not provided, each source value is replaced with `innerObservable`.
     * @returns {Observable} An Observable that emits items from inner Observables emitted by the source Observable.
     */
    function switchMapTo(innerObservable, resultSelector) {
        return isFunction(resultSelector) ? switchMap(function () { return innerObservable; }, resultSelector) : switchMap(function () { return innerObservable; });
    }

    /**
     * Creates an operator that applies a function to each value emitted by the source Observable,
     * with seed accumulator, and returns the accumulated result.
     *
     * @param {function(state: any, value: any, index: number): Observable<any>} accumulator - A function
     * that takes the current state, the emitted value, and the index as arguments and returns an Observable.
     * @param {any} seed - The initial state to be passed to the accumulator function.
     * @return {Observable<any>} An Observable that emits the accumulated result of applying the accumulator
     * function to each emitted value from the source Observable.
     */
    function switchScan(accumulator, seed) {
        return operate(function (source, subscriber) {
            var state = seed;
            switchMap(function (value, index) { return accumulator(state, value, index); }, function (_, innerValue) { return ((state = innerValue), innerValue); })(source).subscribe(subscriber);
            return function () {
                state = null;
            };
        });
    }

    /**
     * Creates an observable that emits values from the source until the notifier observable emits a value.
     *
     * @param {Observable} notifier - An observable that signals when to stop emitting values from the source.
     * @returns {Observable} An observable that emits values from the source until the notifier emits a value.
     */
    function takeUntil(notifier) {
        return operate(function (source, subscriber) {
            innerFrom(notifier).subscribe(createOperatorSubscriber(subscriber, function () { return subscriber.complete(); }, noop));
            !subscriber.closed && source.subscribe(subscriber);
        });
    }

    /**
     * Creates an observable that emits elements from the source observable until the predicate returns false.
     *
     * @function
     * @param {Function} predicate - A function to test each element emitted by the source. It should return a boolean value.
     * @param {boolean} [inclusive=false] - If true, includes the last element that caused the predicate to return false in the output.
     * @returns {Observable} An observable that emits elements until the predicate returns false.
     *
     * @example
     * takeWhile(x => x < 5)(of(1, 2, 3, 4, 5)).subscribe(console.log); // Output: 1, 2, 3, 4
     */
    function takeWhile(predicate, inclusive) {
        if (inclusive === void 0) { inclusive = false; }
        return operate(function (source, subscriber) {
            var index = 0;
            source.subscribe(createOperatorSubscriber(subscriber, function (value) {
                var result = predicate(value, index++);
                (result || inclusive) && subscriber.next(value);
                !result && subscriber.complete();
            }));
        });
    }

    function tap(observerOrNext, error, complete) {
        var tapObserver = isFunction(observerOrNext) || error || complete
            ?
                { next: observerOrNext, error: error, complete: complete }
            : observerOrNext;
        return tapObserver
            ? operate(function (source, subscriber) {
                var _a;
                (_a = tapObserver.subscribe) === null || _a === void 0 ? void 0 : _a.call(tapObserver);
                var isUnsub = true;
                source.subscribe(createOperatorSubscriber(subscriber, function (value) {
                    var _a;
                    (_a = tapObserver.next) === null || _a === void 0 ? void 0 : _a.call(tapObserver, value);
                    subscriber.next(value);
                }, function () {
                    var _a;
                    isUnsub = false;
                    (_a = tapObserver.complete) === null || _a === void 0 ? void 0 : _a.call(tapObserver);
                    subscriber.complete();
                }, function (err) {
                    var _a;
                    isUnsub = false;
                    (_a = tapObserver.error) === null || _a === void 0 ? void 0 : _a.call(tapObserver, err);
                    subscriber.error(err);
                }, function () {
                    var _a, _b;
                    if (isUnsub) {
                        (_a = tapObserver.unsubscribe) === null || _a === void 0 ? void 0 : _a.call(tapObserver);
                    }
                    (_b = tapObserver.finalize) === null || _b === void 0 ? void 0 : _b.call(tapObserver);
                }));
            })
            :
                identity;
    }

    /**
     * Throttles emissions from the source observable by waiting for a specified duration selector to complete before emitting the next value.
     *
     * @param {Observable<T>} durationSelector - An Observable that determines the duration to wait after each emission.
     * @param {{leading?: boolean, trailing?: boolean}} [config={ leading: true, trailing: false }] - Optional configuration object with `leading` and `trailing` flags to control whether to emit the first value immediately and whether to emit the last value on completion.
     * @returns {Observable<T>} A new observable that emits values from the source observable but throttles emissions based on the specified duration selector.
     *
     * @example
     * import { of } from 'rxjs';
     * import { throttle } from './throttle';
     *
     * const source = of(1, 2, 3, 4, 5);
     * const durationSelector = () => interval(1000); // Emit a value every second
     * const throttled$ = throttle(durationSelector)(source);
     *
     * throttled$.subscribe(console.log);
     * // Output: 1 (immediately), 2 (after 1 second), 3 (after another second), etc.
     */
    function throttle(durationSelector, config) {
        return operate(function (source, subscriber) {
            var _a = config !== null && config !== void 0 ? config : {}, _b = _a.leading, leading = _b === void 0 ? true : _b, _c = _a.trailing, trailing = _c === void 0 ? false : _c;
            var hasValue = false;
            var sendValue = null;
            var throttled = null;
            var isComplete = false;
            var endThrottling = function () {
                throttled === null || throttled === void 0 ? void 0 : throttled.unsubscribe();
                throttled = null;
                if (trailing) {
                    send();
                    isComplete && subscriber.complete();
                }
            };
            var cleanupThrottling = function () {
                throttled = null;
                isComplete && subscriber.complete();
            };
            var startThrottle = function (value) {
                return (throttled = innerFrom(durationSelector(value)).subscribe(createOperatorSubscriber(subscriber, endThrottling, cleanupThrottling)));
            };
            var send = function () {
                if (hasValue) {
                    hasValue = false;
                    var value = sendValue;
                    sendValue = null;
                    subscriber.next(value);
                    !isComplete && startThrottle(value);
                }
            };
            source.subscribe(createOperatorSubscriber(subscriber, function (value) {
                hasValue = true;
                sendValue = value;
                !(throttled && !throttled.closed) && (leading ? send() : startThrottle(value));
            }, function () {
                isComplete = true;
                !(trailing && hasValue && throttled && !throttled.closed) && subscriber.complete();
            }));
        });
    }

    /**
     * Throttles the emissions of an Observable by limiting the rate at which items can pass through.
     *
     * @param {number} duration - The time span in milliseconds during which only one item emitted by the source Observable can pass through the throttling mechanism.
     * @param {Object} scheduler - The scheduler to use for scheduling the throttle timer. Defaults to `asyncScheduler`.
     * @param {Object} config - Optional configuration object that can be used to customize the behavior of the throttleTime operator.
     * @returns {Observable} An Observable that emits items from the source Observable, but at most one item per specified time span.
     *
     * Example:
     * ```javascript
     * const source$ = interval(100);
     * const throttled$ = source$.pipe(throttleTime(250));
     * throttled$.subscribe(x => console.log(x)); // Output: 0, 3, 6, ...
     * ```
     */
    function throttleTime(duration, scheduler, config) {
        if (scheduler === void 0) { scheduler = asyncScheduler; }
        var duration$ = timer(duration, scheduler);
        return throttle(function () { return duration$; }, config);
    }

    /**
     * Creates an observable sequence that emits interval values from the given scheduler.
     *
     * @param {SchedulerLike} [scheduler=asyncScheduler] The scheduler to use for scheduling the interval timer. Defaults to `asyncScheduler`.
     * @returns {Observable<TimeInterval<T>>} An observable sequence that emits successive time intervals.
     */
    function timeInterval(scheduler) {
        if (scheduler === void 0) { scheduler = asyncScheduler; }
        return operate(function (source, subscriber) {
            var last = scheduler.now();
            source.subscribe(createOperatorSubscriber(subscriber, function (value) {
                var now = scheduler.now();
                var interval = now - last;
                last = now;
                subscriber.next(new TimeInterval(value, interval));
            }));
        });
    }
    var TimeInterval = (function () {
        /**
         * Represents a time interval with a value and an interval period.
         *
         * @constructor
         * @param {number} value - The numerical value of the interval.
         * @param {string} interval - The time unit for the interval, e.g., 'seconds', 'minutes'.
         */
        function TimeInterval(value, interval) {
            this.value = value;
            this.interval = interval;
        }
        return TimeInterval;
    }());

    /**
     * Creates an observable that emits values after a specified delay or at a specific date/time,
     * switching to another observable if the original observable completes.
     *
     * @param {Date|string|number} due - The time when the observable should complete. Can be a Date object, number of milliseconds, or string representing a date.
     * @param {Observable} withObservable - An Observable that will replace the original one after the specified delay/datetime has passed.
     * @param {SchedulerLike} [scheduler=async] - The scheduler to use for managing timing. Defaults to 'async' if not provided.
     *
     * @returns {Observable} - An Observable that emits values based on the specified conditions and switches to another observable upon completion of the original one.
     *
     * @throws {TypeError} - Throws an error if no observable is provided to switch to or if no timeout is specified.
     */
    function timeoutWith(due, withObservable, scheduler) {
        var first;
        var each;
        var _with;
        scheduler = scheduler !== null && scheduler !== void 0 ? scheduler : async;
        if (isValidDate(due)) {
            first = due;
        }
        else if (typeof due === 'number') {
            each = due;
        }
        if (withObservable) {
            _with = function () { return withObservable; };
        }
        else {
            throw new TypeError('No observable provided to switch to');
        }
        if (first == null && each == null) {
            throw new TypeError('No timeout provided.');
        }
        return timeout({
            first: first,
            each: each,
            scheduler: scheduler,
            with: _with,
        });
    }

    /**
     * Creates a function that maps each value to an object containing the value and its timestamp.
     *
     * @function
     * @param {Function} [timestampProvider=dateTimestampProvider] - The provider for the current timestamp. Defaults to `dateTimestampProvider`.
     * @returns {Function} A function that takes a value and returns an object with the value and the current timestamp.
     *
     * @example
     * const timeStamper = timestamp();
     * console.log(timeStamper('Event 1')); // Output: { value: 'Event 1', timestamp: <current timestamp> }
     *
     * @throws {TypeError} If `timestampProvider` is not a function.
     */
    function timestamp(timestampProvider) {
        if (timestampProvider === void 0) { timestampProvider = dateTimestampProvider; }
        return map(function (value) { return ({ value: value, timestamp: timestampProvider.now() }); });
    }

    /**
     * Creates an observable that emits values from the source observable within specified boundaries.
     *
     * @param {Observable} windowBoundaries - The observable that defines when a new window should be created.
     * @returns {Observable<Observable<T>>} An observable of observables, where each inner observable emits values
     * within its respective window until the `windowBoundaries` observable emits a value or completes.
     *
     * Example:
     * ```javascript
     * const source = from([1, 2, 3, 4, 5]);
     * const boundaries = interval(1000);
     * const result = source.pipe(window(boundaries));
     * result.subscribe(innerObservable => {
     *   innerObservable.subscribe(value => console.log(value));
     * });
     * ```
     */
    function window(windowBoundaries) {
        return operate(function (source, subscriber) {
            var windowSubject = new Subject();
            subscriber.next(windowSubject.asObservable());
            var errorHandler = function (err) {
                windowSubject.error(err);
                subscriber.error(err);
            };
            source.subscribe(createOperatorSubscriber(subscriber, function (value) { return windowSubject === null || windowSubject === void 0 ? void 0 : windowSubject.next(value); }, function () {
                windowSubject.complete();
                subscriber.complete();
            }, errorHandler));
            innerFrom(windowBoundaries).subscribe(createOperatorSubscriber(subscriber, function () {
                windowSubject.complete();
                subscriber.next((windowSubject = new Subject()));
            }, noop, errorHandler));
            return function () {
                windowSubject === null || windowSubject === void 0 ? void 0 : windowSubject.unsubscribe();
                windowSubject = null;
            };
        });
    }

    /**
     * Generates an observable sequence of windows from the source sequence,
     * each containing a subset of elements based on specified window size and start interval.
     *
     * @param {number} windowSize - The size of each window (number of elements).
     * @param {number} [startWindowEvery=0] - Interval at which to start a new window. Defaults to the same as windowSize.
     * @returns {Observable<Subject>} An observable sequence containing windows of elements from the source sequence.
     *
     * @example
     * // Create an observable that emits numbers 1 to 10, and emit each set of three numbers in separate windows.
     * const source$ = interval(100);
     * const windowed$ = source$.pipe(windowCount(3));
     * windowed$.subscribe(w => console.log(w.toArray()));
     *
     * // Output:
     * // [1, 2, 3]
     * // [4, 5, 6]
     * // [7, 8, 9]
     * // [10]
     */
    function windowCount(windowSize, startWindowEvery) {
        if (startWindowEvery === void 0) { startWindowEvery = 0; }
        var startEvery = startWindowEvery > 0 ? startWindowEvery : windowSize;
        return operate(function (source, subscriber) {
            var windows = [new Subject()];
            var count = 0;
            subscriber.next(windows[0].asObservable());
            source.subscribe(createOperatorSubscriber(subscriber, function (value) {
                var e_1, _a;
                try {
                    for (var windows_1 = __values(windows), windows_1_1 = windows_1.next(); !windows_1_1.done; windows_1_1 = windows_1.next()) {
                        var window_1 = windows_1_1.value;
                        window_1.next(value);
                    }
                }
                catch (e_1_1) { e_1 = { error: e_1_1 }; }
                finally {
                    try {
                        if (windows_1_1 && !windows_1_1.done && (_a = windows_1.return)) _a.call(windows_1);
                    }
                    finally { if (e_1) throw e_1.error; }
                }
                var c = count - windowSize + 1;
                if (c >= 0 && c % startEvery === 0) {
                    windows.shift().complete();
                }
                if (++count % startEvery === 0) {
                    var window_2 = new Subject();
                    windows.push(window_2);
                    subscriber.next(window_2.asObservable());
                }
            }, function () {
                while (windows.length > 0) {
                    windows.shift().complete();
                }
                subscriber.complete();
            }, function (err) {
                while (windows.length > 0) {
                    windows.shift().error(err);
                }
                subscriber.error(err);
            }, function () {
                windows = null;
            }));
        });
    }

    /**
     * Groups emitted values from an observable into windows of a specified time duration.
     *
     * @param {number} windowTimeSpan - The time span (in milliseconds) over which to create windows.
     * @return {Observable<Observable<T>>} An observable that emits windows of values, each containing
     *                                      values emitted during the specified time span.
     * @throws {Error} Throws an error if `windowTimeSpan` is not a valid positive number.
     */
    function windowTime(windowTimeSpan) {
        var _a, _b;
        var otherArgs = [];
        for (var _i = 1; _i < arguments.length; _i++) {
            otherArgs[_i - 1] = arguments[_i];
        }
        var scheduler = (_a = popScheduler(otherArgs)) !== null && _a !== void 0 ? _a : asyncScheduler;
        var windowCreationInterval = (_b = otherArgs[0]) !== null && _b !== void 0 ? _b : null;
        var maxWindowSize = otherArgs[1] || Infinity;
        return operate(function (source, subscriber) {
            var windowRecords = [];
            var restartOnClose = false;
            var closeWindow = function (record) {
                var window = record.window, subs = record.subs;
                window.complete();
                subs.unsubscribe();
                arrRemove(windowRecords, record);
                restartOnClose && startWindow();
            };
            var startWindow = function () {
                if (windowRecords) {
                    var subs = new Subscription();
                    subscriber.add(subs);
                    var window_1 = new Subject();
                    var record_1 = {
                        window: window_1,
                        subs: subs,
                        seen: 0,
                    };
                    windowRecords.push(record_1);
                    subscriber.next(window_1.asObservable());
                    executeSchedule(subs, scheduler, function () { return closeWindow(record_1); }, windowTimeSpan);
                }
            };
            if (windowCreationInterval !== null && windowCreationInterval >= 0) {
                executeSchedule(subscriber, scheduler, startWindow, windowCreationInterval, true);
            }
            else {
                restartOnClose = true;
            }
            startWindow();
            var loop = function (cb) { return windowRecords.slice().forEach(cb); };
            var terminate = function (cb) {
                loop(function (_a) {
                    var window = _a.window;
                    return cb(window);
                });
                cb(subscriber);
                subscriber.unsubscribe();
            };
            source.subscribe(createOperatorSubscriber(subscriber, function (value) {
                loop(function (record) {
                    record.window.next(value);
                    maxWindowSize <= ++record.seen && closeWindow(record);
                });
            }, function () { return terminate(function (consumer) { return consumer.complete(); }); }, function (err) { return terminate(function (consumer) { return consumer.error(err); }); }));
            return function () {
                windowRecords = null;
            };
        });
    }

    function windowToggle(openings, closingSelector) {
        return operate(function (source, subscriber) {
            var windows = [];
            var handleError = function (err) {
                while (0 < windows.length) {
                    windows.shift().error(err);
                }
                subscriber.error(err);
            };
            innerFrom(openings).subscribe(createOperatorSubscriber(subscriber, function (openValue) {
                var window = new Subject();
                windows.push(window);
                var closingSubscription = new Subscription();
                var closeWindow = function () {
                    arrRemove(windows, window);
                    window.complete();
                    closingSubscription.unsubscribe();
                };
                var closingNotifier;
                try {
                    closingNotifier = innerFrom(closingSelector(openValue));
                }
                catch (err) {
                    handleError(err);
                    return;
                }
                subscriber.next(window.asObservable());
                closingSubscription.add(closingNotifier.subscribe(createOperatorSubscriber(subscriber, closeWindow, noop, handleError)));
            }, noop));
            source.subscribe(createOperatorSubscriber(subscriber, function (value) {
                var e_1, _a;
                var windowsCopy = windows.slice();
                try {
                    for (var windowsCopy_1 = __values(windowsCopy), windowsCopy_1_1 = windowsCopy_1.next(); !windowsCopy_1_1.done; windowsCopy_1_1 = windowsCopy_1.next()) {
                        var window_1 = windowsCopy_1_1.value;
                        window_1.next(value);
                    }
                }
                catch (e_1_1) { e_1 = { error: e_1_1 }; }
                finally {
                    try {
                        if (windowsCopy_1_1 && !windowsCopy_1_1.done && (_a = windowsCopy_1.return)) _a.call(windowsCopy_1);
                    }
                    finally { if (e_1) throw e_1.error; }
                }
            }, function () {
                while (0 < windows.length) {
                    windows.shift().complete();
                }
                subscriber.complete();
            }, handleError, function () {
                while (0 < windows.length) {
                    windows.shift().unsubscribe();
                }
            }));
        });
    }

    /**
     * Creates an Observable that emits windows of items it collects from the source Observable,
     * emitted based on timing information indicated by an Observable provided.
     *
     * <img src="https://rxjs.dev/assets/images/rxjs-methods-operators/windowWhen.png" width="100%">
     *
     * @param {function(): Observable<any>} closingSelector - A function that receives the output Observable and returns an Observable
     *   that emits a value when to close the current window.
     * @returns {Observable<Observable<T>>} An Observable of windows, each emitting items from the source Observable until it closes.
     *
     * @example <caption>Close windows based on the number of clicks</caption>
     * import { fromEvent, interval } from 'rxjs';
     * import { windowWhen, takeUntil } from 'rxjs/operators';
     *
     * const clicks = fromEvent(document, 'click');
     * const opens = interval(1000);
     * const closes = clicks.pipe(takeUntil(opens));
     * const result = clicks.pipe(windowWhen(() => closes));
     * result.subscribe(x => {
     *   console.log('New Window');
     *   x.subscribe(y => console.log(y));
     * });
     */
    function windowWhen(closingSelector) {
        return operate(function (source, subscriber) {
            var window;
            var closingSubscriber;
            var handleError = function (err) {
                window.error(err);
                subscriber.error(err);
            };
            var openWindow = function () {
                closingSubscriber === null || closingSubscriber === void 0 ? void 0 : closingSubscriber.unsubscribe();
                window === null || window === void 0 ? void 0 : window.complete();
                window = new Subject();
                subscriber.next(window.asObservable());
                var closingNotifier;
                try {
                    closingNotifier = innerFrom(closingSelector());
                }
                catch (err) {
                    handleError(err);
                    return;
                }
                closingNotifier.subscribe((closingSubscriber = createOperatorSubscriber(subscriber, openWindow, openWindow, handleError)));
            };
            openWindow();
            source.subscribe(createOperatorSubscriber(subscriber, function (value) { return window.next(value); }, function () {
                window.complete();
                subscriber.complete();
            }, handleError, function () {
                closingSubscriber === null || closingSubscriber === void 0 ? void 0 : closingSubscriber.unsubscribe();
                window = null;
            }));
        });
    }

    function withLatestFrom() {
        var inputs = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            inputs[_i] = arguments[_i];
        }
        var project = popResultSelector(inputs);
        return operate(function (source, subscriber) {
            var len = inputs.length;
            var otherValues = new Array(len);
            var hasValue = inputs.map(function () { return false; });
            var ready = false;
            var _loop_1 = function (i) {
                innerFrom(inputs[i]).subscribe(createOperatorSubscriber(subscriber, function (value) {
                    otherValues[i] = value;
                    if (!ready && !hasValue[i]) {
                        hasValue[i] = true;
                        (ready = hasValue.every(identity)) && (hasValue = null);
                    }
                }, noop));
            };
            for (var i = 0; i < len; i++) {
                _loop_1(i);
            }
            source.subscribe(createOperatorSubscriber(subscriber, function (value) {
                if (ready) {
                    var values = __spreadArray([value], __read(otherValues));
                    subscriber.next(project ? project.apply(void 0, __spreadArray([], __read(values))) : values);
                }
            }));
        });
    }

    /**
     * Zips all internal arrays of a project into a single array.
     *
     * @param {Project} project - The project object containing arrays to be zipped.
     * @returns {Array} A new array with elements from each input array zipped together.
     * @throws {Error} If the input is not a valid Project object.
     */
    function zipAll(project) {
        return joinAllInternals(zip, project);
    }

    /**
     * Combines multiple Observables to create an Observable whose values are calculated based on the latest values from each input Observable.
     *
     * @param {...Observable} sources - An array of Observables that will be combined.
     * @returns {Observable} An Observable that emits arrays of items, where each item corresponds to the latest value emitted by one of the input Observables.
     */
    function zip$1() {
        var sources = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            sources[_i] = arguments[_i];
        }
        return operate(function (source, subscriber) {
            zip.apply(void 0, __spreadArray([source], __read(sources))).subscribe(subscriber);
        });
    }

    /**
     * Combines arrays using a zip function. It takes multiple arrays as arguments and returns a new array formed by applying the zip function to each set of corresponding elements from the input arrays.
     *
     * @param {...Array} otherInputs - The arrays to be combined.
     * @return {Array} A new array with elements combined from the input arrays.
     */
    function zipWith() {
        var otherInputs = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            otherInputs[_i] = arguments[_i];
        }
        return zip$1.apply(void 0, __spreadArray([], __read(otherInputs)));
    }

    /**
     * Partitions an array into two arrays based on a predicate function.
     *
     * @param {Function} predicate - A function that takes one argument and returns a boolean value.
     * @param {*} thisArg - Optional. Value to use as `this` when executing the predicate function.
     * @returns {Array<Array>} An array containing two arrays: the first with elements for which the predicate returns true, and the second with elements for which it returns false.
     *
     * @example
     * const isEven = (x) => x % 2 === 0;
     * partition$1(isEven)([1, 2, 3, 4]); // Returns [[2, 4], [1, 3]]
     */
    function partition$1(predicate, thisArg) {
        return function (source) {
            return [filter(predicate, thisArg)(source), filter(not(predicate, thisArg))(source)];
        };
    }

    /**
     * Executes multiple promises concurrently and returns a promise that resolves when any of the input promises resolve,
     * or rejects if all of them reject.
     *
     * @param {...Promise} args - One or more promises to race against each other.
     * @returns {Promise} - A promise that resolves with the value from the first promise to resolve, or rejects with an array of reasons if all promises reject.
     */
    function race$1() {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
        }
        return raceWith.apply(void 0, __spreadArray([], __read(argsOrArgArray(args))));
    }



    var _operators = /*#__PURE__*/Object.freeze({
        audit: audit,
        auditTime: auditTime,
        buffer: buffer,
        bufferCount: bufferCount,
        bufferTime: bufferTime,
        bufferToggle: bufferToggle,
        bufferWhen: bufferWhen,
        catchError: catchError,
        combineAll: combineAll,
        combineLatestAll: combineLatestAll,
        combineLatest: combineLatest$1,
        combineLatestWith: combineLatestWith,
        concat: concat$1,
        concatAll: concatAll,
        concatMap: concatMap,
        concatMapTo: concatMapTo,
        concatWith: concatWith,
        connect: connect,
        count: count,
        debounce: debounce,
        debounceTime: debounceTime,
        defaultIfEmpty: defaultIfEmpty,
        delay: delay,
        delayWhen: delayWhen,
        dematerialize: dematerialize,
        distinct: distinct,
        distinctUntilChanged: distinctUntilChanged,
        distinctUntilKeyChanged: distinctUntilKeyChanged,
        elementAt: elementAt,
        endWith: endWith,
        every: every,
        exhaust: exhaust,
        exhaustAll: exhaustAll,
        exhaustMap: exhaustMap,
        expand: expand,
        filter: filter,
        finalize: finalize,
        find: find,
        findIndex: findIndex,
        first: first,
        groupBy: groupBy,
        ignoreElements: ignoreElements,
        isEmpty: isEmpty,
        last: last$1,
        map: map,
        mapTo: mapTo,
        materialize: materialize,
        max: max,
        merge: merge$1,
        mergeAll: mergeAll,
        flatMap: flatMap,
        mergeMap: mergeMap,
        mergeMapTo: mergeMapTo,
        mergeScan: mergeScan,
        mergeWith: mergeWith,
        min: min,
        multicast: multicast,
        observeOn: observeOn,
        onErrorResumeNext: onErrorResumeNext$1,
        pairwise: pairwise,
        partition: partition$1,
        pluck: pluck,
        publish: publish,
        publishBehavior: publishBehavior,
        publishLast: publishLast,
        publishReplay: publishReplay,
        race: race$1,
        raceWith: raceWith,
        reduce: reduce,
        repeat: repeat,
        repeatWhen: repeatWhen,
        retry: retry,
        retryWhen: retryWhen,
        refCount: refCount,
        sample: sample,
        sampleTime: sampleTime,
        scan: scan,
        sequenceEqual: sequenceEqual,
        share: share,
        shareReplay: shareReplay,
        single: single,
        skip: skip,
        skipLast: skipLast,
        skipUntil: skipUntil,
        skipWhile: skipWhile,
        startWith: startWith,
        subscribeOn: subscribeOn,
        switchAll: switchAll,
        switchMap: switchMap,
        switchMapTo: switchMapTo,
        switchScan: switchScan,
        take: take,
        takeLast: takeLast,
        takeUntil: takeUntil,
        takeWhile: takeWhile,
        tap: tap,
        throttle: throttle,
        throttleTime: throttleTime,
        throwIfEmpty: throwIfEmpty,
        timeInterval: timeInterval,
        timeout: timeout,
        timeoutWith: timeoutWith,
        timestamp: timestamp,
        toArray: toArray,
        window: window,
        windowCount: windowCount,
        windowTime: windowTime,
        windowToggle: windowToggle,
        windowWhen: windowWhen,
        withLatestFrom: withLatestFrom,
        zip: zip$1,
        zipAll: zipAll,
        zipWith: zipWith
    });

    var SubscriptionLog = (function () {
        /**
         * Represents a subscription log with frames for when it was subscribed and unsubscribed.
         *
         * @constructor
         * @param {number} subscribedFrame - The frame number when the subscription started.
         * @param {number} [unsubscribedFrame=Infinity] - The frame number when the subscription ended. Defaults to Infinity if not provided.
         */
        function SubscriptionLog(subscribedFrame, unsubscribedFrame) {
            if (unsubscribedFrame === void 0) { unsubscribedFrame = Infinity; }
            this.subscribedFrame = subscribedFrame;
            this.unsubscribedFrame = unsubscribedFrame;
        }
        return SubscriptionLog;
    }());

    var SubscriptionLoggable = (function () {
        /**
         * A class that provides functionality to manage subscriptions and log them.
         */
        function SubscriptionLoggable() {
            this.subscriptions = [];
        }
        SubscriptionLoggable.prototype.logSubscribedFrame = function () {
            this.subscriptions.push(new SubscriptionLog(this.scheduler.now()));
            return this.subscriptions.length - 1;
        };
        SubscriptionLoggable.prototype.logUnsubscribedFrame = function (index) {
            var subscriptionLogs = this.subscriptions;
            var oldSubscriptionLog = subscriptionLogs[index];
            subscriptionLogs[index] = new SubscriptionLog(oldSubscriptionLog.subscribedFrame, this.scheduler.now());
        };
        return SubscriptionLoggable;
    }());

    /**
     * Applies mixins to a derived constructor. Mixins are classes that provide
     * additional functionality to other classes without using inheritance.
     *
     * @param {Function} derivedCtor - The target constructor to which mixins will be applied.
     * @param {Array<Function>} baseCtors - An array of mixin constructors whose methods and properties will be copied to the target constructor's prototype.
     */
    function applyMixins(derivedCtor, baseCtors) {
        for (var i = 0, len = baseCtors.length; i < len; i++) {
            var baseCtor = baseCtors[i];
            var propertyKeys = Object.getOwnPropertyNames(baseCtor.prototype);
            for (var j = 0, len2 = propertyKeys.length; j < len2; j++) {
                var name_1 = propertyKeys[j];
                derivedCtor.prototype[name_1] = baseCtor.prototype[name_1];
            }
        }
    }

    var ColdObservable = (function (_super) {
        __extends(ColdObservable, _super);
        /**
         * A class representing a cold observable sequence.
         *
         * @constructor
         * @param {Array} messages - An array of objects representing the messages to be sent by the observable over time.
         * @param {Object} scheduler - The scheduler used to manage the timing and delivery of messages.
         */
        function ColdObservable(messages, scheduler) {
            var _this = _super.call(this, function (subscriber) {
                var observable = this;
                var index = observable.logSubscribedFrame();
                var subscription = new Subscription();
                subscription.add(new Subscription(function () {
                    observable.logUnsubscribedFrame(index);
                }));
                observable.scheduleMessages(subscriber);
                return subscription;
            }) || this;
            _this.messages = messages;
            _this.subscriptions = [];
            _this.scheduler = scheduler;
            return _this;
        }
        ColdObservable.prototype.scheduleMessages = function (subscriber) {
            var messagesLength = this.messages.length;
            for (var i = 0; i < messagesLength; i++) {
                var message = this.messages[i];
                subscriber.add(this.scheduler.schedule(function (state) {
                    var _a = state, notification = _a.message.notification, destination = _a.subscriber;
                    observeNotification(notification, destination);
                }, message.frame, { message: message, subscriber: subscriber }));
            }
        };
        return ColdObservable;
    }(Observable));
    applyMixins(ColdObservable, [SubscriptionLoggable]);

    var HotObservable = (function (_super) {
        __extends(HotObservable, _super);
        /**
         * Represents an observable sequence that shares a single subscription among multiple observers.
         *
         * @constructor
         * @extends Observable
         * @param {Array} messages - The array of messages to be emitted by the hot observable.
         * @param {IScheduler} scheduler - The scheduler to use for scheduling the emissions.
         */
        function HotObservable(messages, scheduler) {
            var _this = _super.call(this) || this;
            _this.messages = messages;
            _this.subscriptions = [];
            _this.scheduler = scheduler;
            return _this;
        }
        HotObservable.prototype._subscribe = function (subscriber) {
            var subject = this;
            var index = subject.logSubscribedFrame();
            var subscription = new Subscription();
            subscription.add(new Subscription(function () {
                subject.logUnsubscribedFrame(index);
            }));
            subscription.add(_super.prototype._subscribe.call(this, subscriber));
            return subscription;
        };
        HotObservable.prototype.setup = function () {
            var subject = this;
            var messagesLength = subject.messages.length;
            var _loop_1 = function (i) {
                (function () {
                    var _a = subject.messages[i], notification = _a.notification, frame = _a.frame;
                    subject.scheduler.schedule(function () {
                        observeNotification(notification, subject);
                    }, frame);
                })();
            };
            for (var i = 0; i < messagesLength; i++) {
                _loop_1(i);
            }
        };
        return HotObservable;
    }(Subject));
    applyMixins(HotObservable, [SubscriptionLoggable]);

    var defaultMaxFrame = 750;
    var TestScheduler = (function (_super) {
        __extends(TestScheduler, _super);
        /**
         * Creates a new instance of `TestScheduler` which is used for testing reactive applications by simulating time-dependent operations.
         *
         * @constructor
         * @param {Function} assertDeepEqual - The assertion function to be used for deep equality checks during tests.
         */
        function TestScheduler(assertDeepEqual) {
            var _this = _super.call(this, VirtualAction, defaultMaxFrame) || this;
            _this.assertDeepEqual = assertDeepEqual;
            _this.hotObservables = [];
            _this.coldObservables = [];
            _this.flushTests = [];
            _this.runMode = false;
            return _this;
        }
        TestScheduler.prototype.createTime = function (marbles) {
            var indexOf = this.runMode ? marbles.trim().indexOf('|') : marbles.indexOf('|');
            if (indexOf === -1) {
                throw new Error('marble diagram for time should have a completion marker "|"');
            }
            return indexOf * TestScheduler.frameTimeFactor;
        };
        TestScheduler.prototype.createColdObservable = function (marbles, values, error) {
            if (marbles.indexOf('^') !== -1) {
                throw new Error('cold observable cannot have subscription offset "^"');
            }
            if (marbles.indexOf('!') !== -1) {
                throw new Error('cold observable cannot have unsubscription marker "!"');
            }
            var messages = TestScheduler.parseMarbles(marbles, values, error, undefined, this.runMode);
            var cold = new ColdObservable(messages, this);
            this.coldObservables.push(cold);
            return cold;
        };
        TestScheduler.prototype.createHotObservable = function (marbles, values, error) {
            if (marbles.indexOf('!') !== -1) {
                throw new Error('hot observable cannot have unsubscription marker "!"');
            }
            var messages = TestScheduler.parseMarbles(marbles, values, error, undefined, this.runMode);
            var subject = new HotObservable(messages, this);
            this.hotObservables.push(subject);
            return subject;
        };
        TestScheduler.prototype.materializeInnerObservable = function (observable, outerFrame) {
            var _this = this;
            var messages = [];
            observable.subscribe({
                next: function (value) {
                    messages.push({ frame: _this.frame - outerFrame, notification: nextNotification(value) });
                },
                error: function (error) {
                    messages.push({ frame: _this.frame - outerFrame, notification: errorNotification(error) });
                },
                complete: function () {
                    messages.push({ frame: _this.frame - outerFrame, notification: COMPLETE_NOTIFICATION });
                },
            });
            return messages;
        };
        TestScheduler.prototype.expectObservable = function (observable, subscriptionMarbles) {
            var _this = this;
            if (subscriptionMarbles === void 0) { subscriptionMarbles = null; }
            var actual = [];
            var flushTest = { actual: actual, ready: false };
            var subscriptionParsed = TestScheduler.parseMarblesAsSubscriptions(subscriptionMarbles, this.runMode);
            var subscriptionFrame = subscriptionParsed.subscribedFrame === Infinity ? 0 : subscriptionParsed.subscribedFrame;
            var unsubscriptionFrame = subscriptionParsed.unsubscribedFrame;
            var subscription;
            this.schedule(function () {
                subscription = observable.subscribe({
                    next: function (x) {
                        var value = x instanceof Observable ? _this.materializeInnerObservable(x, _this.frame) : x;
                        actual.push({ frame: _this.frame, notification: nextNotification(value) });
                    },
                    error: function (error) {
                        actual.push({ frame: _this.frame, notification: errorNotification(error) });
                    },
                    complete: function () {
                        actual.push({ frame: _this.frame, notification: COMPLETE_NOTIFICATION });
                    },
                });
            }, subscriptionFrame);
            if (unsubscriptionFrame !== Infinity) {
                this.schedule(function () { return subscription.unsubscribe(); }, unsubscriptionFrame);
            }
            this.flushTests.push(flushTest);
            var runMode = this.runMode;
            return {
                toBe: function (marbles, values, errorValue) {
                    flushTest.ready = true;
                    flushTest.expected = TestScheduler.parseMarbles(marbles, values, errorValue, true, runMode);
                },
                toEqual: function (other) {
                    flushTest.ready = true;
                    flushTest.expected = [];
                    _this.schedule(function () {
                        subscription = other.subscribe({
                            next: function (x) {
                                var value = x instanceof Observable ? _this.materializeInnerObservable(x, _this.frame) : x;
                                flushTest.expected.push({ frame: _this.frame, notification: nextNotification(value) });
                            },
                            error: function (error) {
                                flushTest.expected.push({ frame: _this.frame, notification: errorNotification(error) });
                            },
                            complete: function () {
                                flushTest.expected.push({ frame: _this.frame, notification: COMPLETE_NOTIFICATION });
                            },
                        });
                    }, subscriptionFrame);
                },
            };
        };
        TestScheduler.prototype.expectSubscriptions = function (actualSubscriptionLogs) {
            var flushTest = { actual: actualSubscriptionLogs, ready: false };
            this.flushTests.push(flushTest);
            var runMode = this.runMode;
            return {
                toBe: function (marblesOrMarblesArray) {
                    var marblesArray = typeof marblesOrMarblesArray === 'string' ? [marblesOrMarblesArray] : marblesOrMarblesArray;
                    flushTest.ready = true;
                    flushTest.expected = marblesArray
                        .map(function (marbles) { return TestScheduler.parseMarblesAsSubscriptions(marbles, runMode); })
                        .filter(function (marbles) { return marbles.subscribedFrame !== Infinity; });
                },
            };
        };
        TestScheduler.prototype.flush = function () {
            var _this = this;
            var hotObservables = this.hotObservables;
            while (hotObservables.length > 0) {
                hotObservables.shift().setup();
            }
            _super.prototype.flush.call(this);
            this.flushTests = this.flushTests.filter(function (test) {
                if (test.ready) {
                    _this.assertDeepEqual(test.actual, test.expected);
                    return false;
                }
                return true;
            });
        };
        TestScheduler.parseMarblesAsSubscriptions = function (marbles, runMode) {
            var _this = this;
            if (runMode === void 0) { runMode = false; }
            if (typeof marbles !== 'string') {
                return new SubscriptionLog(Infinity);
            }
            var characters = __spreadArray([], __read(marbles));
            var len = characters.length;
            var groupStart = -1;
            var subscriptionFrame = Infinity;
            var unsubscriptionFrame = Infinity;
            var frame = 0;
            var _loop_1 = function (i) {
                var nextFrame = frame;
                var advanceFrameBy = function (count) {
                    nextFrame += count * _this.frameTimeFactor;
                };
                var c = characters[i];
                switch (c) {
                    case ' ':
                        if (!runMode) {
                            advanceFrameBy(1);
                        }
                        break;
                    case '-':
                        advanceFrameBy(1);
                        break;
                    case '(':
                        groupStart = frame;
                        advanceFrameBy(1);
                        break;
                    case ')':
                        groupStart = -1;
                        advanceFrameBy(1);
                        break;
                    case '^':
                        if (subscriptionFrame !== Infinity) {
                            throw new Error("found a second subscription point '^' in a " + 'subscription marble diagram. There can only be one.');
                        }
                        subscriptionFrame = groupStart > -1 ? groupStart : frame;
                        advanceFrameBy(1);
                        break;
                    case '!':
                        if (unsubscriptionFrame !== Infinity) {
                            throw new Error("found a second unsubscription point '!' in a " + 'subscription marble diagram. There can only be one.');
                        }
                        unsubscriptionFrame = groupStart > -1 ? groupStart : frame;
                        break;
                    default:
                        if (runMode && c.match(/^[0-9]$/)) {
                            if (i === 0 || characters[i - 1] === ' ') {
                                var buffer = characters.slice(i).join('');
                                var match = buffer.match(/^([0-9]+(?:\.[0-9]+)?)(ms|s|m) /);
                                if (match) {
                                    i += match[0].length - 1;
                                    var duration = parseFloat(match[1]);
                                    var unit = match[2];
                                    var durationInMs = void 0;
                                    switch (unit) {
                                        case 'ms':
                                            durationInMs = duration;
                                            break;
                                        case 's':
                                            durationInMs = duration * 1000;
                                            break;
                                        case 'm':
                                            durationInMs = duration * 1000 * 60;
                                            break;
                                        default:
                                            break;
                                    }
                                    advanceFrameBy(durationInMs / this_1.frameTimeFactor);
                                    break;
                                }
                            }
                        }
                        throw new Error("there can only be '^' and '!' markers in a " + "subscription marble diagram. Found instead '" + c + "'.");
                }
                frame = nextFrame;
                out_i_1 = i;
            };
            var this_1 = this, out_i_1;
            for (var i = 0; i < len; i++) {
                _loop_1(i);
                i = out_i_1;
            }
            if (unsubscriptionFrame < 0) {
                return new SubscriptionLog(subscriptionFrame);
            }
            else {
                return new SubscriptionLog(subscriptionFrame, unsubscriptionFrame);
            }
        };
        TestScheduler.parseMarbles = function (marbles, values, errorValue, materializeInnerObservables, runMode) {
            var _this = this;
            if (materializeInnerObservables === void 0) { materializeInnerObservables = false; }
            if (runMode === void 0) { runMode = false; }
            if (marbles.indexOf('!') !== -1) {
                throw new Error('conventional marble diagrams cannot have the ' + 'unsubscription marker "!"');
            }
            var characters = __spreadArray([], __read(marbles));
            var len = characters.length;
            var testMessages = [];
            var subIndex = runMode ? marbles.replace(/^[ ]+/, '').indexOf('^') : marbles.indexOf('^');
            var frame = subIndex === -1 ? 0 : subIndex * -this.frameTimeFactor;
            var getValue = typeof values !== 'object'
                ? function (x) { return x; }
                : function (x) {
                    if (materializeInnerObservables && values[x] instanceof ColdObservable) {
                        return values[x].messages;
                    }
                    return values[x];
                };
            var groupStart = -1;
            var _loop_2 = function (i) {
                var nextFrame = frame;
                var advanceFrameBy = function (count) {
                    nextFrame += count * _this.frameTimeFactor;
                };
                var notification = void 0;
                var c = characters[i];
                switch (c) {
                    case ' ':
                        if (!runMode) {
                            advanceFrameBy(1);
                        }
                        break;
                    case '-':
                        advanceFrameBy(1);
                        break;
                    case '(':
                        groupStart = frame;
                        advanceFrameBy(1);
                        break;
                    case ')':
                        groupStart = -1;
                        advanceFrameBy(1);
                        break;
                    case '|':
                        notification = COMPLETE_NOTIFICATION;
                        advanceFrameBy(1);
                        break;
                    case '^':
                        advanceFrameBy(1);
                        break;
                    case '#':
                        notification = errorNotification(errorValue || 'error');
                        advanceFrameBy(1);
                        break;
                    default:
                        if (runMode && c.match(/^[0-9]$/)) {
                            if (i === 0 || characters[i - 1] === ' ') {
                                var buffer = characters.slice(i).join('');
                                var match = buffer.match(/^([0-9]+(?:\.[0-9]+)?)(ms|s|m) /);
                                if (match) {
                                    i += match[0].length - 1;
                                    var duration = parseFloat(match[1]);
                                    var unit = match[2];
                                    var durationInMs = void 0;
                                    switch (unit) {
                                        case 'ms':
                                            durationInMs = duration;
                                            break;
                                        case 's':
                                            durationInMs = duration * 1000;
                                            break;
                                        case 'm':
                                            durationInMs = duration * 1000 * 60;
                                            break;
                                        default:
                                            break;
                                    }
                                    advanceFrameBy(durationInMs / this_2.frameTimeFactor);
                                    break;
                                }
                            }
                        }
                        notification = nextNotification(getValue(c));
                        advanceFrameBy(1);
                        break;
                }
                if (notification) {
                    testMessages.push({ frame: groupStart > -1 ? groupStart : frame, notification: notification });
                }
                frame = nextFrame;
                out_i_2 = i;
            };
            var this_2 = this, out_i_2;
            for (var i = 0; i < len; i++) {
                _loop_2(i);
                i = out_i_2;
            }
            return testMessages;
        };
        TestScheduler.prototype.createAnimator = function () {
            var _this = this;
            if (!this.runMode) {
                throw new Error('animate() must only be used in run mode');
            }
            var lastHandle = 0;
            var map;
            var delegate = {
                requestAnimationFrame: function (callback) {
                    if (!map) {
                        throw new Error('animate() was not called within run()');
                    }
                    var handle = ++lastHandle;
                    map.set(handle, callback);
                    return handle;
                },
                cancelAnimationFrame: function (handle) {
                    if (!map) {
                        throw new Error('animate() was not called within run()');
                    }
                    map.delete(handle);
                },
            };
            var animate = function (marbles) {
                var e_1, _a;
                if (map) {
                    throw new Error('animate() must not be called more than once within run()');
                }
                if (/[|#]/.test(marbles)) {
                    throw new Error('animate() must not complete or error');
                }
                map = new Map();
                var messages = TestScheduler.parseMarbles(marbles, undefined, undefined, undefined, true);
                try {
                    for (var messages_1 = __values(messages), messages_1_1 = messages_1.next(); !messages_1_1.done; messages_1_1 = messages_1.next()) {
                        var message = messages_1_1.value;
                        _this.schedule(function () {
                            var e_2, _a;
                            var now = _this.now();
                            var callbacks = Array.from(map.values());
                            map.clear();
                            try {
                                for (var callbacks_1 = (e_2 = void 0, __values(callbacks)), callbacks_1_1 = callbacks_1.next(); !callbacks_1_1.done; callbacks_1_1 = callbacks_1.next()) {
                                    var callback = callbacks_1_1.value;
                                    callback(now);
                                }
                            }
                            catch (e_2_1) { e_2 = { error: e_2_1 }; }
                            finally {
                                try {
                                    if (callbacks_1_1 && !callbacks_1_1.done && (_a = callbacks_1.return)) _a.call(callbacks_1);
                                }
                                finally { if (e_2) throw e_2.error; }
                            }
                        }, message.frame);
                    }
                }
                catch (e_1_1) { e_1 = { error: e_1_1 }; }
                finally {
                    try {
                        if (messages_1_1 && !messages_1_1.done && (_a = messages_1.return)) _a.call(messages_1);
                    }
                    finally { if (e_1) throw e_1.error; }
                }
            };
            return { animate: animate, delegate: delegate };
        };
        TestScheduler.prototype.createDelegates = function () {
            var _this = this;
            var lastHandle = 0;
            var scheduleLookup = new Map();
            var run = function () {
                var now = _this.now();
                var scheduledRecords = Array.from(scheduleLookup.values());
                var scheduledRecordsDue = scheduledRecords.filter(function (_a) {
                    var due = _a.due;
                    return due <= now;
                });
                var dueImmediates = scheduledRecordsDue.filter(function (_a) {
                    var type = _a.type;
                    return type === 'immediate';
                });
                if (dueImmediates.length > 0) {
                    var _a = dueImmediates[0], handle = _a.handle, handler = _a.handler;
                    scheduleLookup.delete(handle);
                    handler();
                    return;
                }
                var dueIntervals = scheduledRecordsDue.filter(function (_a) {
                    var type = _a.type;
                    return type === 'interval';
                });
                if (dueIntervals.length > 0) {
                    var firstDueInterval = dueIntervals[0];
                    var duration = firstDueInterval.duration, handler = firstDueInterval.handler;
                    firstDueInterval.due = now + duration;
                    firstDueInterval.subscription = _this.schedule(run, duration);
                    handler();
                    return;
                }
                var dueTimeouts = scheduledRecordsDue.filter(function (_a) {
                    var type = _a.type;
                    return type === 'timeout';
                });
                if (dueTimeouts.length > 0) {
                    var _b = dueTimeouts[0], handle = _b.handle, handler = _b.handler;
                    scheduleLookup.delete(handle);
                    handler();
                    return;
                }
                throw new Error('Expected a due immediate or interval');
            };
            var immediate = {
                setImmediate: function (handler) {
                    var handle = ++lastHandle;
                    scheduleLookup.set(handle, {
                        due: _this.now(),
                        duration: 0,
                        handle: handle,
                        handler: handler,
                        subscription: _this.schedule(run, 0),
                        type: 'immediate',
                    });
                    return handle;
                },
                clearImmediate: function (handle) {
                    var value = scheduleLookup.get(handle);
                    if (value) {
                        value.subscription.unsubscribe();
                        scheduleLookup.delete(handle);
                    }
                },
            };
            var interval = {
                setInterval: function (handler, duration) {
                    if (duration === void 0) { duration = 0; }
                    var handle = ++lastHandle;
                    scheduleLookup.set(handle, {
                        due: _this.now() + duration,
                        duration: duration,
                        handle: handle,
                        handler: handler,
                        subscription: _this.schedule(run, duration),
                        type: 'interval',
                    });
                    return handle;
                },
                clearInterval: function (handle) {
                    var value = scheduleLookup.get(handle);
                    if (value) {
                        value.subscription.unsubscribe();
                        scheduleLookup.delete(handle);
                    }
                },
            };
            var timeout = {
                setTimeout: function (handler, duration) {
                    if (duration === void 0) { duration = 0; }
                    var handle = ++lastHandle;
                    scheduleLookup.set(handle, {
                        due: _this.now() + duration,
                        duration: duration,
                        handle: handle,
                        handler: handler,
                        subscription: _this.schedule(run, duration),
                        type: 'timeout',
                    });
                    return handle;
                },
                clearTimeout: function (handle) {
                    var value = scheduleLookup.get(handle);
                    if (value) {
                        value.subscription.unsubscribe();
                        scheduleLookup.delete(handle);
                    }
                },
            };
            return { immediate: immediate, interval: interval, timeout: timeout };
        };
        TestScheduler.prototype.run = function (callback) {
            var prevFrameTimeFactor = TestScheduler.frameTimeFactor;
            var prevMaxFrames = this.maxFrames;
            TestScheduler.frameTimeFactor = 1;
            this.maxFrames = Infinity;
            this.runMode = true;
            var animator = this.createAnimator();
            var delegates = this.createDelegates();
            animationFrameProvider.delegate = animator.delegate;
            dateTimestampProvider.delegate = this;
            immediateProvider.delegate = delegates.immediate;
            intervalProvider.delegate = delegates.interval;
            timeoutProvider.delegate = delegates.timeout;
            performanceTimestampProvider.delegate = this;
            var helpers = {
                cold: this.createColdObservable.bind(this),
                hot: this.createHotObservable.bind(this),
                flush: this.flush.bind(this),
                time: this.createTime.bind(this),
                expectObservable: this.expectObservable.bind(this),
                expectSubscriptions: this.expectSubscriptions.bind(this),
                animate: animator.animate,
            };
            try {
                var ret = callback(helpers);
                this.flush();
                return ret;
            }
            finally {
                TestScheduler.frameTimeFactor = prevFrameTimeFactor;
                this.maxFrames = prevMaxFrames;
                this.runMode = false;
                animationFrameProvider.delegate = undefined;
                dateTimestampProvider.delegate = undefined;
                immediateProvider.delegate = undefined;
                intervalProvider.delegate = undefined;
                timeoutProvider.delegate = undefined;
                performanceTimestampProvider.delegate = undefined;
            }
        };
        TestScheduler.frameTimeFactor = 10;
        return TestScheduler;
    }(VirtualTimeScheduler));



    var _testing = /*#__PURE__*/Object.freeze({
        TestScheduler: TestScheduler
    });

    /**
     * Retrieves the response from an XMLHttpRequest object based on its responseType.
     *
     * @param {XMLHttpRequest} xhr - The XMLHttpRequest object to retrieve the response from.
     * @return {*} The parsed response data.
     *
     * @throws {Error} If an unsupported responseType is provided.
     */
    function getXHRResponse(xhr) {
        switch (xhr.responseType) {
            case 'json': {
                if ('response' in xhr) {
                    return xhr.response;
                }
                else {
                    var ieXHR = xhr;
                    return JSON.parse(ieXHR.responseText);
                }
            }
            case 'document':
                return xhr.responseXML;
            case 'text':
            default: {
                if ('response' in xhr) {
                    return xhr.response;
                }
                else {
                    var ieXHR = xhr;
                    return ieXHR.responseText;
                }
            }
        }
    }

    var AjaxResponse = (function () {
        /**
         * Represents an AJAX response object containing various details about the request and response.
         *
         * @constructor
         * @param {Event} originalEvent - The original event triggered by the AJAX request.
         * @param {XMLHttpRequest} xhr - The XMLHttpRequest object used for making the AJAX request.
         * @param {Object} request - The configuration object passed to the AJAX request.
         * @param {string} [type='download_load'] - The type of the AJAX response, defaults to 'download_load'.
         *
         * @property {Event} originalEvent - The original event triggered by the AJAX request.
         * @property {XMLHttpRequest} xhr - The XMLHttpRequest object used for making the AJAX request.
         * @property {Object} request - The configuration object passed to the AJAX request.
         * @property {string} type - The type of the AJAX response.
         * @property {number} status - The HTTP status code of the response.
         * @property {string} responseType - The response type (e.g., 'text', 'json').
         * @property {Object} responseHeaders - An object containing all response headers.
         * @property {*} response - The parsed response data.
         * @property {number} loaded - The number of bytes that have been transferred.
         * @property {number} total - The total size of the resource being downloaded.
         *
         * @example
         * var xhr = new XMLHttpRequest();
         * xhr.open('GET', 'https://api.example.com/data');
         * xhr.onload = function() {
         *   if (xhr.status === 200) {
         *     var response = new AjaxResponse(xhr.onloadEvent, xhr, { method: 'GET' });
         *     console.log(response.response);
         *   }
         * };
         * xhr.send();
         */
        function AjaxResponse(originalEvent, xhr, request, type) {
            if (type === void 0) { type = 'download_load'; }
            this.originalEvent = originalEvent;
            this.xhr = xhr;
            this.request = request;
            this.type = type;
            var status = xhr.status, responseType = xhr.responseType;
            this.status = status !== null && status !== void 0 ? status : 0;
            this.responseType = responseType !== null && responseType !== void 0 ? responseType : '';
            var allHeaders = xhr.getAllResponseHeaders();
            this.responseHeaders = allHeaders
                ?
                    allHeaders.split('\n').reduce(function (headers, line) {
                        var index = line.indexOf(': ');
                        headers[line.slice(0, index)] = line.slice(index + 2);
                        return headers;
                    }, {})
                : {};
            this.response = getXHRResponse(xhr);
            var loaded = originalEvent.loaded, total = originalEvent.total;
            this.loaded = loaded;
            this.total = total;
        }
        return AjaxResponse;
    }());

    var AjaxError = createErrorClass(function (_super) {
        return function AjaxErrorImpl(message, xhr, request) {
            this.message = message;
            this.name = 'AjaxError';
            this.xhr = xhr;
            this.request = request;
            this.status = xhr.status;
            this.responseType = xhr.responseType;
            var response;
            try {
                response = getXHRResponse(xhr);
            }
            catch (err) {
                response = xhr.responseText;
            }
            this.response = response;
        };
    });
    var AjaxTimeoutError = (function () {
        /**
         * Implements an error handler for AJAX timeout errors.
         *
         * @constructor
         * @extends {AjaxError}
         * @param {string} message - The error message associated with the timeout.
         * @param {XMLHttpRequest} xhr - The XMLHttpRequest object that triggered the error.
         * @param {Object} request - The request configuration that caused the error.
         */
        function AjaxTimeoutErrorImpl(xhr, request) {
            AjaxError.call(this, 'ajax timeout', xhr, request);
            this.name = 'AjaxTimeoutError';
            return this;
        }
        AjaxTimeoutErrorImpl.prototype = Object.create(AjaxError.prototype);
        return AjaxTimeoutErrorImpl;
    })();

    /**
     * Performs an AJAX GET request to the specified URL with custom headers.
     *
     * @param {string} url - The URL to which the GET request is sent.
     * @param {Object} [headers] - Optional object containing custom HTTP headers to send with the request.
     * @returns {Promise<Object>} A Promise that resolves with the response data from the server.
     * @throws {Error} If an error occurs during the AJAX request.
     *
     * Example usage:
     * ajaxGet('https://api.example.com/data', { 'Authorization': 'Bearer token' })
     *   .then(response => console.log(response))
     *   .catch(error => console.error(error));
     */
    function ajaxGet(url, headers) {
        return ajax({ method: 'GET', url: url, headers: headers });
    }
    /**
     * Sends an HTTP POST request to the specified URL with the provided body and headers.
     *
     * @param {string} url - The URL to which the request is sent.
     * @param {Object} body - The data to be sent as the request body. This can be a JSON object or any other format.
     * @param {Object} [headers] - Optional headers to include in the request. Each key-value pair represents a header field and its value.
     * @returns {Promise<Object>} A promise that resolves with the response data if the request is successful, or rejects with an error if it fails.
     *
     * @example
     * ajaxPost('https://api.example.com/data', { name: 'John', age: 30 }, { 'Content-Type': 'application/json' })
     *   .then(response => {
     *     console.log(response);
     *   })
     *   .catch(error => {
     *     console.error(error);
     *   });
     */
    function ajaxPost(url, body, headers) {
        return ajax({ method: 'POST', url: url, body: body, headers: headers });
    }
    /**
     * Sends an HTTP DELETE request to the specified URL with optional headers.
     *
     * @param {string} url - The URL to send the DELETE request to.
     * @param {Object} [headers] - Optional object containing custom headers for the request.
     * @returns {Promise} - A Promise that resolves with the response from the server or rejects with an error.
     *
     * @example
     * ajaxDelete('https://api.example.com/resource')
     *   .then(response => {
     *     console.log('Resource deleted:', response);
     *   })
     *   .catch(error => {
     *     console.error('Error deleting resource:', error);
     *   });
     *
     * @example
     * ajaxDelete('https://api.example.com/resource', { 'Authorization': 'Bearer token' })
     *   .then(response => {
     *     console.log('Resource deleted with custom headers:', response);
     *   })
     *   .catch(error => {
     *     console.error('Error deleting resource with custom headers:', error);
     *   });
     */
    function ajaxDelete(url, headers) {
        return ajax({ method: 'DELETE', url: url, headers: headers });
    }
    /**
     * Sends an HTTP PUT request using the provided URL, body, and headers.
     *
     * @param {string} url - The URL to which the PUT request is sent.
     * @param {Object} body - The data to be sent as the body of the request.
     * @param {Object} [headers={}] - Optional headers for the request.
     * @returns {Promise<Object>} A promise that resolves with the response object.
     *
     * @example
     * ajaxPut('https://api.example.com/data', { key: 'value' })
     *   .then(response => console.log(response))
     *   .catch(error => console.error(error));
     */
    function ajaxPut(url, body, headers) {
        return ajax({ method: 'PUT', url: url, body: body, headers: headers });
    }
    /**
     * Sends an HTTP PATCH request to the specified URL with the given body and headers.
     *
     * @param {string} url - The URL to which the request is sent.
     * @param {*} body - The data to be sent in the body of the request. Must be a JSON-serializable object or string.
     * @param {Object} [headers={}] - An optional object containing HTTP headers to be included in the request.
     * @returns {Promise} - A promise that resolves with the response from the server.
     * @throws {Error} - Throws an error if the AJAX request fails.
     *
     * @example
     * ajaxPatch('/api/resource', { key: 'value' }, { 'Content-Type': 'application/json' })
     *   .then(response => console.log(response))
     *   .catch(error => console.error(error));
     */
    function ajaxPatch(url, body, headers) {
        return ajax({ method: 'PATCH', url: url, body: body, headers: headers });
    }
    var mapResponse = map(function (x) { return x.response; });
    /**
     * Performs an AJAX GET request to fetch JSON data from the specified URL with custom headers.
     *
     * @param {string} url - The URL to send the GET request to.
     * @param {Object} [headers] - An object containing custom HTTP headers for the request. Defaults to an empty object if not provided.
     * @returns {Promise<Object>} A promise that resolves with the JSON response data or rejects with an error.
     *
     * @example
     * ajaxGetJSON('https://api.example.com/data', { 'Authorization': 'Bearer token' })
     *   .then(data => console.log(data))
     *   .catch(error => console.error(error));
     */
    function ajaxGetJSON(url, headers) {
        return mapResponse(ajax({
            method: 'GET',
            url: url,
            headers: headers,
        }));
    }
    var ajax = (function () {
        var create = function (urlOrConfig) {
            var config = typeof urlOrConfig === 'string'
                ? {
                    url: urlOrConfig,
                }
                : urlOrConfig;
            return fromAjax(config);
        };
        create.get = ajaxGet;
        create.post = ajaxPost;
        create.delete = ajaxDelete;
        create.put = ajaxPut;
        create.patch = ajaxPatch;
        create.getJSON = ajaxGetJSON;
        return create;
    })();
    var UPLOAD = 'upload';
    var DOWNLOAD = 'download';
    var LOADSTART = 'loadstart';
    var PROGRESS = 'progress';
    var LOAD = 'load';
    /**
     * Creates an Observable that sends an HTTP request using XMLHttpRequest.
     *
     * @param {Object} init - Configuration object for the AJAX request.
     * @param {string} [init.url] - The URL to which the request is sent. Required.
     * @param {Object} [init.queryParams] - Query parameters to be appended to the URL.
     * @param {*} [init.body] - Body of the request, if applicable.
     * @param {Object} [init.headers] - Custom headers for the request.
     * @param {boolean} [init.async=true] - Whether the request is asynchronous.
     * @param {boolean} [init.crossDomain=false] - Indicates cross-domain requests.
     * @param {boolean} [init.withCredentials=false] - Include user credentials in cross-origin requests.
     * @param {string} [init.responseType='text'] - Expected response type.
     * @param {number} [init.timeout=0] - Timeout for the request, in milliseconds.
     * @param {Object} [init.user] - User credentials for authentication.
     * @param {boolean} [includeUploadProgress=false] - Include progress events for uploading data.
     * @param {Object} [progressSubscriber] - Subscriber to handle progress events.
     *
     * @returns {Observable<AjaxResponse>} An Observable that emits the response from the server.
     */
    function fromAjax(init) {
        return new Observable(function (destination) {
            var _a, _b;
            var config = __assign({ async: true, crossDomain: false, withCredentials: false, method: 'GET', timeout: 0, responseType: 'json' }, init);
            var queryParams = config.queryParams, configuredBody = config.body, configuredHeaders = config.headers;
            var url = config.url;
            if (!url) {
                throw new TypeError('url is required');
            }
            if (queryParams) {
                var searchParams_1;
                if (url.includes('?')) {
                    var parts = url.split('?');
                    if (2 < parts.length) {
                        throw new TypeError('invalid url');
                    }
                    searchParams_1 = new URLSearchParams(parts[1]);
                    new URLSearchParams(queryParams).forEach(function (value, key) { return searchParams_1.set(key, value); });
                    url = parts[0] + '?' + searchParams_1;
                }
                else {
                    searchParams_1 = new URLSearchParams(queryParams);
                    url = url + '?' + searchParams_1;
                }
            }
            var headers = {};
            if (configuredHeaders) {
                for (var key in configuredHeaders) {
                    if (configuredHeaders.hasOwnProperty(key)) {
                        headers[key.toLowerCase()] = configuredHeaders[key];
                    }
                }
            }
            var crossDomain = config.crossDomain;
            if (!crossDomain && !('x-requested-with' in headers)) {
                headers['x-requested-with'] = 'XMLHttpRequest';
            }
            var withCredentials = config.withCredentials, xsrfCookieName = config.xsrfCookieName, xsrfHeaderName = config.xsrfHeaderName;
            if ((withCredentials || !crossDomain) && xsrfCookieName && xsrfHeaderName) {
                var xsrfCookie = (_b = (_a = document === null || document === void 0 ? void 0 : document.cookie.match(new RegExp("(^|;\\s*)(" + xsrfCookieName + ")=([^;]*)"))) === null || _a === void 0 ? void 0 : _a.pop()) !== null && _b !== void 0 ? _b : '';
                if (xsrfCookie) {
                    headers[xsrfHeaderName] = xsrfCookie;
                }
            }
            var body = extractContentTypeAndMaybeSerializeBody(configuredBody, headers);
            var _request = __assign(__assign({}, config), { url: url,
                headers: headers,
                body: body });
            var xhr;
            xhr = init.createXHR ? init.createXHR() : new XMLHttpRequest();
            {
                var progressSubscriber_1 = init.progressSubscriber, _c = init.includeDownloadProgress, includeDownloadProgress = _c === void 0 ? false : _c, _d = init.includeUploadProgress, includeUploadProgress = _d === void 0 ? false : _d;
                var addErrorEvent = function (type, errorFactory) {
                    xhr.addEventListener(type, function () {
                        var _a;
                        var error = errorFactory();
                        (_a = progressSubscriber_1 === null || progressSubscriber_1 === void 0 ? void 0 : progressSubscriber_1.error) === null || _a === void 0 ? void 0 : _a.call(progressSubscriber_1, error);
                        destination.error(error);
                    });
                };
                addErrorEvent('timeout', function () { return new AjaxTimeoutError(xhr, _request); });
                addErrorEvent('abort', function () { return new AjaxError('aborted', xhr, _request); });
                var createResponse_1 = function (direction, event) {
                    return new AjaxResponse(event, xhr, _request, direction + "_" + event.type);
                };
                var addProgressEvent_1 = function (target, type, direction) {
                    target.addEventListener(type, function (event) {
                        destination.next(createResponse_1(direction, event));
                    });
                };
                if (includeUploadProgress) {
                    [LOADSTART, PROGRESS, LOAD].forEach(function (type) { return addProgressEvent_1(xhr.upload, type, UPLOAD); });
                }
                if (progressSubscriber_1) {
                    [LOADSTART, PROGRESS].forEach(function (type) { return xhr.upload.addEventListener(type, function (e) { var _a; return (_a = progressSubscriber_1 === null || progressSubscriber_1 === void 0 ? void 0 : progressSubscriber_1.next) === null || _a === void 0 ? void 0 : _a.call(progressSubscriber_1, e); }); });
                }
                if (includeDownloadProgress) {
                    [LOADSTART, PROGRESS].forEach(function (type) { return addProgressEvent_1(xhr, type, DOWNLOAD); });
                }
                var emitError_1 = function (status) {
                    var msg = 'ajax error' + (status ? ' ' + status : '');
                    destination.error(new AjaxError(msg, xhr, _request));
                };
                xhr.addEventListener('error', function (e) {
                    var _a;
                    (_a = progressSubscriber_1 === null || progressSubscriber_1 === void 0 ? void 0 : progressSubscriber_1.error) === null || _a === void 0 ? void 0 : _a.call(progressSubscriber_1, e);
                    emitError_1();
                });
                xhr.addEventListener(LOAD, function (event) {
                    var _a, _b;
                    var status = xhr.status;
                    if (status < 400) {
                        (_a = progressSubscriber_1 === null || progressSubscriber_1 === void 0 ? void 0 : progressSubscriber_1.complete) === null || _a === void 0 ? void 0 : _a.call(progressSubscriber_1);
                        var response = void 0;
                        try {
                            response = createResponse_1(DOWNLOAD, event);
                        }
                        catch (err) {
                            destination.error(err);
                            return;
                        }
                        destination.next(response);
                        destination.complete();
                    }
                    else {
                        (_b = progressSubscriber_1 === null || progressSubscriber_1 === void 0 ? void 0 : progressSubscriber_1.error) === null || _b === void 0 ? void 0 : _b.call(progressSubscriber_1, event);
                        emitError_1(status);
                    }
                });
            }
            var user = _request.user, method = _request.method, async = _request.async;
            if (user) {
                xhr.open(method, url, async, user, _request.password);
            }
            else {
                xhr.open(method, url, async);
            }
            if (async) {
                xhr.timeout = _request.timeout;
                xhr.responseType = _request.responseType;
            }
            if ('withCredentials' in xhr) {
                xhr.withCredentials = _request.withCredentials;
            }
            for (var key in headers) {
                if (headers.hasOwnProperty(key)) {
                    xhr.setRequestHeader(key, headers[key]);
                }
            }
            if (body) {
                xhr.send(body);
            }
            else {
                xhr.send();
            }
            return function () {
                if (xhr && xhr.readyState !== 4) {
                    xhr.abort();
                }
            };
        });
    }
    /**
     * Extracts content type from headers or serializes body if necessary.
     *
     * This function checks the type of the provided body and determines if it needs to be serialized.
     * If the body is already a string, Blob, ArrayBuffer, FormData, URLSearchParams, or ReadableStream,
     * it returns the body as is. For other object types, it sets the content-type header to 'application/json;charset=utf-8'
     * (if not already set) and serializes the object to JSON.
     *
     * @param {any} body - The body of the request or response.
     * @param {Object} headers - Headers to be included with the request or response.
     * @returns {any} - The original body if it doesn't need serialization, or a serialized version otherwise.
     * @throws {TypeError} - If the body type is unknown and cannot be processed.
     *
     * @example
     * // Example usage:
     * let result = extractContentTypeAndMaybeSerializeBody({key: 'value'}, {});
     * console.log(result); // Should log: '{"key":"value"}'
     */
    function extractContentTypeAndMaybeSerializeBody(body, headers) {
        var _a;
        if (!body ||
            typeof body === 'string' ||
            isFormData(body) ||
            isURLSearchParams(body) ||
            isArrayBuffer(body) ||
            isFile(body) ||
            isBlob(body) ||
            isReadableStream(body)) {
            return body;
        }
        if (isArrayBufferView(body)) {
            return body.buffer;
        }
        if (typeof body === 'object') {
            headers['content-type'] = (_a = headers['content-type']) !== null && _a !== void 0 ? _a : 'application/json;charset=utf-8';
            return JSON.stringify(body);
        }
        throw new TypeError('Unknown body type');
    }
    var _toString = Object.prototype.toString;
    function toStringCheck(obj, name) {
        return _toString.call(obj) === "[object " + name + "]";
    }
    /**
     * Checks if the provided body is an ArrayBuffer.
     *
     * @param {any} body - The item to check.
     * @returns {boolean} - Returns true if the body is an ArrayBuffer, false otherwise.
     */
    function isArrayBuffer(body) {
        return toStringCheck(body, 'ArrayBuffer');
    }
    /**
     * Checks if the provided body is of type 'File'.
     *
     * @param {any} body - The body to check.
     * @returns {boolean} - Returns true if the body is a File, false otherwise.
     * @throws {TypeError} - Throws an error if the input is not defined or null.
     */
    function isFile(body) {
        return toStringCheck(body, 'File');
    }
    function isBlob(body) {
        return toStringCheck(body, 'Blob');
    }
    /**
     * Checks if the provided body is an instance of ArrayBufferView.
     *
     * @param {any} body - The object to check.
     * @returns {boolean} - Returns true if `body` is an instance of ArrayBufferView, false otherwise.
     * @throws {TypeError} - Throws an error if `ArrayBuffer` is not defined in the global scope.
     *
     * Example:
     *   const arrayBuffer = new Uint8Array(16);
     *   console.log(isArrayBufferView(arrayBuffer)); // true
     */
    function isArrayBufferView(body) {
        return typeof ArrayBuffer !== 'undefined' && ArrayBuffer.isView(body);
    }
    /**
     * Checks if the provided body is an instance of FormData.
     *
     * @param {any} body - The body to check.
     * @returns {boolean} - Returns true if the body is an instance of FormData, otherwise false.
     *
     * Example usage:
     * const formData = new FormData();
     * console.log(isFormData(formData)); // Output: true
     */
    function isFormData(body) {
        return typeof FormData !== 'undefined' && body instanceof FormData;
    }
    function isURLSearchParams(body) {
        return typeof URLSearchParams !== 'undefined' && body instanceof URLSearchParams;
    }
    /**
     * Checks if the provided body is an instance of ReadableStream.
     *
     * @param {any} body - The body to check.
     * @returns {boolean} - True if the body is a ReadableStream, false otherwise.
     */
    function isReadableStream(body) {
        return typeof ReadableStream !== 'undefined' && body instanceof ReadableStream;
    }



    var _ajax = /*#__PURE__*/Object.freeze({
        ajax: ajax,
        AjaxError: AjaxError,
        AjaxTimeoutError: AjaxTimeoutError,
        AjaxResponse: AjaxResponse
    });

    var DEFAULT_WEBSOCKET_CONFIG = {
        url: '',
        deserializer: function (e) { return JSON.parse(e.data); },
        serializer: function (value) { return JSON.stringify(value); },
    };
    var WEBSOCKETSUBJECT_INVALID_ERROR_OBJECT = 'WebSocketSubject.error must be called with an object with an error code, and an optional reason: { code: number, reason: string }';
    var WebSocketSubject = (function (_super) {
        __extends(WebSocketSubject, _super);
        /**
         * A Subject implementation that allows messages to be sent from a WebSocket connection.
         *
         * @param {string|Observable} urlConfigOrSource - The URL of the WebSocket or an Observable as the source.
         * @param {Subject} [destination] - Optional destination subject for the WebSocket messages.
         */
        function WebSocketSubject(urlConfigOrSource, destination) {
            var _this = _super.call(this) || this;
            _this._socket = null;
            if (urlConfigOrSource instanceof Observable) {
                _this.destination = destination;
                _this.source = urlConfigOrSource;
            }
            else {
                var config = (_this._config = __assign({}, DEFAULT_WEBSOCKET_CONFIG));
                _this._output = new Subject();
                if (typeof urlConfigOrSource === 'string') {
                    config.url = urlConfigOrSource;
                }
                else {
                    for (var key in urlConfigOrSource) {
                        if (urlConfigOrSource.hasOwnProperty(key)) {
                            config[key] = urlConfigOrSource[key];
                        }
                    }
                }
                if (!config.WebSocketCtor && WebSocket) {
                    config.WebSocketCtor = WebSocket;
                }
                else if (!config.WebSocketCtor) {
                    throw new Error('no WebSocket constructor can be found');
                }
                _this.destination = new ReplaySubject();
            }
            return _this;
        }
        WebSocketSubject.prototype.lift = function (operator) {
            var sock = new WebSocketSubject(this._config, this.destination);
            sock.operator = operator;
            sock.source = this;
            return sock;
        };
        WebSocketSubject.prototype._resetState = function () {
            this._socket = null;
            if (!this.source) {
                this.destination = new ReplaySubject();
            }
            this._output = new Subject();
        };
        WebSocketSubject.prototype.multiplex = function (subMsg, unsubMsg, messageFilter) {
            var self = this;
            return new Observable(function (observer) {
                try {
                    self.next(subMsg());
                }
                catch (err) {
                    observer.error(err);
                }
                var subscription = self.subscribe({
                    next: function (x) {
                        try {
                            if (messageFilter(x)) {
                                observer.next(x);
                            }
                        }
                        catch (err) {
                            observer.error(err);
                        }
                    },
                    error: function (err) { return observer.error(err); },
                    complete: function () { return observer.complete(); },
                });
                return function () {
                    try {
                        self.next(unsubMsg());
                    }
                    catch (err) {
                        observer.error(err);
                    }
                    subscription.unsubscribe();
                };
            });
        };
        WebSocketSubject.prototype._connectSocket = function () {
            var _this = this;
            var _a = this._config, WebSocketCtor = _a.WebSocketCtor, protocol = _a.protocol, url = _a.url, binaryType = _a.binaryType;
            var observer = this._output;
            var socket = null;
            try {
                socket = protocol ? new WebSocketCtor(url, protocol) : new WebSocketCtor(url);
                this._socket = socket;
                if (binaryType) {
                    this._socket.binaryType = binaryType;
                }
            }
            catch (e) {
                observer.error(e);
                return;
            }
            var subscription = new Subscription(function () {
                _this._socket = null;
                if (socket && socket.readyState === 1) {
                    socket.close();
                }
            });
            socket.onopen = function (evt) {
                var _socket = _this._socket;
                if (!_socket) {
                    socket.close();
                    _this._resetState();
                    return;
                }
                var openObserver = _this._config.openObserver;
                if (openObserver) {
                    openObserver.next(evt);
                }
                var queue = _this.destination;
                _this.destination = Subscriber.create(function (x) {
                    if (socket.readyState === 1) {
                        try {
                            var serializer = _this._config.serializer;
                            socket.send(serializer(x));
                        }
                        catch (e) {
                            _this.destination.error(e);
                        }
                    }
                }, function (err) {
                    var closingObserver = _this._config.closingObserver;
                    if (closingObserver) {
                        closingObserver.next(undefined);
                    }
                    if (err && err.code) {
                        socket.close(err.code, err.reason);
                    }
                    else {
                        observer.error(new TypeError(WEBSOCKETSUBJECT_INVALID_ERROR_OBJECT));
                    }
                    _this._resetState();
                }, function () {
                    var closingObserver = _this._config.closingObserver;
                    if (closingObserver) {
                        closingObserver.next(undefined);
                    }
                    socket.close();
                    _this._resetState();
                });
                if (queue && queue instanceof ReplaySubject) {
                    subscription.add(queue.subscribe(_this.destination));
                }
            };
            socket.onerror = function (e) {
                _this._resetState();
                observer.error(e);
            };
            socket.onclose = function (e) {
                if (socket === _this._socket) {
                    _this._resetState();
                }
                var closeObserver = _this._config.closeObserver;
                if (closeObserver) {
                    closeObserver.next(e);
                }
                if (e.wasClean) {
                    observer.complete();
                }
                else {
                    observer.error(e);
                }
            };
            socket.onmessage = function (e) {
                try {
                    var deserializer = _this._config.deserializer;
                    observer.next(deserializer(e));
                }
                catch (err) {
                    observer.error(err);
                }
            };
        };
        WebSocketSubject.prototype._subscribe = function (subscriber) {
            var _this = this;
            var source = this.source;
            if (source) {
                return source.subscribe(subscriber);
            }
            if (!this._socket) {
                this._connectSocket();
            }
            this._output.subscribe(subscriber);
            subscriber.add(function () {
                var _socket = _this._socket;
                if (_this._output.observers.length === 0) {
                    if (_socket && (_socket.readyState === 1 || _socket.readyState === 0)) {
                        _socket.close();
                    }
                    _this._resetState();
                }
            });
            return subscriber;
        };
        WebSocketSubject.prototype.unsubscribe = function () {
            var _socket = this._socket;
            if (_socket && (_socket.readyState === 1 || _socket.readyState === 0)) {
                _socket.close();
            }
            this._resetState();
            _super.prototype.unsubscribe.call(this);
        };
        return WebSocketSubject;
    }(AnonymousSubject));

    /**
     * Creates a WebSocketSubject to manage WebSocket connections.
     *
     * @function webSocket
     * @param {string|Object} urlConfigOrSource - The URL of the WebSocket server or an object containing configuration details.
     * @returns {WebSocketSubject} A new instance of WebSocketSubject configured with the provided URL or source.
     *
     * @example
     * const wsSubject = webSocket('ws://example.com/socket');
     */
    function webSocket(urlConfigOrSource) {
        return new WebSocketSubject(urlConfigOrSource);
    }



    var _webSocket = /*#__PURE__*/Object.freeze({
        webSocket: webSocket,
        WebSocketSubject: WebSocketSubject
    });

    /**
     * Creates an Observable that emits the result of fetching data from a specified URL.
     *
     * @param {string|Request} input - The URL or Request object to fetch data from.
     * @param {Object} [initWithSelector={}] - Options for initializing the Observable with a selector function.
     * @param {function} [initWithSelector.selector] - A function that takes the response and returns an Observable of the desired data.
     * @param {AbortSignal} [initWithSelector.signal] - An optional AbortSignal to abort the fetch operation.
     *
     * @returns {Observable<Response|any>} An Observable that emits either the raw Response or the selected data.
     *
     * @example
     * const fetchData = fromFetch('https://api.example.com/data', {
     *   selector: (response) => response.json()
     * });
     *
     * fetchData.subscribe({
     *   next: (data) => console.log(data),
     *   error: (err) => console.error(err)
     * });
     */
    function fromFetch(input, initWithSelector) {
        if (initWithSelector === void 0) { initWithSelector = {}; }
        var selector = initWithSelector.selector, init = __rest(initWithSelector, ["selector"]);
        return new Observable(function (subscriber) {
            var controller = new AbortController();
            var signal = controller.signal;
            var abortable = true;
            var outerSignal = init.signal;
            if (outerSignal) {
                if (outerSignal.aborted) {
                    controller.abort();
                }
                else {
                    var outerSignalHandler_1 = function () {
                        if (!signal.aborted) {
                            controller.abort();
                        }
                    };
                    outerSignal.addEventListener('abort', outerSignalHandler_1);
                    subscriber.add(function () { return outerSignal.removeEventListener('abort', outerSignalHandler_1); });
                }
            }
            var perSubscriberInit = __assign(__assign({}, init), { signal: signal });
            var handleError = function (err) {
                abortable = false;
                subscriber.error(err);
            };
            fetch(input, perSubscriberInit)
                .then(function (response) {
                if (selector) {
                    innerFrom(selector(response)).subscribe(createOperatorSubscriber(subscriber, undefined, function () {
                        abortable = false;
                        subscriber.complete();
                    }, handleError));
                }
                else {
                    abortable = false;
                    subscriber.next(response);
                    subscriber.complete();
                }
            })
                .catch(handleError);
            return function () {
                if (abortable) {
                    controller.abort();
                }
            };
        });
    }



    var _fetch = /*#__PURE__*/Object.freeze({
        fromFetch: fromFetch
    });

    var operators = _operators;
    var testing = _testing;
    var ajax$1 = _ajax;
    var webSocket$1 = _webSocket;
    var fetch$1 = _fetch;

    exports.operators = operators;
    exports.testing = testing;
    exports.ajax = ajax$1;
    exports.webSocket = webSocket$1;
    exports.fetch = fetch$1;
    exports.Observable = Observable;
    exports.ConnectableObservable = ConnectableObservable;
    exports.observable = observable;
    exports.animationFrames = animationFrames;
    exports.Subject = Subject;
    exports.BehaviorSubject = BehaviorSubject;
    exports.ReplaySubject = ReplaySubject;
    exports.AsyncSubject = AsyncSubject;
    exports.asap = asap;
    exports.asapScheduler = asapScheduler;
    exports.async = async;
    exports.asyncScheduler = asyncScheduler;
    exports.queue = queue;
    exports.queueScheduler = queueScheduler;
    exports.animationFrame = animationFrame;
    exports.animationFrameScheduler = animationFrameScheduler;
    exports.VirtualTimeScheduler = VirtualTimeScheduler;
    exports.VirtualAction = VirtualAction;
    exports.Scheduler = Scheduler;
    exports.Subscription = Subscription;
    exports.Subscriber = Subscriber;
    exports.Notification = Notification;
    exports.pipe = pipe;
    exports.noop = noop;
    exports.identity = identity;
    exports.isObservable = isObservable;
    exports.lastValueFrom = lastValueFrom;
    exports.firstValueFrom = firstValueFrom;
    exports.ArgumentOutOfRangeError = ArgumentOutOfRangeError;
    exports.EmptyError = EmptyError;
    exports.NotFoundError = NotFoundError;
    exports.ObjectUnsubscribedError = ObjectUnsubscribedError;
    exports.SequenceError = SequenceError;
    exports.TimeoutError = TimeoutError;
    exports.UnsubscriptionError = UnsubscriptionError;
    exports.bindCallback = bindCallback;
    exports.bindNodeCallback = bindNodeCallback;
    exports.combineLatest = combineLatest;
    exports.concat = concat;
    exports.connectable = connectable;
    exports.defer = defer;
    exports.empty = empty;
    exports.forkJoin = forkJoin;
    exports.from = from;
    exports.fromEvent = fromEvent;
    exports.fromEventPattern = fromEventPattern;
    exports.generate = generate;
    exports.iif = iif;
    exports.interval = interval;
    exports.merge = merge;
    exports.never = never;
    exports.of = of;
    exports.onErrorResumeNext = onErrorResumeNext;
    exports.pairs = pairs;
    exports.partition = partition;
    exports.race = race;
    exports.range = range;
    exports.throwError = throwError;
    exports.timer = timer;
    exports.using = using;
    exports.zip = zip;
    exports.scheduled = scheduled;
    exports.EMPTY = EMPTY;
    exports.NEVER = NEVER;
    exports.config = config;
    exports.audit = audit;
    exports.auditTime = auditTime;
    exports.buffer = buffer;
    exports.bufferCount = bufferCount;
    exports.bufferTime = bufferTime;
    exports.bufferToggle = bufferToggle;
    exports.bufferWhen = bufferWhen;
    exports.catchError = catchError;
    exports.combineAll = combineAll;
    exports.combineLatestAll = combineLatestAll;
    exports.combineLatestWith = combineLatestWith;
    exports.concatAll = concatAll;
    exports.concatMap = concatMap;
    exports.concatMapTo = concatMapTo;
    exports.concatWith = concatWith;
    exports.connect = connect;
    exports.count = count;
    exports.debounce = debounce;
    exports.debounceTime = debounceTime;
    exports.defaultIfEmpty = defaultIfEmpty;
    exports.delay = delay;
    exports.delayWhen = delayWhen;
    exports.dematerialize = dematerialize;
    exports.distinct = distinct;
    exports.distinctUntilChanged = distinctUntilChanged;
    exports.distinctUntilKeyChanged = distinctUntilKeyChanged;
    exports.elementAt = elementAt;
    exports.endWith = endWith;
    exports.every = every;
    exports.exhaust = exhaust;
    exports.exhaustAll = exhaustAll;
    exports.exhaustMap = exhaustMap;
    exports.expand = expand;
    exports.filter = filter;
    exports.finalize = finalize;
    exports.find = find;
    exports.findIndex = findIndex;
    exports.first = first;
    exports.groupBy = groupBy;
    exports.ignoreElements = ignoreElements;
    exports.isEmpty = isEmpty;
    exports.last = last$1;
    exports.map = map;
    exports.mapTo = mapTo;
    exports.materialize = materialize;
    exports.max = max;
    exports.mergeAll = mergeAll;
    exports.flatMap = flatMap;
    exports.mergeMap = mergeMap;
    exports.mergeMapTo = mergeMapTo;
    exports.mergeScan = mergeScan;
    exports.mergeWith = mergeWith;
    exports.min = min;
    exports.multicast = multicast;
    exports.observeOn = observeOn;
    exports.onErrorResumeNextWith = onErrorResumeNextWith;
    exports.pairwise = pairwise;
    exports.pluck = pluck;
    exports.publish = publish;
    exports.publishBehavior = publishBehavior;
    exports.publishLast = publishLast;
    exports.publishReplay = publishReplay;
    exports.raceWith = raceWith;
    exports.reduce = reduce;
    exports.repeat = repeat;
    exports.repeatWhen = repeatWhen;
    exports.retry = retry;
    exports.retryWhen = retryWhen;
    exports.refCount = refCount;
    exports.sample = sample;
    exports.sampleTime = sampleTime;
    exports.scan = scan;
    exports.sequenceEqual = sequenceEqual;
    exports.share = share;
    exports.shareReplay = shareReplay;
    exports.single = single;
    exports.skip = skip;
    exports.skipLast = skipLast;
    exports.skipUntil = skipUntil;
    exports.skipWhile = skipWhile;
    exports.startWith = startWith;
    exports.subscribeOn = subscribeOn;
    exports.switchAll = switchAll;
    exports.switchMap = switchMap;
    exports.switchMapTo = switchMapTo;
    exports.switchScan = switchScan;
    exports.take = take;
    exports.takeLast = takeLast;
    exports.takeUntil = takeUntil;
    exports.takeWhile = takeWhile;
    exports.tap = tap;
    exports.throttle = throttle;
    exports.throttleTime = throttleTime;
    exports.throwIfEmpty = throwIfEmpty;
    exports.timeInterval = timeInterval;
    exports.timeout = timeout;
    exports.timeoutWith = timeoutWith;
    exports.timestamp = timestamp;
    exports.toArray = toArray;
    exports.window = window;
    exports.windowCount = windowCount;
    exports.windowTime = windowTime;
    exports.windowToggle = windowToggle;
    exports.windowWhen = windowWhen;
    exports.withLatestFrom = withLatestFrom;
    exports.zipAll = zipAll;
    exports.zipWith = zipWith;

    Object.defineProperty(exports, '__esModule', { value: true });

})));

//# sourceMappingURL=rxjs.umd.js.map

