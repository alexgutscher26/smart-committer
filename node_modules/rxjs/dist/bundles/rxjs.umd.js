/**
  @license
                                 Apache License
                         Version 2.0, January 2004
                      http://www.apache.org/licenses/

 TERMS AND CONDITIONS FOR USE, REPRODUCTION, AND DISTRIBUTION

 1. Definitions.

    "License" shall mean the terms and conditions for use, reproduction,
    and distribution as defined by Sections 1 through 9 of this document.

    "Licensor" shall mean the copyright owner or entity authorized by
    the copyright owner that is granting the License.

    "Legal Entity" shall mean the union of the acting entity and all
    other entities that control, are controlled by, or are under common
    control with that entity. For the purposes of this definition,
    "control" means (i) the power, direct or indirect, to cause the
    direction or management of such entity, whether by contract or
    otherwise, or (ii) ownership of fifty percent (50%) or more of the
    outstanding shares, or (iii) beneficial ownership of such entity.

    "You" (or "Your") shall mean an individual or Legal Entity
    exercising permissions granted by this License.

    "Source" form shall mean the preferred form for making modifications,
    including but not limited to software source code, documentation
    source, and configuration files.

    "Object" form shall mean any form resulting from mechanical
    transformation or translation of a Source form, including but
    not limited to compiled object code, generated documentation,
    and conversions to other media types.

    "Work" shall mean the work of authorship, whether in Source or
    Object form, made available under the License, as indicated by a
    copyright notice that is included in or attached to the work
    (an example is provided in the Appendix below).

    "Derivative Works" shall mean any work, whether in Source or Object
    form, that is based on (or derived from) the Work and for which the
    editorial revisions, annotations, elaborations, or other modifications
    represent, as a whole, an original work of authorship. For the purposes
    of this License, Derivative Works shall not include works that remain
    separable from, or merely link (or bind by name) to the interfaces of,
    the Work and Derivative Works thereof.

    "Contribution" shall mean any work of authorship, including
    the original version of the Work and any modifications or additions
    to that Work or Derivative Works thereof, that is intentionally
    submitted to Licensor for inclusion in the Work by the copyright owner
    or by an individual or Legal Entity authorized to submit on behalf of
    the copyright owner. For the purposes of this definition, "submitted"
    means any form of electronic, verbal, or written communication sent
    to the Licensor or its representatives, including but not limited to
    communication on electronic mailing lists, source code control systems,
    and issue tracking systems that are managed by, or on behalf of, the
    Licensor for the purpose of discussing and improving the Work, but
    excluding communication that is conspicuously marked or otherwise
    designated in writing by the copyright owner as "Not a Contribution."

    "Contributor" shall mean Licensor and any individual or Legal Entity
    on behalf of whom a Contribution has been received by Licensor and
    subsequently incorporated within the Work.

 2. Grant of Copyright License. Subject to the terms and conditions of
    this License, each Contributor hereby grants to You a perpetual,
    worldwide, non-exclusive, no-charge, royalty-free, irrevocable
    copyright license to reproduce, prepare Derivative Works of,
    publicly display, publicly perform, sublicense, and distribute the
    Work and such Derivative Works in Source or Object form.

 3. Grant of Patent License. Subject to the terms and conditions of
    this License, each Contributor hereby grants to You a perpetual,
    worldwide, non-exclusive, no-charge, royalty-free, irrevocable
    (except as stated in this section) patent license to make, have made,
    use, offer to sell, sell, import, and otherwise transfer the Work,
    where such license applies only to those patent claims licensable
    by such Contributor that are necessarily infringed by their
    Contribution(s) alone or by combination of their Contribution(s)
    with the Work to which such Contribution(s) was submitted. If You
    institute patent litigation against any entity (including a
    cross-claim or counterclaim in a lawsuit) alleging that the Work
    or a Contribution incorporated within the Work constitutes direct
    or contributory patent infringement, then any patent licenses
    granted to You under this License for that Work shall terminate
    as of the date such litigation is filed.

 4. Redistribution. You may reproduce and distribute copies of the
    Work or Derivative Works thereof in any medium, with or without
    modifications, and in Source or Object form, provided that You
    meet the following conditions:

    (a) You must give any other recipients of the Work or
        Derivative Works a copy of this License; and

    (b) You must cause any modified files to carry prominent notices
        stating that You changed the files; and

    (c) You must retain, in the Source form of any Derivative Works
        that You distribute, all copyright, patent, trademark, and
        attribution notices from the Source form of the Work,
        excluding those notices that do not pertain to any part of
        the Derivative Works; and

    (d) If the Work includes a "NOTICE" text file as part of its
        distribution, then any Derivative Works that You distribute must
        include a readable copy of the attribution notices contained
        within such NOTICE file, excluding those notices that do not
        pertain to any part of the Derivative Works, in at least one
        of the following places: within a NOTICE text file distributed
        as part of the Derivative Works; within the Source form or
        documentation, if provided along with the Derivative Works; or,
        within a display generated by the Derivative Works, if and
        wherever such third-party notices normally appear. The contents
        of the NOTICE file are for informational purposes only and
        do not modify the License. You may add Your own attribution
        notices within Derivative Works that You distribute, alongside
        or as an addendum to the NOTICE text from the Work, provided
        that such additional attribution notices cannot be construed
        as modifying the License.

    You may add Your own copyright statement to Your modifications and
    may provide additional or different license terms and conditions
    for use, reproduction, or distribution of Your modifications, or
    for any such Derivative Works as a whole, provided Your use,
    reproduction, and distribution of the Work otherwise complies with
    the conditions stated in this License.

 5. Submission of Contributions. Unless You explicitly state otherwise,
    any Contribution intentionally submitted for inclusion in the Work
    by You to the Licensor shall be under the terms and conditions of
    this License, without any additional terms or conditions.
    Notwithstanding the above, nothing herein shall supersede or modify
    the terms of any separate license agreement you may have executed
    with Licensor regarding such Contributions.

 6. Trademarks. This License does not grant permission to use the trade
    names, trademarks, service marks, or product names of the Licensor,
    except as required for reasonable and customary use in describing the
    origin of the Work and reproducing the content of the NOTICE file.

 7. Disclaimer of Warranty. Unless required by applicable law or
    agreed to in writing, Licensor provides the Work (and each
    Contributor provides its Contributions) on an "AS IS" BASIS,
    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or
    implied, including, without limitation, any warranties or conditions
    of TITLE, NON-INFRINGEMENT, MERCHANTABILITY, or FITNESS FOR A
    PARTICULAR PURPOSE. You are solely responsible for determining the
    appropriateness of using or redistributing the Work and assume any
    risks associated with Your exercise of permissions under this License.

 8. Limitation of Liability. In no event and under no legal theory,
    whether in tort (including negligence), contract, or otherwise,
    unless required by applicable law (such as deliberate and grossly
    negligent acts) or agreed to in writing, shall any Contributor be
    liable to You for damages, including any direct, indirect, special,
    incidental, or consequential damages of any character arising as a
    result of this License or out of the use or inability to use the
    Work (including but not limited to damages for loss of goodwill,
    work stoppage, computer failure or malfunction, or any and all
    other commercial damages or losses), even if such Contributor
    has been advised of the possibility of such damages.

 9. Accepting Warranty or Additional Liability. While redistributing
    the Work or Derivative Works thereof, You may choose to offer,
    and charge a fee for, acceptance of support, warranty, indemnity,
    or other liability obligations and/or rights consistent with this
    License. However, in accepting such obligations, You may act only
    on Your own behalf and on Your sole responsibility, not on behalf
    of any other Contributor, and only if You agree to indemnify,
    defend, and hold each Contributor harmless for any liability
    incurred by, or claims asserted against, such Contributor by reason
    of your accepting any such warranty or additional liability.

 END OF TERMS AND CONDITIONS

 APPENDIX: How to apply the Apache License to your work.

    To apply the Apache License to your work, attach the following
    boilerplate notice, with the fields enclosed by brackets "[]"
    replaced with your own identifying information. (Don't include
    the brackets!)  The text should be enclosed in the appropriate
    comment syntax for the file format. We also recommend that a
    file or class name and description of purpose be included on the
    same "printed page" as the copyright notice for easier
    identification within third-party archives.

 Copyright (c) 2015-2018 Google, Inc., Netflix, Inc., Microsoft Corp. and contributors

 Licensed under the Apache License, Version 2.0 (the "License");
 you may not use this file except in compliance with the License.
 You may obtain a copy of the License at

     http://www.apache.org/licenses/LICENSE-2.0

 Unless required by applicable law or agreed to in writing, software
 distributed under the License is distributed on an "AS IS" BASIS,
 WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 See the License for the specific language governing permissions and
 limitations under the License.
 

 **/
/**
  @license
                                 Apache License
                         Version 2.0, January 2004
                      http://www.apache.org/licenses/

 TERMS AND CONDITIONS FOR USE, REPRODUCTION, AND DISTRIBUTION

 1. Definitions.

    "License" shall mean the terms and conditions for use, reproduction,
    and distribution as defined by Sections 1 through 9 of this document.

    "Licensor" shall mean the copyright owner or entity authorized by
    the copyright owner that is granting the License.

    "Legal Entity" shall mean the union of the acting entity and all
    other entities that control, are controlled by, or are under common
    control with that entity. For the purposes of this definition,
    "control" means (i) the power, direct or indirect, to cause the
    direction or management of such entity, whether by contract or
    otherwise, or (ii) ownership of fifty percent (50%) or more of the
    outstanding shares, or (iii) beneficial ownership of such entity.

    "You" (or "Your") shall mean an individual or Legal Entity
    exercising permissions granted by this License.

    "Source" form shall mean the preferred form for making modifications,
    including but not limited to software source code, documentation
    source, and configuration files.

    "Object" form shall mean any form resulting from mechanical
    transformation or translation of a Source form, including but
    not limited to compiled object code, generated documentation,
    and conversions to other media types.

    "Work" shall mean the work of authorship, whether in Source or
    Object form, made available under the License, as indicated by a
    copyright notice that is included in or attached to the work
    (an example is provided in the Appendix below).

    "Derivative Works" shall mean any work, whether in Source or Object
    form, that is based on (or derived from) the Work and for which the
    editorial revisions, annotations, elaborations, or other modifications
    represent, as a whole, an original work of authorship. For the purposes
    of this License, Derivative Works shall not include works that remain
    separable from, or merely link (or bind by name) to the interfaces of,
    the Work and Derivative Works thereof.

    "Contribution" shall mean any work of authorship, including
    the original version of the Work and any modifications or additions
    to that Work or Derivative Works thereof, that is intentionally
    submitted to Licensor for inclusion in the Work by the copyright owner
    or by an individual or Legal Entity authorized to submit on behalf of
    the copyright owner. For the purposes of this definition, "submitted"
    means any form of electronic, verbal, or written communication sent
    to the Licensor or its representatives, including but not limited to
    communication on electronic mailing lists, source code control systems,
    and issue tracking systems that are managed by, or on behalf of, the
    Licensor for the purpose of discussing and improving the Work, but
    excluding communication that is conspicuously marked or otherwise
    designated in writing by the copyright owner as "Not a Contribution."

    "Contributor" shall mean Licensor and any individual or Legal Entity
    on behalf of whom a Contribution has been received by Licensor and
    subsequently incorporated within the Work.

 2. Grant of Copyright License. Subject to the terms and conditions of
    this License, each Contributor hereby grants to You a perpetual,
    worldwide, non-exclusive, no-charge, royalty-free, irrevocable
    copyright license to reproduce, prepare Derivative Works of,
    publicly display, publicly perform, sublicense, and distribute the
    Work and such Derivative Works in Source or Object form.

 3. Grant of Patent License. Subject to the terms and conditions of
    this License, each Contributor hereby grants to You a perpetual,
    worldwide, non-exclusive, no-charge, royalty-free, irrevocable
    (except as stated in this section) patent license to make, have made,
    use, offer to sell, sell, import, and otherwise transfer the Work,
    where such license applies only to those patent claims licensable
    by such Contributor that are necessarily infringed by their
    Contribution(s) alone or by combination of their Contribution(s)
    with the Work to which such Contribution(s) was submitted. If You
    institute patent litigation against any entity (including a
    cross-claim or counterclaim in a lawsuit) alleging that the Work
    or a Contribution incorporated within the Work constitutes direct
    or contributory patent infringement, then any patent licenses
    granted to You under this License for that Work shall terminate
    as of the date such litigation is filed.

 4. Redistribution. You may reproduce and distribute copies of the
    Work or Derivative Works thereof in any medium, with or without
    modifications, and in Source or Object form, provided that You
    meet the following conditions:

    (a) You must give any other recipients of the Work or
        Derivative Works a copy of this License; and

    (b) You must cause any modified files to carry prominent notices
        stating that You changed the files; and

    (c) You must retain, in the Source form of any Derivative Works
        that You distribute, all copyright, patent, trademark, and
        attribution notices from the Source form of the Work,
        excluding those notices that do not pertain to any part of
        the Derivative Works; and

    (d) If the Work includes a "NOTICE" text file as part of its
        distribution, then any Derivative Works that You distribute must
        include a readable copy of the attribution notices contained
        within such NOTICE file, excluding those notices that do not
        pertain to any part of the Derivative Works, in at least one
        of the following places: within a NOTICE text file distributed
        as part of the Derivative Works; within the Source form or
        documentation, if provided along with the Derivative Works; or,
        within a display generated by the Derivative Works, if and
        wherever such third-party notices normally appear. The contents
        of the NOTICE file are for informational purposes only and
        do not modify the License. You may add Your own attribution
        notices within Derivative Works that You distribute, alongside
        or as an addendum to the NOTICE text from the Work, provided
        that such additional attribution notices cannot be construed
        as modifying the License.

    You may add Your own copyright statement to Your modifications and
    may provide additional or different license terms and conditions
    for use, reproduction, or distribution of Your modifications, or
    for any such Derivative Works as a whole, provided Your use,
    reproduction, and distribution of the Work otherwise complies with
    the conditions stated in this License.

 5. Submission of Contributions. Unless You explicitly state otherwise,
    any Contribution intentionally submitted for inclusion in the Work
    by You to the Licensor shall be under the terms and conditions of
    this License, without any additional terms or conditions.
    Notwithstanding the above, nothing herein shall supersede or modify
    the terms of any separate license agreement you may have executed
    with Licensor regarding such Contributions.

 6. Trademarks. This License does not grant permission to use the trade
    names, trademarks, service marks, or product names of the Licensor,
    except as required for reasonable and customary use in describing the
    origin of the Work and reproducing the content of the NOTICE file.

 7. Disclaimer of Warranty. Unless required by applicable law or
    agreed to in writing, Licensor provides the Work (and each
    Contributor provides its Contributions) on an "AS IS" BASIS,
    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or
    implied, including, without limitation, any warranties or conditions
    of TITLE, NON-INFRINGEMENT, MERCHANTABILITY, or FITNESS FOR A
    PARTICULAR PURPOSE. You are solely responsible for determining the
    appropriateness of using or redistributing the Work and assume any
    risks associated with Your exercise of permissions under this License.

 8. Limitation of Liability. In no event and under no legal theory,
    whether in tort (including negligence), contract, or otherwise,
    unless required by applicable law (such as deliberate and grossly
    negligent acts) or agreed to in writing, shall any Contributor be
    liable to You for damages, including any direct, indirect, special,
    incidental, or consequential damages of any character arising as a
    result of this License or out of the use or inability to use the
    Work (including but not limited to damages for loss of goodwill,
    work stoppage, computer failure or malfunction, or any and all
    other commercial damages or losses), even if such Contributor
    has been advised of the possibility of such damages.

 9. Accepting Warranty or Additional Liability. While redistributing
    the Work or Derivative Works thereof, You may choose to offer,
    and charge a fee for, acceptance of support, warranty, indemnity,
    or other liability obligations and/or rights consistent with this
    License. However, in accepting such obligations, You may act only
    on Your own behalf and on Your sole responsibility, not on behalf
    of any other Contributor, and only if You agree to indemnify,
    defend, and hold each Contributor harmless for any liability
    incurred by, or claims asserted against, such Contributor by reason
    of your accepting any such warranty or additional liability.

 END OF TERMS AND CONDITIONS

 APPENDIX: How to apply the Apache License to your work.

    To apply the Apache License to your work, attach the following
    boilerplate notice, with the fields enclosed by brackets "[]"
    replaced with your own identifying information. (Don't include
    the brackets!)  The text should be enclosed in the appropriate
    comment syntax for the file format. We also recommend that a
    file or class name and description of purpose be included on the
    same "printed page" as the copyright notice for easier
    identification within third-party archives.

 Copyright (c) 2015-2018 Google, Inc., Netflix, Inc., Microsoft Corp. and contributors

 Licensed under the Apache License, Version 2.0 (the "License");
 you may not use this file except in compliance with the License.
 You may obtain a copy of the License at

     http://www.apache.org/licenses/LICENSE-2.0

 Unless required by applicable law or agreed to in writing, software
 distributed under the License is distributed on an "AS IS" BASIS,
 WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 See the License for the specific language governing permissions and
 limitations under the License.
 

 **/
(function (global, factory) {
    typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :
    typeof define === 'function' && define.amd ? define('rxjs', ['exports'], factory) :
    (factory((global.rxjs = {})));
}(this, (function (exports) { 'use strict';

    /*! *****************************************************************************
    Copyright (c) Microsoft Corporation.

    Permission to use, copy, modify, and/or distribute this software for any
    purpose with or without fee is hereby granted.

    THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
    REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
    AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
    INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
    LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
    OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
    PERFORMANCE OF THIS SOFTWARE.
    ***************************************************************************** */
    /* global Reflect, Promise */

    var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };

    /**
     * A utility function to implement inheritance between classes.
     * It ensures that the prototype chain is correctly set up for the derived class.
     *
     * @param {Function} d - The derived class constructor.
     * @param {Function} b - The base class constructor or null if no inheritance.
     * @throws {TypeError} - If `b` is not a function and not null, indicating an invalid inheritance setup.
     */
    function __extends(d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        /**
         * Constructor function to set the constructor property of an object.
         *
         * @class
         * @param {Function} d - The constructor function to be assigned.
         */
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    }

    var __assign = function() {
        __assign = Object.assign || function __assign(t) {
            for (var s, i = 1, n = arguments.length; i < n; i++) {
                s = arguments[i];
                for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
            }
            return t;
        };
        return __assign.apply(this, arguments);
    };

    /**
     * Extracts remaining properties from an object after excluding specified keys.
     *
     * @param {Object} s - The source object from which properties are to be extracted.
     * @param {Array} e - An array of property names to exclude from the source object.
     * @returns {Object} A new object containing only the properties not excluded by `e`.
     */
    function __rest(s, e) {
        var t = {};
        for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
            t[p] = s[p];
        if (s != null && typeof Object.getOwnPropertySymbols === "function")
            for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
                if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                    t[p[i]] = s[p[i]];
            }
        return t;
    }

    /**
     * Helper function to handle asynchronous operations using Promises.
     *
     * @param {Object} thisArg - The `this` value to be used by the generator function when it's invoked.
     * @param {Array} _arguments - An array of arguments that will be passed to the generator function.
     * @param {PromiseConstructor} P - The Promise constructor. Defaults to the native Promise if not provided.
     * @param {GeneratorFunction} generator - A generator function that yields Promises or values.
     * @returns {Promise} - A promise that resolves when all yielded Promises have resolved, or rejects if any of them reject.
     */
    function __awaiter(thisArg, _arguments, P, generator) {
        /**
         * Converts a value into an instance of Promise if it's not already one.
         *
         * @param {any} value - The value to be converted to a Promise.
         * @returns {Promise<any>} A Promise instance containing the original value or the value itself if it's already a Promise.
         */
        function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
        return new (P || (P = Promise))(function (resolve, reject) {
            /**
             * Handles the fulfillment of a promise by advancing to the next step of the generator.
             *
             * @param {any} value - The value to pass to the generator's next method.
             * @returns {void}
             * @throws {Error} If an error occurs during the execution of the generator.
             */
            function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
            /**
             * Handles rejected promises by passing the error to the next step of the generator.
             *
             * @param {any} value - The value that caused the promise to be rejected.
             * @returns {void}
             * @throws {Error} - If an error occurs during the rejection handling, it is passed to the next step.
             */
            function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
            /**
             * Handles the result of an asynchronous operation, either resolving it or adopting it based on its completion status.
             *
             * @param {Object} result - The result object from an asynchronous operation.
             * @param {boolean} result.done - Indicates whether the operation is complete.
             * @param {*} result.value - The value returned by the asynchronous operation.
             * @param {Function} resolve - A function to call if the operation completes successfully.
             * @param {Function} reject - A function to call if the operation fails.
             * @returns {void}
             */
            function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
            step((generator = generator.apply(thisArg, _arguments || [])).next());
        });
    }

    function __generator(thisArg, body) {
        var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
        return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
        /**
         * Creates a function that can be used to step through a sequence of actions.
         *
         * @param {number} n - The index or identifier for the step.
         * @returns {function} - A function that takes another parameter and returns an array containing the step index and the other parameter.
         */
        function verb(n) { return function (v) { return step([n, v]); }; }
        /**
         * Executes a generator function asynchronously.
         *
         * @param {Array} op - The operation array containing the current state of the generator.
         * @returns {Object} - An object with properties 'value' and 'done'.
         * @throws {TypeError} - If the generator is already executing.
         * @example
         * step([4, 10]); // Example usage within a generator function
         */
        function step(op) {
            if (f) throw new TypeError("Generator is already executing.");
            while (_) try {
                if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
                if (y = 0, t) op = [op[0] & 2, t.value];
                switch (op[0]) {
                    case 0: case 1: t = op; break;
                    case 4: _.label++; return { value: op[1], done: false };
                    case 5: _.label++; y = op[1]; op = [0]; continue;
                    case 7: op = _.ops.pop(); _.trys.pop(); continue;
                    default:
                        if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                        if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                        if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                        if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                        if (t[2]) _.ops.pop();
                        _.trys.pop(); continue;
                }
                op = body.call(thisArg, _);
            } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
            if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
        }
    }

    function __values(o) {
        var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
        if (m) return m.call(o);
        if (o && typeof o.length === "number") return {
            next: function () {
                if (o && i >= o.length) o = void 0;
                return { value: o && o[i++], done: !o };
            }
        };
        throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
    }

    /**
     * Reads elements from an iterable or array-like object up to a specified limit.
     *
     * @param {Iterable|ArrayLike} o - The iterable or array-like object to read from.
     * @param {number} [n=Infinity] - The maximum number of elements to read. If not provided, all elements are read.
     * @returns {Array} An array containing the elements read from the iterable or array-like object.
     *
     * @example
     * const result = __read([1, 2, 3, 4], 2);
     * console.log(result); // Output: [1, 2]
     *
     * @throws {TypeError} If `o` is not iterable or array-like.
     */
    function __read(o, n) {
        var m = typeof Symbol === "function" && o[Symbol.iterator];
        if (!m) return o;
        var i = m.call(o), r, ar = [], e;
        try {
            while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
        }
        catch (error) { e = { error: error }; }
        finally {
            try {
                if (r && !r.done && (m = i["return"])) m.call(i);
            }
            finally { if (e) throw e.error; }
        }
        return ar;
    }

    /**
     * Merges two arrays or adds elements to an array based on conditions.
     *
     * @param {any[]} to - The target array to which elements will be added or merged.
     * @param {any[]} from - The source array whose elements will be copied into the target array.
     * @param {boolean} [pack] - An optional parameter that indicates whether to pack elements.
     * @returns {any[]} A new array containing all elements from both the target and source arrays, with conditions applied if 'pack' is true.
     *
     * Example:
     *   var array1 = [1, 2];
     *   var array2 = [3, 4];
     *   var result = __spreadArray(array1, array2);
     *   console.log(result); // Output: [1, 2, 3, 4]
     */
    function __spreadArray(to, from, pack) {
        if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
            if (ar || !(i in from)) {
                if (!ar) ar = Array.prototype.slice.call(from, 0, i);
                ar[i] = from[i];
            }
        }
        return to.concat(ar || Array.prototype.slice.call(from));
    }

    /**
     * Helper function to handle asynchronous operations.
     *
     * @param {any} v - The value or promise to await.
     * @returns {__await} - An instance of the current context if already an instance, otherwise a new instance of __await with the provided value.
     *
     * @example
     * const result = await __await(somePromise);
     * ```
     * Here, `somePromise` is awaited. If it's already an instance of __await,
     * it returns itself; otherwise, it creates a new instance with the resolved value.
     * ```
     */
    function __await(v) {
        return this instanceof __await ? (this.v = v, this) : new __await(v);
    }

    /**
     * Creates an asynchronous generator function from a regular generator function.
     *
     * @param {Object} thisArg - The value to use as `this` when executing the generator function.
     * @param {Array} _arguments - Arguments passed to the generator function.
     * @param {Function} generator - The generator function to be wrapped.
     * @returns {Object} An object conforming to the async iterator protocol.
     *
     * @throws {TypeError} If `Symbol.asyncIterator` is not defined.
     */
    function __asyncGenerator(thisArg, _arguments, generator) {
        if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
        var g = generator.apply(thisArg, _arguments || []), i, q = [];
        return i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () { return this; }, i;
        /**
         * Registers a new function to handle a specific language verb.
         *
         * @param {string} n - The language verb identifier.
         */
        function verb(n) { if (g[n]) i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }
        /**
         * Resumes the execution of a generator function.
         *
         * @param {number} n - The index of the generator function to execute.
         * @param {*} v - The value to pass to the generator function.
         * @returns {void}
         * @throws {Error} If an error occurs during execution.
         */
        function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }
        /**
         * Handles the result of an asynchronous operation.
         *
         * This function is used within an async function to handle the result of an operation. It checks if the value is a promise using `__await` and either resolves it or settles the promise based on the operation's outcome.
         *
         * @param {Object} r - The result object from an async operation, containing the value and other metadata.
         * @throws {Error} - If there is an error during the settling of the promise.
         */
        function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }
        /**
         * Resumes execution with the provided value.
         *
         * @function fulfill
         * @param {any} value - The value to resume with.
         */
        function fulfill(value) { resume("next", value); }
        /**
         * Rejects the current promise with a given value.
         *
         * @param {any} value - The value to reject the promise with.
         */
        function reject(value) { resume("throw", value); }
        /**
         * Executes the next function in the queue after settling the current one with a value.
         *
         * @param {Function} f - The function to be executed next.
         * @param {*} v - The value with which the current function has settled.
         */
        function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }
    }

    /**
     * Generates an async iterable object from a given iterable or async iterator.
     *
     * @param {any} o - The iterable or async iterator to convert.
     * @returns {AsyncIterableIterator<any>} - An async iterable object.
     * @throws {TypeError} - If Symbol.asyncIterator is not defined.
     *
     * @example
     * const asyncIterable = __asyncValues([1, 2, 3]);
     * for await (const value of asyncIterable) {
     *   console.log(value);
     * }
     */
    function __asyncValues(o) {
        if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
        var m = o[Symbol.asyncIterator], i;
        return m ? m.call(o) : (o = typeof __values === "function" ? __values(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () { return this; }, i);
        /**
         * This function is used to handle verbs or actions within a specific context.
         *
         * @param {string} n - The name of the verb or action to be handled.
         */
        function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }
        /**
         * Helper function to resolve or reject a promise.
         *
         * @param {Function} resolve - The resolver function of the promise.
         * @param {Function} reject - The rejecter function of the promise.
         * @param {boolean} d - A boolean indicating if the operation is done.
         * @param {*} v - The value to be resolved or rejected.
         * @returns {void}
         */
        function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }
    }

    /**
     * Determines if a given value is a function.
     *
     * @param {*} value - The value to check.
     * @returns {boolean} Returns true if the value is a function, otherwise false.
     *
     * @example
     * console.log(isFunction(function(){})); // true
     * console.log(isFunction('not a function')); // false
     */
    function isFunction(value) {
        return typeof value === 'function';
    }

    function createErrorClass(createImpl) {
        var _super = function (instance) {
            Error.call(instance);
            instance.stack = new Error().stack;
        };
        var ctorFunc = createImpl(_super);
        ctorFunc.prototype = Object.create(Error.prototype);
        ctorFunc.prototype.constructor = ctorFunc;
        return ctorFunc;
    }

    var UnsubscriptionError = createErrorClass(function (_super) {
        return function UnsubscriptionErrorImpl(errors) {
            _super(this);
            this.message = errors
                ? errors.length + " errors occurred during unsubscription:\n" + errors.map(function (err, i) { return i + 1 + ") " + err.toString(); }).join('\n  ')
                : '';
            this.name = 'UnsubscriptionError';
            this.errors = errors;
        };
    });

    /**
     * Removes an item from an array if it exists.
     *
     * @param {Array} arr - The array from which to remove the item.
     * @param {*} item - The item to remove from the array.
     * @returns {void}
     * @throws {TypeError} If `arr` is not an array or `item` is undefined.
     */
    function arrRemove(arr, item) {
        if (arr) {
            var index = arr.indexOf(item);
            0 <= index && arr.splice(index, 1);
        }
    }

    var Subscription = (function () {
        /**
         * Represents a subscription that manages cleanup mechanisms.
         *
         * @param {Function} initialTeardown - A function to perform initial teardown when the subscription is closed.
         */
        function Subscription(initialTeardown) {
            this.initialTeardown = initialTeardown;
            this.closed = false;
            this._parentage = null;
            this._finalizers = null;
        }
        Subscription.prototype.unsubscribe = function () {
            var e_1, _a, e_2, _b;
            var errors;
            if (!this.closed) {
                this.closed = true;
                var _parentage = this._parentage;
                if (_parentage) {
                    this._parentage = null;
                    if (Array.isArray(_parentage)) {
                        try {
                            for (var _parentage_1 = __values(_parentage), _parentage_1_1 = _parentage_1.next(); !_parentage_1_1.done; _parentage_1_1 = _parentage_1.next()) {
                                var parent_1 = _parentage_1_1.value;
                                parent_1.remove(this);
                            }
                        }
                        catch (e_1_1) { e_1 = { error: e_1_1 }; }
                        finally {
                            try {
                                if (_parentage_1_1 && !_parentage_1_1.done && (_a = _parentage_1.return)) _a.call(_parentage_1);
                            }
                            finally { if (e_1) throw e_1.error; }
                        }
                    }
                    else {
                        _parentage.remove(this);
                    }
                }
                var initialFinalizer = this.initialTeardown;
                if (isFunction(initialFinalizer)) {
                    try {
                        initialFinalizer();
                    }
                    catch (e) {
                        errors = e instanceof UnsubscriptionError ? e.errors : [e];
                    }
                }
                var _finalizers = this._finalizers;
                if (_finalizers) {
                    this._finalizers = null;
                    try {
                        for (var _finalizers_1 = __values(_finalizers), _finalizers_1_1 = _finalizers_1.next(); !_finalizers_1_1.done; _finalizers_1_1 = _finalizers_1.next()) {
                            var finalizer = _finalizers_1_1.value;
                            try {
                                execFinalizer(finalizer);
                            }
                            catch (err) {
                                errors = errors !== null && errors !== void 0 ? errors : [];
                                if (err instanceof UnsubscriptionError) {
                                    errors = __spreadArray(__spreadArray([], __read(errors)), __read(err.errors));
                                }
                                else {
                                    errors.push(err);
                                }
                            }
                        }
                    }
                    catch (e_2_1) { e_2 = { error: e_2_1 }; }
                    finally {
                        try {
                            if (_finalizers_1_1 && !_finalizers_1_1.done && (_b = _finalizers_1.return)) _b.call(_finalizers_1);
                        }
                        finally { if (e_2) throw e_2.error; }
                    }
                }
                if (errors) {
                    throw new UnsubscriptionError(errors);
                }
            }
        };
        Subscription.prototype.add = function (teardown) {
            var _a;
            if (teardown && teardown !== this) {
                if (this.closed) {
                    execFinalizer(teardown);
                }
                else {
                    if (teardown instanceof Subscription) {
                        if (teardown.closed || teardown._hasParent(this)) {
                            return;
                        }
                        teardown._addParent(this);
                    }
                    (this._finalizers = (_a = this._finalizers) !== null && _a !== void 0 ? _a : []).push(teardown);
                }
            }
        };
        Subscription.prototype._hasParent = function (parent) {
            var _parentage = this._parentage;
            return _parentage === parent || (Array.isArray(_parentage) && _parentage.includes(parent));
        };
        Subscription.prototype._addParent = function (parent) {
            var _parentage = this._parentage;
            this._parentage = Array.isArray(_parentage) ? (_parentage.push(parent), _parentage) : _parentage ? [_parentage, parent] : parent;
        };
        Subscription.prototype._removeParent = function (parent) {
            var _parentage = this._parentage;
            if (_parentage === parent) {
                this._parentage = null;
            }
            else if (Array.isArray(_parentage)) {
                arrRemove(_parentage, parent);
            }
        };
        Subscription.prototype.remove = function (teardown) {
            var _finalizers = this._finalizers;
            _finalizers && arrRemove(_finalizers, teardown);
            if (teardown instanceof Subscription) {
                teardown._removeParent(this);
            }
        };
        Subscription.EMPTY = (function () {
            var empty = new Subscription();
            empty.closed = true;
            return empty;
        })();
        return Subscription;
    }());
    var EMPTY_SUBSCRIPTION = Subscription.EMPTY;
    /**
     * Determines whether a given value is an instance of Subscription or has the necessary methods to behave like one.
     *
     * @param {*} value - The value to be checked.
     * @returns {boolean} - Returns true if the value is an instance of Subscription or behaves like one, false otherwise.
     */
    function isSubscription(value) {
        return (value instanceof Subscription ||
            (value && 'closed' in value && isFunction(value.remove) && isFunction(value.add) && isFunction(value.unsubscribe)));
    }
    /**
     * Executes the provided finalizer function or unsubscribes if it's an observable.
     *
     * @param {Function|Object} finalizer - The finalizer to execute. Can be a function or an object with an `unsubscribe` method.
     * @throws {TypeError} If the finalizer is neither a function nor has an `unsubscribe` method.
     */
    function execFinalizer(finalizer) {
        if (isFunction(finalizer)) {
            finalizer();
        }
        else {
            finalizer.unsubscribe();
        }
    }

    var config = {
        onUnhandledError: null,
        onStoppedNotification: null,
        Promise: undefined,
        useDeprecatedSynchronousErrorHandling: false,
        useDeprecatedNextContext: false,
    };

    var timeoutProvider = {
        setTimeout: function (handler, timeout) {
            var args = [];
            for (var _i = 2; _i < arguments.length; _i++) {
                args[_i - 2] = arguments[_i];
            }
            var delegate = timeoutProvider.delegate;
            if (delegate === null || delegate === void 0 ? void 0 : delegate.setTimeout) {
                return delegate.setTimeout.apply(delegate, __spreadArray([handler, timeout], __read(args)));
            }
            return setTimeout.apply(void 0, __spreadArray([handler, timeout], __read(args)));
        },
        clearTimeout: function (handle) {
            var delegate = timeoutProvider.delegate;
            return ((delegate === null || delegate === void 0 ? void 0 : delegate.clearTimeout) || clearTimeout)(handle);
        },
        delegate: undefined,
    };

    /**
     * Reports an unhandled error by using a timeout provider to delay the execution of the error handling logic.
     *
     * @param {Error} err - The error object that needs to be reported.
     */
    function reportUnhandledError(err) {
        timeoutProvider.setTimeout(function () {
            var onUnhandledError = config.onUnhandledError;
            if (onUnhandledError) {
                onUnhandledError(err);
            }
            else {
                throw err;
            }
        });
    }

    /**
     * A no-operation function that does nothing when called.
     *
     * @function
     * @name noop
     */
    function noop() { }

    var COMPLETE_NOTIFICATION = (function () { return createNotification('C', undefined, undefined); })();
    /**
     * Creates and returns an error notification object.
     *
     * @param {Error} error - The error object to include in the notification.
     * @returns {Object} An error notification object.
     * @throws {TypeError} If the input is not an Error object.
     *
     * Example:
     *   try {
     *       throw new Error('An error occurred');
     *   } catch (err) {
     *       const notification = errorNotification(err);
     *       console.log(notification); // { type: 'E', message: undefined, data: err }
     *   }
     */
    function errorNotification(error) {
        return createNotification('E', undefined, error);
    }
    /**
     * Creates a notification with a specific type and value.
     *
     * @param {string} value - The value to be set for the notification.
     * @returns {Object} - The created notification object.
     */
    function nextNotification(value) {
        return createNotification('N', value, undefined);
    }
    /**
     * Creates a notification object with the specified kind, value, and error.
     *
     * @param {string} kind - The type of notification (e.g., 'info', 'error', 'warning').
     * @param {*} value - The data associated with the notification.
     * @param {Error|undefined} [error] - Optional error object if the notification is an error.
     * @returns {Object} - An object representing the notification with properties kind, value, and error.
     *
     * @example
     * const infoNotification = createNotification('info', 'Operation completed successfully');
     * console.log(infoNotification);
     * // Output: { kind: 'info', value: 'Operation completed successfully', error: undefined }
     *
     * const errorNotification = createNotification('error', 'An error occurred', new Error('Internal Server Error'));
     * console.log(errorNotification);
     * // Output: { kind: 'error', value: 'An error occurred', error: [Error: Internal Server Error] }
     */
    function createNotification(kind, value, error) {
        return {
            kind: kind,
            value: value,
            error: error,
        };
    }

    var context = null;
    /**
     * Executes a callback function with error context handling. If deprecated synchronous error handling is enabled,
     * it will manage the error context to ensure that any errors thrown within the callback are properly handled and rethrown if necessary.
     *
     * @param {function} cb - The callback function to execute.
     */
    function errorContext(cb) {
        if (config.useDeprecatedSynchronousErrorHandling) {
            var isRoot = !context;
            if (isRoot) {
                context = { errorThrown: false, error: null };
            }
            cb();
            if (isRoot) {
                var _a = context, errorThrown = _a.errorThrown, error = _a.error;
                context = null;
                if (errorThrown) {
                    throw error;
                }
            }
        }
        else {
            cb();
        }
    }
    /**
     * Captures an error by setting it on the context if deprecated synchronous error handling is enabled.
     *
     * @param {Error} err - The error to be captured.
     */
    function captureError(err) {
        if (config.useDeprecatedSynchronousErrorHandling && context) {
            context.errorThrown = true;
            context.error = err;
        }
    }

    var Subscriber = (function (_super) {
        __extends(Subscriber, _super);
        /**
         * Creates an instance of Subscriber with an optional destination observer.
         *
         * @constructor
         * @param {Observable} [destination] - The destination observer to receive notifications. If not provided, defaults to an empty observer.
         */
        function Subscriber(destination) {
            var _this = _super.call(this) || this;
            _this.isStopped = false;
            if (destination) {
                _this.destination = destination;
                if (isSubscription(destination)) {
                    destination.add(_this);
                }
            }
            else {
                _this.destination = EMPTY_OBSERVER;
            }
            return _this;
        }
        Subscriber.create = function (next, error, complete) {
            return new SafeSubscriber(next, error, complete);
        };
        Subscriber.prototype.next = function (value) {
            if (this.isStopped) {
                handleStoppedNotification(nextNotification(value), this);
            }
            else {
                this._next(value);
            }
        };
        Subscriber.prototype.error = function (err) {
            if (this.isStopped) {
                handleStoppedNotification(errorNotification(err), this);
            }
            else {
                this.isStopped = true;
                this._error(err);
            }
        };
        Subscriber.prototype.complete = function () {
            if (this.isStopped) {
                handleStoppedNotification(COMPLETE_NOTIFICATION, this);
            }
            else {
                this.isStopped = true;
                this._complete();
            }
        };
        Subscriber.prototype.unsubscribe = function () {
            if (!this.closed) {
                this.isStopped = true;
                _super.prototype.unsubscribe.call(this);
                this.destination = null;
            }
        };
        Subscriber.prototype._next = function (value) {
            this.destination.next(value);
        };
        Subscriber.prototype._error = function (err) {
            try {
                this.destination.error(err);
            }
            finally {
                this.unsubscribe();
            }
        };
        Subscriber.prototype._complete = function () {
            try {
                this.destination.complete();
            }
            finally {
                this.unsubscribe();
            }
        };
        return Subscriber;
    }(Subscription));
    var _bind = Function.prototype.bind;
    /**
     * Binds a function to an object, setting the 'this' value to the provided object.
     *
     * @function
     * @name bind
     * @param {Function} fn - The function to be bound.
     * @param {*} thisArg - The value to which 'this' will be set when the function is called.
     * @returns {Function} - A new function with 'this' bound to the provided object.
     *
     * @example
     * const obj = {
     *   greet: function() {
     *     console.log(`Hello, ${this.name}`);
     *   }
     * };
     * const greet = bind(obj.greet, { name: 'Alice' });
     * greet(); // Outputs: Hello, Alice
     */
    function bind(fn, thisArg) {
        return _bind.call(fn, thisArg);
    }
    var ConsumerObserver = (function () {
        /**
         * Represents an observer that listens to partial observations.
         *
         * @class ConsumerObserver
         * @param {Object} partialObserver - The object containing methods for handling partial observations.
         */
        function ConsumerObserver(partialObserver) {
            this.partialObserver = partialObserver;
        }
        ConsumerObserver.prototype.next = function (value) {
            var partialObserver = this.partialObserver;
            if (partialObserver.next) {
                try {
                    partialObserver.next(value);
                }
                catch (error) {
                    handleUnhandledError(error);
                }
            }
        };
        ConsumerObserver.prototype.error = function (err) {
            var partialObserver = this.partialObserver;
            if (partialObserver.error) {
                try {
                    partialObserver.error(err);
                }
                catch (error) {
                    handleUnhandledError(error);
                }
            }
            else {
                handleUnhandledError(err);
            }
        };
        ConsumerObserver.prototype.complete = function () {
            var partialObserver = this.partialObserver;
            if (partialObserver.complete) {
                try {
                    partialObserver.complete();
                }
                catch (error) {
                    handleUnhandledError(error);
                }
            }
        };
        return ConsumerObserver;
    }());
    var SafeSubscriber = (function (_super) {
        __extends(SafeSubscriber, _super);
        /**
         * Creates a new subscriber that safely handles different types of observer inputs.
         *
         * @param {Function|Object} [observerOrNext] - The observer object or function to subscribe with.
         * @param {Function} [error] - The error handler function (optional).
         * @param {Function} [complete] - The completion handler function (optional).
         * @returns {Subscriber} A new subscriber instance.
         *
         * @example
         * // Using a simple next handler function
         * SafeSubscriber(function(value) {
         *   console.log('Next:', value);
         * });
         *
         * @example
         * // Using an observer object with error and complete handlers
         * SafeSubscriber({
         *   next: function(value) { console.log('Next:', value); },
         *   error: function(err) { console.error('Error:', err); },
         *   complete: function() { console.log('Completed'); }
         * });
         */
        function SafeSubscriber(observerOrNext, error, complete) {
            var _this = _super.call(this) || this;
            var partialObserver;
            if (isFunction(observerOrNext) || !observerOrNext) {
                partialObserver = {
                    next: (observerOrNext !== null && observerOrNext !== void 0 ? observerOrNext : undefined),
                    error: error !== null && error !== void 0 ? error : undefined,
                    complete: complete !== null && complete !== void 0 ? complete : undefined,
                };
            }
            else {
                var context_1;
                if (_this && config.useDeprecatedNextContext) {
                    context_1 = Object.create(observerOrNext);
                    context_1.unsubscribe = function () { return _this.unsubscribe(); };
                    partialObserver = {
                        next: observerOrNext.next && bind(observerOrNext.next, context_1),
                        error: observerOrNext.error && bind(observerOrNext.error, context_1),
                        complete: observerOrNext.complete && bind(observerOrNext.complete, context_1),
                    };
                }
                else {
                    partialObserver = observerOrNext;
                }
            }
            _this.destination = new ConsumerObserver(partialObserver);
            return _this;
        }
        return SafeSubscriber;
    }(Subscriber));
    /**
     * Handles unhandled errors by capturing or reporting them based on configuration settings.
     *
     * @param {Error} error - The error object that was not handled.
     */
    function handleUnhandledError(error) {
        if (config.useDeprecatedSynchronousErrorHandling) {
            captureError(error);
        }
        else {
            reportUnhandledError(error);
        }
    }
    /**
     * A default error handler function that throws the error passed to it.
     *
     * @param {Error} err - The error object to be thrown.
     * @throws {Error} - Throws the same error that was passed as a parameter.
     */
    function defaultErrorHandler(err) {
        throw err;
    }
    /**
     * Handles the stopped notification by invoking the configured callback with a timeout.
     *
     * @param {Object} notification - The notification object that has stopped.
     * @param {Object} subscriber - The subscriber associated with the notification.
     * @throws {Error} If `config.onStoppedNotification` is not a function.
     */
    function handleStoppedNotification(notification, subscriber) {
        var onStoppedNotification = config.onStoppedNotification;
        onStoppedNotification && timeoutProvider.setTimeout(function () { return onStoppedNotification(notification, subscriber); });
    }
    var EMPTY_OBSERVER = {
        closed: true,
        next: noop,
        error: defaultErrorHandler,
        complete: noop,
    };

    var observable = (function () { return (typeof Symbol === 'function' && Symbol.observable) || '@@observable'; })();

    /**
     * Returns the provided value unchanged.
     *
     * @param {*} x - The value to return.
     * @return {*} The same value that was passed in.
     */
    function identity(x) {
        return x;
    }

    /**
     * Creates a function that applies a sequence of functions to an input value sequentially.
     *
     * @param {...Function} fns - A variadic number of functions to be applied sequentially.
     * @returns {Function} - A new function that takes an input and passes it through each provided function in order, returning the result of the last function.
     *
     * Example:
     * const addOne = x => x + 1;
     * const multiplyByTwo = x => x * 2;
     * const result = pipe(addOne, multiplyByTwo)(5); // result will be 12
     */
    function pipe() {
        var fns = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            fns[_i] = arguments[_i];
        }
        return pipeFromArray(fns);
    }
    /**
     * Creates a function that takes one parameter `input` and pipes it through an array of functions,
     * applying each function in sequence.
     *
     * @param {Function[]} fns - An array of functions to be piped together.
     * @returns {Function} A single function that, when called with an input value, applies each function
     *          in the array sequentially and returns the final result.
     *
     * @example
     * const addOne = x => x + 1;
     * const multiplyByTwo = x => x * 2;
     * const pipeline = pipeFromArray([addOne, multiplyByTwo]);
     * console.log(pipeline(5)); // Output: 12 (5 + 1) * 2
     */
    function pipeFromArray(fns) {
        if (fns.length === 0) {
            return identity;
        }
        if (fns.length === 1) {
            return fns[0];
        }
        return function piped(input) {
            return fns.reduce(function (prev, fn) { return fn(prev); }, input);
        };
    }

    var Observable = (function () {
        /**
         * Creates an observable sequence with the specified subscribe method to define subscriber behavior.
         *
         * @param {Function} subscribe - A function that defines the initial subscription logic for the observable sequence.
         */
        function Observable(subscribe) {
            if (subscribe) {
                this._subscribe = subscribe;
            }
        }
        Observable.prototype.lift = function (operator) {
            var observable$$1 = new Observable();
            observable$$1.source = this;
            observable$$1.operator = operator;
            return observable$$1;
        };
        Observable.prototype.subscribe = function (observerOrNext, error, complete) {
            var _this = this;
            var subscriber = isSubscriber(observerOrNext) ? observerOrNext : new SafeSubscriber(observerOrNext, error, complete);
            errorContext(function () {
                var _a = _this, operator = _a.operator, source = _a.source;
                subscriber.add(operator
                    ?
                        operator.call(subscriber, source)
                    : source
                        ?
                            _this._subscribe(subscriber)
                        :
                            _this._trySubscribe(subscriber));
            });
            return subscriber;
        };
        Observable.prototype._trySubscribe = function (sink) {
            try {
                return this._subscribe(sink);
            }
            catch (err) {
                sink.error(err);
            }
        };
        Observable.prototype.forEach = function (next, promiseCtor) {
            var _this = this;
            promiseCtor = getPromiseCtor(promiseCtor);
            return new promiseCtor(function (resolve, reject) {
                var subscriber = new SafeSubscriber({
                    next: function (value) {
                        try {
                            next(value);
                        }
                        catch (err) {
                            reject(err);
                            subscriber.unsubscribe();
                        }
                    },
                    error: reject,
                    complete: resolve,
                });
                _this.subscribe(subscriber);
            });
        };
        Observable.prototype._subscribe = function (subscriber) {
            var _a;
            return (_a = this.source) === null || _a === void 0 ? void 0 : _a.subscribe(subscriber);
        };
        Observable.prototype[observable] = function () {
            return this;
        };
        Observable.prototype.pipe = function () {
            var operations = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                operations[_i] = arguments[_i];
            }
            return pipeFromArray(operations)(this);
        };
        Observable.prototype.toPromise = function (promiseCtor) {
            var _this = this;
            promiseCtor = getPromiseCtor(promiseCtor);
            return new promiseCtor(function (resolve, reject) {
                var value;
                _this.subscribe(function (x) { return (value = x); }, function (err) { return reject(err); }, function () { return resolve(value); });
            });
        };
        Observable.create = function (subscribe) {
            return new Observable(subscribe);
        };
        return Observable;
    }());
    /**
     * Returns a promise constructor function. If `promiseCtor` is provided, it checks if it's a valid promise constructor.
     * If not, it falls back to using the value from `config.Promise`, and if that's also undefined or null, it defaults to the native `Promise`.
     *
     * @param {Function} [promiseCtor] - Optional promise constructor function.
     * @returns {Function} The valid promise constructor function.
     */
    function getPromiseCtor(promiseCtor) {
        var _a;
        return (_a = promiseCtor !== null && promiseCtor !== void 0 ? promiseCtor : config.Promise) !== null && _a !== void 0 ? _a : Promise;
    }
    /**
     * Checks if the provided value is an observer.
     *
     * An observer typically has three methods: next, error, and complete. This function verifies
     * that the given value is not null or undefined and contains these three method properties.
     *
     * @param {any} value - The value to check if it's an observer.
     * @returns {boolean} - Returns true if the value is an observer, false otherwise.
     */
    function isObserver(value) {
        return value && isFunction(value.next) && isFunction(value.error) && isFunction(value.complete);
    }
    function isSubscriber(value) {
        return (value && value instanceof Subscriber) || (isObserver(value) && isSubscription(value));
    }

    function hasLift(source) {
        return isFunction(source === null || source === void 0 ? void 0 : source.lift);
    }
    /**
     * Creates an operator function that processes an Observable source using a provided initialization function.
     *
     * @param {Function} init - A function that initializes the operation on the lifted source. This function should return a new Observable.
     * @returns {Function} An observable factory function that takes an Observable source as its parameter.
     *
     * @throws {TypeError} Throws if the source is not a recognized Observable type.
     */
    function operate(init) {
        return function (source) {
            if (hasLift(source)) {
                return source.lift(function (liftedSource) {
                    try {
                        return init(liftedSource, this);
                    }
                    catch (err) {
                        this.error(err);
                    }
                });
            }
            throw new TypeError('Unable to lift unknown Observable type');
        };
    }

    /**
     * Creates an instance of OperatorSubscriber.
     *
     * @constructor
     * @param {Object} destination - The destination object where the subscriber will send notifications.
     * @param {Function|null} onNext - A function that handles the next notification emitted by the observable. If not provided, it defaults to null.
     * @param {Function|null} onComplete - A function that is called when the observable completes successfully. If not provided, it defaults to null.
     * @param {Function|null} onError - A function that is called if an error occurs during the observable's execution. If not provided, it defaults to null.
     * @param {Function|null} onFinalize - A function that is executed when the subscription is finalized, regardless of whether it completed normally or was canceled. If not provided, it defaults to null.
     * @returns {OperatorSubscriber} - The created OperatorSubscriber instance.
     */
    function createOperatorSubscriber(destination, onNext, onComplete, onError, onFinalize) {
        return new OperatorSubscriber(destination, onNext, onComplete, onError, onFinalize);
    }
    var OperatorSubscriber = (function (_super) {
        __extends(OperatorSubscriber, _super);
        /**
         * A subscriber that operates on values received from an Observable.
         *
         * @class OperatorSubscriber
         * @extends {Subscriber}
         * @param {Subscriber} destination - The Subscriber to receive notifications from the source Observable.
         * @param {function(value): void} [onNext] - Optional function called when a value is emitted by the Observable.
         * @param {function(): void} [onComplete] - Optional function called when the Observable completes normally.
         * @param {function(err: any): void} [onError] - Optional function called when an error occurs in the Observable.
         * @param {function(): void} [onFinalize] - Optional function called when the subscription is about to finalize.
         * @param {boolean} [shouldUnsubscribe = false] - Flag indicating whether the subscriber should unsubscribe after handling errors or completes.
         */
        function OperatorSubscriber(destination, onNext, onComplete, onError, onFinalize, shouldUnsubscribe) {
            var _this = _super.call(this, destination) || this;
            _this.onFinalize = onFinalize;
            _this.shouldUnsubscribe = shouldUnsubscribe;
            _this._next = onNext
                ? function (value) {
                    try {
                        onNext(value);
                    }
                    catch (err) {
                        destination.error(err);
                    }
                }
                : _super.prototype._next;
            _this._error = onError
                ? function (err) {
                    try {
                        onError(err);
                    }
                    catch (err) {
                        destination.error(err);
                    }
                    finally {
                        this.unsubscribe();
                    }
                }
                : _super.prototype._error;
            _this._complete = onComplete
                ? function () {
                    try {
                        onComplete();
                    }
                    catch (err) {
                        destination.error(err);
                    }
                    finally {
                        this.unsubscribe();
                    }
                }
                : _super.prototype._complete;
            return _this;
        }
        OperatorSubscriber.prototype.unsubscribe = function () {
            var _a;
            if (!this.shouldUnsubscribe || this.shouldUnsubscribe()) {
                var closed_1 = this.closed;
                _super.prototype.unsubscribe.call(this);
                !closed_1 && ((_a = this.onFinalize) === null || _a === void 0 ? void 0 : _a.call(this));
            }
        };
        return OperatorSubscriber;
    }(Subscriber));

    /**
     * Increments the reference count of the source observable and manages the lifecycle of shared connections.
     *
     * @returns {Observable} A new Observable that shares the same underlying subscription logic as the source, but with a reference counter to manage subscriptions.
     */
    function refCount() {
        return operate(function (source, subscriber) {
            var connection = null;
            source._refCount++;
            var refCounter = createOperatorSubscriber(subscriber, undefined, undefined, undefined, function () {
                if (!source || source._refCount <= 0 || 0 < --source._refCount) {
                    connection = null;
                    return;
                }
                var sharedConnection = source._connection;
                var conn = connection;
                connection = null;
                if (sharedConnection && (!conn || sharedConnection === conn)) {
                    sharedConnection.unsubscribe();
                }
                subscriber.unsubscribe();
            });
            source.subscribe(refCounter);
            if (!refCounter.closed) {
                connection = source.connect();
            }
        });
    }

    var ConnectableObservable = (function (_super) {
        __extends(ConnectableObservable, _super);
        /**
         * Represents an observable that shares a single subscription to its source with multiple observers.
         *
         * @class
         * @extends {Observable}
         * @param {Observable} source - The source observable to connect with multiple subjects.
         * @param {Function} subjectFactory - A factory function to create a new Subject instance for each observer.
         */
        function ConnectableObservable(source, subjectFactory) {
            var _this = _super.call(this) || this;
            _this.source = source;
            _this.subjectFactory = subjectFactory;
            _this._subject = null;
            _this._refCount = 0;
            _this._connection = null;
            if (hasLift(source)) {
                _this.lift = source.lift;
            }
            return _this;
        }
        ConnectableObservable.prototype._subscribe = function (subscriber) {
            return this.getSubject().subscribe(subscriber);
        };
        ConnectableObservable.prototype.getSubject = function () {
            var subject = this._subject;
            if (!subject || subject.isStopped) {
                this._subject = this.subjectFactory();
            }
            return this._subject;
        };
        ConnectableObservable.prototype._teardown = function () {
            this._refCount = 0;
            var _connection = this._connection;
            this._subject = this._connection = null;
            _connection === null || _connection === void 0 ? void 0 : _connection.unsubscribe();
        };
        ConnectableObservable.prototype.connect = function () {
            var _this = this;
            var connection = this._connection;
            if (!connection) {
                connection = this._connection = new Subscription();
                var subject_1 = this.getSubject();
                connection.add(this.source.subscribe(createOperatorSubscriber(subject_1, undefined, function () {
                    _this._teardown();
                    subject_1.complete();
                }, function (err) {
                    _this._teardown();
                    subject_1.error(err);
                }, function () { return _this._teardown(); })));
                if (connection.closed) {
                    this._connection = null;
                    connection = Subscription.EMPTY;
                }
            }
            return connection;
        };
        ConnectableObservable.prototype.refCount = function () {
            return refCount()(this);
        };
        return ConnectableObservable;
    }(Observable));

    var performanceTimestampProvider = {
        now: function () {
            return (performanceTimestampProvider.delegate || performance).now();
        },
        delegate: undefined,
    };

    var animationFrameProvider = {
        schedule: function (callback) {
            var request = requestAnimationFrame;
            var cancel = cancelAnimationFrame;
            var delegate = animationFrameProvider.delegate;
            if (delegate) {
                request = delegate.requestAnimationFrame;
                cancel = delegate.cancelAnimationFrame;
            }
            var handle = request(function (timestamp) {
                cancel = undefined;
                callback(timestamp);
            });
            return new Subscription(function () { return cancel === null || cancel === void 0 ? void 0 : cancel(handle); });
        },
        requestAnimationFrame: function () {
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                args[_i] = arguments[_i];
            }
            var delegate = animationFrameProvider.delegate;
            return ((delegate === null || delegate === void 0 ? void 0 : delegate.requestAnimationFrame) || requestAnimationFrame).apply(void 0, __spreadArray([], __read(args)));
        },
        cancelAnimationFrame: function () {
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                args[_i] = arguments[_i];
            }
            var delegate = animationFrameProvider.delegate;
            return ((delegate === null || delegate === void 0 ? void 0 : delegate.cancelAnimationFrame) || cancelAnimationFrame).apply(void 0, __spreadArray([], __read(args)));
        },
        delegate: undefined,
    };

    /**
     * Returns an animation frames provider.
     *
     * @param {Function} [timestampProvider] - A function that returns the current timestamp. If not provided, defaults to a predefined set of animation frames.
     * @returns {Object|Function} - An object or function representing the animation frames provider.
     *
     * @example
     * // Using a custom timestamp provider
     * const provider = animationFrames(() => Date.now());
     * console.log(provider);
     *
     * @example
     * // Using the default set of animation frames
     * const provider = animationFrames();
     * console.log(provider);
     */
    function animationFrames(timestampProvider) {
        return timestampProvider ? animationFramesFactory(timestampProvider) : DEFAULT_ANIMATION_FRAMES;
    }
    function animationFramesFactory(timestampProvider) {
        return new Observable(function (subscriber) {
            var provider = timestampProvider || performanceTimestampProvider;
            var start = provider.now();
            var id = 0;
            var run = function () {
                if (!subscriber.closed) {
                    id = animationFrameProvider.requestAnimationFrame(function (timestamp) {
                        id = 0;
                        var now = provider.now();
                        subscriber.next({
                            timestamp: timestampProvider ? now : timestamp,
                            elapsed: now - start,
                        });
                        run();
                    });
                }
            };
            run();
            return function () {
                if (id) {
                    animationFrameProvider.cancelAnimationFrame(id);
                }
            };
        });
    }
    var DEFAULT_ANIMATION_FRAMES = animationFramesFactory();

    var ObjectUnsubscribedError = createErrorClass(function (_super) {
        return function ObjectUnsubscribedErrorImpl() {
            _super(this);
            this.name = 'ObjectUnsubscribedError';
            this.message = 'object unsubscribed';
        };
    });

    var Subject = (function (_super) {
        __extends(Subject, _super);
        /**
         * Represents a subject that can be subscribed to for receiving notifications. A subject acts as both an observer and an observable.
         */
        function Subject() {
            var _this = _super.call(this) || this;
            _this.closed = false;
            _this.currentObservers = null;
            _this.observers = [];
            _this.isStopped = false;
            _this.hasError = false;
            _this.thrownError = null;
            return _this;
        }
        Subject.prototype.lift = function (operator) {
            var subject = new AnonymousSubject(this, this);
            subject.operator = operator;
            return subject;
        };
        Subject.prototype._throwIfClosed = function () {
            if (this.closed) {
                throw new ObjectUnsubscribedError();
            }
        };
        Subject.prototype.next = function (value) {
            var _this = this;
            errorContext(function () {
                var e_1, _a;
                _this._throwIfClosed();
                if (!_this.isStopped) {
                    if (!_this.currentObservers) {
                        _this.currentObservers = Array.from(_this.observers);
                    }
                    try {
                        for (var _b = __values(_this.currentObservers), _c = _b.next(); !_c.done; _c = _b.next()) {
                            var observer = _c.value;
                            observer.next(value);
                        }
                    }
                    catch (e_1_1) { e_1 = { error: e_1_1 }; }
                    finally {
                        try {
                            if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
                        }
                        finally { if (e_1) throw e_1.error; }
                    }
                }
            });
        };
        Subject.prototype.error = function (err) {
            var _this = this;
            errorContext(function () {
                _this._throwIfClosed();
                if (!_this.isStopped) {
                    _this.hasError = _this.isStopped = true;
                    _this.thrownError = err;
                    var observers = _this.observers;
                    while (observers.length) {
                        observers.shift().error(err);
                    }
                }
            });
        };
        Subject.prototype.complete = function () {
            var _this = this;
            errorContext(function () {
                _this._throwIfClosed();
                if (!_this.isStopped) {
                    _this.isStopped = true;
                    var observers = _this.observers;
                    while (observers.length) {
                        observers.shift().complete();
                    }
                }
            });
        };
        Subject.prototype.unsubscribe = function () {
            this.isStopped = this.closed = true;
            this.observers = this.currentObservers = null;
        };
        Object.defineProperty(Subject.prototype, "observed", {
            get: function () {
                var _a;
                return ((_a = this.observers) === null || _a === void 0 ? void 0 : _a.length) > 0;
            },
            enumerable: false,
            configurable: true
        });
        Subject.prototype._trySubscribe = function (subscriber) {
            this._throwIfClosed();
            return _super.prototype._trySubscribe.call(this, subscriber);
        };
        Subject.prototype._subscribe = function (subscriber) {
            this._throwIfClosed();
            this._checkFinalizedStatuses(subscriber);
            return this._innerSubscribe(subscriber);
        };
        Subject.prototype._innerSubscribe = function (subscriber) {
            var _this = this;
            var _a = this, hasError = _a.hasError, isStopped = _a.isStopped, observers = _a.observers;
            if (hasError || isStopped) {
                return EMPTY_SUBSCRIPTION;
            }
            this.currentObservers = null;
            observers.push(subscriber);
            return new Subscription(function () {
                _this.currentObservers = null;
                arrRemove(observers, subscriber);
            });
        };
        Subject.prototype._checkFinalizedStatuses = function (subscriber) {
            var _a = this, hasError = _a.hasError, thrownError = _a.thrownError, isStopped = _a.isStopped;
            if (hasError) {
                subscriber.error(thrownError);
            }
            else if (isStopped) {
                subscriber.complete();
            }
        };
        Subject.prototype.asObservable = function () {
            var observable = new Observable();
            observable.source = this;
            return observable;
        };
        Subject.create = function (destination, source) {
            return new AnonymousSubject(destination, source);
        };
        return Subject;
    }(Observable));
    var AnonymousSubject = (function (_super) {
        __extends(AnonymousSubject, _super);
        /**
         * Creates an instance of AnonymousSubject that acts as both an Observable and Observer.
         *
         * @class
         * @param {Observer} destination - The observer to receive notifications.
         * @param {Observable} source - The observable to receive subscription requests.
         */
        function AnonymousSubject(destination, source) {
            var _this = _super.call(this) || this;
            _this.destination = destination;
            _this.source = source;
            return _this;
        }
        AnonymousSubject.prototype.next = function (value) {
            var _a, _b;
            (_b = (_a = this.destination) === null || _a === void 0 ? void 0 : _a.next) === null || _b === void 0 ? void 0 : _b.call(_a, value);
        };
        AnonymousSubject.prototype.error = function (err) {
            var _a, _b;
            (_b = (_a = this.destination) === null || _a === void 0 ? void 0 : _a.error) === null || _b === void 0 ? void 0 : _b.call(_a, err);
        };
        AnonymousSubject.prototype.complete = function () {
            var _a, _b;
            (_b = (_a = this.destination) === null || _a === void 0 ? void 0 : _a.complete) === null || _b === void 0 ? void 0 : _b.call(_a);
        };
        AnonymousSubject.prototype._subscribe = function (subscriber) {
            var _a, _b;
            return (_b = (_a = this.source) === null || _a === void 0 ? void 0 : _a.subscribe(subscriber)) !== null && _b !== void 0 ? _b : EMPTY_SUBSCRIPTION;
        };
        return AnonymousSubject;
    }(Subject));

    var BehaviorSubject = (function (_super) {
        __extends(BehaviorSubject, _super);
        /**
         * Represents an observable that shares a single value with multiple subscribers.
         *
         * @constructor
         * @param {*} _value - The initial value to be shared among subscribers.
         */
        function BehaviorSubject(_value) {
            var _this = _super.call(this) || this;
            _this._value = _value;
            return _this;
        }
        Object.defineProperty(BehaviorSubject.prototype, "value", {
            get: function () {
                return this.getValue();
            },
            enumerable: false,
            configurable: true
        });
        BehaviorSubject.prototype._subscribe = function (subscriber) {
            var subscription = _super.prototype._subscribe.call(this, subscriber);
            !subscription.closed && subscriber.next(this._value);
            return subscription;
        };
        BehaviorSubject.prototype.getValue = function () {
            var _a = this, hasError = _a.hasError, thrownError = _a.thrownError, _value = _a._value;
            if (hasError) {
                throw thrownError;
            }
            this._throwIfClosed();
            return _value;
        };
        BehaviorSubject.prototype.next = function (value) {
            _super.prototype.next.call(this, (this._value = value));
        };
        return BehaviorSubject;
    }(Subject));

    var dateTimestampProvider = {
        now: function () {
            return (dateTimestampProvider.delegate || Date).now();
        },
        delegate: undefined,
    };

    var ReplaySubject = (function (_super) {
        __extends(ReplaySubject, _super);
        /**
         * A class that represents a subject which can multicast values to multiple observers,
         * but also allows replaying past events upon subscription.
         *
         * @param {number} [_bufferSize=Infinity] - The maximum number of values to store in the buffer. Defaults to Infinity.
         * @param {number} [_windowTime=Infinity] - The time window within which past events should be replayed, in milliseconds. Defaults to Infinity.
         * @param {function} [_timestampProvider=Function] - A function that provides the current timestamp. Defaults to `dateTimestampProvider`.
         *
         * @constructor
         */
        function ReplaySubject(_bufferSize, _windowTime, _timestampProvider) {
            if (_bufferSize === void 0) { _bufferSize = Infinity; }
            if (_windowTime === void 0) { _windowTime = Infinity; }
            if (_timestampProvider === void 0) { _timestampProvider = dateTimestampProvider; }
            var _this = _super.call(this) || this;
            _this._bufferSize = _bufferSize;
            _this._windowTime = _windowTime;
            _this._timestampProvider = _timestampProvider;
            _this._buffer = [];
            _this._infiniteTimeWindow = true;
            _this._infiniteTimeWindow = _windowTime === Infinity;
            _this._bufferSize = Math.max(1, _bufferSize);
            _this._windowTime = Math.max(1, _windowTime);
            return _this;
        }
        ReplaySubject.prototype.next = function (value) {
            var _a = this, isStopped = _a.isStopped, _buffer = _a._buffer, _infiniteTimeWindow = _a._infiniteTimeWindow, _timestampProvider = _a._timestampProvider, _windowTime = _a._windowTime;
            if (!isStopped) {
                _buffer.push(value);
                !_infiniteTimeWindow && _buffer.push(_timestampProvider.now() + _windowTime);
            }
            this._trimBuffer();
            _super.prototype.next.call(this, value);
        };
        ReplaySubject.prototype._subscribe = function (subscriber) {
            this._throwIfClosed();
            this._trimBuffer();
            var subscription = this._innerSubscribe(subscriber);
            var _a = this, _infiniteTimeWindow = _a._infiniteTimeWindow, _buffer = _a._buffer;
            var copy = _buffer.slice();
            for (var i = 0; i < copy.length && !subscriber.closed; i += _infiniteTimeWindow ? 1 : 2) {
                subscriber.next(copy[i]);
            }
            this._checkFinalizedStatuses(subscriber);
            return subscription;
        };
        ReplaySubject.prototype._trimBuffer = function () {
            var _a = this, _bufferSize = _a._bufferSize, _timestampProvider = _a._timestampProvider, _buffer = _a._buffer, _infiniteTimeWindow = _a._infiniteTimeWindow;
            var adjustedBufferSize = (_infiniteTimeWindow ? 1 : 2) * _bufferSize;
            _bufferSize < Infinity && adjustedBufferSize < _buffer.length && _buffer.splice(0, _buffer.length - adjustedBufferSize);
            if (!_infiniteTimeWindow) {
                var now = _timestampProvider.now();
                var last = 0;
                for (var i = 1; i < _buffer.length && _buffer[i] <= now; i += 2) {
                    last = i;
                }
                last && _buffer.splice(0, last + 1);
            }
        };
        return ReplaySubject;
    }(Subject));

    var AsyncSubject = (function (_super) {
        __extends(AsyncSubject, _super);
        function AsyncSubject() {
            var _this = _super !== null && _super.apply(this, arguments) || this;
            _this._value = null;
            _this._hasValue = false;
            _this._isComplete = false;
            return _this;
        }
        AsyncSubject.prototype._checkFinalizedStatuses = function (subscriber) {
            var _a = this, hasError = _a.hasError, _hasValue = _a._hasValue, _value = _a._value, thrownError = _a.thrownError, isStopped = _a.isStopped, _isComplete = _a._isComplete;
            if (hasError) {
                subscriber.error(thrownError);
            }
            else if (isStopped || _isComplete) {
                _hasValue && subscriber.next(_value);
                subscriber.complete();
            }
        };
        AsyncSubject.prototype.next = function (value) {
            if (!this.isStopped) {
                this._value = value;
                this._hasValue = true;
            }
        };
        AsyncSubject.prototype.complete = function () {
            var _a = this, _hasValue = _a._hasValue, _value = _a._value, _isComplete = _a._isComplete;
            if (!_isComplete) {
                this._isComplete = true;
                _hasValue && _super.prototype.next.call(this, _value);
                _super.prototype.complete.call(this);
            }
        };
        return AsyncSubject;
    }(Subject));

    var Action = (function (_super) {
        __extends(Action, _super);
        /**
         * Represents an action that can be scheduled and executed.
         *
         * @constructor
         * @param {Scheduler} scheduler - The scheduler responsible for managing the execution of this action.
         * @param {Function} work - A function representing the task to be executed.
         *
         * @throws {TypeError} If `scheduler` is not an instance of Scheduler or if `work` is not a function.
         */
        function Action(scheduler, work) {
            return _super.call(this) || this;
        }
        Action.prototype.schedule = function (state, delay) {
            if (delay === void 0) { delay = 0; }
            return this;
        };
        return Action;
    }(Subscription));

    var intervalProvider = {
        setInterval: function (handler, timeout) {
            var args = [];
            for (var _i = 2; _i < arguments.length; _i++) {
                args[_i - 2] = arguments[_i];
            }
            var delegate = intervalProvider.delegate;
            if (delegate === null || delegate === void 0 ? void 0 : delegate.setInterval) {
                return delegate.setInterval.apply(delegate, __spreadArray([handler, timeout], __read(args)));
            }
            return setInterval.apply(void 0, __spreadArray([handler, timeout], __read(args)));
        },
        clearInterval: function (handle) {
            var delegate = intervalProvider.delegate;
            return ((delegate === null || delegate === void 0 ? void 0 : delegate.clearInterval) || clearInterval)(handle);
        },
        delegate: undefined,
    };

    var AsyncAction = (function (_super) {
        __extends(AsyncAction, _super);
        /**
         * Represents an asynchronous action that can be scheduled to run at a later time.
         *
         * @constructor
         * @param {Scheduler} scheduler - The scheduler responsible for scheduling the work.
         * @param {Function} work - The function representing the work to be executed.
         */
        function AsyncAction(scheduler, work) {
            var _this = _super.call(this, scheduler, work) || this;
            _this.scheduler = scheduler;
            _this.work = work;
            _this.pending = false;
            return _this;
        }
        AsyncAction.prototype.schedule = function (state, delay) {
            var _a;
            if (delay === void 0) { delay = 0; }
            if (this.closed) {
                return this;
            }
            this.state = state;
            var id = this.id;
            var scheduler = this.scheduler;
            if (id != null) {
                this.id = this.recycleAsyncId(scheduler, id, delay);
            }
            this.pending = true;
            this.delay = delay;
            this.id = (_a = this.id) !== null && _a !== void 0 ? _a : this.requestAsyncId(scheduler, this.id, delay);
            return this;
        };
        AsyncAction.prototype.requestAsyncId = function (scheduler, _id, delay) {
            if (delay === void 0) { delay = 0; }
            return intervalProvider.setInterval(scheduler.flush.bind(scheduler, this), delay);
        };
        AsyncAction.prototype.recycleAsyncId = function (_scheduler, id, delay) {
            if (delay === void 0) { delay = 0; }
            if (delay != null && this.delay === delay && this.pending === false) {
                return id;
            }
            if (id != null) {
                intervalProvider.clearInterval(id);
            }
            return undefined;
        };
        AsyncAction.prototype.execute = function (state, delay) {
            if (this.closed) {
                return new Error('executing a cancelled action');
            }
            this.pending = false;
            var error = this._execute(state, delay);
            if (error) {
                return error;
            }
            else if (this.pending === false && this.id != null) {
                this.id = this.recycleAsyncId(this.scheduler, this.id, null);
            }
        };
        AsyncAction.prototype._execute = function (state, _delay) {
            var errored = false;
            var errorValue;
            try {
                this.work(state);
            }
            catch (e) {
                errored = true;
                errorValue = e ? e : new Error('Scheduled action threw falsy error');
            }
            if (errored) {
                this.unsubscribe();
                return errorValue;
            }
        };
        AsyncAction.prototype.unsubscribe = function () {
            if (!this.closed) {
                var _a = this, id = _a.id, scheduler = _a.scheduler;
                var actions = scheduler.actions;
                this.work = this.state = this.scheduler = null;
                this.pending = false;
                arrRemove(actions, this);
                if (id != null) {
                    this.id = this.recycleAsyncId(scheduler, id, null);
                }
                this.delay = null;
                _super.prototype.unsubscribe.call(this);
            }
        };
        return AsyncAction;
    }(Action));

    var nextHandle = 1;
    var resolved;
    var activeHandles = {};
    /**
     * Attempts to find and clear an active handle by removing it from the `activeHandles` object.
     *
     * @param {string} handle - The identifier of the handle to be cleared.
     * @return {boolean} - Returns true if the handle was found and cleared, false otherwise.
     */
    function findAndClearHandle(handle) {
        if (handle in activeHandles) {
            delete activeHandles[handle];
            return true;
        }
        return false;
    }
    var Immediate = {
        setImmediate: function (cb) {
            var handle = nextHandle++;
            activeHandles[handle] = true;
            if (!resolved) {
                resolved = Promise.resolve();
            }
            resolved.then(function () { return findAndClearHandle(handle) && cb(); });
            return handle;
        },
        clearImmediate: function (handle) {
            findAndClearHandle(handle);
        },
    };

    var setImmediate = Immediate.setImmediate, clearImmediate = Immediate.clearImmediate;
    var immediateProvider = {
        setImmediate: function () {
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                args[_i] = arguments[_i];
            }
            var delegate = immediateProvider.delegate;
            return ((delegate === null || delegate === void 0 ? void 0 : delegate.setImmediate) || setImmediate).apply(void 0, __spreadArray([], __read(args)));
        },
        clearImmediate: function (handle) {
            var delegate = immediateProvider.delegate;
            return ((delegate === null || delegate === void 0 ? void 0 : delegate.clearImmediate) || clearImmediate)(handle);
        },
        delegate: undefined,
    };

    var AsapAction = (function (_super) {
        __extends(AsapAction, _super);
        /**
         * Represents an action that should be executed as soon as possible.
         *
         * @constructor
         * @extends {SchedulerAction}
         *
         * @param {Object} scheduler - The scheduler that manages this action.
         * @param {Function} work - The function to execute when the action is invoked.
         *
         * @example
         * var scheduler = new Scheduler();
         * var action = new AsapAction(scheduler, () => {
         *   console.log('Action executed');
         * });
         */
        function AsapAction(scheduler, work) {
            var _this = _super.call(this, scheduler, work) || this;
            _this.scheduler = scheduler;
            _this.work = work;
            return _this;
        }
        AsapAction.prototype.requestAsyncId = function (scheduler, id, delay) {
            if (delay === void 0) { delay = 0; }
            if (delay !== null && delay > 0) {
                return _super.prototype.requestAsyncId.call(this, scheduler, id, delay);
            }
            scheduler.actions.push(this);
            return scheduler._scheduled || (scheduler._scheduled = immediateProvider.setImmediate(scheduler.flush.bind(scheduler, undefined)));
        };
        AsapAction.prototype.recycleAsyncId = function (scheduler, id, delay) {
            var _a;
            if (delay === void 0) { delay = 0; }
            if (delay != null ? delay > 0 : this.delay > 0) {
                return _super.prototype.recycleAsyncId.call(this, scheduler, id, delay);
            }
            var actions = scheduler.actions;
            if (id != null && ((_a = actions[actions.length - 1]) === null || _a === void 0 ? void 0 : _a.id) !== id) {
                immediateProvider.clearImmediate(id);
                if (scheduler._scheduled === id) {
                    scheduler._scheduled = undefined;
                }
            }
            return undefined;
        };
        return AsapAction;
    }(AsyncAction));

    var Scheduler = (function () {
        function Scheduler(schedulerActionCtor, now) {
            if (now === void 0) { now = Scheduler.now; }
            this.schedulerActionCtor = schedulerActionCtor;
            this.now = now;
        }
        Scheduler.prototype.schedule = function (work, delay, state) {
            if (delay === void 0) { delay = 0; }
            return new this.schedulerActionCtor(this, work).schedule(state, delay);
        };
        Scheduler.now = dateTimestampProvider.now;
        return Scheduler;
    }());

    var AsyncScheduler = (function (_super) {
        __extends(AsyncScheduler, _super);
        /**
         * A scheduler that handles asynchronous operations using Promises.
         *
         * @class
         * @extends Scheduler
         * @param {Function} [SchedulerAction] - The action to be executed asynchronously.
         * @param {Function} [now=Scheduler.now] - Function to get the current time in milliseconds. Defaults to the global `Date.now` function.
         */
        function AsyncScheduler(SchedulerAction, now) {
            if (now === void 0) { now = Scheduler.now; }
            var _this = _super.call(this, SchedulerAction, now) || this;
            _this.actions = [];
            _this._active = false;
            return _this;
        }
        AsyncScheduler.prototype.flush = function (action) {
            var actions = this.actions;
            if (this._active) {
                actions.push(action);
                return;
            }
            var error;
            this._active = true;
            do {
                if ((error = action.execute(action.state, action.delay))) {
                    break;
                }
            } while ((action = actions.shift()));
            this._active = false;
            if (error) {
                while ((action = actions.shift())) {
                    action.unsubscribe();
                }
                throw error;
            }
        };
        return AsyncScheduler;
    }(Scheduler));

    var AsapScheduler = (function (_super) {
        __extends(AsapScheduler, _super);
        /**
         * A scheduler that performs tasks as soon as possible.
         *
         * @constructor
         */
        function AsapScheduler() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        AsapScheduler.prototype.flush = function (action) {
            this._active = true;
            var flushId = this._scheduled;
            this._scheduled = undefined;
            var actions = this.actions;
            var error;
            action = action || actions.shift();
            do {
                if ((error = action.execute(action.state, action.delay))) {
                    break;
                }
            } while ((action = actions[0]) && action.id === flushId && actions.shift());
            this._active = false;
            if (error) {
                while ((action = actions[0]) && action.id === flushId && actions.shift()) {
                    action.unsubscribe();
                }
                throw error;
            }
        };
        return AsapScheduler;
    }(AsyncScheduler));

    var asapScheduler = new AsapScheduler(AsapAction);
    var asap = asapScheduler;

    var asyncScheduler = new AsyncScheduler(AsyncAction);
    var async = asyncScheduler;

    var QueueAction = (function (_super) {
        __extends(QueueAction, _super);
        /**
         * Represents an action that is enqueued for execution at a later time by a scheduler.
         *
         * @class QueueAction
         * @param {Object} scheduler - The scheduler responsible for executing the work.
         * @param {Function} work - The function to be executed when this action runs.
         */
        function QueueAction(scheduler, work) {
            var _this = _super.call(this, scheduler, work) || this;
            _this.scheduler = scheduler;
            _this.work = work;
            return _this;
        }
        QueueAction.prototype.schedule = function (state, delay) {
            if (delay === void 0) { delay = 0; }
            if (delay > 0) {
                return _super.prototype.schedule.call(this, state, delay);
            }
            this.delay = delay;
            this.state = state;
            this.scheduler.flush(this);
            return this;
        };
        QueueAction.prototype.execute = function (state, delay) {
            return delay > 0 || this.closed ? _super.prototype.execute.call(this, state, delay) : this._execute(state, delay);
        };
        QueueAction.prototype.requestAsyncId = function (scheduler, id, delay) {
            if (delay === void 0) { delay = 0; }
            if ((delay != null && delay > 0) || (delay == null && this.delay > 0)) {
                return _super.prototype.requestAsyncId.call(this, scheduler, id, delay);
            }
            scheduler.flush(this);
            return 0;
        };
        return QueueAction;
    }(AsyncAction));

    var QueueScheduler = (function (_super) {
        __extends(QueueScheduler, _super);
        /**
         * Represents a scheduler that manages tasks using a queue.
         *
         * @constructor
         */
        function QueueScheduler() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        return QueueScheduler;
    }(AsyncScheduler));

    var queueScheduler = new QueueScheduler(QueueAction);
    var queue = queueScheduler;

    var AnimationFrameAction = (function (_super) {
        __extends(AnimationFrameAction, _super);
        /**
         * Represents an action that schedules work to run during the next animation frame using requestAnimationFrame.
         *
         * @constructor
         * @extends SchedulerAction
         * @param {Scheduler} scheduler - The scheduler managing this action.
         * @param {Function} work - The function representing the work to be executed.
         */
        function AnimationFrameAction(scheduler, work) {
            var _this = _super.call(this, scheduler, work) || this;
            _this.scheduler = scheduler;
            _this.work = work;
            return _this;
        }
        AnimationFrameAction.prototype.requestAsyncId = function (scheduler, id, delay) {
            if (delay === void 0) { delay = 0; }
            if (delay !== null && delay > 0) {
                return _super.prototype.requestAsyncId.call(this, scheduler, id, delay);
            }
            scheduler.actions.push(this);
            return scheduler._scheduled || (scheduler._scheduled = animationFrameProvider.requestAnimationFrame(function () { return scheduler.flush(undefined); }));
        };
        AnimationFrameAction.prototype.recycleAsyncId = function (scheduler, id, delay) {
            var _a;
            if (delay === void 0) { delay = 0; }
            if (delay != null ? delay > 0 : this.delay > 0) {
                return _super.prototype.recycleAsyncId.call(this, scheduler, id, delay);
            }
            var actions = scheduler.actions;
            if (id != null && id === scheduler._scheduled && ((_a = actions[actions.length - 1]) === null || _a === void 0 ? void 0 : _a.id) !== id) {
                animationFrameProvider.cancelAnimationFrame(id);
                scheduler._scheduled = undefined;
            }
            return undefined;
        };
        return AnimationFrameAction;
    }(AsyncAction));

    var AnimationFrameScheduler = (function (_super) {
        __extends(AnimationFrameScheduler, _super);
        /**
         * A class that schedules tasks using the browser's Animation Frame API for smooth performance.
         *
         * @constructor
         */
        function AnimationFrameScheduler() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        AnimationFrameScheduler.prototype.flush = function (action) {
            this._active = true;
            var flushId;
            if (action) {
                flushId = action.id;
            }
            else {
                flushId = this._scheduled;
                this._scheduled = undefined;
            }
            var actions = this.actions;
            var error;
            action = action || actions.shift();
            do {
                if ((error = action.execute(action.state, action.delay))) {
                    break;
                }
            } while ((action = actions[0]) && action.id === flushId && actions.shift());
            this._active = false;
            if (error) {
                while ((action = actions[0]) && action.id === flushId && actions.shift()) {
                    action.unsubscribe();
                }
                throw error;
            }
        };
        return AnimationFrameScheduler;
    }(AsyncScheduler));

    var animationFrameScheduler = new AnimationFrameScheduler(AnimationFrameAction);
    var animationFrame = animationFrameScheduler;

    var VirtualTimeScheduler = (function (_super) {
        __extends(VirtualTimeScheduler, _super);
        /**
         * A scheduler that uses virtual time to schedule actions. This scheduler allows for time manipulation,
         * which is useful in testing scenarios where exact timing of events is critical.
         *
         * @constructor
         * @extends {Scheduler}
         * @param {Function} [schedulerActionCtor=VirtualAction] - The constructor function for the actions to be scheduled.
         * @param {number} [maxFrames=Infinity] - The maximum number of frames that can be simulated. Default is Infinity.
         */
        function VirtualTimeScheduler(schedulerActionCtor, maxFrames) {
            if (schedulerActionCtor === void 0) { schedulerActionCtor = VirtualAction; }
            if (maxFrames === void 0) { maxFrames = Infinity; }
            var _this = _super.call(this, schedulerActionCtor, function () { return _this.frame; }) || this;
            _this.maxFrames = maxFrames;
            _this.frame = 0;
            _this.index = -1;
            return _this;
        }
        VirtualTimeScheduler.prototype.flush = function () {
            var _a = this, actions = _a.actions, maxFrames = _a.maxFrames;
            var error;
            var action;
            while ((action = actions[0]) && action.delay <= maxFrames) {
                actions.shift();
                this.frame = action.delay;
                if ((error = action.execute(action.state, action.delay))) {
                    break;
                }
            }
            if (error) {
                while ((action = actions.shift())) {
                    action.unsubscribe();
                }
                throw error;
            }
        };
        VirtualTimeScheduler.frameTimeFactor = 10;
        return VirtualTimeScheduler;
    }(AsyncScheduler));
    var VirtualAction = (function (_super) {
        __extends(VirtualAction, _super);
        /**
         * Represents a virtual action to be scheduled by a scheduler.
         *
         * @class VirtualAction
         * @param {Object} scheduler - The scheduler that will execute this action.
         * @param {Function} work - The function representing the work to be executed.
         * @param {number} [index=++scheduler.index] - A unique index for this action, defaults to the next available index in the scheduler.
         */
        function VirtualAction(scheduler, work, index) {
            if (index === void 0) { index = (scheduler.index += 1); }
            var _this = _super.call(this, scheduler, work) || this;
            _this.scheduler = scheduler;
            _this.work = work;
            _this.index = index;
            _this.active = true;
            _this.index = scheduler.index = index;
            return _this;
        }
        VirtualAction.prototype.schedule = function (state, delay) {
            if (delay === void 0) { delay = 0; }
            if (Number.isFinite(delay)) {
                if (!this.id) {
                    return _super.prototype.schedule.call(this, state, delay);
                }
                this.active = false;
                var action = new VirtualAction(this.scheduler, this.work);
                this.add(action);
                return action.schedule(state, delay);
            }
            else {
                return Subscription.EMPTY;
            }
        };
        VirtualAction.prototype.requestAsyncId = function (scheduler, id, delay) {
            if (delay === void 0) { delay = 0; }
            this.delay = scheduler.frame + delay;
            var actions = scheduler.actions;
            actions.push(this);
            actions.sort(VirtualAction.sortActions);
            return 1;
        };
        VirtualAction.prototype.recycleAsyncId = function (scheduler, id, delay) {
            if (delay === void 0) { delay = 0; }
            return undefined;
        };
        VirtualAction.prototype._execute = function (state, delay) {
            if (this.active === true) {
                return _super.prototype._execute.call(this, state, delay);
            }
        };
        VirtualAction.sortActions = function (a, b) {
            if (a.delay === b.delay) {
                if (a.index === b.index) {
                    return 0;
                }
                else if (a.index > b.index) {
                    return 1;
                }
                else {
                    return -1;
                }
            }
            else if (a.delay > b.delay) {
                return 1;
            }
            else {
                return -1;
            }
        };
        return VirtualAction;
    }(AsyncAction));

    var EMPTY = new Observable(function (subscriber) { return subscriber.complete(); });
    /**
     * Returns an empty scheduler or a predefined empty value.
     *
     * @param {Object} scheduler - The scheduler to check. If falsy, returns the pre-defined EMPTY value.
     * @returns {Object} - Either the provided scheduler (if truthy) or the pre-defined EMPTY value.
     */
    function empty(scheduler) {
        return scheduler ? emptyScheduled(scheduler) : EMPTY;
    }
    /**
     * Creates an Observable that emits no items to the Observer and immediately notifies it of completion.
     *
     * @param {Object} scheduler - The scheduler on which to schedule the emission of the completed notification.
     * @returns {Observable} An Observable that emits no items but completes immediately upon subscription.
     */
    function emptyScheduled(scheduler) {
        return new Observable(function (subscriber) { return scheduler.schedule(function () { return subscriber.complete(); }); });
    }

    /**
     * Determines if a given value is an instance of Scheduler.
     *
     * @param {any} value - The value to check.
     * @returns {boolean} Returns `true` if the value is an instance of Scheduler, otherwise `false`.
     */
    function isScheduler(value) {
        return value && isFunction(value.schedule);
    }

    /**
     * Returns the last element of an array.
     *
     * @param {Array} arr - The array from which to retrieve the last element.
     * @returns {*} - The last element of the array.
     * @throws {Error} - Throws an error if the input is not an array or if the array is empty.
     * @example
     * const result = last([1, 2, 3]);
     * console.log(result); // Output: 3
     */
    function last(arr) {
        return arr[arr.length - 1];
    }
    /**
     * Extracts the result selector function from an array of arguments if it exists.
     *
     * @param {Array} args - The array of arguments to process.
     * @returns {(Function|undefined)} - Returns the last element of the array if it is a function, otherwise returns undefined.
     *
     * @example
     * const selector = popResultSelector([1, 2, (x) => x + 1]);
     * console.log(selector); // Output: [Function]
     */
    function popResultSelector(args) {
        return isFunction(last(args)) ? args.pop() : undefined;
    }
    /**
     * Removes and returns the last element of an array if it is a scheduler; otherwise, returns undefined.
     *
     * @param {Array} args - The array from which to pop the element.
     * @returns {(Object|undefined)} The popped object if it is a scheduler, or undefined otherwise.
     */
    function popScheduler(args) {
        return isScheduler(last(args)) ? args.pop() : undefined;
    }
    /**
     * Retrieves the last number from an array or returns a default value if no number is found.
     *
     * @param {Array} args - The array to retrieve the number from.
     * @param {*} defaultValue - The value to return if no number is found in the array.
     * @returns {*} The last number in the array, or the provided default value.
     *
     * @example
     * // Returns 42
     * popNumber([10, 'hello', 42], 0);
     *
     * @example
     * // Returns 0
     * popNumber(['world'], 0);
     */
    function popNumber(args, defaultValue) {
        return typeof last(args) === 'number' ? args.pop() : defaultValue;
    }

    var isArrayLike = (function (x) { return x && typeof x.length === 'number' && typeof x !== 'function'; });

    /**
     * Determines whether a value is a Promise.
     *
     * @param {any} value - The value to check.
     * @returns {boolean} Returns true if the value is a Promise, otherwise false.
     *
     * Example usage:
     * ```javascript
     * const myPromise = new Promise((resolve, reject) => resolve('Success'));
     * console.log(isPromise(myPromise)); // Output: true
     *
     * console.log(isPromise('Not a promise')); // Output: false
     * ```
     */
    function isPromise(value) {
        return isFunction(value === null || value === void 0 ? void 0 : value.then);
    }

    /**
     * Checks if an input object is interop observable by verifying the presence of a 'observable' method property.
     *
     * @param {Object} input - The object to check for interop observability.
     * @returns {boolean} - Returns true if the input is interop observable, false otherwise.
     *
     * Example:
     * const testObject = {
     *   [Symbol.observable]: () => ({ subscribe: () => {} })
     * };
     * console.log(isInteropObservable(testObject)); // true
     */
    function isInteropObservable(input) {
        return isFunction(input[observable]);
    }

    /**
     * Checks if an object is async iterable.
     *
     * @param {any} obj - The object to check.
     * @returns {boolean} - Returns true if the object is async iterable, false otherwise.
     * @throws {TypeError} - If the input parameter is not an object or function.
     */
    function isAsyncIterable(obj) {
        return Symbol.asyncIterator && isFunction(obj === null || obj === void 0 ? void 0 : obj[Symbol.asyncIterator]);
    }

    /**
     * Creates a TypeError indicating that an invalid input was provided where a stream or iterable is expected.
     *
     * @param {*} input - The input value that caused the error.
     * @returns {TypeError} - A TypeError object with a descriptive message.
     *
     * @example
     * try {
     *   createInvalidObservableTypeError(123);
     * } catch (error) {
     *   console.error(error.message); // Outputs: "You provided '123' where a stream was expected. You can provide an Observable, Promise, ReadableStream, Array, AsyncIterable, or Iterable."
     * }
     */
    function createInvalidObservableTypeError(input) {
        return new TypeError("You provided " + (input !== null && typeof input === 'object' ? 'an invalid object' : "'" + input + "'") + " where a stream was expected. You can provide an Observable, Promise, ReadableStream, Array, AsyncIterable, or Iterable.");
    }

    /**
     * Determines the appropriate symbol iterator for the current environment.
     *
     * @returns {string|symbol} - The symbol or string that represents the iterator method.
     *
     * Example usage:
     * const iterator = getSymbolIterator();
     * console.log(iterator); // Outputs: @@iterator or Symbol.iterator depending on the environment
     */
    function getSymbolIterator() {
        if (typeof Symbol !== 'function' || !Symbol.iterator) {
            return '@@iterator';
        }
        return Symbol.iterator;
    }
    var iterator = getSymbolIterator();

    /**
     * Determines if the provided input is iterable.
     *
     * @param {any} input - The value to check for iterability.
     * @returns {boolean} - Returns true if the input is iterable, false otherwise.
     * @throws {TypeError} - Throws an error if the input is not an object.
     */
    function isIterable(input) {
        return isFunction(input === null || input === void 0 ? void 0 : input[iterator]);
    }

    /**
     * Converts a `ReadableStream`-like object into an asynchronous generator.
     *
     * @param {ReadableStream} readableStream - The stream to convert. This can be a native JavaScript `ReadableStream`, or any object that implements the necessary methods.
     * @returns {AsyncGenerator} An asynchronous generator that yields chunks of data from the stream as they become available.
     *
     * @example
     * // Example usage:
     * const readableStream = new ReadableStream({
     *   start(controller) {
     *     controller.enqueue("Hello");
     *     controller.enqueue("World");
     *     controller.close();
     *   }
     * });
     *
     * for await (const chunk of readableStreamLikeToAsyncGenerator(readableStream)) {
     *   console.log(chunk);
     * }
     *
     * @throws {Error} Throws an error if the stream encounters a problem.
     */
    function readableStreamLikeToAsyncGenerator(readableStream) {
        return __asyncGenerator(this, arguments, function readableStreamLikeToAsyncGenerator_1() {
            var reader, _a, value, done;
            return __generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        reader = readableStream.getReader();
                        _b.label = 1;
                    case 1:
                        _b.trys.push([1, , 9, 10]);
                        _b.label = 2;
                    case 2:
                        return [4, __await(reader.read())];
                    case 3:
                        _a = _b.sent(), value = _a.value, done = _a.done;
                        if (!done) return [3, 5];
                        return [4, __await(void 0)];
                    case 4: return [2, _b.sent()];
                    case 5: return [4, __await(value)];
                    case 6: return [4, _b.sent()];
                    case 7:
                        _b.sent();
                        return [3, 2];
                    case 8: return [3, 10];
                    case 9:
                        reader.releaseLock();
                        return [7];
                    case 10: return [2];
                }
            });
        });
    }
    function isReadableStreamLike(obj) {
        return isFunction(obj === null || obj === void 0 ? void 0 : obj.getReader);
    }

    /**
     * Determines if the input is an instance of Observable or implements interop observable protocol.
     *
     * @param {any} input - The input to check.
     * @returns {Observable<any>} An Observable created from the input.
     * @throws {Error} Throws an error if the input does not implement any known observable protocol.
     */
    function innerFrom(input) {
        if (input instanceof Observable) {
            return input;
        }
        if (input != null) {
            if (isInteropObservable(input)) {
                return fromInteropObservable(input);
            }
            if (isArrayLike(input)) {
                return fromArrayLike(input);
            }
            if (isPromise(input)) {
                return fromPromise(input);
            }
            if (isAsyncIterable(input)) {
                return fromAsyncIterable(input);
            }
            if (isIterable(input)) {
                return fromIterable(input);
            }
            if (isReadableStreamLike(input)) {
                return fromReadableStreamLike(input);
            }
        }
        throw createInvalidObservableTypeError(input);
    }
    function fromInteropObservable(obj) {
        return new Observable(function (subscriber) {
            var obs = obj[observable]();
            if (isFunction(obs.subscribe)) {
                return obs.subscribe(subscriber);
            }
            throw new TypeError('Provided object does not correctly implement Symbol.observable');
        });
    }
    function fromArrayLike(array) {
        return new Observable(function (subscriber) {
            for (var i = 0; i < array.length && !subscriber.closed; i++) {
                subscriber.next(array[i]);
            }
            subscriber.complete();
        });
    }
    function fromPromise(promise) {
        return new Observable(function (subscriber) {
            promise
                .then(function (value) {
                if (!subscriber.closed) {
                    subscriber.next(value);
                    subscriber.complete();
                }
            }, function (err) { return subscriber.error(err); })
                .then(null, reportUnhandledError);
        });
    }
    function fromIterable(iterable) {
        return new Observable(function (subscriber) {
            var e_1, _a;
            try {
                for (var iterable_1 = __values(iterable), iterable_1_1 = iterable_1.next(); !iterable_1_1.done; iterable_1_1 = iterable_1.next()) {
                    var value = iterable_1_1.value;
                    subscriber.next(value);
                    if (subscriber.closed) {
                        return;
                    }
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (iterable_1_1 && !iterable_1_1.done && (_a = iterable_1.return)) _a.call(iterable_1);
                }
                finally { if (e_1) throw e_1.error; }
            }
            subscriber.complete();
        });
    }
    function fromAsyncIterable(asyncIterable) {
        return new Observable(function (subscriber) {
            process(asyncIterable, subscriber).catch(function (err) { return subscriber.error(err); });
        });
    }
    /**
     * Converts a readable stream-like object to an asynchronous iterable.
     *
     * @param {ReadableStream} readableStream - The readable stream-like object to convert.
     * @returns {AsyncIterable} - An asynchronous iterable that yields chunks of data from the readable stream.
     *
     * @example
     * const stream = new ReadableStream({
     *   start(controller) {
     *     controller.enqueue('Hello, ');
     *     controller.enqueue('World!');
     *     controller.close();
     *   }
     * });
     *
     * async function processStream() {
     *   for await (const chunk of fromReadableStreamLike(stream)) {
     *     console.log(chunk);
     *   }
     * }
     *
     * processStream().then(() => {
     *   console.log('Streaming complete.');
     * }).catch((error) => {
     *   console.error('Error during streaming:', error);
     * });
     */
    function fromReadableStreamLike(readableStream) {
        return fromAsyncIterable(readableStreamLikeToAsyncGenerator(readableStream));
    }
    /**
     * Processes an async iterable and notifies a subscriber about each value.
     *
     * @param {AsyncIterable} asyncIterable - The async iterable to process.
     * @param {Subscriber} subscriber - The subscriber that will receive updates.
     * @returns {void}
     * @throws {Error} - Throws an error if there's an issue processing the async iterable.
     */
    function process(asyncIterable, subscriber) {
        var asyncIterable_1, asyncIterable_1_1;
        var e_2, _a;
        return __awaiter(this, void 0, void 0, function () {
            var value, e_2_1;
            return __generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        _b.trys.push([0, 5, 6, 11]);
                        asyncIterable_1 = __asyncValues(asyncIterable);
                        _b.label = 1;
                    case 1: return [4, asyncIterable_1.next()];
                    case 2:
                        if (!(asyncIterable_1_1 = _b.sent(), !asyncIterable_1_1.done)) return [3, 4];
                        value = asyncIterable_1_1.value;
                        subscriber.next(value);
                        if (subscriber.closed) {
                            return [2];
                        }
                        _b.label = 3;
                    case 3: return [3, 1];
                    case 4: return [3, 11];
                    case 5:
                        e_2_1 = _b.sent();
                        e_2 = { error: e_2_1 };
                        return [3, 11];
                    case 6:
                        _b.trys.push([6, , 9, 10]);
                        if (!(asyncIterable_1_1 && !asyncIterable_1_1.done && (_a = asyncIterable_1.return))) return [3, 8];
                        return [4, _a.call(asyncIterable_1)];
                    case 7:
                        _b.sent();
                        _b.label = 8;
                    case 8: return [3, 10];
                    case 9:
                        if (e_2) throw e_2.error;
                        return [7];
                    case 10: return [7];
                    case 11:
                        subscriber.complete();
                        return [2];
                }
            });
        });
    }

    function executeSchedule(parentSubscription, scheduler, work, delay, repeat) {
        if (delay === void 0) { delay = 0; }
        if (repeat === void 0) { repeat = false; }
        var scheduleSubscription = scheduler.schedule(function () {
            work();
            if (repeat) {
                parentSubscription.add(this.schedule(null, delay));
            }
            else {
                this.unsubscribe();
            }
        }, delay);
        parentSubscription.add(scheduleSubscription);
        if (!repeat) {
            return scheduleSubscription;
        }
    }

    function observeOn(scheduler, delay) {
        if (delay === void 0) { delay = 0; }
        return operate(function (source, subscriber) {
            source.subscribe(createOperatorSubscriber(subscriber, function (value) { return executeSchedule(subscriber, scheduler, function () { return subscriber.next(value); }, delay); }, function () { return executeSchedule(subscriber, scheduler, function () { return subscriber.complete(); }, delay); }, function (err) { return executeSchedule(subscriber, scheduler, function () { return subscriber.error(err); }, delay); }));
        });
    }

    /**
     * Schedules the subscription of an observable sequence to occur on the specified scheduler.
     *
     * @param {IScheduler} scheduler - The scheduler to schedule the subscription on.
     * @param {number} [delay=0] - (Optional) The delay in milliseconds before subscribing.
     * @returns {Observable} - An observable sequence that represents the original source, but scheduled on the specified scheduler.
     *
     * @example
     * // Example usage:
     * var source = Rx.Observable.interval(100);
     * var scheduledSource = source.subscribeOn(Rx.Scheduler.async);
     * scheduledSource.subscribe(x => console.log(x));
     */
    function subscribeOn(scheduler, delay) {
        if (delay === void 0) { delay = 0; }
        return operate(function (source, subscriber) {
            subscriber.add(scheduler.schedule(function () { return source.subscribe(subscriber); }, delay));
        });
    }

    /**
     * Schedules an observable sequence to be executed on a particular scheduler.
     *
     * @function
     * @param {ObservableInput} input - The observable sequence to schedule.
     * @param {IScheduler} scheduler - The scheduler where the observable will be run.
     * @returns {Observable} An observable sequence whose invocations are scheduled on the specified scheduler.
     *
     * @example
     * import { of } from 'rxjs';
     * import { scheduleObservable } from './SupportedLanguage.JAVASCRIPT code';
     * const scheduler = rxjs.operators.subscribeOn(rxjs.scheduler.async);
     * const obs = scheduleObservable(of(1, 2, 3), scheduler);
     * obs.subscribe(console.log); // Logs the sequence [1, 2, 3] after all current tasks are completed.
     */
    function scheduleObservable(input, scheduler) {
        return innerFrom(input).pipe(subscribeOn(scheduler), observeOn(scheduler));
    }

    function schedulePromise(input, scheduler) {
        return innerFrom(input).pipe(subscribeOn(scheduler), observeOn(scheduler));
    }

    /**
     * Schedules an array of values using the provided scheduler.
     *
     * @param {Array} input - The array of values to be scheduled.
     * @param {Object} scheduler - The scheduler object responsible for timing and scheduling.
     * @returns {Observable} An Observable that emits each value from the input array at scheduled intervals.
     * @throws {Error} Throws an error if the input is not an array or the scheduler is invalid.
     *
     * Example:
     * const scheduler = new Rx.Scheduler();
     * const observable = scheduleArray([1, 2, 3], scheduler);
     * observable.subscribe(value => console.log(value));
     */
    function scheduleArray(input, scheduler) {
        return new Observable(function (subscriber) {
            var i = 0;
            return scheduler.schedule(function () {
                if (i === input.length) {
                    subscriber.complete();
                }
                else {
                    subscriber.next(input[i++]);
                    if (!subscriber.closed) {
                        this.schedule();
                    }
                }
            });
        });
    }

    function scheduleIterable(input, scheduler) {
        return new Observable(function (subscriber) {
            var iterator$$1;
            executeSchedule(subscriber, scheduler, function () {
                iterator$$1 = input[iterator]();
                executeSchedule(subscriber, scheduler, function () {
                    var _a;
                    var value;
                    var done;
                    try {
                        (_a = iterator$$1.next(), value = _a.value, done = _a.done);
                    }
                    catch (err) {
                        subscriber.error(err);
                        return;
                    }
                    if (done) {
                        subscriber.complete();
                    }
                    else {
                        subscriber.next(value);
                    }
                }, 0, true);
            });
            return function () { return isFunction(iterator$$1 === null || iterator$$1 === void 0 ? void 0 : iterator$$1.return) && iterator$$1.return(); };
        });
    }

    function scheduleAsyncIterable(input, scheduler) {
        if (!input) {
            throw new Error('Iterable cannot be null');
        }
        return new Observable(function (subscriber) {
            executeSchedule(subscriber, scheduler, function () {
                var iterator = input[Symbol.asyncIterator]();
                executeSchedule(subscriber, scheduler, function () {
                    iterator.next().then(function (result) {
                        if (result.done) {
                            subscriber.complete();
                        }
                        else {
                            subscriber.next(result.value);
                        }
                    });
                }, 0, true);
            });
        });
    }

    /**
     * Schedules the given readable stream-like object using the provided scheduler.
     *
     * @param {Object} input - The readable stream-like object to be scheduled.
     * @param {Scheduler} scheduler - The scheduler used to manage the execution of the stream.
     * @returns {AsyncIterable} A new async iterable that is scheduled according to the given scheduler.
     * @throws {TypeError} If the input is not a valid readable stream-like object or if the scheduler is not provided.
     *
     * @example
     * const stream = createReadableStream();
     * const scheduler = new Scheduler();
     * const scheduledStream = scheduleReadableStreamLike(stream, scheduler);
     * for await (const chunk of scheduledStream) {
     *   console.log(chunk);
     * }
     */
    function scheduleReadableStreamLike(input, scheduler) {
        return scheduleAsyncIterable(readableStreamLikeToAsyncGenerator(input), scheduler);
    }

    function scheduled(input, scheduler) {
        if (input != null) {
            if (isInteropObservable(input)) {
                return scheduleObservable(input, scheduler);
            }
            if (isArrayLike(input)) {
                return scheduleArray(input, scheduler);
            }
            if (isPromise(input)) {
                return schedulePromise(input, scheduler);
            }
            if (isAsyncIterable(input)) {
                return scheduleAsyncIterable(input, scheduler);
            }
            if (isIterable(input)) {
                return scheduleIterable(input, scheduler);
            }
            if (isReadableStreamLike(input)) {
                return scheduleReadableStreamLike(input, scheduler);
            }
        }
        throw createInvalidObservableTypeError(input);
    }

    /**
     * Creates an Observable from an input source.
     *
     * @param {ObservableInput<T>|ScheduledInput<T>} input - The source of values to create the Observable from.
     * @param {SchedulerLike} [scheduler] - An optional Scheduler to schedule the emissions on.
     * @returns {Observable<T>} An Observable that emits items from the input source.
     *
     * @template T - The type of values emitted by the Observable.
     */
    function from(input, scheduler) {
        return scheduler ? scheduled(input, scheduler) : innerFrom(input);
    }

    /**
     * Creates an observable sequence by concatenating the results of invoking the specified function with each item of a sequence and then flattening the resulting sequences.
     *
     * @param {...*} args - A variable number of arguments to pass to the function to create the observables.
     * @returns {Observable} An observable sequence that contains the concatenated results of invoking the function with each item of the input sequence.
     * @throws {TypeError} if any argument is not valid for the function being called.
     *
     * Example:
     * ```javascript
     * const result = of(function(x) {
     *   return Observable.fromArray([x, x * 2]);
     * }, 1, 2, 3);
     * ```
     */
    function of() {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
        }
        var scheduler = popScheduler(args);
        return from(args, scheduler);
    }

    /**
     * Creates an Observable that emits an error using provided error or error factory.
     *
     * @param {Error | (() => Error)} errorOrErrorFactory - The error to emit, or a function that returns the error to emit.
     * @param {SchedulerLike} [scheduler] - Optional scheduler to use for emitting the error.
     * @returns {Observable<never>} An Observable that emits an error and completes.
     *
     * @example
     * // Example usage with static error:
     * throwError(new Error('Something went wrong'), rxjs.Scheduler.queue)
     *
     * @example
     * // Example usage with dynamic error factory:
     * throwError(() => new Error('Dynamic error occurred'), rxjs.Scheduler.async)
     */
    function throwError(errorOrErrorFactory, scheduler) {
        var errorFactory = isFunction(errorOrErrorFactory) ? errorOrErrorFactory : function () { return errorOrErrorFactory; };
        var init = function (subscriber) { return subscriber.error(errorFactory()); };
        return new Observable(scheduler ? function (subscriber) { return scheduler.schedule(init, 0, subscriber); } : init);
    }

    (function (NotificationKind) {
        NotificationKind["NEXT"] = "N";
        NotificationKind["ERROR"] = "E";
        NotificationKind["COMPLETE"] = "C";
    })(exports.NotificationKind || (exports.NotificationKind = {}));
    var Notification = (function () {
        /**
         * Represents a notification with various kinds of values or errors.
         *
         * @constructor
         * @param {string} kind - The type of the notification. Should be 'N' for value notifications.
         * @param {any} [value=undefined] - The value associated with the notification if `kind` is 'N'.
         * @param {Error} [error=null] - The error associated with the notification if `kind` is not 'N'.
         *
         * @property {string} kind - The type of the notification.
         * @property {any} value - The value associated with the notification, only valid if `kind` is 'N'.
         * @property {Error} error - The error associated with the notification, only valid if `kind` is not 'N'.
         * @property {boolean} hasValue - Indicates whether the notification contains a value.
         *
         * @example
         * // Creating a value notification
         * const valueNotification = new Notification('N', 'Success');
         * console.log(valueNotification.hasValue); // true
         * console.log(valueNotification.value);    // 'Success'
         *
         * @example
         * // Creating an error notification
         * const errorNotification = new Notification('E', null, new Error('Something went wrong'));
         * console.log(errorNotification.hasValue); // false
         * console.log(errorNotification.error.message); // 'Something went wrong'
         */
        function Notification(kind, value, error) {
            this.kind = kind;
            this.value = value;
            this.error = error;
            this.hasValue = kind === 'N';
        }
        Notification.prototype.observe = function (observer) {
            return observeNotification(this, observer);
        };
        Notification.prototype.do = function (nextHandler, errorHandler, completeHandler) {
            var _a = this, kind = _a.kind, value = _a.value, error = _a.error;
            return kind === 'N' ? nextHandler === null || nextHandler === void 0 ? void 0 : nextHandler(value) : kind === 'E' ? errorHandler === null || errorHandler === void 0 ? void 0 : errorHandler(error) : completeHandler === null || completeHandler === void 0 ? void 0 : completeHandler();
        };
        Notification.prototype.accept = function (nextOrObserver, error, complete) {
            var _a;
            return isFunction((_a = nextOrObserver) === null || _a === void 0 ? void 0 : _a.next)
                ? this.observe(nextOrObserver)
                : this.do(nextOrObserver, error, complete);
        };
        Notification.prototype.toObservable = function () {
            var _a = this, kind = _a.kind, value = _a.value, error = _a.error;
            var result = kind === 'N'
                ?
                    of(value)
                :
                    kind === 'E'
                        ?
                            throwError(function () { return error; })
                        :
                            kind === 'C'
                                ?
                                    EMPTY
                                :
                                    0;
            if (!result) {
                throw new TypeError("Unexpected notification kind " + kind);
            }
            return result;
        };
        Notification.createNext = function (value) {
            return new Notification('N', value);
        };
        Notification.createError = function (err) {
            return new Notification('E', undefined, err);
        };
        Notification.createComplete = function () {
            return Notification.completeNotification;
        };
        Notification.completeNotification = new Notification('C');
        return Notification;
    }());
    /**
     * Observes a notification and invokes the appropriate method on an observer based on the notification type.
     *
     * @param {Object} notification - The notification object containing properties like kind, value, and error.
     * @param {Object} observer - The observer object with methods next, error, and complete to handle notifications.
     * @throws {TypeError} If the notification object is missing the 'kind' property.
     */
    function observeNotification(notification, observer) {
        var _a, _b, _c;
        var _d = notification, kind = _d.kind, value = _d.value, error = _d.error;
        if (typeof kind !== 'string') {
            throw new TypeError('Invalid notification, missing "kind"');
        }
        kind === 'N' ? (_a = observer.next) === null || _a === void 0 ? void 0 : _a.call(observer, value) : kind === 'E' ? (_b = observer.error) === null || _b === void 0 ? void 0 : _b.call(observer, error) : (_c = observer.complete) === null || _c === void 0 ? void 0 : _c.call(observer);
    }

    function isObservable(obj) {
        return !!obj && (obj instanceof Observable || (isFunction(obj.lift) && isFunction(obj.subscribe)));
    }

    var EmptyError = createErrorClass(function (_super) {
        return function EmptyErrorImpl() {
            _super(this);
            this.name = 'EmptyError';
            this.message = 'no elements in sequence';
        };
    });

    /**
     * Retrieves the last value emitted by an Observable or returns a default value if no values are emitted.
     *
     * @param {Observable} source - The Observable from which to retrieve the last value.
     * @param {Object} config - (Optional) Configuration object that can specify a default value.
     * @returns {Promise<any>} A Promise that resolves with the last value emitted by the Observable or the specified default value. If no values are emitted and no default value is provided, it rejects with an EmptyError.
     *
     * @example
     * const observable = from([1, 2, 3]);
     * lastValueFrom(observable)
     *   .then(value => console.log(value)) // Output: 3
     *
     * const emptyObservable = of();
     * lastValueFrom(emptyObservable)
     *   .catch(error => console.error(error)); // Output: EmptyError
     */
    function lastValueFrom(source, config) {
        var hasConfig = typeof config === 'object';
        return new Promise(function (resolve, reject) {
            var _hasValue = false;
            var _value;
            source.subscribe({
                next: function (value) {
                    _value = value;
                    _hasValue = true;
                },
                error: reject,
                complete: function () {
                    if (_hasValue) {
                        resolve(_value);
                    }
                    else if (hasConfig) {
                        resolve(config.defaultValue);
                    }
                    else {
                        reject(new EmptyError());
                    }
                },
            });
        });
    }

    /**
     * Returns the first value emitted by an Observable, optionally resolving to a default value if no values are emitted.
     *
     * @param {Observable} source - The Observable from which to retrieve the first value.
     * @param {Object} [config] - Configuration object for handling the observable.
     * @param {any} [config.defaultValue=undefined] - The value to resolve to if no values are emitted by the observable.
     *
     * @returns {Promise<any>} A Promise that resolves with the first value emitted by the Observable or a default value if none are emitted.
     *
     * @throws {EmptyError} If no values are emitted and no defaultValue is provided.
     */
    function firstValueFrom(source, config) {
        var hasConfig = typeof config === 'object';
        return new Promise(function (resolve, reject) {
            var subscriber = new SafeSubscriber({
                next: function (value) {
                    resolve(value);
                    subscriber.unsubscribe();
                },
                error: reject,
                complete: function () {
                    if (hasConfig) {
                        resolve(config.defaultValue);
                    }
                    else {
                        reject(new EmptyError());
                    }
                },
            });
            source.subscribe(subscriber);
        });
    }

    var ArgumentOutOfRangeError = createErrorClass(function (_super) {
        return function ArgumentOutOfRangeErrorImpl() {
            _super(this);
            this.name = 'ArgumentOutOfRangeError';
            this.message = 'argument out of range';
        };
    });

    var NotFoundError = createErrorClass(function (_super) {
        return function NotFoundErrorImpl(message) {
            _super(this);
            this.name = 'NotFoundError';
            this.message = message;
        };
    });

    var SequenceError = createErrorClass(function (_super) {
        return function SequenceErrorImpl(message) {
            _super(this);
            this.name = 'SequenceError';
            this.message = message;
        };
    });

    /**
     * Checks if the provided value is an instance of Date and not NaN.
     *
     * @param {*} value - The value to check.
     * @returns {boolean} - True if the value is a valid date, false otherwise.
     * @throws {TypeError} - If the input is not a valid date type.
     * @example
     * isValidDate(new Date()); // returns true
     * isValidDate('2023-10-05'); // returns false
     */
    function isValidDate(value) {
        return value instanceof Date && !isNaN(value);
    }

    var TimeoutError = createErrorClass(function (_super) {
        return function TimeoutErrorImpl(info) {
            if (info === void 0) { info = null; }
            _super(this);
            this.message = 'Timeout has occurred';
            this.name = 'TimeoutError';
            this.info = info;
        };
    });
    /**
     * Creates an Observable that emits items from the source Observable with a specified delay between emissions.
     *
     * @param {Object|number} config - Configuration object or number specifying the timeout duration.
     * @param {any} schedulerArg - Scheduler to use for scheduling the timeout.
     * @returns {Observable<any>} An Observable that emits items from the source Observable with a specified delay between emissions.
     */
    function timeout(config, schedulerArg) {
        var _a = (isValidDate(config) ? { first: config } : typeof config === 'number' ? { each: config } : config), first = _a.first, each = _a.each, _b = _a.with, _with = _b === void 0 ? timeoutErrorFactory : _b, _c = _a.scheduler, scheduler = _c === void 0 ? schedulerArg !== null && schedulerArg !== void 0 ? schedulerArg : asyncScheduler : _c, _d = _a.meta, meta = _d === void 0 ? null : _d;
        if (first == null && each == null) {
            throw new TypeError('No timeout provided.');
        }
        return operate(function (source, subscriber) {
            var originalSourceSubscription;
            var timerSubscription;
            var lastValue = null;
            var seen = 0;
            var startTimer = function (delay) {
                timerSubscription = executeSchedule(subscriber, scheduler, function () {
                    try {
                        originalSourceSubscription.unsubscribe();
                        innerFrom(_with({
                            meta: meta,
                            lastValue: lastValue,
                            seen: seen,
                        })).subscribe(subscriber);
                    }
                    catch (err) {
                        subscriber.error(err);
                    }
                }, delay);
            };
            originalSourceSubscription = source.subscribe(createOperatorSubscriber(subscriber, function (value) {
                timerSubscription === null || timerSubscription === void 0 ? void 0 : timerSubscription.unsubscribe();
                seen++;
                subscriber.next((lastValue = value));
                each > 0 && startTimer(each);
            }, undefined, undefined, function () {
                if (!(timerSubscription === null || timerSubscription === void 0 ? void 0 : timerSubscription.closed)) {
                    timerSubscription === null || timerSubscription === void 0 ? void 0 : timerSubscription.unsubscribe();
                }
                lastValue = null;
            }));
            !seen && startTimer(first != null ? (typeof first === 'number' ? first : +first - scheduler.now()) : each);
        });
    }
    /**
     * Creates an instance of TimeoutError with the provided information.
     *
     * @param {Object} info - Information object to pass to the error.
     * @throws {TimeoutError} - Throws a new instance of TimeoutError with the given information.
     */
    function timeoutErrorFactory(info) {
        throw new TimeoutError(info);
    }

    /**
     * Creates an Observable that applies a given function to each value emitted by the source Observable,
     * emitting the results of these functions.
     *
     * @param {function(value, index): any} project - A function that accepts an emitted value and its index as arguments and returns a new value.
     * @param {any} [thisArg] - An optional object to use for `this` when executing the projection function.
     * @returns {Observable<any>} An Observable that emits transformed values based on the provided projection function.
     *
     * Example:
     * const source = from([1, 2, 3]);
     * const mapped$ = map((value) => value * 2);
     * mapped$.subscribe(console.log); // Output: 2, 4, 6
     */
    function map(project, thisArg) {
        return operate(function (source, subscriber) {
            var index = 0;
            source.subscribe(createOperatorSubscriber(subscriber, function (value) {
                subscriber.next(project.call(thisArg, value, index++));
            }));
        });
    }

    var isArray = Array.isArray;
    /**
     * Calls a function with arguments or applies it to an array of arguments.
     *
     * @param {Function} fn - The function to be called or applied.
     * @param {Array|Object} args - An array of arguments or an object that can be spread into the function.
     * @returns {*} The result of calling or applying the function.
     * @throws {TypeError} If `fn` is not a function.
     * @example
     * callOrApply(Math.max, [1, 2, 3]); // Returns 3
     * callOrApply((a, b) => a + b, [5, 6]); // Returns 11
     */
    function callOrApply(fn, args) {
        return isArray(args) ? fn.apply(void 0, __spreadArray([], __read(args))) : fn(args);
    }
    /**
     * Returns a function that takes an array of arguments and applies them to the provided function.
     *
     * @param {Function} fn - The function to apply arguments to.
     * @returns {Function} A new function that can be called with an array of arguments.
     */
    function mapOneOrManyArgs(fn) {
        return map(function (args) { return callOrApply(fn, args); });
    }

    /**
     * Binds callback internals to handle different types of callbacks and result selectors.
     *
     * @param {boolean} isNodeStyle - Indicates if the callback follows Node.js error-first convention.
     * @param {Function} callbackFunc - The callback function to be bound.
     * @param {Function|Scheduler} [resultSelector] - Optional selector or scheduler for processing results.
     * @param {Scheduler} [scheduler] - Optional scheduler for handling asynchronous operations.
     * @returns {Function} - A new function that wraps the original callback with additional behavior.
     *
     * @example
     * const boundCallback = bindCallbackInternals(false, (err, data) => {
     *   if (err) console.error(err);
     *   else console.log(data);
     * });
     */
    function bindCallbackInternals(isNodeStyle, callbackFunc, resultSelector, scheduler) {
        if (resultSelector) {
            if (isScheduler(resultSelector)) {
                scheduler = resultSelector;
            }
            else {
                return function () {
                    var args = [];
                    for (var _i = 0; _i < arguments.length; _i++) {
                        args[_i] = arguments[_i];
                    }
                    return bindCallbackInternals(isNodeStyle, callbackFunc, scheduler)
                        .apply(this, args)
                        .pipe(mapOneOrManyArgs(resultSelector));
                };
            }
        }
        if (scheduler) {
            return function () {
                var args = [];
                for (var _i = 0; _i < arguments.length; _i++) {
                    args[_i] = arguments[_i];
                }
                return bindCallbackInternals(isNodeStyle, callbackFunc)
                    .apply(this, args)
                    .pipe(subscribeOn(scheduler), observeOn(scheduler));
            };
        }
        return function () {
            var _this = this;
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                args[_i] = arguments[_i];
            }
            var subject = new AsyncSubject();
            var uninitialized = true;
            return new Observable(function (subscriber) {
                var subs = subject.subscribe(subscriber);
                if (uninitialized) {
                    uninitialized = false;
                    var isAsync_1 = false;
                    var isComplete_1 = false;
                    callbackFunc.apply(_this, __spreadArray(__spreadArray([], __read(args)), [
                        function () {
                            var results = [];
                            for (var _i = 0; _i < arguments.length; _i++) {
                                results[_i] = arguments[_i];
                            }
                            if (isNodeStyle) {
                                var err = results.shift();
                                if (err != null) {
                                    subject.error(err);
                                    return;
                                }
                            }
                            subject.next(1 < results.length ? results : results[0]);
                            isComplete_1 = true;
                            if (isAsync_1) {
                                subject.complete();
                            }
                        },
                    ]));
                    if (isComplete_1) {
                        subject.complete();
                    }
                    isAsync_1 = true;
                }
                return subs;
            });
        };
    }

    /**
     * Binds a callback function with optional result selector and scheduler.
     *
     * @param {Function} callbackFunc - The callback function to be bound.
     * @param {Function} [resultSelector] - A function that selects the result from the callback.
     * @param {Scheduler} [scheduler] - Scheduler to use for execution.
     * @returns {Function} - The bound callback function.
     *
     * Example usage:
     * const boundCallback = bindCallback(myCallback, myResultSelector, myScheduler);
     * boundCallback();
     */
    function bindCallback(callbackFunc, resultSelector, scheduler) {
        return bindCallbackInternals(false, callbackFunc, resultSelector, scheduler);
    }

    /**
     * Binds a callback function to an observable sequence using the provided Node.js-style callback conventions.
     *
     * @param {Function} callbackFunc - The callback function to bind.
     * @param {Function} [resultSelector] - A selector that determines how the inner value is exposed on the resulting observable sequence. If not specified, defaults to returning the entire result object.
     * @param {Scheduler} [scheduler] - Scheduler to run the subscription on. If not provided, defaults to using the current scheduler.
     * @returns {Function} The bound callback function.
     *
     * @example
     * const source = Rx.Observable.fromEvent(document, 'click');
     * const boundCallback = bindNodeCallback((err, result) => {
     *   if (err) throw err;
     *   console.log(result);
     * });
     * source.subscribe(boundCallback);
     *
     * @throws {Error} Throws an error if the callback function is not provided.
     */
    function bindNodeCallback(callbackFunc, resultSelector, scheduler) {
        return bindCallbackInternals(true, callbackFunc, resultSelector, scheduler);
    }

    var isArray$1 = Array.isArray;
    var getPrototypeOf = Object.getPrototypeOf, objectProto = Object.prototype, getKeys = Object.keys;
    /**
     * Processes the input arguments to return an object containing either the array of values or null if no keys are present.
     *
     * @param {any[]} args - The input arguments which can be a single array, a plain old JavaScript object (POJO), or any other type.
     * @returns {{args: any[], keys: string[] | null}} An object with two properties:
     *   - `args`: An array containing the values extracted from the input. If the input is an array, it returns the array itself. If it's a POJO, it returns an array of its values.
     *   - `keys`: An array of keys corresponding to the values if the input was a POJO; otherwise, it returns null.
     * @example
     * argsArgArrayOrObject([1, 2, 3]); // Returns { args: [1, 2, 3], keys: null }
     * argsArgArrayOrObject({ a: 1, b: 2 }); // Returns { args: [1, 2], keys: ['a', 'b'] }
     * argsArgArrayOrObject('not an array or object'); // Returns { args: ['not an array or object'], keys: null }
     */
    function argsArgArrayOrObject(args) {
        if (args.length === 1) {
            var first_1 = args[0];
            if (isArray$1(first_1)) {
                return { args: first_1, keys: null };
            }
            if (isPOJO(first_1)) {
                var keys = getKeys(first_1);
                return {
                    args: keys.map(function (key) { return first_1[key]; }),
                    keys: keys,
                };
            }
        }
        return { args: args, keys: null };
    }
    /**
     * Checks if an object is a Plain Old JavaScript Object (POJO).
     *
     * @param {Object} obj - The object to check.
     * @returns {boolean} - True if the object is a POJO, false otherwise.
     * @throws {TypeError} - If the input is not an object.
     *
     * A POJO is an object that is created using either object literals or the 'new Object()' constructor,
     * without any prototype inheritance other than what is provided by Object.prototype.
     */
    function isPOJO(obj) {
        return obj && typeof obj === 'object' && getPrototypeOf(obj) === objectProto;
    }

    /**
     * Creates an object by pairing keys with corresponding values.
     *
     * @param {string[]} keys - An array of strings representing the object keys.
     * @param {*} values - An array containing the values for the corresponding keys.
     * @returns {object} - The newly created object.
     * @throws {Error} If `keys` and `values` arrays have different lengths.
     *
     * @example
     * const obj = createObject(['a', 'b'], [1, 2]);
     * console.log(obj); // Output: { a: 1, b: 2 }
     */
    function createObject(keys, values) {
        return keys.reduce(function (result, key, i) { return ((result[key] = values[i]), result); }, {});
    }

    function combineLatest() {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
        }
        var scheduler = popScheduler(args);
        var resultSelector = popResultSelector(args);
        var _a = argsArgArrayOrObject(args), observables = _a.args, keys = _a.keys;
        if (observables.length === 0) {
            return from([], scheduler);
        }
        var result = new Observable(combineLatestInit(observables, scheduler, keys
            ?
                function (values) { return createObject(keys, values); }
            :
                identity));
        return resultSelector ? result.pipe(mapOneOrManyArgs(resultSelector)) : result;
    }
    /**
     * Creates an observable that combines the latest values from multiple observables into one.
     *
     * @param {Array<Observable<T>>} observables - An array of observables to combine.
     * @param {SchedulerLike} [scheduler] - The scheduler to use for scheduling the emissions. Defaults to a non-scheduled execution.
     * @param {Function} [valueTransform=identity] - A function that transforms the combined values before emission. Defaults to returning the values as is.
     * @returns {Observable<T>} An observable that emits an array of the latest values from each input observable, transformed by `valueTransform`.
     *
     * @throws {Error} If any of the observables emits an error, it will be propagated through the resulting observable.
     *
     * @example
     * const source1 = interval(500);
     * const source2 = timer(300, 1000);
     * combineLatestInit([source1, source2]).subscribe(console.log);
     * // Output: [0, 0], [1, 0], [1, 1], [2, 1], ...
     */
    function combineLatestInit(observables, scheduler, valueTransform) {
        if (valueTransform === void 0) { valueTransform = identity; }
        return function (subscriber) {
            maybeSchedule(scheduler, function () {
                var length = observables.length;
                var values = new Array(length);
                var active = length;
                var remainingFirstValues = length;
                var _loop_1 = function (i) {
                    maybeSchedule(scheduler, function () {
                        var source = from(observables[i], scheduler);
                        var hasFirstValue = false;
                        source.subscribe(createOperatorSubscriber(subscriber, function (value) {
                            values[i] = value;
                            if (!hasFirstValue) {
                                hasFirstValue = true;
                                remainingFirstValues--;
                            }
                            if (!remainingFirstValues) {
                                subscriber.next(valueTransform(values.slice()));
                            }
                        }, function () {
                            if (!--active) {
                                subscriber.complete();
                            }
                        }));
                    }, subscriber);
                };
                for (var i = 0; i < length; i++) {
                    _loop_1(i);
                }
            }, subscriber);
        };
    }
    function maybeSchedule(scheduler, execute, subscription) {
        if (scheduler) {
            executeSchedule(subscription, scheduler, execute);
        }
        else {
            execute();
        }
    }

    function mergeInternals(source, subscriber, project, concurrent, onBeforeNext, expand, innerSubScheduler, additionalFinalizer) {
        var buffer = [];
        var active = 0;
        var index = 0;
        var isComplete = false;
        var checkComplete = function () {
            if (isComplete && !buffer.length && !active) {
                subscriber.complete();
            }
        };
        var outerNext = function (value) { return (active < concurrent ? doInnerSub(value) : buffer.push(value)); };
        var doInnerSub = function (value) {
            expand && subscriber.next(value);
            active++;
            var innerComplete = false;
            innerFrom(project(value, index++)).subscribe(createOperatorSubscriber(subscriber, function (innerValue) {
                onBeforeNext === null || onBeforeNext === void 0 ? void 0 : onBeforeNext(innerValue);
                if (expand) {
                    outerNext(innerValue);
                }
                else {
                    subscriber.next(innerValue);
                }
            }, function () {
                innerComplete = true;
            }, undefined, function () {
                if (innerComplete) {
                    try {
                        active--;
                        var _loop_1 = function () {
                            var bufferedValue = buffer.shift();
                            if (innerSubScheduler) {
                                executeSchedule(subscriber, innerSubScheduler, function () { return doInnerSub(bufferedValue); });
                            }
                            else {
                                doInnerSub(bufferedValue);
                            }
                        };
                        while (buffer.length && active < concurrent) {
                            _loop_1();
                        }
                        checkComplete();
                    }
                    catch (err) {
                        subscriber.error(err);
                    }
                }
            }));
        };
        source.subscribe(createOperatorSubscriber(subscriber, outerNext, function () {
            isComplete = true;
            checkComplete();
        }));
        return function () {
            additionalFinalizer === null || additionalFinalizer === void 0 ? void 0 : additionalFinalizer();
        };
    }

    function mergeMap(project, resultSelector, concurrent) {
        if (concurrent === void 0) { concurrent = Infinity; }
        if (isFunction(resultSelector)) {
            return mergeMap(function (a, i) { return map(function (b, ii) { return resultSelector(a, b, i, ii); })(innerFrom(project(a, i))); }, concurrent);
        }
        else if (typeof resultSelector === 'number') {
            concurrent = resultSelector;
        }
        return operate(function (source, subscriber) { return mergeInternals(source, subscriber, project, concurrent); });
    }

    /**
     * Merges multiple observables concurrently up to a specified limit.
     *
     * @param {number} [concurrent=Infinity] - The maximum number of concurrent subscriptions. Defaults to infinity, meaning no limit.
     * @returns {Observable} - An Observable that merges the values from the source Observables as they complete.
     */
    function mergeAll(concurrent) {
        if (concurrent === void 0) { concurrent = Infinity; }
        return mergeMap(identity, concurrent);
    }

    /**
     * Combines all elements from multiple arrays into one array.
     *
     * @returns {Array} A new array containing all elements from the input arrays.
     * @throws {TypeError} If any of the arguments is not an array.
     */
    function concatAll() {
        return mergeAll(1);
    }

    /**
     * Concatenates multiple observables together, waiting for each to complete before moving on to the next.
     *
     * @returns {Observable} An observable that emits the concatenated results of all input observables.
     *
     * @throws {Error} Throws an error if any of the provided arguments are not observables.
     */
    function concat() {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
        }
        return concatAll()(from(args, popScheduler(args)));
    }

    /**
     * Creates an observable that defers to the provided observable factory function.
     *
     * @param {function(): Observable<T>} observableFactory - A function that returns an Observable.
     * @returns {Observable<T>} An Observable that will invoke the observableFactory and subscribe to its result.
     *
     * @example
     * const source = defer(() => of('Hello, world!'));
     * source.subscribe(console.log);
     */
    function defer(observableFactory) {
        return new Observable(function (subscriber) {
            innerFrom(observableFactory()).subscribe(subscriber);
        });
    }

    var DEFAULT_CONFIG = {
        connector: function () { return new Subject(); },
        resetOnDisconnect: true,
    };
    /**
     * Creates an observable that connects to a source using a provided connector.
     *
     * @param {Observable} source - The source observable to connect.
     * @param {Object} [config=DEFAULT_CONFIG] - Configuration options for the connection.
     * @param {Function} config.connector - A function that returns an observable to connect to.
     * @param {boolean} [config.resetOnDisconnect=true] - Whether to reset the connector's observable when the current connection closes.
     * @returns {Observable} An observable with a `connect` method to establish and manage connections.
     *
     * @example
     * const source$ = new Observable(subscriber => subscriber.next('data'));
     * const config = {
     *   connector: () => fromEvent(document, 'click'),
     *   resetOnDisconnect: true
     * };
     * const connectionObservable = connectable(source$, config);
     *
     * connectionObservable.connect().subscribe(data => console.log(data));
     */
    function connectable(source, config) {
        if (config === void 0) { config = DEFAULT_CONFIG; }
        var connection = null;
        var connector = config.connector, _a = config.resetOnDisconnect, resetOnDisconnect = _a === void 0 ? true : _a;
        var subject = connector();
        var result = new Observable(function (subscriber) {
            return subject.subscribe(subscriber);
        });
        result.connect = function () {
            if (!connection || connection.closed) {
                connection = defer(function () { return source; }).subscribe(subject);
                if (resetOnDisconnect) {
                    connection.add(function () { return (subject = connector()); });
                }
            }
            return connection;
        };
        return result;
    }

    function forkJoin() {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
        }
        var resultSelector = popResultSelector(args);
        var _a = argsArgArrayOrObject(args), sources = _a.args, keys = _a.keys;
        var result = new Observable(function (subscriber) {
            var length = sources.length;
            if (!length) {
                subscriber.complete();
                return;
            }
            var values = new Array(length);
            var remainingCompletions = length;
            var remainingEmissions = length;
            var _loop_1 = function (sourceIndex) {
                var hasValue = false;
                innerFrom(sources[sourceIndex]).subscribe(createOperatorSubscriber(subscriber, function (value) {
                    if (!hasValue) {
                        hasValue = true;
                        remainingEmissions--;
                    }
                    values[sourceIndex] = value;
                }, function () { return remainingCompletions--; }, undefined, function () {
                    if (!remainingCompletions || !hasValue) {
                        if (!remainingEmissions) {
                            subscriber.next(keys ? createObject(keys, values) : values);
                        }
                        subscriber.complete();
                    }
                }));
            };
            for (var sourceIndex = 0; sourceIndex < length; sourceIndex++) {
                _loop_1(sourceIndex);
            }
        });
        return resultSelector ? result.pipe(mapOneOrManyArgs(resultSelector)) : result;
    }

    var nodeEventEmitterMethods = ['addListener', 'removeListener'];
    var eventTargetMethods = ['addEventListener', 'removeEventListener'];
    var jqueryMethods = ['on', 'off'];
    function fromEvent(target, eventName, options, resultSelector) {
        if (isFunction(options)) {
            resultSelector = options;
            options = undefined;
        }
        if (resultSelector) {
            return fromEvent(target, eventName, options).pipe(mapOneOrManyArgs(resultSelector));
        }
        var _a = __read(isEventTarget(target)
            ? eventTargetMethods.map(function (methodName) { return function (handler) { return target[methodName](eventName, handler, options); }; })
            :
                isNodeStyleEventEmitter(target)
                    ? nodeEventEmitterMethods.map(toCommonHandlerRegistry(target, eventName))
                    : isJQueryStyleEventEmitter(target)
                        ? jqueryMethods.map(toCommonHandlerRegistry(target, eventName))
                        : [], 2), add = _a[0], remove = _a[1];
        if (!add) {
            if (isArrayLike(target)) {
                return mergeMap(function (subTarget) { return fromEvent(subTarget, eventName, options); })(innerFrom(target));
            }
        }
        if (!add) {
            throw new TypeError('Invalid event target');
        }
        return new Observable(function (subscriber) {
            var handler = function () {
                var args = [];
                for (var _i = 0; _i < arguments.length; _i++) {
                    args[_i] = arguments[_i];
                }
                return subscriber.next(1 < args.length ? args : args[0]);
            };
            add(handler);
            return function () { return remove(handler); };
        });
    }
    /**
     * Creates a common handler registry function for a given target object and event name.
     *
     * @param {Object} target - The target object that will hold the method for handling events.
     * @param {string} eventName - The name of the event to handle.
     * @returns {function(string): function(function(*): void)} A function that takes a methodName as an argument and returns another function that takes a handler function.
     *
     * Example usage:
     *   const registry = toCommonHandlerRegistry(target, 'click');
     *   registry('onClick')(handlerFunction);
     */
    function toCommonHandlerRegistry(target, eventName) {
        return function (methodName) { return function (handler) { return target[methodName](eventName, handler); }; };
    }
    /**
     * Checks if the provided target object has methods for adding and removing listeners,
     * which are typical in Node.js style event emitters.
     *
     * @param {Object} target - The object to check for Node-style EventEmitter functionality.
     * @returns {boolean} - Returns true if the target is a Node-style EventEmitter, false otherwise.
     */
    function isNodeStyleEventEmitter(target) {
        return isFunction(target.addListener) && isFunction(target.removeListener);
    }
    /**
     * Determines if the provided target object is a jQuery-style event emitter.
     *
     * @param {Object} target - The object to check.
     * @returns {boolean} - Returns true if the target has 'on' and 'off' methods, indicating it's a jQuery-style event emitter; otherwise, returns false.
     *
     * @example
     * const element = document.querySelector('.myElement');
     * console.log(isJQueryStyleEventEmitter(element)); // Output: false (unless jQuery is used to enhance the DOM)
     */
    function isJQueryStyleEventEmitter(target) {
        return isFunction(target.on) && isFunction(target.off);
    }
    /**
     * Determines if the provided target is an event target by checking for the presence of `addEventListener` and `removeEventListener` methods.
     *
     * @param {Object} target - The object to check if it's an event target.
     * @returns {boolean} - Returns true if the target has both `addEventListener` and `removeEventListener` methods, false otherwise.
     */
    function isEventTarget(target) {
        return isFunction(target.addEventListener) && isFunction(target.removeEventListener);
    }

    function fromEventPattern(addHandler, removeHandler, resultSelector) {
        if (resultSelector) {
            return fromEventPattern(addHandler, removeHandler).pipe(mapOneOrManyArgs(resultSelector));
        }
        return new Observable(function (subscriber) {
            var handler = function () {
                var e = [];
                for (var _i = 0; _i < arguments.length; _i++) {
                    e[_i] = arguments[_i];
                }
                return subscriber.next(e.length === 1 ? e[0] : e);
            };
            var retValue = addHandler(handler);
            return isFunction(removeHandler) ? function () { return removeHandler(handler, retValue); } : undefined;
        });
    }

    function generate(initialStateOrOptions, condition, iterate, resultSelectorOrScheduler, scheduler) {
        var _a, _b;
        var resultSelector;
        var initialState;
        if (arguments.length === 1) {
            (_a = initialStateOrOptions, initialState = _a.initialState, condition = _a.condition, iterate = _a.iterate, _b = _a.resultSelector, resultSelector = _b === void 0 ? identity : _b, scheduler = _a.scheduler);
        }
        else {
            initialState = initialStateOrOptions;
            if (!resultSelectorOrScheduler || isScheduler(resultSelectorOrScheduler)) {
                resultSelector = identity;
                scheduler = resultSelectorOrScheduler;
            }
            else {
                resultSelector = resultSelectorOrScheduler;
            }
        }
        /**
         * Generates a sequence of values using an iterative process.
         *
         * This generator function repeatedly applies the `iterate` function to a state until a condition is met, as determined by the `condition` function. Once the condition is satisfied, it invokes the `resultSelector` function with the current state and yields its result.
         *
         * @param {Function} initialState - The initial state of the generator.
         * @param {Function} condition - A function that determines when to stop generating values. It should return false if the generation should continue, or true otherwise.
         * @param {Function} iterate - A function that takes the current state and returns the next state in the sequence.
         * @param {Function} resultSelector - A function that takes the final state and returns the result to be yielded.
         *
         * @returns {Generator}
         *
         * @example
         * const initialState = { count: 0 };
         * const condition = (state) => state.count >= 5;
         * const iterate = (state) => ({ count: state.count + 1 });
         * const resultSelector = (state) => `Count reached ${state.count}`;
         *
         * for (const result of gen(initialState, condition, iterate, resultSelector)) {
         *   console.log(result);
         * }
         *
         * // Output:
         * // Count reached 5
         */
        function gen() {
            var state;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        state = initialState;
                        _a.label = 1;
                    case 1:
                        if (!(!condition || condition(state))) return [3, 4];
                        return [4, resultSelector(state)];
                    case 2:
                        _a.sent();
                        _a.label = 3;
                    case 3:
                        state = iterate(state);
                        return [3, 1];
                    case 4: return [2];
                }
            });
        }
        return defer((scheduler
            ?
                function () { return scheduleIterable(gen(), scheduler); }
            :
                gen));
    }

    /**
     * Evaluates a condition and returns one of two results based on that condition.
     *
     * @param {Function} condition - A function that returns a boolean value to evaluate.
     * @param {*} trueResult - The result to return if the condition evaluates to true.
     * @param {*} falseResult - The result to return if the condition evaluates to false.
     * @returns {*} - Returns `trueResult` if `condition` is true, otherwise returns `falseResult`.
     *
     * @example
     * const result = iif(() => true, 'Yes', 'No'); // returns 'Yes'
     * const result2 = iif(() => false, 'Yes', 'No'); // returns 'No'
     */
    function iif(condition, trueResult, falseResult) {
        return defer(function () { return (condition() ? trueResult : falseResult); });
    }

    /**
     * Creates an observable that emits values at specified intervals or after a specified due time.
     *
     * @param {number} [dueTime=0] - The delay before the first emission.
     * @param {SchedulerLike | number} [intervalOrScheduler=-1] - The interval between emissions, or a scheduler to use for timing.
     * @param {SchedulerLike} [scheduler=async] - The scheduler to use for scheduling emissions. Defaults to the async scheduler if not provided.
     * @returns {Observable<number>} An observable that emits sequential numbers at specified intervals or after a specified due time.
     *
     * @example
     * // Emit values every 1000 milliseconds starting after 2000 milliseconds
     * const observable = timer(2000, 1000);
     * observable.subscribe(value => console.log(value));
     */
    function timer(dueTime, intervalOrScheduler, scheduler) {
        if (dueTime === void 0) { dueTime = 0; }
        if (scheduler === void 0) { scheduler = async; }
        var intervalDuration = -1;
        if (intervalOrScheduler != null) {
            if (isScheduler(intervalOrScheduler)) {
                scheduler = intervalOrScheduler;
            }
            else {
                intervalDuration = intervalOrScheduler;
            }
        }
        return new Observable(function (subscriber) {
            var due = isValidDate(dueTime) ? +dueTime - scheduler.now() : dueTime;
            if (due < 0) {
                due = 0;
            }
            var n = 0;
            return scheduler.schedule(function () {
                if (!subscriber.closed) {
                    subscriber.next(n++);
                    if (0 <= intervalDuration) {
                        this.schedule(undefined, intervalDuration);
                    }
                    else {
                        subscriber.complete();
                    }
                }
            }, due);
        });
    }

    function interval(period, scheduler) {
        if (period === void 0) { period = 0; }
        if (scheduler === void 0) { scheduler = asyncScheduler; }
        if (period < 0) {
            period = 0;
        }
        return timer(period, period, scheduler);
    }

    /**
     * Merges multiple observables or arrays into one observable sequence.
     *
     * @param {...*} args - A variable number of arguments representing observables, arrays, or other sequences to be merged.
     * @returns {Observable<any>} An observable that emits all elements from the provided observables and arrays.
     */
    function merge() {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
        }
        var scheduler = popScheduler(args);
        var concurrent = popNumber(args, Infinity);
        var sources = args;
        return !sources.length
            ?
                EMPTY
            : sources.length === 1
                ?
                    innerFrom(sources[0])
                :
                    mergeAll(concurrent)(from(sources, scheduler));
    }

    var NEVER = new Observable(noop);
    /**
     * Returns the constant value representing "never" or "none".
     *
     * @returns {string} The constant value 'NEVER'.
     */
    function never() {
        return NEVER;
    }

    var isArray$2 = Array.isArray;
    /**
     * Checks if the input is an array with a single element that is also an array. If so,
     * it returns the inner array; otherwise, it returns the original arguments.
     *
     * @param {any[]} args - The arguments to be checked.
     * @returns {any[]} The inner array if the input matches the condition, otherwise the original arguments.
     * @example
     * // Returns [1, 2, 3]
     * argsOrArgArray([[1, 2, 3]]);
     *
     * @example
     * // Returns [1, 2, 3]
     * argsOrArgArray([1, 2, 3]);
     */
    function argsOrArgArray(args) {
        return args.length === 1 && isArray$2(args[0]) ? args[0] : args;
    }

    /**
     * Creates an Observable that emits all items emitted by each of the Observables passed to it, handling any errors by continuing with the next Observable.
     *
     * @param {...*} sources - A variable number of sources (Observables or values) to be concatenated and handled.
     * @returns {Observable} An Observable that emits all items from the provided sources in sequence, ignoring errors and moving on to the next source if an error occurs.
     *
     * Example:
     * onErrorResumeNext(obs1$, obs2$, obs3$)
     *   .subscribe(
     *     value => console.log(value),
     *     err => console.error(err), // This will not be called
     *     () => console.log('Completed')
     *   );
     */
    function onErrorResumeNext() {
        var sources = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            sources[_i] = arguments[_i];
        }
        var nextSources = argsOrArgArray(sources);
        return new Observable(function (subscriber) {
            var sourceIndex = 0;
            var subscribeNext = function () {
                if (sourceIndex < nextSources.length) {
                    var nextSource = void 0;
                    try {
                        nextSource = innerFrom(nextSources[sourceIndex++]);
                    }
                    catch (err) {
                        subscribeNext();
                        return;
                    }
                    var innerSubscriber = new OperatorSubscriber(subscriber, undefined, noop, noop);
                    nextSource.subscribe(innerSubscriber);
                    innerSubscriber.add(subscribeNext);
                }
                else {
                    subscriber.complete();
                }
            };
            subscribeNext();
        });
    }

    /**
     * Creates an observable sequence from an object.
     *
     * @param {Object} obj - The input object to convert into an observable sequence.
     * @param {Scheduler} [scheduler] - Scheduler to run the enumeration of the input sequence on. If not specified, defaults to the current thread's scheduler.
     * @returns {Observable} An observable sequence containing the key-value pairs from the input object.
     */
    function pairs(obj, scheduler) {
        return from(Object.entries(obj), scheduler);
    }

    /**
     * Returns a new function that negates the result of the given predicate function.
     *
     * @param {Function} pred - The predicate function to negate.
     * @param {*} [thisArg] - Optional value to use as this when executing the predicate function.
     * @returns {Function} A new function that takes a value and returns the negation of the predicate's result.
     */
    function not(pred, thisArg) {
        return function (value, index) { return !pred.call(thisArg, value, index); };
    }

    /**
     * Creates an observable that emits only those elements of the source observable for which the provided predicate returns true.
     *
     * @param {Function} predicate - A function that receives each element emitted by the source observable and returns a boolean indicating whether to include it in the output.
     * @param {*} [thisArg] - An optional object to be used as 'this' when executing the predicate function.
     * @returns {Observable} An observable emitting elements from the source observable for which the predicate returns true.
     *
     * @example
     * const numbers = range(1, 5);
     * const evenNumbers = filter(numbers, (value) => value % 2 === 0);
     * evenNumbers.subscribe(console.log); // Output: 2, 4
     */
    function filter(predicate, thisArg) {
        return operate(function (source, subscriber) {
            var index = 0;
            source.subscribe(createOperatorSubscriber(subscriber, function (value) { return predicate.call(thisArg, value, index++) && subscriber.next(value); }));
        });
    }

    /**
     * Splits the source iterable into two arrays based on the predicate function.
     *
     * @param {Iterable<any>} source - The iterable to partition.
     * @param {Function} predicate - A function that determines which elements should go into the first array.
     * @param {Object} [thisArg] - Optional value to use as this when executing predicate.
     * @returns {[Array, Array]} An array containing two arrays: the first with elements that satisfy the predicate and the second with those that do not.
     *
     * @example
     * const [evenNumbers, oddNumbers] = partition([1, 2, 3, 4, 5], n => n % 2 === 0);
     * console.log(evenNumbers); // [2, 4]
     * console.log(oddNumbers); // [1, 3, 5]
     */
    function partition(source, predicate, thisArg) {
        return [filter(predicate, thisArg)(innerFrom(source)), filter(not(predicate, thisArg))(innerFrom(source))];
    }

    /**
     * Creates an Observable that emits the first value emitted by any of the observables provided as arguments.
     *
     * @param {...*} sources - A variadic argument list of observables to compete for the first emission.
     * @returns {Observable} An Observable that will emit the first value from one of the input observables and then complete.
     */
    function race() {
        var sources = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            sources[_i] = arguments[_i];
        }
        sources = argsOrArgArray(sources);
        return sources.length === 1 ? innerFrom(sources[0]) : new Observable(raceInit(sources));
    }
    /**
     * Creates a new observable that emits values from one of multiple observables based on the fastest emitted value.
     *
     * @param {Array<Observable<any>>} sources - An array of observables to race.
     * @returns {Observable<any>} A new observable that will emit values from the first observable to emit a value.
     */
    function raceInit(sources) {
        return function (subscriber) {
            var subscriptions = [];
            var _loop_1 = function (i) {
                subscriptions.push(innerFrom(sources[i]).subscribe(createOperatorSubscriber(subscriber, function (value) {
                    if (subscriptions) {
                        for (var s = 0; s < subscriptions.length; s++) {
                            s !== i && subscriptions[s].unsubscribe();
                        }
                        subscriptions = null;
                    }
                    subscriber.next(value);
                })));
            };
            for (var i = 0; subscriptions && !subscriber.closed && i < sources.length; i++) {
                _loop_1(i);
            }
        };
    }

    /**
     * Creates an Observable sequence that emits a range of integers within a specified inclusive range.
     *
     * @param {number} [start=0] - The index at which to start emitting numbers.
     * @param {number} count - The number of sequential longs to produce.
     * @param {SchedulerLike} [scheduler] - Optional scheduler to schedule the emissions on.
     * @returns {Observable<number>} An Observable sequence that emits a range of integers within the specified inclusive range.
     *
     * @throws {Error} If 'count' is less than or equal to zero.
     */
    function range(start, count, scheduler) {
        if (count == null) {
            count = start;
            start = 0;
        }
        if (count <= 0) {
            return EMPTY;
        }
        var end = count + start;
        return new Observable(scheduler
            ?
                function (subscriber) {
                    var n = start;
                    return scheduler.schedule(function () {
                        if (n < end) {
                            subscriber.next(n++);
                            this.schedule();
                        }
                        else {
                            subscriber.complete();
                        }
                    });
                }
            :
                function (subscriber) {
                    var n = start;
                    while (n < end && !subscriber.closed) {
                        subscriber.next(n++);
                    }
                    subscriber.complete();
                });
    }

    /**
     * Creates an Observable from a resource factory function and an observable factory function.
     *
     * @param {function(): Resource} resourceFactory - A function that returns a resource to be used with the observable factory.
     * @param {function(Resource): Observable|Promise} observableFactory - A function that takes a resource and returns an Observable or Promise to observe.
     * @returns {Observable} An Observable that will create a new Observable from the result of the observableFactory.
     *
     * @example
     * const resource = {
     *   getData: () => fetch('https://api.example.com/data'),
     *   unsubscribe: () => console.log('Resource unsubscribed')
     * };
     *
     * using(() => resource, (res) => res.getData()).subscribe({
     *   next: (data) => console.log(data),
     *   error: (err) => console.error(err),
     *   complete: () => console.log('Completed')
     * });
     *
     * @throws {Error} If the observableFactory function returns an invalid Observable or Promise.
     */
    function using(resourceFactory, observableFactory) {
        return new Observable(function (subscriber) {
            var resource = resourceFactory();
            var result = observableFactory(resource);
            var source = result ? innerFrom(result) : EMPTY;
            source.subscribe(subscriber);
            return function () {
                if (resource) {
                    resource.unsubscribe();
                }
            };
        });
    }

    /**
     * Combines multiple observables by emitting an array containing the latest values from each observable whenever any of them emits.
     *
     * @param {...Observable} sources - The observables to be combined.
     * @returns {Observable<Array<any>>>} An observable that emits arrays with the latest values from each input observable.
     */
    function zip() {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
        }
        var resultSelector = popResultSelector(args);
        var sources = argsOrArgArray(args);
        return sources.length
            ? new Observable(function (subscriber) {
                var buffers = sources.map(function () { return []; });
                var completed = sources.map(function () { return false; });
                subscriber.add(function () {
                    buffers = completed = null;
                });
                var _loop_1 = function (sourceIndex) {
                    innerFrom(sources[sourceIndex]).subscribe(createOperatorSubscriber(subscriber, function (value) {
                        buffers[sourceIndex].push(value);
                        if (buffers.every(function (buffer) { return buffer.length; })) {
                            var result = buffers.map(function (buffer) { return buffer.shift(); });
                            subscriber.next(resultSelector ? resultSelector.apply(void 0, __spreadArray([], __read(result))) : result);
                            if (buffers.some(function (buffer, i) { return !buffer.length && completed[i]; })) {
                                subscriber.complete();
                            }
                        }
                    }, function () {
                        completed[sourceIndex] = true;
                        !buffers[sourceIndex].length && subscriber.complete();
                    }));
                };
                for (var sourceIndex = 0; !subscriber.closed && sourceIndex < sources.length; sourceIndex++) {
                    _loop_1(sourceIndex);
                }
                return function () {
                    buffers = completed = null;
                };
            })
            : EMPTY;
    }

    /**
     * Creates an operator that emits a value from the source observable only after a specified duration has passed since the last emission or subscription.
     *
     * @param {function(value): Observable} durationSelector - A function that returns an Observable whose completion signals the end of the current period.
     * @returns {Observable<T>} An Observable that emits values from the source observable but only after the specified duration has passed.
     */
    function audit(durationSelector) {
        return operate(function (source, subscriber) {
            var hasValue = false;
            var lastValue = null;
            var durationSubscriber = null;
            var isComplete = false;
            var endDuration = function () {
                durationSubscriber === null || durationSubscriber === void 0 ? void 0 : durationSubscriber.unsubscribe();
                durationSubscriber = null;
                if (hasValue) {
                    hasValue = false;
                    var value = lastValue;
                    lastValue = null;
                    subscriber.next(value);
                }
                isComplete && subscriber.complete();
            };
            var cleanupDuration = function () {
                durationSubscriber = null;
                isComplete && subscriber.complete();
            };
            source.subscribe(createOperatorSubscriber(subscriber, function (value) {
                hasValue = true;
                lastValue = value;
                if (!durationSubscriber) {
                    innerFrom(durationSelector(value)).subscribe((durationSubscriber = createOperatorSubscriber(subscriber, endDuration, cleanupDuration)));
                }
            }, function () {
                isComplete = true;
                (!hasValue || !durationSubscriber || durationSubscriber.closed) && subscriber.complete();
            }));
        });
    }

    /**
     * Schedules an observable to emit values after a specified duration using the provided scheduler.
     *
     * @param {number} duration - The time in milliseconds after which to start emitting values.
     * @param {SchedulerLike} [scheduler=asyncScheduler] - The scheduler to use for scheduling the emission of values. Defaults to asyncScheduler.
     * @returns {Observable} An observable that emits values after the specified duration.
     *
     * @example
     * const source$ = interval(1000);
     * const result$ = source$.pipe(
     *   auditTime(500)
     * );
     * // Emits 0, 2, 4 after 500ms intervals
     */
    function auditTime(duration, scheduler) {
        if (scheduler === void 0) { scheduler = asyncScheduler; }
        return audit(function () { return timer(duration, scheduler); });
    }

    /**
     * Creates an observable that buffers values emitted by the source until a notifier emits a value.
     *
     * @param {Observable<any>} closingNotifier - An Observable that signals when to emit the current buffer.
     * @returns {Observable<Array<any>>} - An Observable that emits arrays of buffered values.
     */
    function buffer(closingNotifier) {
        return operate(function (source, subscriber) {
            var currentBuffer = [];
            source.subscribe(createOperatorSubscriber(subscriber, function (value) { return currentBuffer.push(value); }, function () {
                subscriber.next(currentBuffer);
                subscriber.complete();
            }));
            innerFrom(closingNotifier).subscribe(createOperatorSubscriber(subscriber, function () {
                var b = currentBuffer;
                currentBuffer = [];
                subscriber.next(b);
            }, noop));
            return function () {
                currentBuffer = null;
            };
        });
    }

    /**
     * Splits an observable sequence of values into buffers which are produced based on element count or timing.
     *
     * @param {number} bufferSize - The maximum number of elements in each buffer before it is emitted.
     * @param {number} [startBufferEvery=bufferSize] - The interval at which to start a new buffer. If not specified, a new buffer starts when the previous one reaches its `bufferSize`.
     * @returns {Observable<Array<any>>} An observable sequence of buffers, each containing up to `bufferSize` elements.
     *
     * @example
     * // Split values into buffers of size 3
     * const source$ = from([1, 2, 3, 4, 5, 6, 7, 8, 9]);
     * source$.pipe(bufferCount(3)).subscribe(console.log);
     * // Output: [1, 2, 3], [4, 5, 6], [7, 8, 9]
     *
     * @example
     * // Start a new buffer every 2 elements, with each buffer having a maximum of 3 elements
     * const source$ = from([1, 2, 3, 4, 5, 6, 7, 8, 9]);
     * source$.pipe(bufferCount(3, 2)).subscribe(console.log);
     * // Output: [1, 2, 3], [3, 4, 5], [5, 6, 7], [7, 8, 9]
     */
    function bufferCount(bufferSize, startBufferEvery) {
        if (startBufferEvery === void 0) { startBufferEvery = null; }
        startBufferEvery = startBufferEvery !== null && startBufferEvery !== void 0 ? startBufferEvery : bufferSize;
        return operate(function (source, subscriber) {
            var buffers = [];
            var count = 0;
            source.subscribe(createOperatorSubscriber(subscriber, function (value) {
                var e_1, _a, e_2, _b;
                var toEmit = null;
                if (count++ % startBufferEvery === 0) {
                    buffers.push([]);
                }
                try {
                    for (var buffers_1 = __values(buffers), buffers_1_1 = buffers_1.next(); !buffers_1_1.done; buffers_1_1 = buffers_1.next()) {
                        var buffer = buffers_1_1.value;
                        buffer.push(value);
                        if (bufferSize <= buffer.length) {
                            toEmit = toEmit !== null && toEmit !== void 0 ? toEmit : [];
                            toEmit.push(buffer);
                        }
                    }
                }
                catch (e_1_1) { e_1 = { error: e_1_1 }; }
                finally {
                    try {
                        if (buffers_1_1 && !buffers_1_1.done && (_a = buffers_1.return)) _a.call(buffers_1);
                    }
                    finally { if (e_1) throw e_1.error; }
                }
                if (toEmit) {
                    try {
                        for (var toEmit_1 = __values(toEmit), toEmit_1_1 = toEmit_1.next(); !toEmit_1_1.done; toEmit_1_1 = toEmit_1.next()) {
                            var buffer = toEmit_1_1.value;
                            arrRemove(buffers, buffer);
                            subscriber.next(buffer);
                        }
                    }
                    catch (e_2_1) { e_2 = { error: e_2_1 }; }
                    finally {
                        try {
                            if (toEmit_1_1 && !toEmit_1_1.done && (_b = toEmit_1.return)) _b.call(toEmit_1);
                        }
                        finally { if (e_2) throw e_2.error; }
                    }
                }
            }, function () {
                var e_3, _a;
                try {
                    for (var buffers_2 = __values(buffers), buffers_2_1 = buffers_2.next(); !buffers_2_1.done; buffers_2_1 = buffers_2.next()) {
                        var buffer = buffers_2_1.value;
                        subscriber.next(buffer);
                    }
                }
                catch (e_3_1) { e_3 = { error: e_3_1 }; }
                finally {
                    try {
                        if (buffers_2_1 && !buffers_2_1.done && (_a = buffers_2.return)) _a.call(buffers_2);
                    }
                    finally { if (e_3) throw e_3.error; }
                }
                subscriber.complete();
            }, undefined, function () {
                buffers = null;
            }));
        });
    }

    /**
     * Buffers values from the source observable until a specified interval or buffer size is reached.
     *
     * @param {number} bufferTimeSpan - The time span to wait before emitting a buffered value.
     * @returns {Observable<any[]>} An Observable that emits arrays of buffered values.
     */
    function bufferTime(bufferTimeSpan) {
        var _a, _b;
        var otherArgs = [];
        for (var _i = 1; _i < arguments.length; _i++) {
            otherArgs[_i - 1] = arguments[_i];
        }
        var scheduler = (_a = popScheduler(otherArgs)) !== null && _a !== void 0 ? _a : asyncScheduler;
        var bufferCreationInterval = (_b = otherArgs[0]) !== null && _b !== void 0 ? _b : null;
        var maxBufferSize = otherArgs[1] || Infinity;
        return operate(function (source, subscriber) {
            var bufferRecords = [];
            var restartOnEmit = false;
            var emit = function (record) {
                var buffer = record.buffer, subs = record.subs;
                subs.unsubscribe();
                arrRemove(bufferRecords, record);
                subscriber.next(buffer);
                restartOnEmit && startBuffer();
            };
            var startBuffer = function () {
                if (bufferRecords) {
                    var subs = new Subscription();
                    subscriber.add(subs);
                    var buffer = [];
                    var record_1 = {
                        buffer: buffer,
                        subs: subs,
                    };
                    bufferRecords.push(record_1);
                    executeSchedule(subs, scheduler, function () { return emit(record_1); }, bufferTimeSpan);
                }
            };
            if (bufferCreationInterval !== null && bufferCreationInterval >= 0) {
                executeSchedule(subscriber, scheduler, startBuffer, bufferCreationInterval, true);
            }
            else {
                restartOnEmit = true;
            }
            startBuffer();
            var bufferTimeSubscriber = createOperatorSubscriber(subscriber, function (value) {
                var e_1, _a;
                var recordsCopy = bufferRecords.slice();
                try {
                    for (var recordsCopy_1 = __values(recordsCopy), recordsCopy_1_1 = recordsCopy_1.next(); !recordsCopy_1_1.done; recordsCopy_1_1 = recordsCopy_1.next()) {
                        var record = recordsCopy_1_1.value;
                        var buffer = record.buffer;
                        buffer.push(value);
                        maxBufferSize <= buffer.length && emit(record);
                    }
                }
                catch (e_1_1) { e_1 = { error: e_1_1 }; }
                finally {
                    try {
                        if (recordsCopy_1_1 && !recordsCopy_1_1.done && (_a = recordsCopy_1.return)) _a.call(recordsCopy_1);
                    }
                    finally { if (e_1) throw e_1.error; }
                }
            }, function () {
                while (bufferRecords === null || bufferRecords === void 0 ? void 0 : bufferRecords.length) {
                    subscriber.next(bufferRecords.shift().buffer);
                }
                bufferTimeSubscriber === null || bufferTimeSubscriber === void 0 ? void 0 : bufferTimeSubscriber.unsubscribe();
                subscriber.complete();
                subscriber.unsubscribe();
            }, undefined, function () { return (bufferRecords = null); });
            source.subscribe(bufferTimeSubscriber);
        });
    }

    /**
     * Creates an operator that buffers values from the source observable until a closing selector emits a value.
     *
     * @param {Observable<any>} openings - Observable that emits opening signals to start buffering.
     * @param {Function} closingSelector - Function that takes the opening signal and returns an Observable that emits when to close the buffer.
     * @returns {OperatorFunction<T, T[]>} Operator function that transforms the source observable into one that buffers values until a closing signal is emitted.
     *
     * @example
     * import { of } from 'rxjs';
     * import { bufferToggle } from 'supported-language-javascript-code';
     *
     * const openings = of(1, 2);
     * const closingSelector = (value) => of(value + 1);
     *
     * source.pipe(
     *   bufferToggle(openings, closingSelector)
     * ).subscribe(console.log);
     */
    function bufferToggle(openings, closingSelector) {
        return operate(function (source, subscriber) {
            var buffers = [];
            innerFrom(openings).subscribe(createOperatorSubscriber(subscriber, function (openValue) {
                var buffer = [];
                buffers.push(buffer);
                var closingSubscription = new Subscription();
                var emitBuffer = function () {
                    arrRemove(buffers, buffer);
                    subscriber.next(buffer);
                    closingSubscription.unsubscribe();
                };
                closingSubscription.add(innerFrom(closingSelector(openValue)).subscribe(createOperatorSubscriber(subscriber, emitBuffer, noop)));
            }, noop));
            source.subscribe(createOperatorSubscriber(subscriber, function (value) {
                var e_1, _a;
                try {
                    for (var buffers_1 = __values(buffers), buffers_1_1 = buffers_1.next(); !buffers_1_1.done; buffers_1_1 = buffers_1.next()) {
                        var buffer = buffers_1_1.value;
                        buffer.push(value);
                    }
                }
                catch (e_1_1) { e_1 = { error: e_1_1 }; }
                finally {
                    try {
                        if (buffers_1_1 && !buffers_1_1.done && (_a = buffers_1.return)) _a.call(buffers_1);
                    }
                    finally { if (e_1) throw e_1.error; }
                }
            }, function () {
                while (buffers.length > 0) {
                    subscriber.next(buffers.shift());
                }
                subscriber.complete();
            }));
        });
    }

    function bufferWhen(closingSelector) {
        return operate(function (source, subscriber) {
            var buffer = null;
            var closingSubscriber = null;
            var openBuffer = function () {
                closingSubscriber === null || closingSubscriber === void 0 ? void 0 : closingSubscriber.unsubscribe();
                var b = buffer;
                buffer = [];
                b && subscriber.next(b);
                innerFrom(closingSelector()).subscribe((closingSubscriber = createOperatorSubscriber(subscriber, openBuffer, noop)));
            };
            openBuffer();
            source.subscribe(createOperatorSubscriber(subscriber, function (value) { return buffer === null || buffer === void 0 ? void 0 : buffer.push(value); }, function () {
                buffer && subscriber.next(buffer);
                subscriber.complete();
            }, undefined, function () { return (buffer = closingSubscriber = null); }));
        });
    }

    /**
     * Catches errors thrown by an Observable and continues with another Observable or throws an error based on the provided selector function.
     *
     * @param {function} selector - A function that takes an error and returns an Observable to continue with. If it returns an observable, catchError will subscribe to it and emit its values. If it throws an error, the caughtError operator will rethrow the error.
     * @returns {Observable} An Observable that emits the same items as the source Observable or emits new items from the selected Observable if an error occurs.
     *
     * Example:
     * const observable = throwError(new Error('Something went wrong'));
     * observable.pipe(
     *   catchError(error => of('Recovered'))
     * ).subscribe(console.log); // Output: Recovered
     */
    function catchError(selector) {
        return operate(function (source, subscriber) {
            var innerSub = null;
            var syncUnsub = false;
            var handledResult;
            innerSub = source.subscribe(createOperatorSubscriber(subscriber, undefined, undefined, function (err) {
                handledResult = innerFrom(selector(err, catchError(selector)(source)));
                if (innerSub) {
                    innerSub.unsubscribe();
                    innerSub = null;
                    handledResult.subscribe(subscriber);
                }
                else {
                    syncUnsub = true;
                }
            }));
            if (syncUnsub) {
                innerSub.unsubscribe();
                innerSub = null;
                handledResult.subscribe(subscriber);
            }
        });
    }

    /**
     * Generates an operator that applies an accumulator function to each value emitted by the source Observable, emitting the result.
     *
     * @param {Function} accumulator - A function that takes the current state, the next value, and the index as arguments and returns the new state.
     * @param {*} seed - The initial state for the accumulator.
     * @param {boolean} hasSeed - Indicates whether a seed value is provided.
     * @param {boolean} emitOnNext - If true, emits the accumulated state on each next event.
     * @param {boolean} emitBeforeComplete - If true, emits the accumulated state before completing the subscription.
     * @returns {Function} An operator function that can be used with Observables.
     */
    function scanInternals(accumulator, seed, hasSeed, emitOnNext, emitBeforeComplete) {
        return function (source, subscriber) {
            var hasState = hasSeed;
            var state = seed;
            var index = 0;
            source.subscribe(createOperatorSubscriber(subscriber, function (value) {
                var i = index++;
                state = hasState
                    ?
                        accumulator(state, value, i)
                    :
                        ((hasState = true), value);
                emitOnNext && subscriber.next(state);
            }, emitBeforeComplete &&
                (function () {
                    hasState && subscriber.next(state);
                    subscriber.complete();
                })));
        };
    }

    /**
     * Reduces an array of values to a single value by applying a binary function to each element.
     *
     * @param {Function} accumulator - A function that takes two parameters and returns their reduction result.
     * @param {*} seed - The initial value for the accumulator.
     * @returns {*} The final reduced value.
     *
     * @example
     * reduce((a, b) => a + b, 0, [1, 2, 3, 4]); // returns 10
     */
    function reduce(accumulator, seed) {
        return operate(scanInternals(accumulator, seed, arguments.length >= 2, false, true));
    }

    var arrReducer = function (arr, value) { return (arr.push(value), arr); };
    function toArray() {
        return operate(function (source, subscriber) {
            reduce(arrReducer, [])(source).subscribe(subscriber);
        });
    }

    /**
     * Joins multiple internal sources using a specified join function and optionally projects the result.
     *
     * @param {Function} joinFn - A function that takes an array of sources and returns an Observable or Promise.
     * @param {Function} [project] - An optional function to project each source before joining. It can return multiple values.
     * @returns {Observable|Promise} - An Observable or Promise containing the joined result.
     *
     * @example
     * const joinFn = (sources) => Observable.forkJoin(sources);
     * const result = joinAllInternals(joinFn, projectFn).subscribe(console.log);
     */
    function joinAllInternals(joinFn, project) {
        return pipe(toArray(), mergeMap(function (sources) { return joinFn(sources); }), project ? mapOneOrManyArgs(project) : identity);
    }

    /**
     * Combines multiple projects into a single project that emits an array of the latest values from each input project whenever any of them emit a value.
     *
     * @param {Project} project - The project to combine.
     * @returns {Project} A new project that combines the latest values from all input projects.
     *
     * @example
     * const project1 = createProject();
     * const project2 = createProject();
     * const combinedProject = combineLatestAll([project1, project2]);
     * combinedProject.subscribe((values) => {
     *   console.log('Latest values:', values);
     * });
     *
     * @throws {Error} Throws an error if the input is not a valid project.
     */
    function combineLatestAll(project) {
        return joinAllInternals(combineLatest, project);
    }

    var combineAll = combineLatestAll;

    function combineLatest$1() {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
        }
        var resultSelector = popResultSelector(args);
        return resultSelector
            ? pipe(combineLatest$1.apply(void 0, __spreadArray([], __read(args))), mapOneOrManyArgs(resultSelector))
            : operate(function (source, subscriber) {
                combineLatestInit(__spreadArray([source], __read(argsOrArgArray(args))))(subscriber);
            });
    }

    /**
     * Combines multiple observables into a single observable that emits arrays of latest values from each input observable.
     *
     * @param {...Observable} otherSources - Variable arguments representing the observables to be combined.
     * @returns {Observable<Array>} An observable that emits an array containing the latest values from each input observable.
     * @throws Will throw an error if no observables are provided.
     * @example
     * // Example usage:
     * const source1 = of(1, 2, 3);
     * const source2 = of('a', 'b', 'c');
     * combineLatestWith(source1, source2).subscribe(console.log);
     * // Output: [3, 'c']
     */
    function combineLatestWith() {
        var otherSources = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            otherSources[_i] = arguments[_i];
        }
        return combineLatest$1.apply(void 0, __spreadArray([], __read(otherSources)));
    }

    /**
     * Projects each element of an observable sequence to an observable sequence, and then flattens the resulting sequences into one observable sequence.
     *
     * @param {Function} project - A transform function to apply to each item in the source observable. The function should return a new observable sequence.
     * @param {number} [concurrent=1] - [Optional] Maximum number of input observables being subscribed to concurrently.
     * @returns {Observable} - An observable sequence whose elements are the result of applying the transform function to each element of the source observable and then flattening the resulting sequences.
     *
     * Example:
     * const source = Rx.Observable.from([1, 2, 3]);
     * const result = source.concatMap(x => Rx.Observable.range(1, x));
     * // result will emit [1, 2, 1, 2, 3]
     */
    function concatMap(project, resultSelector) {
        return isFunction(resultSelector) ? mergeMap(project, resultSelector, 1) : mergeMap(project, 1);
    }

    /**
     * Projects each source value to an Observable which is merged in the output Observable.
     *
     * @template T The type of the source elements.
     * @template R The type of the result elements.
     * @param {ObservableInput<R>} innerObservable An Observable to replace each item emitted by the source Observable.
     * @param {(innerValue: R, outerValue: T, innerIndex: number, outerIndex: number) => ObservableInput<any>} [resultSelector] A function that produces an Observable to substitute for each value emitted by the source Observable.
     * @returns {OperatorFunction<T, R | O>} An operator function that returns an Observable that emits items from the innerObservable when the source Observable emits items.
     */
    function concatMapTo(innerObservable, resultSelector) {
        return isFunction(resultSelector) ? concatMap(function () { return innerObservable; }, resultSelector) : concatMap(function () { return innerObservable; });
    }

    function concat$1() {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
        }
        var scheduler = popScheduler(args);
        return operate(function (source, subscriber) {
            concatAll()(from(__spreadArray([source], __read(args)), scheduler)).subscribe(subscriber);
        });
    }

    /**
     * Concatenates multiple arrays into one array.
     *
     * @param {...Array} otherSources - The arrays to concatenate with the initial array.
     * @returns {Array} - A new array containing all elements from the original array and the provided arrays.
     */
    function concatWith() {
        var otherSources = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            otherSources[_i] = arguments[_i];
        }
        return concat$1.apply(void 0, __spreadArray([], __read(otherSources)));
    }

    function fromSubscribable(subscribable) {
        return new Observable(function (subscriber) { return subscribable.subscribe(subscriber); });
    }

    var DEFAULT_CONFIG$1 = {
        connector: function () { return new Subject(); },
    };
    /**
     * Establishes a connection to a data source using the provided selector and configuration.
     *
     * @param {Subscribable<any>} selector - The data source to subscribe to.
     * @param {Object} [config] - Configuration options for the connection. If not provided, defaults to DEFAULT_CONFIG$1.
     * @param {ConnectorFunction} config.connector - A function that returns a new connector subject.
     *
     * @returns {Observable<any>} An observable that emits data from the connected source.
     *
     * Example:
     * connect(myDataSource, {
     *   connector: () => new Subject()
     * }).subscribe(data => console.log(data));
     */
    function connect(selector, config) {
        if (config === void 0) { config = DEFAULT_CONFIG$1; }
        var connector = config.connector;
        return operate(function (source, subscriber) {
            var subject = connector();
            innerFrom(selector(fromSubscribable(subject))).subscribe(subscriber);
            subscriber.add(source.subscribe(subject));
        });
    }

    /**
     * Counts the number of elements that satisfy the provided predicate function.
     *
     * @param {Function} predicate - A function that takes an element and its index as arguments and returns a boolean indicating whether to count the element.
     * @returns {number} The count of elements satisfying the predicate.
     *
     * @example
     * // Counting even numbers in an array
     * const result = count([1, 2, 3, 4], (value) => value % 2 === 0);
     * console.log(result); // Output: 2
     */
    function count(predicate) {
        return reduce(function (total, value, i) { return (!predicate || predicate(value, i) ? total + 1 : total); }, 0);
    }

    /**
     * Creates an operator function that debounces events from the source observable by a specified duration selector.
     *
     * @param {function} durationSelector - A function that returns an Observable, which determines how long to wait before emitting the latest value from the source observable.
     * @returns {Observable} An Observable that emits values from the source observable after the specified duration has passed since the last emission.
     */
    function debounce(durationSelector) {
        return operate(function (source, subscriber) {
            var hasValue = false;
            var lastValue = null;
            var durationSubscriber = null;
            var emit = function () {
                durationSubscriber === null || durationSubscriber === void 0 ? void 0 : durationSubscriber.unsubscribe();
                durationSubscriber = null;
                if (hasValue) {
                    hasValue = false;
                    var value = lastValue;
                    lastValue = null;
                    subscriber.next(value);
                }
            };
            source.subscribe(createOperatorSubscriber(subscriber, function (value) {
                durationSubscriber === null || durationSubscriber === void 0 ? void 0 : durationSubscriber.unsubscribe();
                hasValue = true;
                lastValue = value;
                durationSubscriber = createOperatorSubscriber(subscriber, emit, noop);
                innerFrom(durationSelector(value)).subscribe(durationSubscriber);
            }, function () {
                emit();
                subscriber.complete();
            }, undefined, function () {
                lastValue = durationSubscriber = null;
            }));
        });
    }

    /**
     * Debounces emissions from the source observable by a specified due time.
     *
     * @param {number} dueTime - The duration in milliseconds to wait before emitting the last value.
     * @param {IScheduler} [scheduler=asyncScheduler] - The scheduler on which to perform the debouncing. Defaults to `asyncScheduler`.
     * @returns {Observable<T>} An observable that emits items from the source observable after a specified due time, only if no other emissions occur during this period.
     *
     * @example
     * import { fromEvent } from 'rxjs';
     * import { debounceTime } from 'rxjs/operators';
     *
     * // Example usage with a click event
     * const button = document.getElementById('myButton');
     * const clicks$ = fromEvent(button, 'click').pipe(debounceTime(300));
     * clicks$.subscribe(() => console.log('Button clicked after 300ms of inactivity'));
     */
    function debounceTime(dueTime, scheduler) {
        if (scheduler === void 0) { scheduler = asyncScheduler; }
        return operate(function (source, subscriber) {
            var activeTask = null;
            var lastValue = null;
            var lastTime = null;
            var emit = function () {
                if (activeTask) {
                    activeTask.unsubscribe();
                    activeTask = null;
                    var value = lastValue;
                    lastValue = null;
                    subscriber.next(value);
                }
            };
            /**
             * Schedules the emission of an event when the scheduler's current time is greater than or equal to the target time.
             *
             * @returns {void}
             */
            function emitWhenIdle() {
                var targetTime = lastTime + dueTime;
                var now = scheduler.now();
                if (now < targetTime) {
                    activeTask = this.schedule(undefined, targetTime - now);
                    subscriber.add(activeTask);
                    return;
                }
                emit();
            }
            source.subscribe(createOperatorSubscriber(subscriber, function (value) {
                lastValue = value;
                lastTime = scheduler.now();
                if (!activeTask) {
                    activeTask = scheduler.schedule(emitWhenIdle, dueTime);
                    subscriber.add(activeTask);
                }
            }, function () {
                emit();
                subscriber.complete();
            }, undefined, function () {
                lastValue = activeTask = null;
            }));
        });
    }

    /**
     * Returns an Observable that emits a specified default value if the source observable does not emit any values within a specified time frame.
     *
     * @param {any} defaultValue - The default value to emit if no values are emitted by the source observable.
     * @returns {Observable<any>} An Observable that emits the default value or values from the source observable.
     */
    function defaultIfEmpty(defaultValue) {
        return operate(function (source, subscriber) {
            var hasValue = false;
            source.subscribe(createOperatorSubscriber(subscriber, function (value) {
                hasValue = true;
                subscriber.next(value);
            }, function () {
                if (!hasValue) {
                    subscriber.next(defaultValue);
                }
                subscriber.complete();
            }));
        });
    }

    /**
     * Creates an Observable that emits a specified number of values from the source Observable.
     *
     * @param {number} count - The maximum number of values to emit from the source.
     * @returns {Observable} An Observable that emits up to `count` values from the source, then completes.
     * @throws {Error} Throws an error if `count` is less than or equal to 0.
     *
     * @example
     * const source$ = of(1, 2, 3, 4, 5);
     * const limitedSource$ = take(3)(source$);
     * limitedSource$.subscribe(value => console.log(value));
     * // Output: 1, 2, 3
     */
    function take(count) {
        return count <= 0
            ?
                function () { return EMPTY; }
            : operate(function (source, subscriber) {
                var seen = 0;
                source.subscribe(createOperatorSubscriber(subscriber, function (value) {
                    if (++seen <= count) {
                        subscriber.next(value);
                        if (count <= seen) {
                            subscriber.complete();
                        }
                    }
                }));
            });
    }

    /**
     * Ignores all elements of an Observable.
     *
     * This operator does not alter the values emitted by the source Observable,
     * but it skips over them, effectively ignoring any data.
     *
     * @returns {Observable} An empty Observable that emits no items and completes immediately after the source Observable has completed.
     */
    function ignoreElements() {
        return operate(function (source, subscriber) {
            source.subscribe(createOperatorSubscriber(subscriber, noop));
        });
    }

    /**
     * Creates a function that returns a constant value.
     *
     * @param {*} value - The value to return when the function is called.
     * @returns {Function} - A function that, when invoked, will return the specified value.
     *
     * @example
     * const getValue = mapTo(42);
     * console.log(getValue()); // Output: 42
     */
    function mapTo(value) {
        return map(function () { return value; });
    }

    /**
     * Delays the emission of items from the source observable by a duration determined by the provided selector function.
     *
     * @param {function(value: T, index: number): Observable<number>} delayDurationSelector - A selector function that returns an observable for each emitted value. The returned observable determines the delay duration in milliseconds.
     * @param {Observable<any>|undefined} subscriptionDelay - An optional observable to delay the subscription of the source observable until it emits a value.
     * @returns {Observable<T>} - An observable that emits items from the source after the specified delay duration.
     *
     * @example
     * import { interval, delayWhen } from 'rxjs';
     * import { mapTo } from 'rxjs/operators';
     *
     * // Delay each emission by 500 milliseconds
     * const delayedInterval = interval(100).pipe(delayWhen(value => of(500)));
     * delayedInterval.subscribe(console.log);
     */
    function delayWhen(delayDurationSelector, subscriptionDelay) {
        if (subscriptionDelay) {
            return function (source) {
                return concat(subscriptionDelay.pipe(take(1), ignoreElements()), source.pipe(delayWhen(delayDurationSelector)));
            };
        }
        return mergeMap(function (value, index) { return innerFrom(delayDurationSelector(value, index)).pipe(take(1), mapTo(value)); });
    }

    /**
     * Delays the execution of an observable sequence until a relative or absolute time period elapses.
     *
     * @param {number} due - The relative time (specified as a Duration) or absolute time (specified as a Date)
     * to wait before subscribing to the source observable.
     * @param {Scheduler} [scheduler=asyncScheduler] - Scheduler to run timer in. Defaults to asyncScheduler.
     * @returns {Observable} An observable sequence that delays the given amount of time before beginning to emit items from the source sequence.
     */
    function delay(due, scheduler) {
        if (scheduler === void 0) { scheduler = asyncScheduler; }
        var duration = timer(due, scheduler);
        return delayWhen(function () { return duration; });
    }

    /**
     * Converts an Observable of {@link Notification|Notifications} into an Observable that emits the underlying `value` from each delivered {@link NextNotification|NextNotification}.
     *
     * <span class="informal">Unwraps {@link NextNotification|Next}, {@link ErrorNotification|Error}, and {@link CompleteNotification|Complete} notifications, emitting only their respective values.</span>
     *
     * ![](![marble diagram for dematerialize](https://raw.githubusercontent.com/ReactiveX/rxjs/master/assets/images/marble/dematerialize.png))
     *
     * ## Examples
     * Unwrap notifications from an Observable of Notifications
     * ```javascript
     * import { of, Notification } from 'rxjs';
     * import { dematerialize } from 'rxjs/operators';
     *
     * // Create an observable that emits a next notification with value 'a'
     * const source$ = of(Notification.createNext('a'));
     *
     * source$.pipe(
     *   dematerialize()
     * ).subscribe({
     *   next: value => console.log(value), // Outputs: 'a'
     *   error: err => console.error(err),
     *   complete: () => console.log('Completed')
     * });
     * ```
     *
     * @return {Observable<T>} An Observable that emits the values from `NextNotification` notifications of the source Observable.
     */
    function dematerialize() {
        return operate(function (source, subscriber) {
            source.subscribe(createOperatorSubscriber(subscriber, function (notification) { return observeNotification(notification, subscriber); }));
        });
    }

    /**
     * Returns an Observable that emits only unique items from the source, determined by a key selector function.
     *
     * @param {function(value: T): K} [keySelector] - A function to extract a key for each item. Defaults to using the item itself.
     * @param {Observable<any>} [flushes] - An Observable that, when emitted, will reset the set of distinct keys, allowing duplicates to be emitted again.
     * @returns {OperatorFunction<T, T>} An OperatorFunction that emits unique items based on the key selector.
     *
     * @example
     * // Example usage:
     * const source = from([1, 2, 3, 2, 4]);
     * const distinctValues$ = source.pipe(distinct());
     * distinctValues$.subscribe(console.log); // Output: 1, 2, 3, 4
     *
     * @example
     * // Example with key selector:
     * const source = from([{ id: 1, name: 'Alice' }, { id: 2, name: 'Bob' }, { id: 1, name: 'Charlie' }]);
     * const distinctById$ = source.pipe(distinct(item => item.id));
     * distinctById$.subscribe(console.log); // Output: { id: 1, name: 'Alice' }, { id: 2, name: 'Bob' }
     *
     * @example
     * // Example with flushes:
     * const source = from([1, 2, 3, 4, 5]);
     * const flushes$ = timer(5000);
     * const distinctWithFlush$ = source.pipe(distinct(null, flushes$));
     * distinctWithFlush$.subscribe(console.log); // Output will vary based on the timing of flushes$
     */
    function distinct(keySelector, flushes) {
        return operate(function (source, subscriber) {
            var distinctKeys = new Set();
            source.subscribe(createOperatorSubscriber(subscriber, function (value) {
                var key = keySelector ? keySelector(value) : value;
                if (!distinctKeys.has(key)) {
                    distinctKeys.add(key);
                    subscriber.next(value);
                }
            }));
            flushes && innerFrom(flushes).subscribe(createOperatorSubscriber(subscriber, function () { return distinctKeys.clear(); }, noop));
        });
    }

    /**
     * Operator function to filter out consecutive duplicate values emitted by an observable,
     * optionally comparing the values using a custom comparator.
     *
     * @param {Function} [comparator] - Optional function used to compare two values for equality. Defaults to strict equality comparison.
     * @param {Function} [keySelector] - Optional function that extracts a key from each value to be compared. Defaults to identity function, which uses the value itself as the key.
     * @returns {Observable<T>} - An observable that emits only distinct values based on the provided comparator and key selector.
     *
     * @example
     * const source$ = of(1, 2, 2, 3, 4, 4);
     * const distinctValues$ = source$.pipe(distinctUntilChanged());
     * distinctValues$.subscribe(value => console.log(value));
     * // Output: 1, 2, 3, 4
     *
     * @example
     * const source$ = of('apple', 'banana', 'apple');
     * const distinctFruits$ = source$.pipe(distinctUntilChanged((prev, curr) => prev.toLowerCase() === curr.toLowerCase()));
     * distinctFruits$.subscribe(fruit => console.log(fruit));
     * // Output: apple, banana
     */
    function distinctUntilChanged(comparator, keySelector) {
        if (keySelector === void 0) { keySelector = identity; }
        comparator = comparator !== null && comparator !== void 0 ? comparator : defaultCompare;
        return operate(function (source, subscriber) {
            var previousKey;
            var first = true;
            source.subscribe(createOperatorSubscriber(subscriber, function (value) {
                var currentKey = keySelector(value);
                if (first || !comparator(previousKey, currentKey)) {
                    first = false;
                    previousKey = currentKey;
                    subscriber.next(value);
                }
            }));
        });
    }
    /**
     * Compares two values and returns true if they are equal, false otherwise.
     *
     * @param {any} a - The first value to compare.
     * @param {any} b - The second value to compare.
     * @returns {boolean} - True if the values are equal, false otherwise.
     */
    function defaultCompare(a, b) {
        return a === b;
    }

    /**
     * Creates an operator that returns only distinct values based on a specified key from the source Observable.
     *
     * @param {string} key The key to compare the previous and current values by.
     * @param {function} [compare] Optional function to compare two values. If not provided, strict equality (===) is used.
     * @returns {Observable} An Observable that emits only distinct values based on the specified key.
     *
     * @example
     * // Example usage:
     * const source$ = from([{id: 1, value: 'a'}, {id: 2, value: 'b'}, {id: 2, value: 'c'}]);
     * const distinctSource$ = source$.pipe(distinctUntilKeyChanged('id'));
     *
     * distinctSource$.subscribe(value => {
     *   console.log(value); // Output: {id: 1, value: 'a'}, {id: 2, value: 'b'}
     * });
     */
    function distinctUntilKeyChanged(key, compare) {
        return distinctUntilChanged(function (x, y) { return (compare ? compare(x[key], y[key]) : x[key] === y[key]); });
    }

    /**
     * Throws an error if the source observable is empty.
     *
     * @param {function(): Error} [errorFactory=defaultErrorFactory] - A function that returns an error to be thrown if the source observable is empty. Defaults to a default error factory.
     * @returns {Observable<T>} - An Observable that emits values from the source unless it completes without emitting any items, in which case it throws an error.
     *
     * @example
     * const observable = of();
     * const result = throwIfEmpty(() => new Error('No data received'))(observable);
     * result.subscribe({
     *   next: (value) => console.log(value),
     *   error: (error) => console.error(error)
     * });
     *
     * @throws {Error} - Throws an error if the source observable completes without emitting any items.
     */
    function throwIfEmpty(errorFactory) {
        if (errorFactory === void 0) { errorFactory = defaultErrorFactory; }
        return operate(function (source, subscriber) {
            var hasValue = false;
            source.subscribe(createOperatorSubscriber(subscriber, function (value) {
                hasValue = true;
                subscriber.next(value);
            }, function () { return (hasValue ? subscriber.complete() : subscriber.error(errorFactory())); }));
        });
    }
    /**
     * Creates and returns an instance of the `EmptyError` class.
     *
     * @returns {EmptyError} An instance of the `EmptyError` class.
     *
     * Example usage:
     * ```javascript
     * try {
     *   // Some code that might throw an error
     * } catch (error) {
     *   const emptyError = defaultErrorFactory();
     *   console.log(emptyError);
     * }
     * ```
     */
    function defaultErrorFactory() {
        return new EmptyError();
    }

    /**
     * Returns an observable sequence that contains only elements from the source sequence at the specified index.
     *
     * @param {number} index - The zero-based index of the element to retrieve.
     * @param {*} [defaultValue] - The default value to return if the index is out of range.
     * @returns {Observable} An observable sequence containing only the element at the specified index.
     * @throws {ArgumentOutOfRangeError} If the index is less than 0 or greater than or equal to the number of elements in the source sequence.
     *
     * Example:
     * const source = from([1, 2, 3]);
     * const result = elementAt(1);
     * result.subscribe(console.log); // Output: 2
     */
    function elementAt(index, defaultValue) {
        if (index < 0) {
            throw new ArgumentOutOfRangeError();
        }
        var hasDefaultValue = arguments.length >= 2;
        return function (source) {
            return source.pipe(filter(function (v, i) { return i === index; }), take(1), hasDefaultValue ? defaultIfEmpty(defaultValue) : throwIfEmpty(function () { return new ArgumentOutOfRangeError(); }));
        };
    }

    /**
     * Creates an operator function that appends one or more values to the source observable sequence.
     *
     * @function
     * @name endWith
     * @param {...*} values - The values to append to the source sequence.
     * @returns {Observable} An observable sequence with the appended values.
     */
    function endWith() {
        var values = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            values[_i] = arguments[_i];
        }
        return function (source) { return concat(source, of.apply(void 0, __spreadArray([], __read(values)))); };
    }

    /**
     * Determines whether all elements of an observable sequence satisfy a condition.
     *
     * @param {Function} predicate - A function to test each element for a condition.
     * @param {*} [thisArg] - The object to which the 'this' keyword will be bound during the execution of the predicate function.
     * @returns {Observable<boolean>} An observable sequence returning a boolean indicating whether all elements passed the test in the predicate.
     *
     * @example
     * // Example usage:
     * const numbers = [1, 2, 3, 4];
     * from(numbers).pipe(every(x => x > 0)).subscribe(result => console.log(result)); // Output: true
     */
    function every(predicate, thisArg) {
        return operate(function (source, subscriber) {
            var index = 0;
            source.subscribe(createOperatorSubscriber(subscriber, function (value) {
                if (!predicate.call(thisArg, value, index++, source)) {
                    subscriber.next(false);
                    subscriber.complete();
                }
            }, function () {
                subscriber.next(true);
                subscriber.complete();
            }));
        });
    }

    /**
     * Projects each source value to an Observable which is merged into the output Observable only if there is no currently active inner subscription.
     *
     * <img src="https://rxjs.dev/assets/images/rxjs-methods/exhaustMap.png" width="100%">
     *
     * @param {function(value: T, index: number): Observable} project - A function that receives an item emitted by the source Observable and returns an Observable.
     * @param {function(outerValue: T, innerValue: I, outerIndex: number, innerIndex: number): any} [resultSelector] - An optional function to map the values emitted from the inner Observable to the output Observable.
     * @return {Observable} An Observable that emits the result of applying the project function to each value emitted by the source Observable.
     * @throws {TypeError} If the `project` argument is not a valid function.
     *
     * @example
     * // Project each item from the source observable to an inner observable and merge it into the output observable
     * const source$ = of(1, 2, 3);
     * const result$ = source$.pipe(exhaustMap(x => of(x * 2)));
     * result$.subscribe(console.log); // Output: 2, 4, 6
     *
     * @example
     * // Project each item from the source observable to an inner observable and use a result selector function
     * const source$ = of(1, 2, 3);
     * const result$ = source$.pipe(exhaustMap(x => of(x * 2), (outer, inner) => outer + inner));
     * result$.subscribe(console.log); // Output: 3, 5, 7
     */
    function exhaustMap(project, resultSelector) {
        if (resultSelector) {
            return function (source) {
                return source.pipe(exhaustMap(function (a, i) { return innerFrom(project(a, i)).pipe(map(function (b, ii) { return resultSelector(a, b, i, ii); })); }));
            };
        }
        return operate(function (source, subscriber) {
            var index = 0;
            var innerSub = null;
            var isComplete = false;
            source.subscribe(createOperatorSubscriber(subscriber, function (outerValue) {
                if (!innerSub) {
                    innerSub = createOperatorSubscriber(subscriber, undefined, function () {
                        innerSub = null;
                        isComplete && subscriber.complete();
                    });
                    innerFrom(project(outerValue, index++)).subscribe(innerSub);
                }
            }, function () {
                isComplete = true;
                !innerSub && subscriber.complete();
            }));
        });
    }

    /**
     * Exhausts all emissions from an observable by passing them through an identity function.
     *
     * @returns {Observable} - An observable that emits the same values as the input observable.
     */
    function exhaustAll() {
        return exhaustMap(identity);
    }

    var exhaust = exhaustAll;

    /**
     * Expands the source observable by applying a projection function to each item concurrently.
     *
     * @param {Function} project - A function that maps each emitted value of the source observable to an Observable. The result is merged into the output Observable.
     * @param {number} [concurrent=Infinity] - The maximum number of concurrent subscriptions to allow from the projection functions.
     * @param {SchedulerLike} [scheduler] - The scheduler to use for scheduling the emissions.
     *
     * @returns {Observable<any>} - An Observable that emits the results of merging the Observables returned by the projection function.
     *
     * @example
     * // Example usage:
     * const source$ = from([1, 2, 3]);
     * const result$ = source$.pipe(expand(item => of(item * 2), 2));
     * result$.subscribe(console.log); // Logs: 2, 4, 6 (order may vary)
     */
    function expand(project, concurrent, scheduler) {
        if (concurrent === void 0) { concurrent = Infinity; }
        concurrent = (concurrent || 0) < 1 ? Infinity : concurrent;
        return operate(function (source, subscriber) {
            return mergeInternals(source, subscriber, project, concurrent, undefined, true, scheduler);
        });
    }

    /**
     * Executes a callback function after the source has been subscribed to.
     *
     * @param {Function} callback - The function to execute after subscription.
     * @returns {Observable} - An Observable that wraps the original operation with the finalization callback.
     */
    function finalize(callback) {
        return operate(function (source, subscriber) {
            try {
                source.subscribe(subscriber);
            }
            finally {
                subscriber.add(callback);
            }
        });
    }

    /**
     * Finds the value of the first element in the array that satisfies the provided testing function.
     *
     * @function find
     * @param {Function} predicate - A function that is called for each element in the array until it finds one where predicate returns true. The function takes three arguments: currentValue, index, and array.
     * @param {*} [thisArg] - Value to use as this when executing callback.
     * @returns {*} The value of the first element that satisfies the provided testing function, or undefined if no such element is found.
     *
     * @throws {TypeError} If predicate is not a function.
     */
    function find(predicate, thisArg) {
        return operate(createFind(predicate, thisArg, 'value'));
    }
    /**
     * Creates an operator function that finds values in a source observable based on a predicate function.
     *
     * @param {Function} predicate - A function to test each value emitted by the source. It returns true if the value should be included, false otherwise.
     * @param {*} thisArg - An optional object to which `this` will be bound inside the predicate function.
     * @param {'value' | 'index'} [emit='value'] - Determines whether to emit the index of the found value ('index') or the value itself ('value').
     * @returns {Function} - A higher-order function that takes a source observable and returns a new observable.
     */
    function createFind(predicate, thisArg, emit) {
        var findIndex = emit === 'index';
        return function (source, subscriber) {
            var index = 0;
            source.subscribe(createOperatorSubscriber(subscriber, function (value) {
                var i = index++;
                if (predicate.call(thisArg, value, i, source)) {
                    subscriber.next(findIndex ? i : value);
                    subscriber.complete();
                }
            }, function () {
                subscriber.next(findIndex ? -1 : undefined);
                subscriber.complete();
            }));
        };
    }

    /**
     * Returns the index of the first element in the array that satisfies the provided testing function.
     *
     * @param {Function} predicate - A function that is called with each element in the array, returning true if the element meets the condition.
     * @param {*} [thisArg] - Value to use as `this` when executing `predicate`.
     * @returns {number} The index of the first element that satisfies the condition, or -1 if no such element is found.
     *
     * @throws {TypeError} If predicate is not a function.
     *
     * @example
     * const array = [5, 12, 8, 130, 44];
     * const index = findIndex(element => element > 10);
     * console.log(index); // Output: 1
     */
    function findIndex(predicate, thisArg) {
        return operate(createFind(predicate, thisArg, 'index'));
    }

    /**
     * Returns an observable that emits the first element of an observable sequence that satisfies a specified condition or a default value if no such element is found.
     *
     * @function
     * @param {Function} predicate - A function to test each source element for a condition. The function takes three arguments: the current value, its index, and the source observable.
     * @param {*} [defaultValue] - The default value to return if no elements satisfy the condition.
     * @returns {Observable} An observable sequence containing the first element that satisfies the condition or the default value if not found.
     *
     * @throws {EmptyError} If no elements satisfy the condition and no default value is provided.
     *
     * @example
     * const source$ = of(1, 2, 3, 4);
     * const firstEven$ = source$.pipe(first((x) => x % 2 === 0));
     * firstEven$.subscribe(console.log); // Output: 2
     */
    function first(predicate, defaultValue) {
        var hasDefaultValue = arguments.length >= 2;
        return function (source) {
            return source.pipe(predicate ? filter(function (v, i) { return predicate(v, i, source); }) : identity, take(1), hasDefaultValue ? defaultIfEmpty(defaultValue) : throwIfEmpty(function () { return new EmptyError(); }));
        };
    }

    /**
     * Groups emitted values by a specified key selector and emits each group as an Observable.
     *
     * @param {Function} keySelector - A function that extracts the key for grouping from each value.
     * @param {Object|Function} [elementOrOptions] - An object containing options or a function to transform elements before grouping.
     * @param {Observable|Function} [duration] - An Observable or a function that defines when groups should complete.
     * @param {Function} [connector] - A function that returns a new Subject for each group.
     * @returns {Observable} An Observable emitting GroupedObservables, each representing a group of values.
     *
     * @example
     * const source$ = interval(100).pipe(groupBy(i => i % 2));
     * source$.subscribe(grouped$ => {
     *   grouped$.key; // Key used for grouping
     *   grouped$.subscribe(val => console.log(val)); // Values belonging to the group
     * });
     */
    function groupBy(keySelector, elementOrOptions, duration, connector) {
        return operate(function (source, subscriber) {
            var element;
            if (!elementOrOptions || typeof elementOrOptions === 'function') {
                element = elementOrOptions;
            }
            else {
                (duration = elementOrOptions.duration, element = elementOrOptions.element, connector = elementOrOptions.connector);
            }
            var groups = new Map();
            var notify = function (cb) {
                groups.forEach(cb);
                cb(subscriber);
            };
            var handleError = function (err) { return notify(function (consumer) { return consumer.error(err); }); };
            var activeGroups = 0;
            var teardownAttempted = false;
            var groupBySourceSubscriber = new OperatorSubscriber(subscriber, function (value) {
                try {
                    var key_1 = keySelector(value);
                    var group_1 = groups.get(key_1);
                    if (!group_1) {
                        groups.set(key_1, (group_1 = connector ? connector() : new Subject()));
                        var grouped = createGroupedObservable(key_1, group_1);
                        subscriber.next(grouped);
                        if (duration) {
                            var durationSubscriber_1 = createOperatorSubscriber(group_1, function () {
                                group_1.complete();
                                durationSubscriber_1 === null || durationSubscriber_1 === void 0 ? void 0 : durationSubscriber_1.unsubscribe();
                            }, undefined, undefined, function () { return groups.delete(key_1); });
                            groupBySourceSubscriber.add(innerFrom(duration(grouped)).subscribe(durationSubscriber_1));
                        }
                    }
                    group_1.next(element ? element(value) : value);
                }
                catch (err) {
                    handleError(err);
                }
            }, function () { return notify(function (consumer) { return consumer.complete(); }); }, handleError, function () { return groups.clear(); }, function () {
                teardownAttempted = true;
                return activeGroups === 0;
            });
            source.subscribe(groupBySourceSubscriber);
            function createGroupedObservable(key, groupSubject) {
                var result = new Observable(function (groupSubscriber) {
                    activeGroups++;
                    var innerSub = groupSubject.subscribe(groupSubscriber);
                    return function () {
                        innerSub.unsubscribe();
                        --activeGroups === 0 && teardownAttempted && groupBySourceSubscriber.unsubscribe();
                    };
                });
                result.key = key;
                return result;
            }
        });
    }

    /**
     * Determines whether an Observable is empty.
     *
     * The `isEmpty` function checks if the provided Observable emits any items. If it completes without emitting any items,
     * the subscriber receives `true`. If it emits at least one item, the subscriber receives `false`.
     *
     * @returns {Observable<boolean>} An Observable that emits a single boolean value indicating whether the source Observable is empty.
     *
     * Example:
     * ```javascript
     * const observable = rxjs.from([]);
     * observable.pipe(isEmpty()).subscribe(result => {
     *   console.log(result); // Output: true
     * });
     * ```
     */
    function isEmpty() {
        return operate(function (source, subscriber) {
            source.subscribe(createOperatorSubscriber(subscriber, function () {
                subscriber.next(false);
                subscriber.complete();
            }, function () {
                subscriber.next(true);
                subscriber.complete();
            }));
        });
    }

    /**
     * Creates an operator function that returns only the last `count` elements from the source Observable.
     *
     * @param {number} count - The number of elements to return from the end of the sequence.
     * @returns {function} An operator function that takes a source Observable and returns an Observable that emits only the last `count` elements.
     *
     * Example:
     * ```
     * const observable = rxjs.range(1, 10);
     * const result = takeLast(3)(observable);
     * result.subscribe(console.log); // Output: 8, 9, 10
     * ```
     */
    function takeLast(count) {
        return count <= 0
            ? function () { return EMPTY; }
            : operate(function (source, subscriber) {
                var buffer = [];
                source.subscribe(createOperatorSubscriber(subscriber, function (value) {
                    buffer.push(value);
                    count < buffer.length && buffer.shift();
                }, function () {
                    var e_1, _a;
                    try {
                        for (var buffer_1 = __values(buffer), buffer_1_1 = buffer_1.next(); !buffer_1_1.done; buffer_1_1 = buffer_1.next()) {
                            var value = buffer_1_1.value;
                            subscriber.next(value);
                        }
                    }
                    catch (e_1_1) { e_1 = { error: e_1_1 }; }
                    finally {
                        try {
                            if (buffer_1_1 && !buffer_1_1.done && (_a = buffer_1.return)) _a.call(buffer_1);
                        }
                        finally { if (e_1) throw e_1.error; }
                    }
                    subscriber.complete();
                }, undefined, function () {
                    buffer = null;
                }));
            });
    }

    /**
     * Returns an Observable that emits only the last item emitted by the source Observable,
     * or a default value if no items were emitted.
     *
     * <img src="https://reactivex.io/assets/images/rxjs-methods.png" width="640px" alt="last">
     *
     * @param {function} [predicate] - Optional predicate function to filter the values emitted by the source Observable.
     * @param {*} [defaultValue] - Default value to emit if no items were emitted by the source Observable and a predicate is provided.
     * @returns {Observable} An Observable that emits only the last item or the default value, if applicable.
     *
     * @example
     * // Example usage:
     * const observable = of(1, 2, 3);
     * observable.pipe(last$1()).subscribe(value => console.log(value)); // Outputs: 3
     */
    function last$1(predicate, defaultValue) {
        var hasDefaultValue = arguments.length >= 2;
        return function (source) {
            return source.pipe(predicate ? filter(function (v, i) { return predicate(v, i, source); }) : identity, takeLast(1), hasDefaultValue ? defaultIfEmpty(defaultValue) : throwIfEmpty(function () { return new EmptyError(); }));
        };
    }

    /**
     * Creates an observable that emits items from the source observable, wrapping each item or completion signal with a `Notification` object.
     *
     * @returns {Observable<Notification<any>>} An observable emitting `Notification` objects representing next values, completions, and errors.
     */
    function materialize() {
        return operate(function (source, subscriber) {
            source.subscribe(createOperatorSubscriber(subscriber, function (value) {
                subscriber.next(Notification.createNext(value));
            }, function () {
                subscriber.next(Notification.createComplete());
                subscriber.complete();
            }, function (err) {
                subscriber.next(Notification.createError(err));
                subscriber.complete();
            }));
        });
    }

    /**
     * Returns the maximum element of an array or a value from applying a comparison function to each pair of elements.
     *
     * @param {Function} comparer - A function that takes two arguments and returns a number indicating whether the first argument is less than, equal to, or greater than the second argument.
     * @returns {*} The maximum element based on the comparison, or undefined if the array is empty.
     *
     * @example
     * // Using the default comparer
     * const maxNumber = max([1, 3, 2]);
     * console.log(maxNumber); // Output: 3
     *
     * // Using a custom comparer
     * const maxString = max(['apple', 'banana', 'cherry'], (a, b) => a.length - b.length);
     * console.log(maxString); // Output: 'banana'
     */
    function max(comparer) {
        return reduce(isFunction(comparer) ? function (x, y) { return (comparer(x, y) > 0 ? x : y); } : function (x, y) { return (x > y ? x : y); });
    }

    var flatMap = mergeMap;

    /**
     * Merges an Observable with another Observable, using a specified function to project each value from the source into an inner Observable.
     *
     * @param {Observable} innerObservable - The Observable to merge with the source Observable.
     * @param {function|number} resultSelector - A function that projects the value of one Observable into another Observable. If it returns a number, it specifies the concurrency level.
     * @param {number} [concurrent=Infinity] - Maximum number of input Observables being subscribed to concurrently. Defaults to Infinity if not specified.
     * @returns {Observable} An Observable that merges the results from both the source and inner Observables using the provided function or concurrency level.
     *
     * @example
     * // Merge two observables with a custom result selector function
     * const source$ = of(1, 2, 3);
     * const inner$ = of('a', 'b');
     * const merged$ = mergeMapTo(inner$, (x) => `Value: ${x}`);
     * merged$.subscribe(console.log); // Output: Value: a, Value: b
     *
     * @example
     * // Merge two observables with concurrency level set to 2
     * const source$ = of(1, 2, 3);
     * const inner$ = of('a', 'b');
     * const merged$ = mergeMapTo(inner$, 2);
     * merged$.subscribe(console.log); // Output: Value: a, Value: b
     */
    function mergeMapTo(innerObservable, resultSelector, concurrent) {
        if (concurrent === void 0) { concurrent = Infinity; }
        if (isFunction(resultSelector)) {
            return mergeMap(function () { return innerObservable; }, resultSelector, concurrent);
        }
        if (typeof resultSelector === 'number') {
            concurrent = resultSelector;
        }
        return mergeMap(function () { return innerObservable; }, concurrent);
    }

    /**
     * Merges multiple observables into a single observable that applies an accumulator function to combine their values.
     *
     * @param {function} accumulator - A function that takes the current state, a value from one of the observables, and its index as arguments and returns the new state.
     * @param {*} seed - The initial state for the accumulator function.
     * @param {number} [concurrent=Infinity] - Maximum number of observable subscriptions to run concurrently. Defaults to Infinity.
     * @returns {Observable} - An observable that emits the accumulated state after each value is processed.
     *
     * @example
     * const obs1 = Observable.of(1, 2);
     * const obs2 = Observable.of(3, 4);
     * mergeScan((acc, value) => acc + value, 0)(obs1, obs2).subscribe(console.log); // Outputs: 6 10
     *
     * @throws {TypeError} - Throws an error if the accumulator function is not provided.
     */
    function mergeScan(accumulator, seed, concurrent) {
        if (concurrent === void 0) { concurrent = Infinity; }
        return operate(function (source, subscriber) {
            var state = seed;
            return mergeInternals(source, subscriber, function (value, index) { return accumulator(state, value, index); }, concurrent, function (value) {
                state = value;
            }, false, undefined, function () { return (state = null); });
        });
    }

    /**
     * Merges multiple observables into one observable, with optional concurrency control and scheduler.
     *
     * @param {...any} args - Variable arguments that can be observables or options.
     * @returns {Observable<any>} - An Observable that emits items from each of the input observables as they arrive.
     */
    function merge$1() {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
        }
        var scheduler = popScheduler(args);
        var concurrent = popNumber(args, Infinity);
        return operate(function (source, subscriber) {
            mergeAll(concurrent)(from(__spreadArray([source], __read(args)), scheduler)).subscribe(subscriber);
        });
    }

    /**
     * Merges multiple sources into a single object or array using a deep merging strategy.
     *
     * @param {...Object|Array} otherSources - The sources to be merged with the base source.
     * @returns {Object|Array} - The merged result of all provided sources.
     * @throws {Error} - If any of the sources are not valid objects or arrays for merging.
     *
     * @example
     * const result = mergeWith({ a: 1 }, { b: 2 });
     * console.log(result); // { a: 1, b: 2 }
     */
    function mergeWith() {
        var otherSources = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            otherSources[_i] = arguments[_i];
        }
        return merge$1.apply(void 0, __spreadArray([], __read(otherSources)));
    }

    /**
     * Returns the minimum element of an array based on a comparison function or a default comparator.
     *
     * @param {Function} [comparer] - A function that defines the sort order. If not provided, elements are compared using the default comparator.
     * @returns {*} The minimum element in the array.
     * @throws {Error} If the input array is empty and no comparer is provided.
     *
     * @example
     * const numbers = [3, 1, 4, 1, 5];
     * console.log(min(numbers)); // Output: 1
     */
    function min(comparer) {
        return reduce(isFunction(comparer) ? function (x, y) { return (comparer(x, y) < 0 ? x : y); } : function (x, y) { return (x < y ? x : y); });
    }

    /**
     * Creates an observable that multicasts all values from the source observable to multiple observers.
     *
     * @param {Observable|Function} subjectOrSubjectFactory - The subject or a factory function that returns a subject. If not provided, a default subject is used.
     * @param {Function} [selector] - A selector function to create an inner connection for each observer. If not provided, the source observable is directly connected to all observers.
     * @returns {ConnectableObservable|Function} - Returns a connectable observable if a selector is provided, otherwise returns a factory function that can be used to create a connectable observable.
     *
     * @example
     * const subject = new Subject();
     * const source$ = of(1, 2, 3);
     * const connectable$ = multicast(subject)(source$);
     *
     * // Connect the multicasted observable to all observers
     * connectable$.connect();
     *
     * connectable$.subscribe(console.log); // Outputs: 1, 2, 3
     * connectable$.subscribe(console.log); // Outputs: 1, 2, 3
     */
    function multicast(subjectOrSubjectFactory, selector) {
        var subjectFactory = isFunction(subjectOrSubjectFactory) ? subjectOrSubjectFactory : function () { return subjectOrSubjectFactory; };
        if (isFunction(selector)) {
            return connect(selector, {
                connector: subjectFactory,
            });
        }
        return function (source) { return new ConnectableObservable(source, subjectFactory); };
    }

    /**
     * Creates an observable that emits all values from the source observable, but resumes to the next observable in case of an error.
     *
     * @param {...Observable} sources - An array or arguments list of observables to subscribe to sequentially.
     * @returns {function} A function that takes a source observable and returns an observable that subscribes to it and handles errors by moving to the next observable.
     */
    function onErrorResumeNextWith() {
        var sources = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            sources[_i] = arguments[_i];
        }
        var nextSources = argsOrArgArray(sources);
        return function (source) { return onErrorResumeNext.apply(void 0, __spreadArray([source], __read(nextSources))); };
    }
    var onErrorResumeNext$1 = onErrorResumeNextWith;

    /**
     * Creates an operator that emits an array containing each value from the source Observable
     * and its preceding value(s), as they are emitted.
     *
     * @returns {Observable<Array>} An observable of arrays, where each array contains a value and its predecessor.
     */
    function pairwise() {
        return operate(function (source, subscriber) {
            var prev;
            var hasPrev = false;
            source.subscribe(createOperatorSubscriber(subscriber, function (value) {
                var p = prev;
                prev = value;
                hasPrev && subscriber.next([p, value]);
                hasPrev = true;
            }));
        });
    }

    /**
     * Extracts properties from an object or array of objects based on a list of property names.
     *
     * @param {...string} properties - A variable number of property names to extract.
     * @returns {Array|undefined} - An array containing the extracted properties, or undefined if any property is not found.
     * @throws {Error} - Throws an error if the list of properties is empty.
     *
     * @example
     * const data = [{ a: { b: { c: 1 } } }, { a: { b: { d: 2 } } }];
     * const result = pluck('a', 'b', 'c');
     * console.log(result); // Output: [1, undefined]
     *
     * @example
     * const data = [{ a: { b: { c: 1 } } }, { a: { b: { d: 2 } } }];
     * const result = pluck('a', 'b');
     * console.log(result); // Output: [{c: 1}, {d: 2}]
     */
    function pluck() {
        var properties = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            properties[_i] = arguments[_i];
        }
        var length = properties.length;
        if (length === 0) {
            throw new Error('list of properties cannot be empty.');
        }
        return map(function (x) {
            var currentProp = x;
            for (var i = 0; i < length; i++) {
                var p = currentProp === null || currentProp === void 0 ? void 0 : currentProp[properties[i]];
                if (typeof p !== 'undefined') {
                    currentProp = p;
                }
                else {
                    return undefined;
                }
            }
            return currentProp;
        });
    }

    /**
     * Publishes the source observable to multiple subscribers. If a selector is provided, it applies the selector function to each emitted value.
     *
     * @param {Function} [selector] - Optional function to apply to each emitted value before publishing.
     * @returns {Function} A function that takes an observable source and returns an observable.
     */
    function publish(selector) {
        return selector ? function (source) { return connect(selector)(source); } : function (source) { return multicast(new Subject())(source); };
    }

    /**
     * Creates an observable that shares the emissions of the source observable with all observers until it completes or errors.
     *
     * @param {any} initialValue - The initial value to start the BehaviorSubject with.
     * @returns {function} A function that takes a source observable and returns a ConnectableObservable.
     *
     * Example:
     * const source = of(1, 2, 3);
     * const behaviorSubject = publishBehavior(0)(source).publishReplay();
     * behaviorSubject.connect();
     *
     * @throws {Error} Throws an error if the source observable completes or errors before any observer subscribes.
     */
    function publishBehavior(initialValue) {
        return function (source) {
            var subject = new BehaviorSubject(initialValue);
            return new ConnectableObservable(source, function () { return subject; });
        };
    }

    /**
     * Creates an observable that emits only the last value emitted by the source observable.
     *
     * @returns {Function} A function that takes an observable as a source and returns a new observable.
     */
    function publishLast() {
        return function (source) {
            var subject = new AsyncSubject();
            return new ConnectableObservable(source, function () { return subject; });
        };
    }

    /**
     * Creates an operator that multicasts the source observable by using a ReplaySubject as the inner subject for caching emitted values.
     *
     * @param {number} bufferSize - The maximum number of recent emissions to replay.
     * @param {number} windowTime - The time window over which to replay the cached emissions.
     * @param {Function|Scheduler} [selectorOrScheduler] - Optional. A selector function that determines how to determine the values to be emitted, or a Scheduler to run the multicasting on.
     * @param {Function} [timestampProvider=Date.now] - An optional function to provide timestamps for determining the window time.
     *
     * @returns {function(observable: Observable): Observable} A function that takes an observable and returns a new observable which shares the same emissions but caches recent values.
     */
    function publishReplay(bufferSize, windowTime, selectorOrScheduler, timestampProvider) {
        if (selectorOrScheduler && !isFunction(selectorOrScheduler)) {
            timestampProvider = selectorOrScheduler;
        }
        var selector = isFunction(selectorOrScheduler) ? selectorOrScheduler : undefined;
        return function (source) { return multicast(new ReplaySubject(bufferSize, windowTime, timestampProvider), selector)(source); };
    }

    function raceWith() {
        var otherSources = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            otherSources[_i] = arguments[_i];
        }
        return !otherSources.length
            ? identity
            : operate(function (source, subscriber) {
                raceInit(__spreadArray([source], __read(otherSources)))(subscriber);
            });
    }

    /**
     * Creates an observable that emits a value repeatedly for a specified number of times or indefinitely if not specified.
     *
     * @param {Object|number} [countOrConfig] - The number of times to repeat the value, or an object with `count` and optionally `delay`.
     * @returns {Observable<any>} An observable that emits the value repeatedly.
     *
     * @example
     * // Repeat a value 5 times
     * const repeated = repeat(5);
     *
     * @example
     * // Repeat a value indefinitely with a delay of 1000ms between each emission
     * const repeatedWithDelay = repeat({ count: Infinity, delay: 1000 });
     */
    function repeat(countOrConfig) {
        var _a;
        var count = Infinity;
        var delay;
        if (countOrConfig != null) {
            if (typeof countOrConfig === 'object') {
                (_a = countOrConfig.count, count = _a === void 0 ? Infinity : _a, delay = countOrConfig.delay);
            }
            else {
                count = countOrConfig;
            }
        }
        return count <= 0
            ? function () { return EMPTY; }
            : operate(function (source, subscriber) {
                var soFar = 0;
                var sourceSub;
                var resubscribe = function () {
                    sourceSub === null || sourceSub === void 0 ? void 0 : sourceSub.unsubscribe();
                    sourceSub = null;
                    if (delay != null) {
                        var notifier = typeof delay === 'number' ? timer(delay) : innerFrom(delay(soFar));
                        var notifierSubscriber_1 = createOperatorSubscriber(subscriber, function () {
                            notifierSubscriber_1.unsubscribe();
                            subscribeToSource();
                        });
                        notifier.subscribe(notifierSubscriber_1);
                    }
                    else {
                        subscribeToSource();
                    }
                };
                var subscribeToSource = function () {
                    var syncUnsub = false;
                    sourceSub = source.subscribe(createOperatorSubscriber(subscriber, undefined, function () {
                        if (++soFar < count) {
                            if (sourceSub) {
                                resubscribe();
                            }
                            else {
                                syncUnsub = true;
                            }
                        }
                        else {
                            subscriber.complete();
                        }
                    }));
                    if (syncUnsub) {
                        resubscribe();
                    }
                };
                subscribeToSource();
            });
    }

    /**
     * Repeats the source observable as long as the notifier returns true.
     *
     * @param {function} notifier - A function that receives an observable of completions and returns a notifier.
     * @returns {Observable<T>} An Observable that will emit items from the source until the notifier returns false.
     */
    function repeatWhen(notifier) {
        return operate(function (source, subscriber) {
            var innerSub;
            var syncResub = false;
            var completions$;
            var isNotifierComplete = false;
            var isMainComplete = false;
            var checkComplete = function () { return isMainComplete && isNotifierComplete && (subscriber.complete(), true); };
            var getCompletionSubject = function () {
                if (!completions$) {
                    completions$ = new Subject();
                    innerFrom(notifier(completions$)).subscribe(createOperatorSubscriber(subscriber, function () {
                        if (innerSub) {
                            subscribeForRepeatWhen();
                        }
                        else {
                            syncResub = true;
                        }
                    }, function () {
                        isNotifierComplete = true;
                        checkComplete();
                    }));
                }
                return completions$;
            };
            var subscribeForRepeatWhen = function () {
                isMainComplete = false;
                innerSub = source.subscribe(createOperatorSubscriber(subscriber, undefined, function () {
                    isMainComplete = true;
                    !checkComplete() && getCompletionSubject().next();
                }));
                if (syncResub) {
                    innerSub.unsubscribe();
                    innerSub = null;
                    syncResub = false;
                    subscribeForRepeatWhen();
                }
            };
            subscribeForRepeatWhen();
        });
    }

    /**
     * Retries an observable sequence a specified number of times before failing.
     *
     * @param {number|RetryConfig} configOrCount - The maximum number of retries or a RetryConfig object.
     * @returns {Observable<T>} An observable that will resubscribe to the source observable in case of errors up to the specified count.
     */
    function retry(configOrCount) {
        if (configOrCount === void 0) { configOrCount = Infinity; }
        var config;
        if (configOrCount && typeof configOrCount === 'object') {
            config = configOrCount;
        }
        else {
            config = {
                count: configOrCount,
            };
        }
        var _a = config.count, count = _a === void 0 ? Infinity : _a, delay = config.delay, _b = config.resetOnSuccess, resetOnSuccess = _b === void 0 ? false : _b;
        return count <= 0
            ? identity
            : operate(function (source, subscriber) {
                var soFar = 0;
                var innerSub;
                var subscribeForRetry = function () {
                    var syncUnsub = false;
                    innerSub = source.subscribe(createOperatorSubscriber(subscriber, function (value) {
                        if (resetOnSuccess) {
                            soFar = 0;
                        }
                        subscriber.next(value);
                    }, undefined, function (err) {
                        if (soFar++ < count) {
                            var resub_1 = function () {
                                if (innerSub) {
                                    innerSub.unsubscribe();
                                    innerSub = null;
                                    subscribeForRetry();
                                }
                                else {
                                    syncUnsub = true;
                                }
                            };
                            if (delay != null) {
                                var notifier = typeof delay === 'number' ? timer(delay) : innerFrom(delay(err, soFar));
                                var notifierSubscriber_1 = createOperatorSubscriber(subscriber, function () {
                                    notifierSubscriber_1.unsubscribe();
                                    resub_1();
                                }, function () {
                                    subscriber.complete();
                                });
                                notifier.subscribe(notifierSubscriber_1);
                            }
                            else {
                                resub_1();
                            }
                        }
                        else {
                            subscriber.error(err);
                        }
                    }));
                    if (syncUnsub) {
                        innerSub.unsubscribe();
                        innerSub = null;
                        subscribeForRetry();
                    }
                };
                subscribeForRetry();
            });
    }

    /**
     * Creates an operator that retries an observable if it encounters an error.
     *
     * @param {function(errors$: Observable<any>): Observable<any>} notifier - A function that takes the error observable and returns an observable that determines when to retry.
     * @returns {Observable<T>} An observable sequence that continues to emit items from the original source until an error occurs, at which point it will resubscribe based on the notifier's signal.
     *
     * @example
     * const source$ = interval(100).pipe(
     *   map(n => n / 0),
     *   retryWhen(errors$ => errors$.pipe(delay(500)))
     * );
     */
    function retryWhen(notifier) {
        return operate(function (source, subscriber) {
            var innerSub;
            var syncResub = false;
            var errors$;
            var subscribeForRetryWhen = function () {
                innerSub = source.subscribe(createOperatorSubscriber(subscriber, undefined, undefined, function (err) {
                    if (!errors$) {
                        errors$ = new Subject();
                        innerFrom(notifier(errors$)).subscribe(createOperatorSubscriber(subscriber, function () {
                            return innerSub ? subscribeForRetryWhen() : (syncResub = true);
                        }));
                    }
                    if (errors$) {
                        errors$.next(err);
                    }
                }));
                if (syncResub) {
                    innerSub.unsubscribe();
                    innerSub = null;
                    syncResub = false;
                    subscribeForRetryWhen();
                }
            };
            subscribeForRetryWhen();
        });
    }

    /**
     * A function that creates an operator to notify subscribers with the last value received from a source observable when a notifier emits.
     *
     * @param {function} notifier - A function that, when called, triggers the notification of the last value.
     * @returns {Observable} An Observable that emits the last value received from the source observable when the notifier is triggered.
     * @throws {Error} Throws an error if the source observable does not emit any values before the notifier is triggered.
     */
    function sample(notifier) {
        return operate(function (source, subscriber) {
            var hasValue = false;
            var lastValue = null;
            source.subscribe(createOperatorSubscriber(subscriber, function (value) {
                hasValue = true;
                lastValue = value;
            }));
            innerFrom(notifier).subscribe(createOperatorSubscriber(subscriber, function () {
                if (hasValue) {
                    hasValue = false;
                    var value = lastValue;
                    lastValue = null;
                    subscriber.next(value);
                }
            }, noop));
        });
    }

    /**
     * Samples an Observable by emitting the most recent value from the source Observable,
     * periodically or when the scheduler decides to emit it.
     *
     * @param {number} period - The period of time between samples in milliseconds.
     * @param {SchedulerLike} [scheduler=asyncScheduler] - Scheduler used for determining the timing of samples.
     * @returns {Observable<T>} An Observable that emits sampled values from the source Observable.
     *
     * @example
     * // Example usage:
     * const source$ = interval(1000);
     * const sampled$ = source$.pipe(sampleTime(2000));
     * sampled$.subscribe(console.log);
     * // Logs every 2 seconds with the most recent value from the source Observable
     */
    function sampleTime(period, scheduler) {
        if (scheduler === void 0) { scheduler = asyncScheduler; }
        return sample(interval(period, scheduler));
    }

    /**
     * Combines elements of an array or an iterable into a single value using a provided accumulator function.
     *
     * @param {Function} operate - The main operation to be performed on the accumulator and seed values.
     * @param {Function} scanInternals - The internal scanning function that handles the accumulation logic.
     * @param {*} accumulator - The initial value or accumulator used for accumulating elements.
     * @param {*} seed - (Optional) An additional initial value, often used as a starting point.
     * @returns {*} The accumulated result after processing all elements.
     *
     * @example
     * // Example usage of the scan function
     * const result = scan((acc, x) => acc + x, 0, [1, 2, 3]);
     * console.log(result); // Output: 6
     */
    function scan(accumulator, seed) {
        return operate(scanInternals(accumulator, seed, arguments.length >= 2, true));
    }

    function sequenceEqual(compareTo, comparator) {
        if (comparator === void 0) { comparator = function (a, b) { return a === b; }; }
        return operate(function (source, subscriber) {
            var aState = createState();
            var bState = createState();
            var emit = function (isEqual) {
                subscriber.next(isEqual);
                subscriber.complete();
            };
            var createSubscriber = function (selfState, otherState) {
                var sequenceEqualSubscriber = createOperatorSubscriber(subscriber, function (a) {
                    var buffer = otherState.buffer, complete = otherState.complete;
                    if (buffer.length === 0) {
                        complete ? emit(false) : selfState.buffer.push(a);
                    }
                    else {
                        !comparator(a, buffer.shift()) && emit(false);
                    }
                }, function () {
                    selfState.complete = true;
                    var complete = otherState.complete, buffer = otherState.buffer;
                    complete && emit(buffer.length === 0);
                    sequenceEqualSubscriber === null || sequenceEqualSubscriber === void 0 ? void 0 : sequenceEqualSubscriber.unsubscribe();
                });
                return sequenceEqualSubscriber;
            };
            source.subscribe(createSubscriber(aState, bState));
            innerFrom(compareTo).subscribe(createSubscriber(bState, aState));
        });
    }
    /**
     * Creates and returns an object representing the initial state.
     *
     * @returns {Object} An object with two properties:
     *   - buffer {Array}: An empty array to store data temporarily.
     *   - complete {boolean}: A boolean indicating if the operation is complete (default: false).
     */
    function createState() {
        return {
            buffer: [],
            complete: false,
        };
    }

    /**
     * Creates an observable that shares the emissions of the source observable with multiple subscribers. It ensures that the source observable is only subscribed to once and emits values to all subscribers.
     *
     * @param {Object} [options={}] - Configuration options for the sharing behavior.
     * @property {Function} [connector=function () { return new Subject(); }] - A factory function that returns an observable (e.g., a Subject) used to connect multiple subscribers. Defaults to creating a new Subject.
     * @property {boolean} [resetOnError=true] - Whether to reset the sharing state and re-subscribe if an error occurs in the source observable. Defaults to true.
     * @property {boolean} [resetOnComplete=true] - Whether to reset the sharing state and re-subscribe when the source observable completes. Defaults to true.
     * @property {boolean} [resetOnRefCountZero=false] - Whether to reset the sharing state and re-subscribe when the number of subscribers reaches zero. Defaults to false.
     *
     * @returns {Function} A function that takes an observable (wrapperSource) as input and returns a new observable that shares emissions with multiple subscribers according to the specified options.
     */
    function share(options) {
        if (options === void 0) { options = {}; }
        var _a = options.connector, connector = _a === void 0 ? function () { return new Subject(); } : _a, _b = options.resetOnError, resetOnError = _b === void 0 ? true : _b, _c = options.resetOnComplete, resetOnComplete = _c === void 0 ? true : _c, _d = options.resetOnRefCountZero, resetOnRefCountZero = _d === void 0 ? true : _d;
        return function (wrapperSource) {
            var connection;
            var resetConnection;
            var subject;
            var refCount = 0;
            var hasCompleted = false;
            var hasErrored = false;
            var cancelReset = function () {
                resetConnection === null || resetConnection === void 0 ? void 0 : resetConnection.unsubscribe();
                resetConnection = undefined;
            };
            var reset = function () {
                cancelReset();
                connection = subject = undefined;
                hasCompleted = hasErrored = false;
            };
            var resetAndUnsubscribe = function () {
                var conn = connection;
                reset();
                conn === null || conn === void 0 ? void 0 : conn.unsubscribe();
            };
            return operate(function (source, subscriber) {
                refCount++;
                if (!hasErrored && !hasCompleted) {
                    cancelReset();
                }
                var dest = (subject = subject !== null && subject !== void 0 ? subject : connector());
                subscriber.add(function () {
                    refCount--;
                    if (refCount === 0 && !hasErrored && !hasCompleted) {
                        resetConnection = handleReset(resetAndUnsubscribe, resetOnRefCountZero);
                    }
                });
                dest.subscribe(subscriber);
                if (!connection &&
                    refCount > 0) {
                    connection = new SafeSubscriber({
                        next: function (value) { return dest.next(value); },
                        error: function (err) {
                            hasErrored = true;
                            cancelReset();
                            resetConnection = handleReset(reset, resetOnError, err);
                            dest.error(err);
                        },
                        complete: function () {
                            hasCompleted = true;
                            cancelReset();
                            resetConnection = handleReset(reset, resetOnComplete);
                            dest.complete();
                        },
                    });
                    innerFrom(source).subscribe(connection);
                }
            })(wrapperSource);
        };
    }
    /**
     * Handles the reset logic based on the provided `on` parameter.
     *
     * @param {function} reset - The function to call for resetting.
     * @param {boolean} on - Determines whether to immediately call the `reset` function or subscribe to an observable.
     * @param {...*} args - Additional arguments to pass to the `on` function if subscribing.
     *
     * If `on` is true, the `reset` function is called immediately and no further action is taken.
     * If `on` is false, the function returns without any action.
     * If `on` is neither true nor false, it subscribes to an observable returned by calling `on` with the provided arguments,
     * and calls the `reset` function when the observable emits a value. The subscription is then automatically unsubscribed after the first emission.
     *
     * @returns {Subscription|undefined} - If subscribing to an observable, returns the resulting Subscription object.
     * @throws {Error} - Throws an error if `on` is not a boolean or a function that returns an observable.
     */
    function handleReset(reset, on) {
        var args = [];
        for (var _i = 2; _i < arguments.length; _i++) {
            args[_i - 2] = arguments[_i];
        }
        if (on === true) {
            reset();
            return;
        }
        if (on === false) {
            return;
        }
        var onSubscriber = new SafeSubscriber({
            next: function () {
                onSubscriber.unsubscribe();
                reset();
            },
        });
        return innerFrom(on.apply(void 0, __spreadArray([], __read(args)))).subscribe(onSubscriber);
    }

    /**
     * Creates an observable that shares the emissions of the source observable but
     * replays a limited window of emitted values to new subscribers.
     *
     * @param {(number | Object)} configOrBufferSize - Configuration object or buffer size for replaying.
     * @param {number} [windowTime=Infinity] - The maximum time window to replay.
     * @param {SchedulerLike} [scheduler=undefined] - Scheduler to use for scheduling the replays.
     * @returns {Observable<T>} A new observable that shares and replays emissions of the source observable.
     *
     * @example
     * // Using buffer size configuration
     * const shared$ = shareReplay({ bufferSize: 3 });
     * shared$.subscribe(x => console.log(x));
     *
     * // Using buffer size and window time configuration
     * const shared$ = shareReplay({ bufferSize: 3, windowTime: 1000 });
     * shared$.subscribe(x => console.log(x));
     *
     * @exception {TypeError} If `configOrBufferSize` is not a number or object.
     */
    function shareReplay(configOrBufferSize, windowTime, scheduler) {
        var _a, _b, _c;
        var bufferSize;
        var refCount = false;
        if (configOrBufferSize && typeof configOrBufferSize === 'object') {
            (_a = configOrBufferSize.bufferSize, bufferSize = _a === void 0 ? Infinity : _a, _b = configOrBufferSize.windowTime, windowTime = _b === void 0 ? Infinity : _b, _c = configOrBufferSize.refCount, refCount = _c === void 0 ? false : _c, scheduler = configOrBufferSize.scheduler);
        }
        else {
            bufferSize = (configOrBufferSize !== null && configOrBufferSize !== void 0 ? configOrBufferSize : Infinity);
        }
        return share({
            connector: function () { return new ReplaySubject(bufferSize, windowTime, scheduler); },
            resetOnError: true,
            resetOnComplete: false,
            resetOnRefCountZero: refCount,
        });
    }

    /**
     * Emits only the first value emitted by the source Observable that satisfies a specified condition.
     *
     * @param {function(value: T, index: number, source: Observable<T>): boolean} predicate - A function to test each value emitted by the source Observable. It takes three arguments:
     *   - `value`: The current value being emitted.
     *   - `index`: The zero-based index of the current emission.
     *   - `source`: The source Observable that is emitting values.
     *   - Returns true if the value should be emitted, false otherwise.
     *
     * @returns {Observable<T>} An Observable that emits only the first value that meets the condition or an error if no such value exists.
     *
     * @throws {SequenceError} If there are multiple matching values and a predicate is provided.
     * @throws {NotFoundError} If there are no matching values and a predicate is provided.
     * @throws {EmptyError} If the source Observable completes without emitting any values and no predicate is provided.
     */
    function single(predicate) {
        return operate(function (source, subscriber) {
            var hasValue = false;
            var singleValue;
            var seenValue = false;
            var index = 0;
            source.subscribe(createOperatorSubscriber(subscriber, function (value) {
                seenValue = true;
                if (!predicate || predicate(value, index++, source)) {
                    hasValue && subscriber.error(new SequenceError('Too many matching values'));
                    hasValue = true;
                    singleValue = value;
                }
            }, function () {
                if (hasValue) {
                    subscriber.next(singleValue);
                    subscriber.complete();
                }
                else {
                    subscriber.error(seenValue ? new NotFoundError('No matching values') : new EmptyError());
                }
            }));
        });
    }

    /**
     * Creates a new sequence by skipping a specified number of elements from the beginning.
     *
     * @param {number} count - The number of elements to skip. Must be a non-negative integer.
     * @returns {Function} A function that, when called with an array, returns a new array with the first `count` elements removed.
     * @throws {Error} If `count` is negative.
     *
     * Example usage:
     *   const result = skip(2)([10, 20, 30, 40]);
     *   console.log(result); // Output: [30, 40]
     */
    function skip(count) {
        return filter(function (_, index) { return count <= index; });
    }

    function skipLast(skipCount) {
        return skipCount <= 0
            ?
                identity
            : operate(function (source, subscriber) {
                var ring = new Array(skipCount);
                var seen = 0;
                source.subscribe(createOperatorSubscriber(subscriber, function (value) {
                    var valueIndex = seen++;
                    if (valueIndex < skipCount) {
                        ring[valueIndex] = value;
                    }
                    else {
                        var index = valueIndex % skipCount;
                        var oldValue = ring[index];
                        ring[index] = value;
                        subscriber.next(oldValue);
                    }
                }));
                return function () {
                    ring = null;
                };
            });
    }

    /**
     * Skips values emitted by an Observable until a second Observable emits a value.
     *
     * <img src="https://rxjs.dev/assets/images/marble-diagrams/skip-until.png" width="60%">
     *
     * @param {Observable} notifier - The Observable that triggers the emission of values from the source Observable.
     * @returns {OperatorFunction<T, T>} An operator function that returns an Observable which skips emissions from the source until `notifier` emits a value.
     */
    function skipUntil(notifier) {
        return operate(function (source, subscriber) {
            var taking = false;
            var skipSubscriber = createOperatorSubscriber(subscriber, function () {
                skipSubscriber === null || skipSubscriber === void 0 ? void 0 : skipSubscriber.unsubscribe();
                taking = true;
            }, noop);
            innerFrom(notifier).subscribe(skipSubscriber);
            source.subscribe(createOperatorSubscriber(subscriber, function (value) { return taking && subscriber.next(value); }));
        });
    }

    /**
     * Creates an operator that skips values emitted by the source observable while a specified predicate returns true.
     *
     * @param {function(value, index): boolean} predicate - The function to test each value. It takes two arguments:
     *   - `value`: The current value being processed.
     *   - `index`: The zero-based index of the current value in the sequence.
     * @return {Observable} An observable that emits values from the source observable starting when the predicate returns false for the first time.
     *
     * Example:
     * ```javascript
     * const source$ = from([1, 2, 3, 4, 5]);
     * const result$ = skipWhile(source$, value => value < 3);
     * result$.subscribe(console.log); // Output: 3, 4, 5
     * ```
     */
    function skipWhile(predicate) {
        return operate(function (source, subscriber) {
            var taking = false;
            var index = 0;
            source.subscribe(createOperatorSubscriber(subscriber, function (value) { return (taking || (taking = !predicate(value, index++))) && subscriber.next(value); }));
        });
    }

    /**
     * Creates an observable sequence that emits the elements of the specified arrays, interleaving them as they complete.
     *
     * @function
     * @param {...Array} values - One or more arrays to concatenate and emit first.
     * @returns {Observable} An observable sequence emitting the elements from the provided arrays.
     */
    function startWith() {
        var values = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            values[_i] = arguments[_i];
        }
        var scheduler = popScheduler(values);
        return operate(function (source, subscriber) {
            (scheduler ? concat(values, source, scheduler) : concat(values, source)).subscribe(subscriber);
        });
    }

    function switchMap(project, resultSelector) {
        return operate(function (source, subscriber) {
            var innerSubscriber = null;
            var index = 0;
            var isComplete = false;
            var checkComplete = function () { return isComplete && !innerSubscriber && subscriber.complete(); };
            source.subscribe(createOperatorSubscriber(subscriber, function (value) {
                innerSubscriber === null || innerSubscriber === void 0 ? void 0 : innerSubscriber.unsubscribe();
                var innerIndex = 0;
                var outerIndex = index++;
                innerFrom(project(value, outerIndex)).subscribe((innerSubscriber = createOperatorSubscriber(subscriber, function (innerValue) { return subscriber.next(resultSelector ? resultSelector(value, innerValue, outerIndex, innerIndex++) : innerValue); }, function () {
                    innerSubscriber = null;
                    checkComplete();
                })));
            }, function () {
                isComplete = true;
                checkComplete();
            }));
        });
    }

    /**
     * Switches all values in an Observable sequence to their corresponding inner sequences,
     * then flattens the transformed Observable into a single sequence.
     *
     * @returns {Observable} An Observable that emits items from flattened inner sequences.
     */
    function switchAll() {
        return switchMap(identity);
    }

    /**
     * Projects each source value to an Observable which is merged in the output Observable, emitting values only from the most recently projected inner Observable.
     *
     * @template {T} T The type of the source Observable.
     * @template {R} R The type of the result Observable.
     * @param {ObservableInput<R>|((value: T) => ObservableInput<R>)} innerObservable An Observable to replace each value from the source Observable with.
     * @param {(outerValue: T, innerValue: R, outerIndex: number, innerIndex: number) => R} [resultSelector] A function that produces an Observable for each value emitted by the source Observable and the inner Observable. It takes as arguments:
     *   - `outerValue`: The value from the source Observable.
     *   - `innerValue`: The value from the inner Observable produced by the resultSelector.
     *   - `outerIndex`: The zero-based index of the value emitted by the source Observable.
     *   - `innerIndex`: The zero-based index of the value emitted by the inner Observable.
     * @returns {Observable<R>} An Observable that emits items from the most recently projected inner Observable.
     */
    function switchMapTo(innerObservable, resultSelector) {
        return isFunction(resultSelector) ? switchMap(function () { return innerObservable; }, resultSelector) : switchMap(function () { return innerObservable; });
    }

    /**
     * Applies an accumulator function over a source observable to produce a resulting observable.
     *
     * @param {Function} accumulator - A function that takes the current state, the next value from the source,
     *                                 and an index, and returns the new state. The result is emitted by the returned observable.
     * @param {*} seed - The initial state used in the accumulator function.
     * @returns {Observable} - An observable that emits the results of applying the accumulator function over each value from the source observable.
     *
     * Example:
     * const source = rxjs.from([1, 2, 3]);
     * const result$ = source.pipe(switchScan((acc, value) => acc + value, 0));
     * result$.subscribe(console.log); // Output: 0, 1, 3, 6
     */
    function switchScan(accumulator, seed) {
        return operate(function (source, subscriber) {
            var state = seed;
            switchMap(function (value, index) { return accumulator(state, value, index); }, function (_, innerValue) { return ((state = innerValue), innerValue); })(source).subscribe(subscriber);
            return function () {
                state = null;
            };
        });
    }

    /**
     * Creates an operator that emits values from the source observable until a notifier observable emits a value.
     *
     * @param {Observable} notifier - The observable that will cause the subscription to complete.
     * @returns {OperatorFunction<T, T>} A function that takes a source observable and returns a new observable which completes when `notifier` emits.
     */
    function takeUntil(notifier) {
        return operate(function (source, subscriber) {
            innerFrom(notifier).subscribe(createOperatorSubscriber(subscriber, function () { return subscriber.complete(); }, noop));
            !subscriber.closed && source.subscribe(subscriber);
        });
    }

    /**
     * Creates an observable that emits values from the source observable until the predicate returns false.
     *
     * @param {Function} predicate - A function called with each value emitted by the source observable. It should return a boolean indicating whether to continue emission or not.
     * @param {boolean} [inclusive=false] - If true, the last value that made the predicate return true will also be emitted before completion.
     * @returns {Observable} An observable emitting values from the source until the predicate returns false.
     *
     * @example
     * takeWhile(x => x < 5); // Emits values from the source until a value is greater than or equal to 5
     */
    function takeWhile(predicate, inclusive) {
        if (inclusive === void 0) { inclusive = false; }
        return operate(function (source, subscriber) {
            var index = 0;
            source.subscribe(createOperatorSubscriber(subscriber, function (value) {
                var result = predicate(value, index++);
                (result || inclusive) && subscriber.next(value);
                !result && subscriber.complete();
            }));
        });
    }

    /**
     * Creates an operator that taps into the observable sequence for debugging or other purposes.
     *
     * @param {function|Object} observerOrNext - The observer or next function to handle events.
     * @param {function} [error] - An error handler function.
     * @param {function} [complete] - A complete handler function.
     * @returns {Observable} - The source observable with the tap operator applied.
     *
     * @example
     * // Using a single next function
     * const subscription = of(1, 2, 3).pipe(tap(value => console.log(`Value: ${value}`))).subscribe();
     *
     * @example
     * // Using an observer object
     * const subscription = of(1, 2, 3).pipe(
     *   tap({
     *     next: value => console.log(`Next: ${value}`),
     *     error: err => console.error(`Error: ${err}`),
     *     complete: () => console.log('Complete')
     *   })
     * ).subscribe();
     */
    function tap(observerOrNext, error, complete) {
        var tapObserver = isFunction(observerOrNext) || error || complete
            ?
                { next: observerOrNext, error: error, complete: complete }
            : observerOrNext;
        return tapObserver
            ? operate(function (source, subscriber) {
                var _a;
                (_a = tapObserver.subscribe) === null || _a === void 0 ? void 0 : _a.call(tapObserver);
                var isUnsub = true;
                source.subscribe(createOperatorSubscriber(subscriber, function (value) {
                    var _a;
                    (_a = tapObserver.next) === null || _a === void 0 ? void 0 : _a.call(tapObserver, value);
                    subscriber.next(value);
                }, function () {
                    var _a;
                    isUnsub = false;
                    (_a = tapObserver.complete) === null || _a === void 0 ? void 0 : _a.call(tapObserver);
                    subscriber.complete();
                }, function (err) {
                    var _a;
                    isUnsub = false;
                    (_a = tapObserver.error) === null || _a === void 0 ? void 0 : _a.call(tapObserver, err);
                    subscriber.error(err);
                }, function () {
                    var _a, _b;
                    if (isUnsub) {
                        (_a = tapObserver.unsubscribe) === null || _a === void 0 ? void 0 : _a.call(tapObserver);
                    }
                    (_b = tapObserver.finalize) === null || _b === void 0 ? void 0 : _b.call(tapObserver);
                }));
            })
            :
                identity;
    }

    /**
     * Throttles the emissions of an observable based on a given duration selector and configuration.
     *
     * @param {Function} durationSelector - A function that takes the emitted value and returns an Observable that defines when to allow emission.
     * @param {Object} [config={ leading: true, trailing: false }] - Configuration object for throttle behavior.
     *   @param {boolean} [config.leading=true] - Whether to emit the initial value immediately before any throttling begins.
     *   @param {boolean} [config.trailing=false] - Whether to emit the last value after the duration has expired.
     * @returns {Observable<T>} - A new Observable that emits values according to the throttle configuration.
     */
    function throttle(durationSelector, config) {
        return operate(function (source, subscriber) {
            var _a = config !== null && config !== void 0 ? config : {}, _b = _a.leading, leading = _b === void 0 ? true : _b, _c = _a.trailing, trailing = _c === void 0 ? false : _c;
            var hasValue = false;
            var sendValue = null;
            var throttled = null;
            var isComplete = false;
            var endThrottling = function () {
                throttled === null || throttled === void 0 ? void 0 : throttled.unsubscribe();
                throttled = null;
                if (trailing) {
                    send();
                    isComplete && subscriber.complete();
                }
            };
            var cleanupThrottling = function () {
                throttled = null;
                isComplete && subscriber.complete();
            };
            var startThrottle = function (value) {
                return (throttled = innerFrom(durationSelector(value)).subscribe(createOperatorSubscriber(subscriber, endThrottling, cleanupThrottling)));
            };
            var send = function () {
                if (hasValue) {
                    hasValue = false;
                    var value = sendValue;
                    sendValue = null;
                    subscriber.next(value);
                    !isComplete && startThrottle(value);
                }
            };
            source.subscribe(createOperatorSubscriber(subscriber, function (value) {
                hasValue = true;
                sendValue = value;
                !(throttled && !throttled.closed) && (leading ? send() : startThrottle(value));
            }, function () {
                isComplete = true;
                !(trailing && hasValue && throttled && !throttled.closed) && subscriber.complete();
            }));
        });
    }

    /**
     * Throttles the emission of values from an observable based on time intervals.
     *
     * @param {number} duration - The time interval in milliseconds to limit emissions.
     * @param {AsyncSchedulerLike | SchedulerLike} [scheduler=asyncScheduler] - The scheduler to use for scheduling the throttle logic. Defaults to `asyncScheduler`.
     * @param {{ leading?: boolean; trailing?: boolean }} [config={ leading: true, trailing: true }] - Configuration object to specify whether the first and/or last emission should be allowed.
     * @returns {Observable<T>} - An observable that emits values from the source observable at most once per specified time interval.
     *
     * @example
     * // Example usage of throttleTime
     * const source$ = interval(200);
     * const throttled$ = source$.pipe(throttleTime(1000));
     * throttled$.subscribe(value => console.log(value));
     */
    function throttleTime(duration, scheduler, config) {
        if (scheduler === void 0) { scheduler = asyncScheduler; }
        var duration$ = timer(duration, scheduler);
        return throttle(function () { return duration$; }, config);
    }

    /**
     * Creates an observable that emits the interval between consecutive emissions from the source observable.
     *
     * @param {SchedulerLike} [scheduler=asyncScheduler] - The scheduler on which to schedule the emission of intervals.
     * @returns {Observable<TimeInterval<T>>} - An observable that emits `TimeInterval` objects representing the time intervals between consecutive emissions.
     */
    function timeInterval(scheduler) {
        if (scheduler === void 0) { scheduler = asyncScheduler; }
        return operate(function (source, subscriber) {
            var last = scheduler.now();
            source.subscribe(createOperatorSubscriber(subscriber, function (value) {
                var now = scheduler.now();
                var interval = now - last;
                last = now;
                subscriber.next(new TimeInterval(value, interval));
            }));
        });
    }
    var TimeInterval = (function () {
        function TimeInterval(value, interval) {
            this.value = value;
            this.interval = interval;
        }
        return TimeInterval;
    }());

    /**
     * Creates an observable that emits values with specified timeouts.
     *
     * @param {Date|number} due - The time to wait for the first emission or interval between emissions.
     * @param {Observable} [withObservable] - An optional observable to switch to after the timeout.
     * @param {Scheduler} [scheduler=async] - The scheduler to use for timing. Defaults to 'async'.
     * @returns {Observable} - An observable that emits values with specified timeouts.
     *
     * @throws {TypeError} If `withObservable` is not provided and no valid timeout is set.
     */
    function timeoutWith(due, withObservable, scheduler) {
        var first;
        var each;
        var _with;
        scheduler = scheduler !== null && scheduler !== void 0 ? scheduler : async;
        if (isValidDate(due)) {
            first = due;
        }
        else if (typeof due === 'number') {
            each = due;
        }
        if (withObservable) {
            _with = function () { return withObservable; };
        }
        else {
            throw new TypeError('No observable provided to switch to');
        }
        if (first == null && each == null) {
            throw new TypeError('No timeout provided.');
        }
        return timeout({
            first: first,
            each: each,
            scheduler: scheduler,
            with: _with,
        });
    }

    /**
     * Creates a function that maps over an array of values, adding a timestamp to each value.
     *
     * @function timestamp
     * @param {Function} [timestampProvider=dateTimestampProvider] - The provider for the current timestamp. Defaults to `dateTimestampProvider`.
     * @returns {Function} A new function that takes an array and returns a new array of objects, each containing a value and its corresponding timestamp.
     *
     * Example:
     * const result = timestamp()(['item1', 'item2']);
     * console.log(result);
     * // Output: [ { value: 'item1', timestamp: 1633072800000 }, { value: 'item2', timestamp: 1633072800000 } ]
     */
    function timestamp(timestampProvider) {
        if (timestampProvider === void 0) { timestampProvider = dateTimestampProvider; }
        return map(function (value) { return ({ value: value, timestamp: timestampProvider.now() }); });
    }

    function window(windowBoundaries) {
        return operate(function (source, subscriber) {
            var windowSubject = new Subject();
            subscriber.next(windowSubject.asObservable());
            var errorHandler = function (err) {
                windowSubject.error(err);
                subscriber.error(err);
            };
            source.subscribe(createOperatorSubscriber(subscriber, function (value) { return windowSubject === null || windowSubject === void 0 ? void 0 : windowSubject.next(value); }, function () {
                windowSubject.complete();
                subscriber.complete();
            }, errorHandler));
            innerFrom(windowBoundaries).subscribe(createOperatorSubscriber(subscriber, function () {
                windowSubject.complete();
                subscriber.next((windowSubject = new Subject()));
            }, noop, errorHandler));
            return function () {
                windowSubject === null || windowSubject === void 0 ? void 0 : windowSubject.unsubscribe();
                windowSubject = null;
            };
        });
    }

    /**
     * Generates an observable sequence of windows that are sampled periodically based on the provided window size and start interval.
     *
     * @param {number} windowSize - The length of each window (in number of elements).
     * @param {number} [startWindowEvery=0] - The interval at which to create a new window. If not specified, windows are created immediately after the previous one completes.
     * @returns {Observable<Observable<T>>} An observable sequence that emits windows of values over the specified time interval.
     *
     * Example:
     * const source = interval(100);
     * const result = source.pipe(windowCount(3));
     * result.subscribe(w => w.subscribe(console.log));
     *
     * This will create a new window every 3 emitted values from the source observable.
     */
    function windowCount(windowSize, startWindowEvery) {
        if (startWindowEvery === void 0) { startWindowEvery = 0; }
        var startEvery = startWindowEvery > 0 ? startWindowEvery : windowSize;
        return operate(function (source, subscriber) {
            var windows = [new Subject()];
            var count = 0;
            subscriber.next(windows[0].asObservable());
            source.subscribe(createOperatorSubscriber(subscriber, function (value) {
                var e_1, _a;
                try {
                    for (var windows_1 = __values(windows), windows_1_1 = windows_1.next(); !windows_1_1.done; windows_1_1 = windows_1.next()) {
                        var window_1 = windows_1_1.value;
                        window_1.next(value);
                    }
                }
                catch (e_1_1) { e_1 = { error: e_1_1 }; }
                finally {
                    try {
                        if (windows_1_1 && !windows_1_1.done && (_a = windows_1.return)) _a.call(windows_1);
                    }
                    finally { if (e_1) throw e_1.error; }
                }
                var c = count - windowSize + 1;
                if (c >= 0 && c % startEvery === 0) {
                    windows.shift().complete();
                }
                if (++count % startEvery === 0) {
                    var window_2 = new Subject();
                    windows.push(window_2);
                    subscriber.next(window_2.asObservable());
                }
            }, function () {
                while (windows.length > 0) {
                    windows.shift().complete();
                }
                subscriber.complete();
            }, function (err) {
                while (windows.length > 0) {
                    windows.shift().error(err);
                }
                subscriber.error(err);
            }, function () {
                windows = null;
            }));
        });
    }

    /**
     * Operator function that emits a new Observable sequence after a specified time has elapsed since the previous emission from the source Observable.
     *
     * @param {number} windowTimeSpan - The time span in milliseconds after which a new window will be started.
     * @return {Observable} An Observable that emits windows of values over the specified time span.
     */
    function windowTime(windowTimeSpan) {
        var _a, _b;
        var otherArgs = [];
        for (var _i = 1; _i < arguments.length; _i++) {
            otherArgs[_i - 1] = arguments[_i];
        }
        var scheduler = (_a = popScheduler(otherArgs)) !== null && _a !== void 0 ? _a : asyncScheduler;
        var windowCreationInterval = (_b = otherArgs[0]) !== null && _b !== void 0 ? _b : null;
        var maxWindowSize = otherArgs[1] || Infinity;
        return operate(function (source, subscriber) {
            var windowRecords = [];
            var restartOnClose = false;
            var closeWindow = function (record) {
                var window = record.window, subs = record.subs;
                window.complete();
                subs.unsubscribe();
                arrRemove(windowRecords, record);
                restartOnClose && startWindow();
            };
            var startWindow = function () {
                if (windowRecords) {
                    var subs = new Subscription();
                    subscriber.add(subs);
                    var window_1 = new Subject();
                    var record_1 = {
                        window: window_1,
                        subs: subs,
                        seen: 0,
                    };
                    windowRecords.push(record_1);
                    subscriber.next(window_1.asObservable());
                    executeSchedule(subs, scheduler, function () { return closeWindow(record_1); }, windowTimeSpan);
                }
            };
            if (windowCreationInterval !== null && windowCreationInterval >= 0) {
                executeSchedule(subscriber, scheduler, startWindow, windowCreationInterval, true);
            }
            else {
                restartOnClose = true;
            }
            startWindow();
            var loop = function (cb) { return windowRecords.slice().forEach(cb); };
            var terminate = function (cb) {
                loop(function (_a) {
                    var window = _a.window;
                    return cb(window);
                });
                cb(subscriber);
                subscriber.unsubscribe();
            };
            source.subscribe(createOperatorSubscriber(subscriber, function (value) {
                loop(function (record) {
                    record.window.next(value);
                    maxWindowSize <= ++record.seen && closeWindow(record);
                });
            }, function () { return terminate(function (consumer) { return consumer.complete(); }); }, function (err) { return terminate(function (consumer) { return consumer.error(err); }); }));
            return function () {
                windowRecords = null;
            };
        });
    }

    /**
     * Creates an observable that emits windows of values from the source observable based on opening and closing selectors.
     *
     * @param {Observable<any>} openings - An Observable that signals when to open a new window.
     * @param {function(value: any): Observable<any>} closingSelector - A function that selects an Observable for each opened window, signaling when to close it.
     * @returns {Observable<Subject<any>>} An observable of Subjects, each representing an opened window.
     *
     * @example
     * const openings$ = from([1, 2]);
     * const closingSelector$ = (value) => of(value + 1);
     * windowToggle(openings$, closingSelector$).subscribe(window => {
     *   window.subscribe(val => console.log(`Value: ${val}`));
     * });
     *
     * @note
     * - The `openings` Observable triggers the opening of new windows.
     * - Each window is a Subject that emits values from the source until it is closed by the `closingSelector`.
     * - Errors in either the `openings`, `closingSelector`, or value emission are propagated to all open windows and the subscriber.
     */
    function windowToggle(openings, closingSelector) {
        return operate(function (source, subscriber) {
            var windows = [];
            var handleError = function (err) {
                while (0 < windows.length) {
                    windows.shift().error(err);
                }
                subscriber.error(err);
            };
            innerFrom(openings).subscribe(createOperatorSubscriber(subscriber, function (openValue) {
                var window = new Subject();
                windows.push(window);
                var closingSubscription = new Subscription();
                var closeWindow = function () {
                    arrRemove(windows, window);
                    window.complete();
                    closingSubscription.unsubscribe();
                };
                var closingNotifier;
                try {
                    closingNotifier = innerFrom(closingSelector(openValue));
                }
                catch (err) {
                    handleError(err);
                    return;
                }
                subscriber.next(window.asObservable());
                closingSubscription.add(closingNotifier.subscribe(createOperatorSubscriber(subscriber, closeWindow, noop, handleError)));
            }, noop));
            source.subscribe(createOperatorSubscriber(subscriber, function (value) {
                var e_1, _a;
                var windowsCopy = windows.slice();
                try {
                    for (var windowsCopy_1 = __values(windowsCopy), windowsCopy_1_1 = windowsCopy_1.next(); !windowsCopy_1_1.done; windowsCopy_1_1 = windowsCopy_1.next()) {
                        var window_1 = windowsCopy_1_1.value;
                        window_1.next(value);
                    }
                }
                catch (e_1_1) { e_1 = { error: e_1_1 }; }
                finally {
                    try {
                        if (windowsCopy_1_1 && !windowsCopy_1_1.done && (_a = windowsCopy_1.return)) _a.call(windowsCopy_1);
                    }
                    finally { if (e_1) throw e_1.error; }
                }
            }, function () {
                while (0 < windows.length) {
                    windows.shift().complete();
                }
                subscriber.complete();
            }, handleError, function () {
                while (0 < windows.length) {
                    windows.shift().unsubscribe();
                }
            }));
        });
    }

    /**
     * Creates an Observable that emits windows of items it collects from the source Observable until a notifier Observable emits an item, at which point
     * it emits the current window and starts a new one.
     *
     * @param {function(): Observable} closingSelector - A function that returns an Observable that signals when to close the current window and start a new one.
     * @returns {Observable<Subject>} An Observable of Observables, where each inner Observable represents a window of items emitted by the source until it is closed.
     *
     * @example
     * // Emit windows of values every 1 second until the mouse button is clicked
     * const source$ = interval(500);
     * const closing$ = fromEvent(document, 'click');
     * const windowed$ = source$.pipe(windowWhen(() => closing$));
     * windowed$.subscribe(window => {
     *   console.log('New Window:', window);
     * });
     *
     * @throws {Error} Throws an error if the provided `closingSelector` function throws.
     */
    function windowWhen(closingSelector) {
        return operate(function (source, subscriber) {
            var window;
            var closingSubscriber;
            var handleError = function (err) {
                window.error(err);
                subscriber.error(err);
            };
            var openWindow = function () {
                closingSubscriber === null || closingSubscriber === void 0 ? void 0 : closingSubscriber.unsubscribe();
                window === null || window === void 0 ? void 0 : window.complete();
                window = new Subject();
                subscriber.next(window.asObservable());
                var closingNotifier;
                try {
                    closingNotifier = innerFrom(closingSelector());
                }
                catch (err) {
                    handleError(err);
                    return;
                }
                closingNotifier.subscribe((closingSubscriber = createOperatorSubscriber(subscriber, openWindow, openWindow, handleError)));
            };
            openWindow();
            source.subscribe(createOperatorSubscriber(subscriber, function (value) { return window.next(value); }, function () {
                window.complete();
                subscriber.complete();
            }, handleError, function () {
                closingSubscriber === null || closingSubscriber === void 0 ? void 0 : closingSubscriber.unsubscribe();
                window = null;
            }));
        });
    }

    function withLatestFrom() {
        var inputs = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            inputs[_i] = arguments[_i];
        }
        var project = popResultSelector(inputs);
        return operate(function (source, subscriber) {
            var len = inputs.length;
            var otherValues = new Array(len);
            var hasValue = inputs.map(function () { return false; });
            var ready = false;
            var _loop_1 = function (i) {
                innerFrom(inputs[i]).subscribe(createOperatorSubscriber(subscriber, function (value) {
                    otherValues[i] = value;
                    if (!ready && !hasValue[i]) {
                        hasValue[i] = true;
                        (ready = hasValue.every(identity)) && (hasValue = null);
                    }
                }, noop));
            };
            for (var i = 0; i < len; i++) {
                _loop_1(i);
            }
            source.subscribe(createOperatorSubscriber(subscriber, function (value) {
                if (ready) {
                    var values = __spreadArray([value], __read(otherValues));
                    subscriber.next(project ? project.apply(void 0, __spreadArray([], __read(values))) : values);
                }
            }));
        });
    }

    /**
     * Zips all elements from the given project using the provided zipper function.
     *
     * @param {Object} project - The project object containing the elements to be zipped.
     * @returns {Array} - An array of zipped elements.
     * @throws {Error} - Throws an error if the project is invalid or the zipper function does not return a valid result.
     *
     * @example
     * const project = {
     *   items: ['item1', 'item2', 'item3'],
     *   zipper: (a, b) => `${a}-${b}`
     * };
     * const result = zipAll(project);
     * console.log(result); // ['item1-item2', 'item2-item3']
     */
    function zipAll(project) {
        return joinAllInternals(zip, project);
    }

    /**
     * Zips multiple sources together by subscribing to each source in sequence and combining their emitted values into arrays.
     *
     * @param {...Observable} sources - One or more Observables to be zipped together.
     * @returns {Observable<Array<any>>} An Observable that emits arrays containing one value from each input Observable, in the order they were provided.
     */
    function zip$1() {
        var sources = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            sources[_i] = arguments[_i];
        }
        return operate(function (source, subscriber) {
            zip.apply(void 0, __spreadArray([source], __read(sources))).subscribe(subscriber);
        });
    }

    function zipWith() {
        var otherInputs = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            otherInputs[_i] = arguments[_i];
        }
        return zip$1.apply(void 0, __spreadArray([], __read(otherInputs)));
    }

    /**
     * Splits an array into two arrays based on a predicate function.
     *
     * @function partition$1
     * @param {Function} predicate - The function used to test each element of the array. It should return true or false.
     * @param {Object} thisArg - Optional. Value to use as `this` when executing `predicate`.
     * @returns {Array<Array>} An array containing two arrays: one with elements that pass the test and another with elements that do not.
     *
     * @example
     * const isEven = (x) => x % 2 === 0;
     * const result = partition$1(isEven)([1, 2, 3, 4]);
     * console.log(result); // [[2, 4], [1, 3]]
     */
    function partition$1(predicate, thisArg) {
        return function (source) {
            return [filter(predicate, thisArg)(source), filter(not(predicate, thisArg))(source)];
        };
    }

    /**
     * A function that returns a promise that resolves when any of the promises in the given array resolve or rejects when all reject.
     * @param {...Promise} argsOrArgArray - An array of promises or multiple arguments each being a promise. If only one argument is provided and it is an array, it will be treated as the array of promises.
     * @returns {Promise} A promise that resolves with the value of the first resolved promise or rejects with the reason from the last rejected promise.
     */
    function race$1() {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
        }
        return raceWith.apply(void 0, __spreadArray([], __read(argsOrArgArray(args))));
    }



    var _operators = /*#__PURE__*/Object.freeze({
        audit: audit,
        auditTime: auditTime,
        buffer: buffer,
        bufferCount: bufferCount,
        bufferTime: bufferTime,
        bufferToggle: bufferToggle,
        bufferWhen: bufferWhen,
        catchError: catchError,
        combineAll: combineAll,
        combineLatestAll: combineLatestAll,
        combineLatest: combineLatest$1,
        combineLatestWith: combineLatestWith,
        concat: concat$1,
        concatAll: concatAll,
        concatMap: concatMap,
        concatMapTo: concatMapTo,
        concatWith: concatWith,
        connect: connect,
        count: count,
        debounce: debounce,
        debounceTime: debounceTime,
        defaultIfEmpty: defaultIfEmpty,
        delay: delay,
        delayWhen: delayWhen,
        dematerialize: dematerialize,
        distinct: distinct,
        distinctUntilChanged: distinctUntilChanged,
        distinctUntilKeyChanged: distinctUntilKeyChanged,
        elementAt: elementAt,
        endWith: endWith,
        every: every,
        exhaust: exhaust,
        exhaustAll: exhaustAll,
        exhaustMap: exhaustMap,
        expand: expand,
        filter: filter,
        finalize: finalize,
        find: find,
        findIndex: findIndex,
        first: first,
        groupBy: groupBy,
        ignoreElements: ignoreElements,
        isEmpty: isEmpty,
        last: last$1,
        map: map,
        mapTo: mapTo,
        materialize: materialize,
        max: max,
        merge: merge$1,
        mergeAll: mergeAll,
        flatMap: flatMap,
        mergeMap: mergeMap,
        mergeMapTo: mergeMapTo,
        mergeScan: mergeScan,
        mergeWith: mergeWith,
        min: min,
        multicast: multicast,
        observeOn: observeOn,
        onErrorResumeNext: onErrorResumeNext$1,
        pairwise: pairwise,
        partition: partition$1,
        pluck: pluck,
        publish: publish,
        publishBehavior: publishBehavior,
        publishLast: publishLast,
        publishReplay: publishReplay,
        race: race$1,
        raceWith: raceWith,
        reduce: reduce,
        repeat: repeat,
        repeatWhen: repeatWhen,
        retry: retry,
        retryWhen: retryWhen,
        refCount: refCount,
        sample: sample,
        sampleTime: sampleTime,
        scan: scan,
        sequenceEqual: sequenceEqual,
        share: share,
        shareReplay: shareReplay,
        single: single,
        skip: skip,
        skipLast: skipLast,
        skipUntil: skipUntil,
        skipWhile: skipWhile,
        startWith: startWith,
        subscribeOn: subscribeOn,
        switchAll: switchAll,
        switchMap: switchMap,
        switchMapTo: switchMapTo,
        switchScan: switchScan,
        take: take,
        takeLast: takeLast,
        takeUntil: takeUntil,
        takeWhile: takeWhile,
        tap: tap,
        throttle: throttle,
        throttleTime: throttleTime,
        throwIfEmpty: throwIfEmpty,
        timeInterval: timeInterval,
        timeout: timeout,
        timeoutWith: timeoutWith,
        timestamp: timestamp,
        toArray: toArray,
        window: window,
        windowCount: windowCount,
        windowTime: windowTime,
        windowToggle: windowToggle,
        windowWhen: windowWhen,
        withLatestFrom: withLatestFrom,
        zip: zip$1,
        zipAll: zipAll,
        zipWith: zipWith
    });

    var SubscriptionLog = (function () {
        /**
         * Creates an instance of SubscriptionLog to manage subscription frames.
         *
         * @constructor
         * @param {number} subscribedFrame - The frame number at which the subscription began.
         * @param {number} [unsubscribedFrame=Infinity] - The frame number at which the subscription ended. Defaults to Infinity if not provided.
         */
        function SubscriptionLog(subscribedFrame, unsubscribedFrame) {
            if (unsubscribedFrame === void 0) { unsubscribedFrame = Infinity; }
            this.subscribedFrame = subscribedFrame;
            this.unsubscribedFrame = unsubscribedFrame;
        }
        return SubscriptionLog;
    }());

    var SubscriptionLoggable = (function () {
        /**
         * A class that allows logging subscriptions.
         * @class
         */
        function SubscriptionLoggable() {
            this.subscriptions = [];
        }
        SubscriptionLoggable.prototype.logSubscribedFrame = function () {
            this.subscriptions.push(new SubscriptionLog(this.scheduler.now()));
            return this.subscriptions.length - 1;
        };
        SubscriptionLoggable.prototype.logUnsubscribedFrame = function (index) {
            var subscriptionLogs = this.subscriptions;
            var oldSubscriptionLog = subscriptionLogs[index];
            subscriptionLogs[index] = new SubscriptionLog(oldSubscriptionLog.subscribedFrame, this.scheduler.now());
        };
        return SubscriptionLoggable;
    }());

    /**
     * Applies mixins to a derived constructor from one or more base constructors.
     *
     * This function takes a derived constructor and an array of base constructors
     * and assigns all the properties (including methods) from each base constructor's
     * prototype to the prototype of the derived constructor. This is useful for
     * combining multiple behaviors into a single class in JavaScript, which does not support
     * inheritance like traditional object-oriented languages.
     *
     * @param {Function} derivedCtor - The constructor of the derived class that will receive the mixins.
     * @param {Array<Function>} baseCtors - An array of constructors representing the base classes from which to mix in properties.
     */
    function applyMixins(derivedCtor, baseCtors) {
        for (var i = 0, len = baseCtors.length; i < len; i++) {
            var baseCtor = baseCtors[i];
            var propertyKeys = Object.getOwnPropertyNames(baseCtor.prototype);
            for (var j = 0, len2 = propertyKeys.length; j < len2; j++) {
                var name_1 = propertyKeys[j];
                derivedCtor.prototype[name_1] = baseCtor.prototype[name_1];
            }
        }
    }

    var ColdObservable = (function (_super) {
        __extends(ColdObservable, _super);
        /**
         * Creates a cold observable with the specified messages and scheduler.
         *
         * @constructor
         * @param {Array} messages - An array of message objects representing the sequence of events to emit.
         * @param {Scheduler} scheduler - The scheduler used to schedule the emission of messages.
         * @throws {Error} If no messages are provided or if the scheduler is not valid.
         */
        function ColdObservable(messages, scheduler) {
            var _this = _super.call(this, function (subscriber) {
                var observable = this;
                var index = observable.logSubscribedFrame();
                var subscription = new Subscription();
                subscription.add(new Subscription(function () {
                    observable.logUnsubscribedFrame(index);
                }));
                observable.scheduleMessages(subscriber);
                return subscription;
            }) || this;
            _this.messages = messages;
            _this.subscriptions = [];
            _this.scheduler = scheduler;
            return _this;
        }
        ColdObservable.prototype.scheduleMessages = function (subscriber) {
            var messagesLength = this.messages.length;
            for (var i = 0; i < messagesLength; i++) {
                var message = this.messages[i];
                subscriber.add(this.scheduler.schedule(function (state) {
                    var _a = state, notification = _a.message.notification, destination = _a.subscriber;
                    observeNotification(notification, destination);
                }, message.frame, { message: message, subscriber: subscriber }));
            }
        };
        return ColdObservable;
    }(Observable));
    applyMixins(ColdObservable, [SubscriptionLoggable]);

    var HotObservable = (function (_super) {
        __extends(HotObservable, _super);
        /**
         * Represents an observable sequence that can multicast multiple observers.
         *
         * @constructor
         * @param {Array} messages - An array of messages to be emitted by the observable.
         * @param {Scheduler} scheduler - The scheduler on which to schedule the emissions.
         */
        function HotObservable(messages, scheduler) {
            var _this = _super.call(this) || this;
            _this.messages = messages;
            _this.subscriptions = [];
            _this.scheduler = scheduler;
            return _this;
        }
        HotObservable.prototype._subscribe = function (subscriber) {
            var subject = this;
            var index = subject.logSubscribedFrame();
            var subscription = new Subscription();
            subscription.add(new Subscription(function () {
                subject.logUnsubscribedFrame(index);
            }));
            subscription.add(_super.prototype._subscribe.call(this, subscriber));
            return subscription;
        };
        HotObservable.prototype.setup = function () {
            var subject = this;
            var messagesLength = subject.messages.length;
            var _loop_1 = function (i) {
                (function () {
                    var _a = subject.messages[i], notification = _a.notification, frame = _a.frame;
                    subject.scheduler.schedule(function () {
                        observeNotification(notification, subject);
                    }, frame);
                })();
            };
            for (var i = 0; i < messagesLength; i++) {
                _loop_1(i);
            }
        };
        return HotObservable;
    }(Subject));
    applyMixins(HotObservable, [SubscriptionLoggable]);

    var defaultMaxFrame = 750;
    var TestScheduler = (function (_super) {
        __extends(TestScheduler, _super);
        /**
         * A class representing a test scheduler that handles virtual observables for testing purposes.
         *
         * @constructor
         * @param {function} assertDeepEqual - The assertion function to use for deep equality checks.
         */
        function TestScheduler(assertDeepEqual) {
            var _this = _super.call(this, VirtualAction, defaultMaxFrame) || this;
            _this.assertDeepEqual = assertDeepEqual;
            _this.hotObservables = [];
            _this.coldObservables = [];
            _this.flushTests = [];
            _this.runMode = false;
            return _this;
        }
        TestScheduler.prototype.createTime = function (marbles) {
            var indexOf = this.runMode ? marbles.trim().indexOf('|') : marbles.indexOf('|');
            if (indexOf === -1) {
                throw new Error('marble diagram for time should have a completion marker "|"');
            }
            return indexOf * TestScheduler.frameTimeFactor;
        };
        TestScheduler.prototype.createColdObservable = function (marbles, values, error) {
            if (marbles.indexOf('^') !== -1) {
                throw new Error('cold observable cannot have subscription offset "^"');
            }
            if (marbles.indexOf('!') !== -1) {
                throw new Error('cold observable cannot have unsubscription marker "!"');
            }
            var messages = TestScheduler.parseMarbles(marbles, values, error, undefined, this.runMode);
            var cold = new ColdObservable(messages, this);
            this.coldObservables.push(cold);
            return cold;
        };
        TestScheduler.prototype.createHotObservable = function (marbles, values, error) {
            if (marbles.indexOf('!') !== -1) {
                throw new Error('hot observable cannot have unsubscription marker "!"');
            }
            var messages = TestScheduler.parseMarbles(marbles, values, error, undefined, this.runMode);
            var subject = new HotObservable(messages, this);
            this.hotObservables.push(subject);
            return subject;
        };
        TestScheduler.prototype.materializeInnerObservable = function (observable, outerFrame) {
            var _this = this;
            var messages = [];
            observable.subscribe({
                next: function (value) {
                    messages.push({ frame: _this.frame - outerFrame, notification: nextNotification(value) });
                },
                error: function (error) {
                    messages.push({ frame: _this.frame - outerFrame, notification: errorNotification(error) });
                },
                complete: function () {
                    messages.push({ frame: _this.frame - outerFrame, notification: COMPLETE_NOTIFICATION });
                },
            });
            return messages;
        };
        TestScheduler.prototype.expectObservable = function (observable, subscriptionMarbles) {
            var _this = this;
            if (subscriptionMarbles === void 0) { subscriptionMarbles = null; }
            var actual = [];
            var flushTest = { actual: actual, ready: false };
            var subscriptionParsed = TestScheduler.parseMarblesAsSubscriptions(subscriptionMarbles, this.runMode);
            var subscriptionFrame = subscriptionParsed.subscribedFrame === Infinity ? 0 : subscriptionParsed.subscribedFrame;
            var unsubscriptionFrame = subscriptionParsed.unsubscribedFrame;
            var subscription;
            this.schedule(function () {
                subscription = observable.subscribe({
                    next: function (x) {
                        var value = x instanceof Observable ? _this.materializeInnerObservable(x, _this.frame) : x;
                        actual.push({ frame: _this.frame, notification: nextNotification(value) });
                    },
                    error: function (error) {
                        actual.push({ frame: _this.frame, notification: errorNotification(error) });
                    },
                    complete: function () {
                        actual.push({ frame: _this.frame, notification: COMPLETE_NOTIFICATION });
                    },
                });
            }, subscriptionFrame);
            if (unsubscriptionFrame !== Infinity) {
                this.schedule(function () { return subscription.unsubscribe(); }, unsubscriptionFrame);
            }
            this.flushTests.push(flushTest);
            var runMode = this.runMode;
            return {
                toBe: function (marbles, values, errorValue) {
                    flushTest.ready = true;
                    flushTest.expected = TestScheduler.parseMarbles(marbles, values, errorValue, true, runMode);
                },
                toEqual: function (other) {
                    flushTest.ready = true;
                    flushTest.expected = [];
                    _this.schedule(function () {
                        subscription = other.subscribe({
                            next: function (x) {
                                var value = x instanceof Observable ? _this.materializeInnerObservable(x, _this.frame) : x;
                                flushTest.expected.push({ frame: _this.frame, notification: nextNotification(value) });
                            },
                            error: function (error) {
                                flushTest.expected.push({ frame: _this.frame, notification: errorNotification(error) });
                            },
                            complete: function () {
                                flushTest.expected.push({ frame: _this.frame, notification: COMPLETE_NOTIFICATION });
                            },
                        });
                    }, subscriptionFrame);
                },
            };
        };
        TestScheduler.prototype.expectSubscriptions = function (actualSubscriptionLogs) {
            var flushTest = { actual: actualSubscriptionLogs, ready: false };
            this.flushTests.push(flushTest);
            var runMode = this.runMode;
            return {
                toBe: function (marblesOrMarblesArray) {
                    var marblesArray = typeof marblesOrMarblesArray === 'string' ? [marblesOrMarblesArray] : marblesOrMarblesArray;
                    flushTest.ready = true;
                    flushTest.expected = marblesArray
                        .map(function (marbles) { return TestScheduler.parseMarblesAsSubscriptions(marbles, runMode); })
                        .filter(function (marbles) { return marbles.subscribedFrame !== Infinity; });
                },
            };
        };
        TestScheduler.prototype.flush = function () {
            var _this = this;
            var hotObservables = this.hotObservables;
            while (hotObservables.length > 0) {
                hotObservables.shift().setup();
            }
            _super.prototype.flush.call(this);
            this.flushTests = this.flushTests.filter(function (test) {
                if (test.ready) {
                    _this.assertDeepEqual(test.actual, test.expected);
                    return false;
                }
                return true;
            });
        };
        TestScheduler.parseMarblesAsSubscriptions = function (marbles, runMode) {
            var _this = this;
            if (runMode === void 0) { runMode = false; }
            if (typeof marbles !== 'string') {
                return new SubscriptionLog(Infinity);
            }
            var characters = __spreadArray([], __read(marbles));
            var len = characters.length;
            var groupStart = -1;
            var subscriptionFrame = Infinity;
            var unsubscriptionFrame = Infinity;
            var frame = 0;
            var _loop_1 = function (i) {
                var nextFrame = frame;
                var advanceFrameBy = function (count) {
                    nextFrame += count * _this.frameTimeFactor;
                };
                var c = characters[i];
                switch (c) {
                    case ' ':
                        if (!runMode) {
                            advanceFrameBy(1);
                        }
                        break;
                    case '-':
                        advanceFrameBy(1);
                        break;
                    case '(':
                        groupStart = frame;
                        advanceFrameBy(1);
                        break;
                    case ')':
                        groupStart = -1;
                        advanceFrameBy(1);
                        break;
                    case '^':
                        if (subscriptionFrame !== Infinity) {
                            throw new Error("found a second subscription point '^' in a " + 'subscription marble diagram. There can only be one.');
                        }
                        subscriptionFrame = groupStart > -1 ? groupStart : frame;
                        advanceFrameBy(1);
                        break;
                    case '!':
                        if (unsubscriptionFrame !== Infinity) {
                            throw new Error("found a second unsubscription point '!' in a " + 'subscription marble diagram. There can only be one.');
                        }
                        unsubscriptionFrame = groupStart > -1 ? groupStart : frame;
                        break;
                    default:
                        if (runMode && c.match(/^[0-9]$/)) {
                            if (i === 0 || characters[i - 1] === ' ') {
                                var buffer = characters.slice(i).join('');
                                var match = buffer.match(/^([0-9]+(?:\.[0-9]+)?)(ms|s|m) /);
                                if (match) {
                                    i += match[0].length - 1;
                                    var duration = parseFloat(match[1]);
                                    var unit = match[2];
                                    var durationInMs = void 0;
                                    switch (unit) {
                                        case 'ms':
                                            durationInMs = duration;
                                            break;
                                        case 's':
                                            durationInMs = duration * 1000;
                                            break;
                                        case 'm':
                                            durationInMs = duration * 1000 * 60;
                                            break;
                                        default:
                                            break;
                                    }
                                    advanceFrameBy(durationInMs / this_1.frameTimeFactor);
                                    break;
                                }
                            }
                        }
                        throw new Error("there can only be '^' and '!' markers in a " + "subscription marble diagram. Found instead '" + c + "'.");
                }
                frame = nextFrame;
                out_i_1 = i;
            };
            var this_1 = this, out_i_1;
            for (var i = 0; i < len; i++) {
                _loop_1(i);
                i = out_i_1;
            }
            if (unsubscriptionFrame < 0) {
                return new SubscriptionLog(subscriptionFrame);
            }
            else {
                return new SubscriptionLog(subscriptionFrame, unsubscriptionFrame);
            }
        };
        TestScheduler.parseMarbles = function (marbles, values, errorValue, materializeInnerObservables, runMode) {
            var _this = this;
            if (materializeInnerObservables === void 0) { materializeInnerObservables = false; }
            if (runMode === void 0) { runMode = false; }
            if (marbles.indexOf('!') !== -1) {
                throw new Error('conventional marble diagrams cannot have the ' + 'unsubscription marker "!"');
            }
            var characters = __spreadArray([], __read(marbles));
            var len = characters.length;
            var testMessages = [];
            var subIndex = runMode ? marbles.replace(/^[ ]+/, '').indexOf('^') : marbles.indexOf('^');
            var frame = subIndex === -1 ? 0 : subIndex * -this.frameTimeFactor;
            var getValue = typeof values !== 'object'
                ? function (x) { return x; }
                : function (x) {
                    if (materializeInnerObservables && values[x] instanceof ColdObservable) {
                        return values[x].messages;
                    }
                    return values[x];
                };
            var groupStart = -1;
            var _loop_2 = function (i) {
                var nextFrame = frame;
                var advanceFrameBy = function (count) {
                    nextFrame += count * _this.frameTimeFactor;
                };
                var notification = void 0;
                var c = characters[i];
                switch (c) {
                    case ' ':
                        if (!runMode) {
                            advanceFrameBy(1);
                        }
                        break;
                    case '-':
                        advanceFrameBy(1);
                        break;
                    case '(':
                        groupStart = frame;
                        advanceFrameBy(1);
                        break;
                    case ')':
                        groupStart = -1;
                        advanceFrameBy(1);
                        break;
                    case '|':
                        notification = COMPLETE_NOTIFICATION;
                        advanceFrameBy(1);
                        break;
                    case '^':
                        advanceFrameBy(1);
                        break;
                    case '#':
                        notification = errorNotification(errorValue || 'error');
                        advanceFrameBy(1);
                        break;
                    default:
                        if (runMode && c.match(/^[0-9]$/)) {
                            if (i === 0 || characters[i - 1] === ' ') {
                                var buffer = characters.slice(i).join('');
                                var match = buffer.match(/^([0-9]+(?:\.[0-9]+)?)(ms|s|m) /);
                                if (match) {
                                    i += match[0].length - 1;
                                    var duration = parseFloat(match[1]);
                                    var unit = match[2];
                                    var durationInMs = void 0;
                                    switch (unit) {
                                        case 'ms':
                                            durationInMs = duration;
                                            break;
                                        case 's':
                                            durationInMs = duration * 1000;
                                            break;
                                        case 'm':
                                            durationInMs = duration * 1000 * 60;
                                            break;
                                        default:
                                            break;
                                    }
                                    advanceFrameBy(durationInMs / this_2.frameTimeFactor);
                                    break;
                                }
                            }
                        }
                        notification = nextNotification(getValue(c));
                        advanceFrameBy(1);
                        break;
                }
                if (notification) {
                    testMessages.push({ frame: groupStart > -1 ? groupStart : frame, notification: notification });
                }
                frame = nextFrame;
                out_i_2 = i;
            };
            var this_2 = this, out_i_2;
            for (var i = 0; i < len; i++) {
                _loop_2(i);
                i = out_i_2;
            }
            return testMessages;
        };
        TestScheduler.prototype.createAnimator = function () {
            var _this = this;
            if (!this.runMode) {
                throw new Error('animate() must only be used in run mode');
            }
            var lastHandle = 0;
            var map;
            var delegate = {
                requestAnimationFrame: function (callback) {
                    if (!map) {
                        throw new Error('animate() was not called within run()');
                    }
                    var handle = ++lastHandle;
                    map.set(handle, callback);
                    return handle;
                },
                cancelAnimationFrame: function (handle) {
                    if (!map) {
                        throw new Error('animate() was not called within run()');
                    }
                    map.delete(handle);
                },
            };
            var animate = function (marbles) {
                var e_1, _a;
                if (map) {
                    throw new Error('animate() must not be called more than once within run()');
                }
                if (/[|#]/.test(marbles)) {
                    throw new Error('animate() must not complete or error');
                }
                map = new Map();
                var messages = TestScheduler.parseMarbles(marbles, undefined, undefined, undefined, true);
                try {
                    for (var messages_1 = __values(messages), messages_1_1 = messages_1.next(); !messages_1_1.done; messages_1_1 = messages_1.next()) {
                        var message = messages_1_1.value;
                        _this.schedule(function () {
                            var e_2, _a;
                            var now = _this.now();
                            var callbacks = Array.from(map.values());
                            map.clear();
                            try {
                                for (var callbacks_1 = (e_2 = void 0, __values(callbacks)), callbacks_1_1 = callbacks_1.next(); !callbacks_1_1.done; callbacks_1_1 = callbacks_1.next()) {
                                    var callback = callbacks_1_1.value;
                                    callback(now);
                                }
                            }
                            catch (e_2_1) { e_2 = { error: e_2_1 }; }
                            finally {
                                try {
                                    if (callbacks_1_1 && !callbacks_1_1.done && (_a = callbacks_1.return)) _a.call(callbacks_1);
                                }
                                finally { if (e_2) throw e_2.error; }
                            }
                        }, message.frame);
                    }
                }
                catch (e_1_1) { e_1 = { error: e_1_1 }; }
                finally {
                    try {
                        if (messages_1_1 && !messages_1_1.done && (_a = messages_1.return)) _a.call(messages_1);
                    }
                    finally { if (e_1) throw e_1.error; }
                }
            };
            return { animate: animate, delegate: delegate };
        };
        TestScheduler.prototype.createDelegates = function () {
            var _this = this;
            var lastHandle = 0;
            var scheduleLookup = new Map();
            var run = function () {
                var now = _this.now();
                var scheduledRecords = Array.from(scheduleLookup.values());
                var scheduledRecordsDue = scheduledRecords.filter(function (_a) {
                    var due = _a.due;
                    return due <= now;
                });
                var dueImmediates = scheduledRecordsDue.filter(function (_a) {
                    var type = _a.type;
                    return type === 'immediate';
                });
                if (dueImmediates.length > 0) {
                    var _a = dueImmediates[0], handle = _a.handle, handler = _a.handler;
                    scheduleLookup.delete(handle);
                    handler();
                    return;
                }
                var dueIntervals = scheduledRecordsDue.filter(function (_a) {
                    var type = _a.type;
                    return type === 'interval';
                });
                if (dueIntervals.length > 0) {
                    var firstDueInterval = dueIntervals[0];
                    var duration = firstDueInterval.duration, handler = firstDueInterval.handler;
                    firstDueInterval.due = now + duration;
                    firstDueInterval.subscription = _this.schedule(run, duration);
                    handler();
                    return;
                }
                var dueTimeouts = scheduledRecordsDue.filter(function (_a) {
                    var type = _a.type;
                    return type === 'timeout';
                });
                if (dueTimeouts.length > 0) {
                    var _b = dueTimeouts[0], handle = _b.handle, handler = _b.handler;
                    scheduleLookup.delete(handle);
                    handler();
                    return;
                }
                throw new Error('Expected a due immediate or interval');
            };
            var immediate = {
                setImmediate: function (handler) {
                    var handle = ++lastHandle;
                    scheduleLookup.set(handle, {
                        due: _this.now(),
                        duration: 0,
                        handle: handle,
                        handler: handler,
                        subscription: _this.schedule(run, 0),
                        type: 'immediate',
                    });
                    return handle;
                },
                clearImmediate: function (handle) {
                    var value = scheduleLookup.get(handle);
                    if (value) {
                        value.subscription.unsubscribe();
                        scheduleLookup.delete(handle);
                    }
                },
            };
            var interval = {
                setInterval: function (handler, duration) {
                    if (duration === void 0) { duration = 0; }
                    var handle = ++lastHandle;
                    scheduleLookup.set(handle, {
                        due: _this.now() + duration,
                        duration: duration,
                        handle: handle,
                        handler: handler,
                        subscription: _this.schedule(run, duration),
                        type: 'interval',
                    });
                    return handle;
                },
                clearInterval: function (handle) {
                    var value = scheduleLookup.get(handle);
                    if (value) {
                        value.subscription.unsubscribe();
                        scheduleLookup.delete(handle);
                    }
                },
            };
            var timeout = {
                setTimeout: function (handler, duration) {
                    if (duration === void 0) { duration = 0; }
                    var handle = ++lastHandle;
                    scheduleLookup.set(handle, {
                        due: _this.now() + duration,
                        duration: duration,
                        handle: handle,
                        handler: handler,
                        subscription: _this.schedule(run, duration),
                        type: 'timeout',
                    });
                    return handle;
                },
                clearTimeout: function (handle) {
                    var value = scheduleLookup.get(handle);
                    if (value) {
                        value.subscription.unsubscribe();
                        scheduleLookup.delete(handle);
                    }
                },
            };
            return { immediate: immediate, interval: interval, timeout: timeout };
        };
        TestScheduler.prototype.run = function (callback) {
            var prevFrameTimeFactor = TestScheduler.frameTimeFactor;
            var prevMaxFrames = this.maxFrames;
            TestScheduler.frameTimeFactor = 1;
            this.maxFrames = Infinity;
            this.runMode = true;
            var animator = this.createAnimator();
            var delegates = this.createDelegates();
            animationFrameProvider.delegate = animator.delegate;
            dateTimestampProvider.delegate = this;
            immediateProvider.delegate = delegates.immediate;
            intervalProvider.delegate = delegates.interval;
            timeoutProvider.delegate = delegates.timeout;
            performanceTimestampProvider.delegate = this;
            var helpers = {
                cold: this.createColdObservable.bind(this),
                hot: this.createHotObservable.bind(this),
                flush: this.flush.bind(this),
                time: this.createTime.bind(this),
                expectObservable: this.expectObservable.bind(this),
                expectSubscriptions: this.expectSubscriptions.bind(this),
                animate: animator.animate,
            };
            try {
                var ret = callback(helpers);
                this.flush();
                return ret;
            }
            finally {
                TestScheduler.frameTimeFactor = prevFrameTimeFactor;
                this.maxFrames = prevMaxFrames;
                this.runMode = false;
                animationFrameProvider.delegate = undefined;
                dateTimestampProvider.delegate = undefined;
                immediateProvider.delegate = undefined;
                intervalProvider.delegate = undefined;
                timeoutProvider.delegate = undefined;
                performanceTimestampProvider.delegate = undefined;
            }
        };
        TestScheduler.frameTimeFactor = 10;
        return TestScheduler;
    }(VirtualTimeScheduler));



    var _testing = /*#__PURE__*/Object.freeze({
        TestScheduler: TestScheduler
    });

    /**
     * Extracts the response from an XMLHttpRequest object based on its responseType.
     *
     * @param {XMLHttpRequest} xhr - The XMLHttpRequest object containing the response.
     * @returns {any} - The response data parsed according to the responseType.
     *
     * @example
     * var xhr = new XMLHttpRequest();
     * xhr.open('GET', 'https://api.example.com/data', true);
     * xhr.responseType = 'json';
     * xhr.onload = function() {
     *     if (xhr.status === 200) {
     *         console.log(getXHRResponse(xhr));
     *     }
     * };
     * xhr.send();
     *
     * @throws {Error} - Throws an error if the response type is not supported.
     */
    function getXHRResponse(xhr) {
        switch (xhr.responseType) {
            case 'json': {
                if ('response' in xhr) {
                    return xhr.response;
                }
                else {
                    var ieXHR = xhr;
                    return JSON.parse(ieXHR.responseText);
                }
            }
            case 'document':
                return xhr.responseXML;
            case 'text':
            default: {
                if ('response' in xhr) {
                    return xhr.response;
                }
                else {
                    var ieXHR = xhr;
                    return ieXHR.responseText;
                }
            }
        }
    }

    var AjaxResponse = (function () {
        /**
         * Represents an AJAX response object containing detailed information about the request and its result.
         *
         * @class AjaxResponse
         * @param {Event} originalEvent - The original event triggered by the AJAX request.
         * @param {XMLHttpRequest} xhr - The XMLHttpRequest object used for making the request.
         * @param {Object} request - The configuration object for the AJAX request.
         * @param {string} [type='download_load'] - The type of the response. Default is 'download_load'.
         */
        function AjaxResponse(originalEvent, xhr, request, type) {
            if (type === void 0) { type = 'download_load'; }
            this.originalEvent = originalEvent;
            this.xhr = xhr;
            this.request = request;
            this.type = type;
            var status = xhr.status, responseType = xhr.responseType;
            this.status = status !== null && status !== void 0 ? status : 0;
            this.responseType = responseType !== null && responseType !== void 0 ? responseType : '';
            var allHeaders = xhr.getAllResponseHeaders();
            this.responseHeaders = allHeaders
                ?
                    allHeaders.split('\n').reduce(function (headers, line) {
                        var index = line.indexOf(': ');
                        headers[line.slice(0, index)] = line.slice(index + 2);
                        return headers;
                    }, {})
                : {};
            this.response = getXHRResponse(xhr);
            var loaded = originalEvent.loaded, total = originalEvent.total;
            this.loaded = loaded;
            this.total = total;
        }
        return AjaxResponse;
    }());

    var AjaxError = createErrorClass(function (_super) {
        return function AjaxErrorImpl(message, xhr, request) {
            this.message = message;
            this.name = 'AjaxError';
            this.xhr = xhr;
            this.request = request;
            this.status = xhr.status;
            this.responseType = xhr.responseType;
            var response;
            try {
                response = getXHRResponse(xhr);
            }
            catch (err) {
                response = xhr.responseText;
            }
            this.response = response;
        };
    });
    var AjaxTimeoutError = (function () {
        /**
         * Represents an error that occurs when an AJAX request times out.
         *
         * @constructor
         * @extends {AjaxError}
         * @param {string} message - The error message.
         * @param {XMLHttpRequest} xhr - The XMLHttpRequest object associated with the error.
         * @param {Object} request - The request configuration that caused the error.
         */
        function AjaxTimeoutErrorImpl(xhr, request) {
            AjaxError.call(this, 'ajax timeout', xhr, request);
            this.name = 'AjaxTimeoutError';
            return this;
        }
        AjaxTimeoutErrorImpl.prototype = Object.create(AjaxError.prototype);
        return AjaxTimeoutErrorImpl;
    })();

    /**
     * Performs an HTTP GET request using the provided URL and headers.
     *
     * @param {string} url - The URL to which the GET request is sent.
     * @param {Object} [headers] - An object containing custom HTTP headers.
     * @returns {Promise<Object>} A promise that resolves with the response data from the server.
     * @throws {Error} If an error occurs during the AJAX request, such as a network error or invalid URL.
     *
     * @example
     * ajaxGet('https://api.example.com/data', { 'Authorization': 'Bearer token' })
     *   .then(response => {
     *     console.log(response);
     *   })
     *   .catch(error => {
     *     console.error('Error fetching data:', error);
     *   });
     */
    function ajaxGet(url, headers) {
        return ajax({ method: 'GET', url: url, headers: headers });
    }
    /**
     * Sends an HTTP POST request using the provided URL, body, and headers.
     *
     * @param {string} url - The URL to send the POST request to.
     * @param {Object|string} body - The data to be sent with the request. Can be an object or a string.
     * @param {Object} [headers] - Optional headers to include in the request.
     * @returns {Promise<Object>} A promise that resolves with the response data, or rejects with an error.
     *
     * @example
     * ajaxPost('https://example.com/api/data', { key: 'value' }, { 'Content-Type': 'application/json' })
     *   .then(response => {
     *       console.log(response);
     *   })
     *   .catch(error => {
     *       console.error(error);
     *   });
     *
     * @throws {Error} If the request fails for any reason.
     */
    function ajaxPost(url, body, headers) {
        return ajax({ method: 'POST', url: url, body: body, headers: headers });
    }
    /**
     * Performs an HTTP DELETE request to the specified URL with custom headers.
     *
     * @param {string} url - The URL to which the DELETE request will be sent.
     * @param {Object} headers - An object containing custom headers for the request.
     * @returns {Promise<Object>} A Promise that resolves to the response data from the server.
     * @throws {Error} If an error occurs during the AJAX request.
     *
     * @example
     * ajaxDelete('https://api.example.com/data', { 'Authorization': 'Bearer token' })
     *   .then(response => {
     *     console.log(response);
     *   })
     *   .catch(error => {
     *     console.error(error);
     *   });
     */
    function ajaxDelete(url, headers) {
        return ajax({ method: 'DELETE', url: url, headers: headers });
    }
    /**
     * Sends an HTTP PUT request to the specified URL with the provided body and headers.
     *
     * @param {string} url - The URL to send the request to.
     * @param {*} body - The data to be sent as the body of the request.
     * @param {Object} [headers={}] - Optional headers to include in the request.
     * @returns {Promise<Object>} A promise that resolves with the response from the server.
     * @throws {Error} If the request fails due to network issues or invalid arguments.
     *
     * @example
     * ajaxPut('https://api.example.com/data', { key: 'value' }, { Authorization: 'Bearer token' })
     *   .then(response => console.log(response))
     *   .catch(error => console.error(error));
     */
    function ajaxPut(url, body, headers) {
        return ajax({ method: 'PUT', url: url, body: body, headers: headers });
    }
    /**
     * Sends an HTTP PATCH request to the specified URL with the given body and headers.
     *
     * @param {string} url - The URL to send the request to.
     * @param {any} body - The body of the request, typically a JSON object or form data.
     * @param {Object<string, string>} headers - An object containing HTTP headers to include in the request.
     * @returns {Promise<any>} A promise that resolves with the response from the server.
     *
     * @example
     * ajaxPatch('/api/resource', { key: 'value' }, { 'Content-Type': 'application/json' })
     *   .then(response => {
     *       console.log('Success:', response);
     *   })
     *   .catch(error => {
     *       console.error('Error:', error);
     *   });
     *
     * @throws {Error} If there is an issue with the request.
     */
    function ajaxPatch(url, body, headers) {
        return ajax({ method: 'PATCH', url: url, body: body, headers: headers });
    }
    var mapResponse = map(function (x) { return x.response; });
    /**
     * Sends an HTTP GET request to the specified URL with optional headers and processes the JSON response.
     *
     * @param {string} url - The URL to which the GET request will be sent.
     * @param {Object} [headers] - Optional headers to include in the request.
     * @returns {Promise<Object>} A promise that resolves with the parsed JSON response.
     * @throws {Error} If the AJAX request fails or if the response is not valid JSON.
     *
     * Example usage:
     * ajaxGetJSON('https://api.example.com/data', {'Authorization': 'Bearer token'})
     *   .then(data => console.log(data))
     *   .catch(error => console.error(error));
     */
    function ajaxGetJSON(url, headers) {
        return mapResponse(ajax({
            method: 'GET',
            url: url,
            headers: headers,
        }));
    }
    var ajax = (function () {
        var create = function (urlOrConfig) {
            var config = typeof urlOrConfig === 'string'
                ? {
                    url: urlOrConfig,
                }
                : urlOrConfig;
            return fromAjax(config);
        };
        create.get = ajaxGet;
        create.post = ajaxPost;
        create.delete = ajaxDelete;
        create.put = ajaxPut;
        create.patch = ajaxPatch;
        create.getJSON = ajaxGetJSON;
        return create;
    })();
    var UPLOAD = 'upload';
    var DOWNLOAD = 'download';
    var LOADSTART = 'loadstart';
    var PROGRESS = 'progress';
    var LOAD = 'load';
    /**
     * Creates an Observable that performs an Ajax request to the specified URL.
     *
     * @param {Object} init - The initialization options for the Ajax request.
     * @returns {Observable} - An Observable that emits the response data on success or errors on failure.
     *
     * @example
     * const observable = fromAjax({
     *   url: 'https://api.example.com/data',
     *   method: 'GET'
     * });
     * observable.subscribe(
     *   data => console.log(data),
     *   error => console.error(error)
     * );
     *
     * @throws {TypeError} If the `url` parameter is not provided.
     * @throws {AjaxTimeoutError} If the request times out.
     * @throws {AjaxError} If any other Ajax error occurs.
     */
    function fromAjax(init) {
        return new Observable(function (destination) {
            var _a, _b;
            var config = __assign({ async: true, crossDomain: false, withCredentials: false, method: 'GET', timeout: 0, responseType: 'json' }, init);
            var queryParams = config.queryParams, configuredBody = config.body, configuredHeaders = config.headers;
            var url = config.url;
            if (!url) {
                throw new TypeError('url is required');
            }
            if (queryParams) {
                var searchParams_1;
                if (url.includes('?')) {
                    var parts = url.split('?');
                    if (2 < parts.length) {
                        throw new TypeError('invalid url');
                    }
                    searchParams_1 = new URLSearchParams(parts[1]);
                    new URLSearchParams(queryParams).forEach(function (value, key) { return searchParams_1.set(key, value); });
                    url = parts[0] + '?' + searchParams_1;
                }
                else {
                    searchParams_1 = new URLSearchParams(queryParams);
                    url = url + '?' + searchParams_1;
                }
            }
            var headers = {};
            if (configuredHeaders) {
                for (var key in configuredHeaders) {
                    if (configuredHeaders.hasOwnProperty(key)) {
                        headers[key.toLowerCase()] = configuredHeaders[key];
                    }
                }
            }
            var crossDomain = config.crossDomain;
            if (!crossDomain && !('x-requested-with' in headers)) {
                headers['x-requested-with'] = 'XMLHttpRequest';
            }
            var withCredentials = config.withCredentials, xsrfCookieName = config.xsrfCookieName, xsrfHeaderName = config.xsrfHeaderName;
            if ((withCredentials || !crossDomain) && xsrfCookieName && xsrfHeaderName) {
                var xsrfCookie = (_b = (_a = document === null || document === void 0 ? void 0 : document.cookie.match(new RegExp("(^|;\\s*)(" + xsrfCookieName + ")=([^;]*)"))) === null || _a === void 0 ? void 0 : _a.pop()) !== null && _b !== void 0 ? _b : '';
                if (xsrfCookie) {
                    headers[xsrfHeaderName] = xsrfCookie;
                }
            }
            var body = extractContentTypeAndMaybeSerializeBody(configuredBody, headers);
            var _request = __assign(__assign({}, config), { url: url,
                headers: headers,
                body: body });
            var xhr;
            xhr = init.createXHR ? init.createXHR() : new XMLHttpRequest();
            {
                var progressSubscriber_1 = init.progressSubscriber, _c = init.includeDownloadProgress, includeDownloadProgress = _c === void 0 ? false : _c, _d = init.includeUploadProgress, includeUploadProgress = _d === void 0 ? false : _d;
                var addErrorEvent = function (type, errorFactory) {
                    xhr.addEventListener(type, function () {
                        var _a;
                        var error = errorFactory();
                        (_a = progressSubscriber_1 === null || progressSubscriber_1 === void 0 ? void 0 : progressSubscriber_1.error) === null || _a === void 0 ? void 0 : _a.call(progressSubscriber_1, error);
                        destination.error(error);
                    });
                };
                addErrorEvent('timeout', function () { return new AjaxTimeoutError(xhr, _request); });
                addErrorEvent('abort', function () { return new AjaxError('aborted', xhr, _request); });
                var createResponse_1 = function (direction, event) {
                    return new AjaxResponse(event, xhr, _request, direction + "_" + event.type);
                };
                var addProgressEvent_1 = function (target, type, direction) {
                    target.addEventListener(type, function (event) {
                        destination.next(createResponse_1(direction, event));
                    });
                };
                if (includeUploadProgress) {
                    [LOADSTART, PROGRESS, LOAD].forEach(function (type) { return addProgressEvent_1(xhr.upload, type, UPLOAD); });
                }
                if (progressSubscriber_1) {
                    [LOADSTART, PROGRESS].forEach(function (type) { return xhr.upload.addEventListener(type, function (e) { var _a; return (_a = progressSubscriber_1 === null || progressSubscriber_1 === void 0 ? void 0 : progressSubscriber_1.next) === null || _a === void 0 ? void 0 : _a.call(progressSubscriber_1, e); }); });
                }
                if (includeDownloadProgress) {
                    [LOADSTART, PROGRESS].forEach(function (type) { return addProgressEvent_1(xhr, type, DOWNLOAD); });
                }
                var emitError_1 = function (status) {
                    var msg = 'ajax error' + (status ? ' ' + status : '');
                    destination.error(new AjaxError(msg, xhr, _request));
                };
                xhr.addEventListener('error', function (e) {
                    var _a;
                    (_a = progressSubscriber_1 === null || progressSubscriber_1 === void 0 ? void 0 : progressSubscriber_1.error) === null || _a === void 0 ? void 0 : _a.call(progressSubscriber_1, e);
                    emitError_1();
                });
                xhr.addEventListener(LOAD, function (event) {
                    var _a, _b;
                    var status = xhr.status;
                    if (status < 400) {
                        (_a = progressSubscriber_1 === null || progressSubscriber_1 === void 0 ? void 0 : progressSubscriber_1.complete) === null || _a === void 0 ? void 0 : _a.call(progressSubscriber_1);
                        var response = void 0;
                        try {
                            response = createResponse_1(DOWNLOAD, event);
                        }
                        catch (err) {
                            destination.error(err);
                            return;
                        }
                        destination.next(response);
                        destination.complete();
                    }
                    else {
                        (_b = progressSubscriber_1 === null || progressSubscriber_1 === void 0 ? void 0 : progressSubscriber_1.error) === null || _b === void 0 ? void 0 : _b.call(progressSubscriber_1, event);
                        emitError_1(status);
                    }
                });
            }
            var user = _request.user, method = _request.method, async = _request.async;
            if (user) {
                xhr.open(method, url, async, user, _request.password);
            }
            else {
                xhr.open(method, url, async);
            }
            if (async) {
                xhr.timeout = _request.timeout;
                xhr.responseType = _request.responseType;
            }
            if ('withCredentials' in xhr) {
                xhr.withCredentials = _request.withCredentials;
            }
            for (var key in headers) {
                if (headers.hasOwnProperty(key)) {
                    xhr.setRequestHeader(key, headers[key]);
                }
            }
            if (body) {
                xhr.send(body);
            }
            else {
                xhr.send();
            }
            return function () {
                if (xhr && xhr.readyState !== 4) {
                    xhr.abort();
                }
            };
        });
    }
    /**
     * Extracts the content type from headers and optionally serializes the body based on its type.
     *
     * @param {any} body - The request body to be checked and potentially serialized.
     * @param {Object} headers - The headers object that may include or need a content-type.
     * @returns {any} - The original body if it's already of a serializable type, otherwise the serialized version.
     * @throws {TypeError} - If the body type is unknown and cannot be handled.
     *
     * @example
     * // Example usage of extractContentTypeAndMaybeSerializeBody function
     * const headers = {};
     * const serializedBody = extractContentTypeAndMaybeSerializeBody({ key: 'value' }, headers);
     * console.log(serializedBody); // Output: '{"key":"value"}'
     */
    function extractContentTypeAndMaybeSerializeBody(body, headers) {
        var _a;
        if (!body ||
            typeof body === 'string' ||
            isFormData(body) ||
            isURLSearchParams(body) ||
            isArrayBuffer(body) ||
            isFile(body) ||
            isBlob(body) ||
            isReadableStream(body)) {
            return body;
        }
        if (isArrayBufferView(body)) {
            return body.buffer;
        }
        if (typeof body === 'object') {
            headers['content-type'] = (_a = headers['content-type']) !== null && _a !== void 0 ? _a : 'application/json;charset=utf-8';
            return JSON.stringify(body);
        }
        throw new TypeError('Unknown body type');
    }
    var _toString = Object.prototype.toString;
    /**
     * Checks if an object is of a specific type by comparing its `toString` method result.
     *
     * @param {Object} obj - The object to check.
     * @param {string} name - The expected type name (e.g., 'Array', 'String').
     * @returns {boolean} - Returns true if the object is of the specified type, false otherwise.
     * @throws {TypeError} - If `name` is not a string or if it's an empty string.
     *
     * @example
     * // Check if an array is of type 'Array'
     * console.log(toStringCheck([1, 2, 3], 'Array')); // true
     *
     * // Check if a number is of type 'Number'
     * console.log(toStringCheck(42, 'Number')); // false
     */
    function toStringCheck(obj, name) {
        return _toString.call(obj) === "[object " + name + "]";
    }
    /**
     * Checks if the provided body is an ArrayBuffer.
     *
     * @param {any} body - The object to check.
     * @returns {boolean} - Returns true if body is an ArrayBuffer, false otherwise.
     */
    function isArrayBuffer(body) {
        return toStringCheck(body, 'ArrayBuffer');
    }
    /**
     * Checks if the provided body is an instance of File.
     *
     * @param {any} body - The body to check.
     * @returns {boolean} - Returns true if the body is an instance of File, false otherwise.
     */
    function isFile(body) {
        return toStringCheck(body, 'File');
    }
    /**
     * Checks if the provided body is an instance of Blob.
     *
     * @param {any} body - The item to check.
     * @returns {boolean} - Returns true if the body is a Blob, false otherwise.
     */
    function isBlob(body) {
        return toStringCheck(body, 'Blob');
    }
    /**
     * Checks if the provided body is an ArrayBuffer view.
     *
     * @param {any} body - The item to check.
     * @returns {boolean} - Returns true if the body is an ArrayBuffer view, otherwise false.
     *
     * @example
     * isArrayBufferView(new Uint8Array([1, 2, 3])); // returns true
     * isArrayBufferView('string'); // returns false
     */
    function isArrayBufferView(body) {
        return typeof ArrayBuffer !== 'undefined' && ArrayBuffer.isView(body);
    }
    /**
     * Determines if the provided body is an instance of FormData.
     *
     * @param {any} body - The body to check.
     * @returns {boolean} - Returns true if the body is an instance of FormData, false otherwise.
     *
     * Example:
     *   const form = new FormData();
     *   console.log(isFormData(form)); // Output: true
     */
    function isFormData(body) {
        return typeof FormData !== 'undefined' && body instanceof FormData;
    }
    /**
     * Checks if the provided body is an instance of URLSearchParams.
     *
     * @param {any} body - The body to check.
     * @returns {boolean} - True if the body is an instance of URLSearchParams, false otherwise.
     */
    function isURLSearchParams(body) {
        return typeof URLSearchParams !== 'undefined' && body instanceof URLSearchParams;
    }
    /**
     * Determines if the given body is an instance of ReadableStream.
     *
     * @param {any} body - The body to check.
     * @returns {boolean} True if the body is a ReadableStream, false otherwise.
     * @throws {TypeError} If `ReadableStream` is not defined in the environment.
     *
     * @example
     * const isStream = isReadableStream(new ReadableStream());
     * console.log(isStream); // true
     */
    function isReadableStream(body) {
        return typeof ReadableStream !== 'undefined' && body instanceof ReadableStream;
    }



    var _ajax = /*#__PURE__*/Object.freeze({
        ajax: ajax,
        AjaxError: AjaxError,
        AjaxTimeoutError: AjaxTimeoutError,
        AjaxResponse: AjaxResponse
    });

    var DEFAULT_WEBSOCKET_CONFIG = {
        url: '',
        deserializer: function (e) { return JSON.parse(e.data); },
        serializer: function (value) { return JSON.stringify(value); },
    };
    var WEBSOCKETSUBJECT_INVALID_ERROR_OBJECT = 'WebSocketSubject.error must be called with an object with an error code, and an optional reason: { code: number, reason: string }';
    var WebSocketSubject = (function (_super) {
        __extends(WebSocketSubject, _super);
        /**
         * Represents an observable sequence wrapping a WebSocket connection that is either manually opened or provided via an Observable source.
         * @class WebSocketSubject
         * @extends Subject
         * @param {String|Observable} urlConfigOrSource - The URL of the WebSocket to connect to, or an Observable providing the URL and configuration options.
         * @param {Object} [destination] - Optional destination observable for sending data through the WebSocket.
         */
        function WebSocketSubject(urlConfigOrSource, destination) {
            var _this = _super.call(this) || this;
            _this._socket = null;
            if (urlConfigOrSource instanceof Observable) {
                _this.destination = destination;
                _this.source = urlConfigOrSource;
            }
            else {
                var config = (_this._config = __assign({}, DEFAULT_WEBSOCKET_CONFIG));
                _this._output = new Subject();
                if (typeof urlConfigOrSource === 'string') {
                    config.url = urlConfigOrSource;
                }
                else {
                    for (var key in urlConfigOrSource) {
                        if (urlConfigOrSource.hasOwnProperty(key)) {
                            config[key] = urlConfigOrSource[key];
                        }
                    }
                }
                if (!config.WebSocketCtor && WebSocket) {
                    config.WebSocketCtor = WebSocket;
                }
                else if (!config.WebSocketCtor) {
                    throw new Error('no WebSocket constructor can be found');
                }
                _this.destination = new ReplaySubject();
            }
            return _this;
        }
        WebSocketSubject.prototype.lift = function (operator) {
            var sock = new WebSocketSubject(this._config, this.destination);
            sock.operator = operator;
            sock.source = this;
            return sock;
        };
        WebSocketSubject.prototype._resetState = function () {
            this._socket = null;
            if (!this.source) {
                this.destination = new ReplaySubject();
            }
            this._output = new Subject();
        };
        WebSocketSubject.prototype.multiplex = function (subMsg, unsubMsg, messageFilter) {
            var self = this;
            return new Observable(function (observer) {
                try {
                    self.next(subMsg());
                }
                catch (err) {
                    observer.error(err);
                }
                var subscription = self.subscribe({
                    next: function (x) {
                        try {
                            if (messageFilter(x)) {
                                observer.next(x);
                            }
                        }
                        catch (err) {
                            observer.error(err);
                        }
                    },
                    error: function (err) { return observer.error(err); },
                    complete: function () { return observer.complete(); },
                });
                return function () {
                    try {
                        self.next(unsubMsg());
                    }
                    catch (err) {
                        observer.error(err);
                    }
                    subscription.unsubscribe();
                };
            });
        };
        WebSocketSubject.prototype._connectSocket = function () {
            var _this = this;
            var _a = this._config, WebSocketCtor = _a.WebSocketCtor, protocol = _a.protocol, url = _a.url, binaryType = _a.binaryType;
            var observer = this._output;
            var socket = null;
            try {
                socket = protocol ? new WebSocketCtor(url, protocol) : new WebSocketCtor(url);
                this._socket = socket;
                if (binaryType) {
                    this._socket.binaryType = binaryType;
                }
            }
            catch (e) {
                observer.error(e);
                return;
            }
            var subscription = new Subscription(function () {
                _this._socket = null;
                if (socket && socket.readyState === 1) {
                    socket.close();
                }
            });
            socket.onopen = function (evt) {
                var _socket = _this._socket;
                if (!_socket) {
                    socket.close();
                    _this._resetState();
                    return;
                }
                var openObserver = _this._config.openObserver;
                if (openObserver) {
                    openObserver.next(evt);
                }
                var queue = _this.destination;
                _this.destination = Subscriber.create(function (x) {
                    if (socket.readyState === 1) {
                        try {
                            var serializer = _this._config.serializer;
                            socket.send(serializer(x));
                        }
                        catch (e) {
                            _this.destination.error(e);
                        }
                    }
                }, function (err) {
                    var closingObserver = _this._config.closingObserver;
                    if (closingObserver) {
                        closingObserver.next(undefined);
                    }
                    if (err && err.code) {
                        socket.close(err.code, err.reason);
                    }
                    else {
                        observer.error(new TypeError(WEBSOCKETSUBJECT_INVALID_ERROR_OBJECT));
                    }
                    _this._resetState();
                }, function () {
                    var closingObserver = _this._config.closingObserver;
                    if (closingObserver) {
                        closingObserver.next(undefined);
                    }
                    socket.close();
                    _this._resetState();
                });
                if (queue && queue instanceof ReplaySubject) {
                    subscription.add(queue.subscribe(_this.destination));
                }
            };
            socket.onerror = function (e) {
                _this._resetState();
                observer.error(e);
            };
            socket.onclose = function (e) {
                if (socket === _this._socket) {
                    _this._resetState();
                }
                var closeObserver = _this._config.closeObserver;
                if (closeObserver) {
                    closeObserver.next(e);
                }
                if (e.wasClean) {
                    observer.complete();
                }
                else {
                    observer.error(e);
                }
            };
            socket.onmessage = function (e) {
                try {
                    var deserializer = _this._config.deserializer;
                    observer.next(deserializer(e));
                }
                catch (err) {
                    observer.error(err);
                }
            };
        };
        WebSocketSubject.prototype._subscribe = function (subscriber) {
            var _this = this;
            var source = this.source;
            if (source) {
                return source.subscribe(subscriber);
            }
            if (!this._socket) {
                this._connectSocket();
            }
            this._output.subscribe(subscriber);
            subscriber.add(function () {
                var _socket = _this._socket;
                if (_this._output.observers.length === 0) {
                    if (_socket && (_socket.readyState === 1 || _socket.readyState === 0)) {
                        _socket.close();
                    }
                    _this._resetState();
                }
            });
            return subscriber;
        };
        WebSocketSubject.prototype.unsubscribe = function () {
            var _socket = this._socket;
            if (_socket && (_socket.readyState === 1 || _socket.readyState === 0)) {
                _socket.close();
            }
            this._resetState();
            _super.prototype.unsubscribe.call(this);
        };
        return WebSocketSubject;
    }(AnonymousSubject));

    /**
     * Creates a WebSocketSubject that wraps around a WebSocket for communication.
     *
     * @param {string|WebSocket} urlConfigOrSource - The URL string or WebSocket instance to connect to.
     * @returns {WebSocketSubject} A new WebSocketSubject that can be used to communicate over the WebSocket connection.
     *
     * @throws {Error} If an invalid URL is provided or if the WebSocket fails to connect.
     *
     * Example usage:
     * const subject = webSocket('ws://example.com/socket');
     * subject.subscribe(
     *   message => console.log('Received message:', message),
     *   error => console.error('WebSocket error:', error)
     * );
     */
    function webSocket(urlConfigOrSource) {
        return new WebSocketSubject(urlConfigOrSource);
    }



    var _webSocket = /*#__PURE__*/Object.freeze({
        webSocket: webSocket,
        WebSocketSubject: WebSocketSubject
    });

    /**
     * Creates an Observable that emits the result of calling fetch() with the provided URL and options.
     *
     * @param {string|Request} input - The URL or request object to fetch.
     * @param {Object} [initWithSelector={}] - Optional configuration object for initializing the observable.
     * @param {Function|string} [initWithSelector.selector] - A selector function to process the fetched response.
     * @param {AbortSignal} [initWithSelector.signal] - An optional AbortSignal that can be used to abort the request.
     * @returns {Observable<Response|any>} - An Observable that emits either the raw Response object or the result of applying the selector function.
     *
     * @example
     * fromFetch('https://api.example.com/data', { selector: data => data.json() })
     *   .subscribe(
     *     data => console.log(data),
     *     error => console.error(error)
     *   );
     */
    function fromFetch(input, initWithSelector) {
        if (initWithSelector === void 0) { initWithSelector = {}; }
        var selector = initWithSelector.selector, init = __rest(initWithSelector, ["selector"]);
        return new Observable(function (subscriber) {
            var controller = new AbortController();
            var signal = controller.signal;
            var abortable = true;
            var outerSignal = init.signal;
            if (outerSignal) {
                if (outerSignal.aborted) {
                    controller.abort();
                }
                else {
                    var outerSignalHandler_1 = function () {
                        if (!signal.aborted) {
                            controller.abort();
                        }
                    };
                    outerSignal.addEventListener('abort', outerSignalHandler_1);
                    subscriber.add(function () { return outerSignal.removeEventListener('abort', outerSignalHandler_1); });
                }
            }
            var perSubscriberInit = __assign(__assign({}, init), { signal: signal });
            var handleError = function (err) {
                abortable = false;
                subscriber.error(err);
            };
            fetch(input, perSubscriberInit)
                .then(function (response) {
                if (selector) {
                    innerFrom(selector(response)).subscribe(createOperatorSubscriber(subscriber, undefined, function () {
                        abortable = false;
                        subscriber.complete();
                    }, handleError));
                }
                else {
                    abortable = false;
                    subscriber.next(response);
                    subscriber.complete();
                }
            })
                .catch(handleError);
            return function () {
                if (abortable) {
                    controller.abort();
                }
            };
        });
    }



    var _fetch = /*#__PURE__*/Object.freeze({
        fromFetch: fromFetch
    });

    var operators = _operators;
    var testing = _testing;
    var ajax$1 = _ajax;
    var webSocket$1 = _webSocket;
    var fetch$1 = _fetch;

    exports.operators = operators;
    exports.testing = testing;
    exports.ajax = ajax$1;
    exports.webSocket = webSocket$1;
    exports.fetch = fetch$1;
    exports.Observable = Observable;
    exports.ConnectableObservable = ConnectableObservable;
    exports.observable = observable;
    exports.animationFrames = animationFrames;
    exports.Subject = Subject;
    exports.BehaviorSubject = BehaviorSubject;
    exports.ReplaySubject = ReplaySubject;
    exports.AsyncSubject = AsyncSubject;
    exports.asap = asap;
    exports.asapScheduler = asapScheduler;
    exports.async = async;
    exports.asyncScheduler = asyncScheduler;
    exports.queue = queue;
    exports.queueScheduler = queueScheduler;
    exports.animationFrame = animationFrame;
    exports.animationFrameScheduler = animationFrameScheduler;
    exports.VirtualTimeScheduler = VirtualTimeScheduler;
    exports.VirtualAction = VirtualAction;
    exports.Scheduler = Scheduler;
    exports.Subscription = Subscription;
    exports.Subscriber = Subscriber;
    exports.Notification = Notification;
    exports.pipe = pipe;
    exports.noop = noop;
    exports.identity = identity;
    exports.isObservable = isObservable;
    exports.lastValueFrom = lastValueFrom;
    exports.firstValueFrom = firstValueFrom;
    exports.ArgumentOutOfRangeError = ArgumentOutOfRangeError;
    exports.EmptyError = EmptyError;
    exports.NotFoundError = NotFoundError;
    exports.ObjectUnsubscribedError = ObjectUnsubscribedError;
    exports.SequenceError = SequenceError;
    exports.TimeoutError = TimeoutError;
    exports.UnsubscriptionError = UnsubscriptionError;
    exports.bindCallback = bindCallback;
    exports.bindNodeCallback = bindNodeCallback;
    exports.combineLatest = combineLatest;
    exports.concat = concat;
    exports.connectable = connectable;
    exports.defer = defer;
    exports.empty = empty;
    exports.forkJoin = forkJoin;
    exports.from = from;
    exports.fromEvent = fromEvent;
    exports.fromEventPattern = fromEventPattern;
    exports.generate = generate;
    exports.iif = iif;
    exports.interval = interval;
    exports.merge = merge;
    exports.never = never;
    exports.of = of;
    exports.onErrorResumeNext = onErrorResumeNext;
    exports.pairs = pairs;
    exports.partition = partition;
    exports.race = race;
    exports.range = range;
    exports.throwError = throwError;
    exports.timer = timer;
    exports.using = using;
    exports.zip = zip;
    exports.scheduled = scheduled;
    exports.EMPTY = EMPTY;
    exports.NEVER = NEVER;
    exports.config = config;
    exports.audit = audit;
    exports.auditTime = auditTime;
    exports.buffer = buffer;
    exports.bufferCount = bufferCount;
    exports.bufferTime = bufferTime;
    exports.bufferToggle = bufferToggle;
    exports.bufferWhen = bufferWhen;
    exports.catchError = catchError;
    exports.combineAll = combineAll;
    exports.combineLatestAll = combineLatestAll;
    exports.combineLatestWith = combineLatestWith;
    exports.concatAll = concatAll;
    exports.concatMap = concatMap;
    exports.concatMapTo = concatMapTo;
    exports.concatWith = concatWith;
    exports.connect = connect;
    exports.count = count;
    exports.debounce = debounce;
    exports.debounceTime = debounceTime;
    exports.defaultIfEmpty = defaultIfEmpty;
    exports.delay = delay;
    exports.delayWhen = delayWhen;
    exports.dematerialize = dematerialize;
    exports.distinct = distinct;
    exports.distinctUntilChanged = distinctUntilChanged;
    exports.distinctUntilKeyChanged = distinctUntilKeyChanged;
    exports.elementAt = elementAt;
    exports.endWith = endWith;
    exports.every = every;
    exports.exhaust = exhaust;
    exports.exhaustAll = exhaustAll;
    exports.exhaustMap = exhaustMap;
    exports.expand = expand;
    exports.filter = filter;
    exports.finalize = finalize;
    exports.find = find;
    exports.findIndex = findIndex;
    exports.first = first;
    exports.groupBy = groupBy;
    exports.ignoreElements = ignoreElements;
    exports.isEmpty = isEmpty;
    exports.last = last$1;
    exports.map = map;
    exports.mapTo = mapTo;
    exports.materialize = materialize;
    exports.max = max;
    exports.mergeAll = mergeAll;
    exports.flatMap = flatMap;
    exports.mergeMap = mergeMap;
    exports.mergeMapTo = mergeMapTo;
    exports.mergeScan = mergeScan;
    exports.mergeWith = mergeWith;
    exports.min = min;
    exports.multicast = multicast;
    exports.observeOn = observeOn;
    exports.onErrorResumeNextWith = onErrorResumeNextWith;
    exports.pairwise = pairwise;
    exports.pluck = pluck;
    exports.publish = publish;
    exports.publishBehavior = publishBehavior;
    exports.publishLast = publishLast;
    exports.publishReplay = publishReplay;
    exports.raceWith = raceWith;
    exports.reduce = reduce;
    exports.repeat = repeat;
    exports.repeatWhen = repeatWhen;
    exports.retry = retry;
    exports.retryWhen = retryWhen;
    exports.refCount = refCount;
    exports.sample = sample;
    exports.sampleTime = sampleTime;
    exports.scan = scan;
    exports.sequenceEqual = sequenceEqual;
    exports.share = share;
    exports.shareReplay = shareReplay;
    exports.single = single;
    exports.skip = skip;
    exports.skipLast = skipLast;
    exports.skipUntil = skipUntil;
    exports.skipWhile = skipWhile;
    exports.startWith = startWith;
    exports.subscribeOn = subscribeOn;
    exports.switchAll = switchAll;
    exports.switchMap = switchMap;
    exports.switchMapTo = switchMapTo;
    exports.switchScan = switchScan;
    exports.take = take;
    exports.takeLast = takeLast;
    exports.takeUntil = takeUntil;
    exports.takeWhile = takeWhile;
    exports.tap = tap;
    exports.throttle = throttle;
    exports.throttleTime = throttleTime;
    exports.throwIfEmpty = throwIfEmpty;
    exports.timeInterval = timeInterval;
    exports.timeout = timeout;
    exports.timeoutWith = timeoutWith;
    exports.timestamp = timestamp;
    exports.toArray = toArray;
    exports.window = window;
    exports.windowCount = windowCount;
    exports.windowTime = windowTime;
    exports.windowToggle = windowToggle;
    exports.windowWhen = windowWhen;
    exports.withLatestFrom = withLatestFrom;
    exports.zipAll = zipAll;
    exports.zipWith = zipWith;

    Object.defineProperty(exports, '__esModule', { value: true });

})));

//# sourceMappingURL=rxjs.umd.js.map

