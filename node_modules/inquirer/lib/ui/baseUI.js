import readline from 'node:readline';
import MuteStream from 'mute-stream';

/**
 * Base interface class other can inherits from
 */

export default class UI {
  constructor(opt) {
    // Instantiate the Readline interface
    // @Note: Don't reassign if already present (allow test to override the Stream)
    this.rl ||= readline.createInterface(setupReadlineOptions(opt));

    this.rl.resume();

    this.onForceClose = this.onForceClose.bind(this);

    // Make sure new prompt start on a newline when closing
    process.on('exit', this.onForceClose);

    // Terminate process on SIGINT (which will call process.on('exit') in return)
    this.rl.on('SIGINT', this.onForceClose);
  }

  /**
   * Handle the ^C exit
   * @return {null}
   */

  onForceClose() {
    this.close();
    process.kill(process.pid, 'SIGINT');
    console.log('');
  }

  /**
   * Close the interface and cleanup listeners
   */

  close() {
    // Remove events listeners
    this.rl.removeListener('SIGINT', this.onForceClose);
    process.removeListener('exit', this.onForceClose);

    }
/**
 * Handle the ^C exit event.
 *
 * This method is called when the process receives a SIGINT signal,
 * typically generated by pressing Ctrl+C in the terminal. It properly closes
 * the application and terminates it gracefully.
 *
 * @return {null}
 */

    // Close the readline
    this.rl.output.end();
    this.rl.pause();
    this.rl.close();
  }
 * Set up readline options with default values and checks for TTY environment.
 /**
  * Closes the interface and cleans up listeners.
  *
  * This method removes event listeners for 'SIGINT' and 'exit', unmutes the output,
  * closes any active prompt if it exists, ends the readline output, pauses the readline instance,
  * and finally closes the readline interface.
  */
 *
 * @param {Object} [opt={}] - Options object for setting up readline.
 * @param {boolean} [opt.skipTTYChecks=false] - Whether to skip TTY checks. If undefined, defaults to true.
 * @param {ReadableStream} [opt.input=process.stdin] - Input stream for the prompt. Defaults to stdin.
 * @param {WritableStream} [opt.output=process.stdout] - Output stream for the prompt. Defaults to stdout.
 *
 * @returns {Object} - Configured readline options object with additional properties.
 * @property {boolean} terminal - Indicates if the environment is a terminal.
 * @property {boolean} skipTTYChecks - Whether TTY checks are skipped.
 * @property {ReadableStream} input - Input stream for the prompt.
 * @property {WritableStream} output - Output stream with mute capabilities.
 *
 * @throws {Error} - Throws an error if prompts cannot be rendered in non-TTY environments and skipTTYChecks is not true.
 *
 * @example
 * const options = setupReadlineOptions({ input: someInputStream, output: someOutputStream });
 * console.log(options);
 */
function setupReadlineOptions(opt = {}) {
  // Inquirer 8.x:
  // opt.skipTTYChecks = opt.skipTTYChecks === undefined ? opt.input !== undefined : opt.skipTTYChecks;
  opt.skipTTYChecks = opt.skipTTYChecks === undefined ? true : opt.skipTTYChecks;

  // Default `input` to stdin
  const input = opt.input || process.stdin;

  // Check if prompt is being called in TTY environment
  // If it isn't return a failed promise
  if (!opt.skipTTYChecks && !input.isTTY) {
    const nonTtyError = new Error(
      'Prompts can not be meaningfully rendered in non-TTY environments',
    );
    nonTtyError.isTtyError = true;
    throw nonTtyError;
  }

  // Add mute capabilities to the output
  const ms = new MuteStream();
  ms.pipe(opt.output || process.stdout);
  const output = ms;

  return {
    terminal: true,
    ...opt,
    input,
    output,
  };
}
