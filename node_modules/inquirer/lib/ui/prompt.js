const _ = {
  set: (obj, path = '', value) => {
    let pointer = obj;
    path.split('.').forEach((key, index, arr) => {
      if (key === '__proto__' || key === 'constructor') return;

      if (index === arr.length - 1) {
        pointer[key] = value;
      } else if (!(key in pointer) || typeof pointer[key] !== 'object') {
        pointer[key] = {};
      }

      pointer = pointer[key];
    });
  },
  get: (obj, path = '', defaultValue) => {
    /**
     * Splits a given path using a regular expression and reduces it to an object based on the provided key.
     *
     * @param {RegExp} regexp - The regular expression used to split the path.
     * @return {Object} The reduced object based on the split keys and their corresponding values in the original object.
     */
    const travel = (regexp) =>
      String.prototype.split
        .call(path, regexp)
        .filter(Boolean)
        .reduce(
          // @ts-expect-error implicit any on res[key]
          (res, key) => (res !== null && res !== undefined ? res[key] : res),
          obj,
        );
    const result = travel(/[,[\]]+?/) || travel(/[,.[\]]+?/);
    return result === undefined || result === obj ? defaultValue : result;
  },
};

import {
  defer,
  EMPTY,
  from,
  of,
  concatMap,
  filter,
  publish,
  reduce,
  isObservable,
} from 'rxjs';
import runAsync from 'run-async';
import * as utils from '../utils/utils.js';
import Base from './baseUI.js';

/**
 * Base interface class other can inherits from
 */
export default class PromptUI extends Base {
  constructor(prompts, opt) {
    super(opt);
    this.prompts = prompts;
  }

  /**
   * Executes a series of questions to gather answers, handling different input formats and processing them sequentially.
   *
   * @param {Array|Object} questions - An array of question objects or an object mapping names to question configurations.
   * @param {Object} [answers={}] - An optional object containing initial answers that can be provided.
   * @returns {Promise<Object>} A promise resolving to the final set of answers after processing all questions.
   *
   * @example
   * const runner = new QuestionRunner();
   * runner.run([
   *   {
   *     name: 'question1',
   *     prompt: 'What is your name?',
   *     validate: (input) => input.length > 0,
   *   },
   *   {
   *     name: 'question2',
   *     prompt: 'How old are you?',
   *     validate: (input) => !isNaN(input),
   *   },
   * ]).then(answers => console.log(answers));
   *
   * @throws {Error} If the input questions format is incorrect.
   */
  run(questions, answers) {
    // Keep global reference to the answers
    this.answers = typeof answers === 'object' ? { ...answers } : {};

    let obs;
    if (Array.isArray(questions)) {
      obs = from(questions);
    } else if (isObservable(questions)) {
      obs = questions;
    } else if (
      Object.values(questions).every(
        (maybeQuestion) =>
          typeof maybeQuestion === 'object' &&
          !Array.isArray(maybeQuestion) &&
          maybeQuestion != null,
      )
    ) {
      // Case: Called with a set of { name: question }
      obs = from(
        Object.entries(questions).map(([name, question]) => ({
          name,
          ...question,
        })),
      );
    } else {
      // Case: Called with a single question config
      obs = from([questions]);
    }

    this.process = obs.pipe(
      concatMap(this.processQuestion.bind(this)),
      publish(), // Creates a hot Observable. It prevents duplicating prompts.
    );

    this.process.connect();

    return this.process
      .pipe(
        reduce((answersObj, answer) => {
          _.set(answersObj, answer.name, answer.answer);
          return answersObj;
        }, this.answers),
      )
      .toPromise(Promise)
      .then(this.onCompletion.bind(this), this.onError.bind(this));
  }

  /**
   * Called once all prompts are completed.
   * Closes the current context and returns the collected answers.
   *
   * @return {Array} - An array containing the answers to the prompts.
   */
  onCompletion() {
    this.close();

    return this.answers;
  }

  /**
   * Handles an error by closing the current resource and rejecting a Promise with the given error.
   *
   * @param {Error} error - The error object that occurred.
   * @returns {Promise} A rejected Promise containing the provided error object.
   */
  onError(error) {
    this.close();
    return Promise.reject(error);
  }

  processQuestion(question) {
    question = { ...question };
    return defer(() => {
      const obs = of(question);

      return obs.pipe(
        concatMap(this.setDefaultType.bind(this)),
        concatMap(this.filterIfRunnable.bind(this)),
        concatMap(() =>
          utils.fetchAsyncQuestionProperty(question, 'message', this.answers),
        ),
        concatMap(() =>
          utils.fetchAsyncQuestionProperty(question, 'default', this.answers),
        ),
        concatMap(() =>
          utils.fetchAsyncQuestionProperty(question, 'choices', this.answers),
        ),
        concatMap(this.fetchAnswer.bind(this)),
      );
    });
  }

  /**
   * Fetches an answer to a given question by creating and running an active prompt.
   *
   * @param {Object} question - The question object containing details about the question to be answered.
   * @returns {Promise<{name: string, answer: any}>} A promise that resolves with an object containing the question name and its corresponding answer.
   * @throws {Error} If the provided question type does not exist in the prompts dictionary.
   *
   * @example
   * const question = { type: 'text', name: 'What is your favorite color?' };
   * fetchAnswer(question)
   *   .then(result => console.log(result))
   *   .catch(error => console.error(error));
   */
  fetchAnswer(question) {
    const Prompt = this.prompts[question.type];
    this.activePrompt = new Prompt(question, this.rl, this.answers);
    return defer(() =>
      from(this.activePrompt.run().then((answer) => ({ name: question.name, answer }))),
    );
  }

  /**
   * Sets the default type of a question if it is not already defined.
   *
   * @param {Object} question - The question object whose type may need to be set.
   * @return {Promise<Object>} A promise that resolves with the updated question object.
   * @throws {Error} Throws an error if there is no default type for the specified question.
   */
  setDefaultType(question) {
    // Default type to input
    if (!this.prompts[question.type]) {
      question.type = 'input';
    }

    return defer(() => of(question));
  }

  /**
   * Filters questions to determine if they should be runnable based on certain conditions.
   *
   * @param {Object} question - The question object to check.
   * @return {Observable|null} An Observable containing the question if it should run, or null if it should not.
   * @throws {Error} If `question.when` is a function but throws an error when executed with the provided answers.
   *
   * @example
   * // Example usage:
   * const result = filterIfRunnable({ name: 'sampleQuestion', askAnswered: false, when: () => true });
   * result.subscribe((q) => console.log(q)); // Output: { name: 'sampleQuestion', askAnswered: false, when: () => true }
   */
  filterIfRunnable(question) {
    if (
      question.askAnswered !== true &&
      _.get(this.answers, question.name) !== undefined
    ) {
      return EMPTY;
    }

    if (question.when === false) {
      return EMPTY;
    }

    if (typeof question.when !== 'function') {
      return of(question);
    }

    const { answers } = this;
    return defer(() =>
      from(
        runAsync(question.when)(answers).then((shouldRun) => {
          if (shouldRun) {
            return question;
          }
        }),
      ).pipe(filter((val) => val != null)),
    );
  }
}
