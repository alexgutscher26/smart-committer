const _ = {
  set: (obj, path = '', value) => {
    let pointer = obj;
    path.split('.').forEach((key, index, arr) => {
      if (key === '__proto__' || key === 'constructor') return;

      if (index === arr.length - 1) {
        pointer[key] = value;
      } else if (!(key in pointer) || typeof pointer[key] !== 'object') {
        pointer[key] = {};
      }

      pointer = pointer[key];
    });
  },
  get: (obj, path = '', defaultValue) => {
    /**
     * Splits a string using a regular expression, filters out any empty strings,
     * and reduces the resulting array to access nested properties in an object.
     *
     * @param {RegExp} regexp - The regular expression used to split the input string.
     * @returns {*} The value of the nested property if found, otherwise undefined.
     * @throws {TypeError} If the input parameters are invalid.
     */
    const travel = (regexp) =>
      String.prototype.split
        .call(path, regexp)
        .filter(Boolean)
        .reduce(
          // @ts-expect-error implicit any on res[key]
          (res, key) => (res !== null && res !== undefined ? res[key] : res),
          obj,
        );
    const result = travel(/[,[\]]+?/) || travel(/[,.[\]]+?/);
    return result === undefined || result === obj ? defaultValue : result;
  },
};

import {
  defer,
  EMPTY,
  from,
  of,
  concatMap,
  filter,
  publish,
  reduce,
  isObservable,
} from 'rxjs';
import runAsync from 'run-async';
import * as utils from '../utils/utils.js';
import Base from './baseUI.js';

/**
 * Base interface class other can inherits from
 */
export default class PromptUI extends Base {
  constructor(prompts, opt) {
    super(opt);
    this.prompts = prompts;
  }

  /**
   * Runs a sequence of questions and answers, processing each question sequentially.
   *
   * @param {Array|Object} questions - An array of question objects or an object where keys are names and values are question objects.
   * @param {Object} [answers={}] - An optional object containing initial answers to be updated during the process.
   * @returns {Promise<Object>} A promise that resolves with the final set of answers after processing all questions.
   *
   * @throws {Error} If the input questions are not in a valid format.
   */
  run(questions, answers) {
    // Keep global reference to the answers
    this.answers = typeof answers === 'object' ? { ...answers } : {};

    let obs;
    if (Array.isArray(questions)) {
      obs = from(questions);
    } else if (isObservable(questions)) {
      obs = questions;
    } else if (
      Object.values(questions).every(
        (maybeQuestion) =>
          typeof maybeQuestion === 'object' &&
          !Array.isArray(maybeQuestion) &&
          maybeQuestion != null,
      )
    ) {
      // Case: Called with a set of { name: question }
      obs = from(
        Object.entries(questions).map(([name, question]) => ({
          name,
          ...question,
        })),
      );
    } else {
      // Case: Called with a single question config
      obs = from([questions]);
    }

    this.process = obs.pipe(
      concatMap(this.processQuestion.bind(this)),
      publish(), // Creates a hot Observable. It prevents duplicating prompts.
    );

    this.process.connect();

    return this.process
      .pipe(
        reduce((answersObj, answer) => {
          _.set(answersObj, answer.name, answer.answer);
          return answersObj;
        }, this.answers),
      )
      .toPromise(Promise)
      .then(this.onCompletion.bind(this), this.onError.bind(this));
  }

  /**
   * Once all prompts are over.
   *
   * This method is called when all prompt-related operations have been completed. It closes the current context or resource and returns the accumulated answers.
   *
   * @returns {Object} - The collected answers from the prompts.
   *
   * @example
   * const result = onCompletion();
   * console.log(result);
   */
  onCompletion() {
    this.close();

    return this.answers;
  }

  /**
   * Handles an error by closing the connection and rejecting the Promise with the error.
   *
   * @param {Error} error - The error that occurred.
   * @returns {Promise<never>} A rejected Promise containing the error.
   */
  onError(error) {
    this.close();
    return Promise.reject(error);
  }

  /**
   * Processes a question by transforming it and applying various operations to fetch answer details.
   *
   * @param {Object} question - The question object to be processed.
   * @returns {Promise<Object>} - A promise that resolves with the processed question.
   * @throws {Error} - Throws an error if any of the asynchronous operations fail.
   */
  processQuestion(question) {
    question = { ...question };
    return defer(() => {
      const obs = of(question);

      return obs.pipe(
        concatMap(this.setDefaultType.bind(this)),
        concatMap(this.filterIfRunnable.bind(this)),
        concatMap(() =>
          utils.fetchAsyncQuestionProperty(question, 'message', this.answers),
        ),
        concatMap(() =>
          utils.fetchAsyncQuestionProperty(question, 'default', this.answers),
        ),
        concatMap(() =>
          utils.fetchAsyncQuestionProperty(question, 'choices', this.answers),
        ),
        concatMap(this.fetchAnswer.bind(this)),
      );
    });
  }

  /**
   * Fetches an answer to a given question using the appropriate prompt type.
   *
   * @param {Object} question - The question object containing details about the question to be answered.
   * @returns {Promise<Object>} A promise that resolves with an object containing the question name and its corresponding answer.
   * @throws {Error} Throws an error if the prompt type is not recognized.
   *
   * @example
   * const question = {
   *   type: 'input',
   *   name: 'userInput'
   * };
   * fetchAnswer(question)
   *   .then(result => console.log(result))
   *   .catch(error => console.error(error));
   */
  fetchAnswer(question) {
    const Prompt = this.prompts[question.type];
    this.activePrompt = new Prompt(question, this.rl, this.answers);
    return defer(() =>
      from(this.activePrompt.run().then((answer) => ({ name: question.name, answer }))),
    );
  }

  /**
   * Sets the default type to 'input' if the specified question does not have an existing type in this.prompts.
   *
   * @param {Object} question - The question object whose type is being checked and potentially updated.
   * @returns {Promise<Object>} A promise that resolves with the updated question object.
   * @throws Will throw an error if `question` is undefined or null.
   *
   * Example usage:
   * const updatedQuestion = await setDefaultType({ type: 'number' });
   * console.log(updatedQuestion); // Output will be { type: 'input' }
   */
  setDefaultType(question) {
    // Default type to input
    if (!this.prompts[question.type]) {
      question.type = 'input';
    }

    return defer(() => of(question));
  }

  /**
   * Filters questions based on whether they can run or not.
   *
   * @param {Object} question - The question object to filter.
   * @returns {Observable} An observable that emits the filtered question if it can run, otherwise completes.
   *
   * Example usage:
   * const result = instance.filterIfRunnable(question);
   * result.subscribe(filteredQuestion => {
   *   if (filteredQuestion) {
   *     console.log('Question can run:', filteredQuestion);
   *   } else {
   *     console.log('Question cannot run.');
   *   }
   * });
   */
  filterIfRunnable(question) {
    if (
      question.askAnswered !== true &&
      _.get(this.answers, question.name) !== undefined
    ) {
      return EMPTY;
    }

    if (question.when === false) {
      return EMPTY;
    }

    if (typeof question.when !== 'function') {
      return of(question);
    }

    const { answers } = this;
    return defer(() =>
      from(
        runAsync(question.when)(answers).then((shouldRun) => {
          if (shouldRun) {
            return question;
          }
        }),
      ).pipe(filter((val) => val != null)),
    );
  }
}
