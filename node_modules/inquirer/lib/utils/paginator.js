import colors from 'yoctocolors-cjs';

/**
 * The paginator returns a subset of the choices if the list is too long.
 */

export default class Paginator {
  /**
   * @param {import("./screen-manager")} [screen]
   * @param {{isInfinite?: boolean}} [options]
   */
  constructor(screen, options = {}) {
    const { isInfinite = true } = options;
    this.lastIndex = 0;
    this.screen = screen;
    this.isInfinite = isInfinite;
  }

  /**
   * Paginates the given output based on the active line and page size.
   *
   * @param {string} output - The text to be paginated.
   * @param {number} active - The index of the currently active line.
   * @param {number} [pageSize=7] - The number of lines to display per page.
   * @returns {string} - The paginated text with a message encouraging navigation if applicable.
   *
   * @example
   * const output = "Line 1\nLine 2\nLine 3\nLine 4\nLine 5\nLine 6\nLine 7";
   * const activeLine = 0;
   * const paginatedText = paginate(output, activeLine);
   * console.log(paginatedText); // Output: "Line 1\nLine 2\nLine 3\nLine 4\nLine 5\nLine 6\nLine 7 (Move up and down to reveal more choices)"
   */
  paginate(output, active, pageSize) {
    pageSize ||= 7;
    let lines = output.split('\n');

    if (this.screen) {
      lines = this.screen.breakLines(lines);
      active = lines
        .map((lineParts) => lineParts.length)
        .splice(0, active)
        .reduce((a, b) => a + b, 0);
      lines = lines.flat();
    }

    // Make sure there's enough lines to paginate
    if (lines.length <= pageSize) {
      return output;
    }
    const visibleLines = this.isInfinite
      ? this.getInfiniteLines(lines, active, pageSize)
      : this.getFiniteLines(lines, active, pageSize);
    this.lastIndex = active;
    return (
      visibleLines.join('\n') +
      '\n' +
      colors.dim('(Move up and down to reveal more choices)')
    );
  }

  /**
   * Generates an infinite list of lines based on the provided parameters.
   *
   * @param {Array} lines - The array of lines to be duplicated to create an infinite effect.
   * @param {number} active - The index indicating the current active line.
   * @param {number} pageSize - The number of lines to return in the result.
   * @returns {Array} An array containing a portion of the infinite list based on the current state and parameters.
   *
   * Example:
   * const lines = ["Line 1", "Line 2", "Line 3"];
   * const activeIndex = 5;
   * const pageSize = 3;
   * getInfiniteLines(lines, activeIndex, pageSize); // Returns ["Line 4", "Line 5", "Line 6"]
   */
  getInfiniteLines(lines, active, pageSize) {
    if (this.pointer === undefined) {
      this.pointer = 0;
    }
    const middleOfList = Math.floor(pageSize / 2);
    // Move the pointer only when the user go down and limit it to the middle of the list
    if (
      this.pointer < middleOfList &&
      this.lastIndex < active &&
      active - this.lastIndex < pageSize
    ) {
      this.pointer = Math.min(middleOfList, this.pointer + active - this.lastIndex);
    }

    // Duplicate the lines so it give an infinite list look
    const infinite = [lines, lines, lines].flat();
    const topIndex = Math.max(0, active + lines.length - this.pointer);

    return infinite.splice(topIndex, pageSize);
  }

  /**
   * Retrieves a finite number of lines from an array based on the active index and page size,
   * ensuring that the result does not exceed the bounds of the array.
   *
   * @param {Array} lines - The array of lines to retrieve lines from.
   * @param {number} active - The currently active index, which determines the starting point for retrieval.
   * @param {number} pageSize - The number of lines to retrieve.
   * @returns {Array} An array containing up to `pageSize` lines starting from the calculated `topIndex`.
   *
   * @example
   * const lines = ['line1', 'line2', 'line3', 'line4', 'line5'];
   * const active = 2;
   * const pageSize = 3;
   * console.log(getFiniteLines(lines, active, pageSize)); // Output: ['line2', 'line3', 'line4']
   *
   * @note If `active - pageSize / 2` is less than 0, the result will start from index 0.
   * @note If `topIndex + pageSize` exceeds the length of the array, the result will end at the last index of the array.
   */
  getFiniteLines(lines, active, pageSize) {
    let topIndex = active - pageSize / 2;
    if (topIndex < 0) {
      topIndex = 0;
    } else if (topIndex + pageSize > lines.length) {
      topIndex = lines.length - pageSize;
    }
    return lines.splice(topIndex, pageSize);
  }
}
