import ansiEscapes from 'ansi-escapes';
import cliWidth from 'cli-width';
import wrapAnsi from 'wrap-ansi';
import stripAnsi from 'strip-ansi';
import stringWidth from 'string-width';
import ora from 'ora';
import * as util from './readline.js';

/**
 * Calculates the number of lines in a given text content.
 *
 * @param {string} content - The text content to analyze.
 * @return {number} The total number of lines in the content.
 *
 * @example
 * const content = "Line 1\nLine 2\nLine 3";
 * console.log(height(content)); // Output: 3
 */
function height(content) {
  return content.split('\n').length;
}

/**
 * Returns the last line of a given string content.
 *
 * @param {string} content - The input string from which the last line is to be extracted.
 * @returns {string} - The last line of the input string.
 *
 * Example:
 *   const result = lastLine("Hello\nWorld");
 *   console.log(result); // Outputs: "World"
 */
function lastLine(content) {
  return content.split('\n').pop();
}

export default class ScreenManager {
  constructor(rl) {
    // These variables are keeping information to allow correct prompt re-rendering
    this.height = 0;
    this.extraLinesUnderPrompt = 0;

    this.rl = rl;
  }

  /**
   * Renders content with a spinner animation.
   *
   * @param {string} content - The main content to display.
   * @param {string} [bottomContent] - Optional additional text below the spinner.
   * @returns {void}
   */
  renderWithSpinner(content, bottomContent) {
    if (this.spinnerId) {
      clearInterval(this.spinnerId);
    }

    let spinner;
    let contentFunc;
    let bottomContentFunc;

    if (bottomContent) {
      spinner = ora(bottomContent);
      contentFunc = () => content;
      bottomContentFunc = () => spinner.frame();
    } else {
      spinner = ora(content);
      contentFunc = () => spinner.frame();
      bottomContentFunc = () => '';
    }

    this.spinnerId = setInterval(
      () => this.render(contentFunc(), bottomContentFunc(), true),
      spinner.interval,
    );
  }

  /**
   * Renders content to the screen with optional bottom content and spinner control.
   *
   * @param {string} content - The main content to be rendered.
   * @param {string} [bottomContent] - Optional additional content displayed below the prompt.
   * @param {boolean} [spinning=false] - Indicates whether the spinner should continue spinning.
   */
  render(content, bottomContent, spinning = false) {
    if (this.spinnerId && !spinning) {
      clearInterval(this.spinnerId);
    }

    this.rl.output.unmute();
    this.clean(this.extraLinesUnderPrompt);

    /**
     * Write message to screen and setPrompt to control backspace
     */

    const promptLine = lastLine(content);
    const rawPromptLine = stripAnsi(promptLine);

    // Remove the rl.line from our prompt. We can't rely on the content of
    // rl.line (mainly because of the password prompt), so just rely on it's
    // length.
    let prompt = rawPromptLine;
    if (this.rl.line.length > 0) {
      prompt = prompt.slice(0, -this.rl.line.length);
    }

    this.rl.setPrompt(prompt);

    // SetPrompt will change cursor position, now we can get correct value
    const cursorPos = this.rl._getCursorPos();
    const width = this.normalizedCliWidth();

    content = this.forceLineReturn(content, width);
    bottomContent &&= this.forceLineReturn(bottomContent, width);

    // Manually insert an extra line if we're at the end of the line.
    // This prevent the cursor from appearing at the beginning of the
    // current line.
    if (rawPromptLine.length % width === 0) {
      content += '\n';
    }

    const fullContent = content + (bottomContent ? '\n' + bottomContent : '');
    this.rl.output.write(fullContent);

    /**
     * Re-adjust the cursor at the correct position.
     */

    // We need to consider parts of the prompt under the cursor as part of the bottom
    // content in order to correctly cleanup and re-render.
    const promptLineUpDiff = Math.floor(rawPromptLine.length / width) - cursorPos.rows;
    const bottomContentHeight =
      promptLineUpDiff + (bottomContent ? height(bottomContent) : 0);
    if (bottomContentHeight > 0) {
      util.up(this.rl, bottomContentHeight);
    }

    // Reset cursor at the beginning of the line
    util.left(this.rl, stringWidth(lastLine(fullContent)));

    // Adjust cursor on the right
    if (cursorPos.cols > 0) {
      util.right(this.rl, cursorPos.cols);
    }

    /**
     * Set up state for next re-rendering
     */
    this.extraLinesUnderPrompt = bottomContentHeight;
    this.height = height(fullContent);

    this.rl.output.mute();
  }

  /**
   * Cleans up the display by moving the cursor down and clearing the line.
   *
   * @param {number} extraLines - The number of lines to move the cursor down before clearing.
   */
  clean(extraLines) {
    if (extraLines > 0) {
      util.down(this.rl, extraLines);
    }

    util.clearLine(this.rl, this.height);
  }

  /**
   * Completes the interaction by resetting the prompt and unmuting the output,
   * then displaying the cursor.
   *
   * @function done
   * @instance
   * @memberof SupportedLanguage.JAVASCRIPT code
   * @returns {void}
   */
  done() {
    this.rl.setPrompt('');
    this.rl.output.unmute();
    this.rl.output.write(`\n${ansiEscapes.cursorShow}`);
  }

  /**
   * Releases the cursor after scrolling down by the number of extra lines under the prompt.
   * @returns {void}
   */
  releaseCursor() {
    if (this.extraLinesUnderPrompt > 0) {
      util.down(this.rl, this.extraLinesUnderPrompt);
    }
  }

  /**
   * Calculates the normalized CLI width using the `cli-width` package.
   *
   * @returns {number} - The calculated CLI width. Defaults to 80 if an error occurs.
   */
  normalizedCliWidth() {
    const width = cliWidth({
      defaultWidth: 80,
      output: this.rl.output,
    });
    return width;
  }

  /**
   * Breaks lines that are longer than the CLI width to normalize the natural line returns behavior across terminals.
   *
   * @param {string[]} lines - The array of strings representing the lines to be broken.
   * @param {number} [width=this.normalizedCliWidth()] - The maximum width for each line. Defaults to the normalized CLI width.
   * @returns {string[][]} - An array of arrays, where each inner array contains the broken lines.
   *
   * @example
   * // Example usage:
   * const lines = ['This is a long line that needs to be broken.', 'Short line.'];
   * const brokenLines = breakLines(lines);
   * console.log(brokenLines);
   * // Output: [["This is a long line that needs", "to be broken."], ["Short line."]]
   */
  breakLines(lines, width = this.normalizedCliWidth()) {
    // Break lines who're longer than the cli width so we can normalize the natural line
    // returns behavior across terminals.
    // re: trim: false; by default, `wrap-ansi` trims whitespace, which
    // is not what we want.
    // re: hard: true; by default', `wrap-ansi` does soft wrapping
    return lines.map((line) =>
      wrapAnsi(line, width, { trim: false, hard: true }).split('\n'),
    );
  }

  /**
   * Forces line returns in the given content based on the specified width.
   *
   * @param {string} content - The input string containing lines to be processed.
   * @param {number} [width=this.normalizedCliWidth()] - The maximum line width. Defaults to the normalized command-line interface width.
   * @returns {string} - The modified string with forced line returns.
   *
   * Example:
   *   const processor = new ContentProcessor();
   *   const result = processor.forceLineReturn("This is a long sentence that needs to be split into multiple lines.", 20);
   *   console.log(result); // Outputs: "This is a long\nsentence that needs\nto be split\ninto multiple lines."
   *
   * Note:
   *   This method splits the content into lines, breaks each line if it exceeds the specified width,
   *   and then flattens the array of arrays back into a single string joined by newline characters.
   */
  forceLineReturn(content, width = this.normalizedCliWidth()) {
    return this.breakLines(content.split('\n'), width).flat().join('\n');
  }
}
