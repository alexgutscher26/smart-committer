import ansiEscapes from 'ansi-escapes';
import cliWidth from 'cli-width';
import wrapAnsi from 'wrap-ansi';
import stripAnsi from 'strip-ansi';
import stringWidth from 'string-width';
import ora from 'ora';
import * as util from './readline.js';

/**
 * Calculates the number of lines in the provided content.
 *
 * @param {string} content - The input string whose line count is to be calculated.
 * @returns {number} The number of lines in the content.
 * @throws {TypeError} If the input is not a string.
 *
 * Example:
 * height("Hello\nWorld") returns 2
 */
function height(content) {
  return content.split('\n').length;
}

/**
 * Retrieves the last line of a given content string.
 *
 * @param {string} content - The input string from which to extract the last line.
 * @returns {string} The last line of the input string.
 *
 * Example:
 * lastLine("Hello\nWorld"); // returns "World"
 */
function lastLine(content) {
  return content.split('\n').pop();
}

export default class ScreenManager {
  constructor(rl) {
    // These variables are keeping information to allow correct prompt re-rendering
    this.height = 0;
    this.extraLinesUnderPrompt = 0;

    this.rl = rl;
  }

  /**
   * Renders content with an animated spinner.
   *
   * @param {string} content - The main content to render.
   * @param {string} [bottomContent] - Optional bottom content to display alongside the spinner.
   */
  renderWithSpinner(content, bottomContent) {
    if (this.spinnerId) {
      clearInterval(this.spinnerId);
    }

    let spinner;
    let contentFunc;
    let bottomContentFunc;

    if (bottomContent) {
      spinner = ora(bottomContent);
      contentFunc = () => content;
      bottomContentFunc = () => spinner.frame();
    } else {
      spinner = ora(content);
      contentFunc = () => spinner.frame();
      bottomContentFunc = () => '';
    }

    this.spinnerId = setInterval(
      () => this.render(contentFunc(), bottomContentFunc(), true),
      spinner.interval,
    );
  }

  /**
   * Renders content to the console with optional bottom content and control over the spinner.
   *
   * @param {string} content - The main content to be rendered.
   * @param {string|undefined} bottomContent - Optional additional content to be rendered below the main content.
   * @param {boolean} [spinning=false] - Indicates whether the spinner should be active or not.
   */
  render(content, bottomContent, spinning = false) {
    if (this.spinnerId && !spinning) {
      clearInterval(this.spinnerId);
    }

    this.rl.output.unmute();
    this.clean(this.extraLinesUnderPrompt);

    /**
     * Write message to screen and setPrompt to control backspace
     */

    const promptLine = lastLine(content);
    const rawPromptLine = stripAnsi(promptLine);

    // Remove the rl.line from our prompt. We can't rely on the content of
    // rl.line (mainly because of the password prompt), so just rely on it's
    // length.
    let prompt = rawPromptLine;
    if (this.rl.line.length > 0) {
      prompt = prompt.slice(0, -this.rl.line.length);
    }

    this.rl.setPrompt(prompt);

    // SetPrompt will change cursor position, now we can get correct value
    const cursorPos = this.rl._getCursorPos();
    const width = this.normalizedCliWidth();

    content = this.forceLineReturn(content, width);
    bottomContent &&= this.forceLineReturn(bottomContent, width);

    // Manually insert an extra line if we're at the end of the line.
    // This prevent the cursor from appearing at the beginning of the
    // current line.
    if (rawPromptLine.length % width === 0) {
      content += '\n';
    }

    const fullContent = content + (bottomContent ? '\n' + bottomContent : '');
    this.rl.output.write(fullContent);

    /**
     * Re-adjust the cursor at the correct position.
     */

    // We need to consider parts of the prompt under the cursor as part of the bottom
    // content in order to correctly cleanup and re-render.
    const promptLineUpDiff = Math.floor(rawPromptLine.length / width) - cursorPos.rows;
    const bottomContentHeight =
      promptLineUpDiff + (bottomContent ? height(bottomContent) : 0);
    if (bottomContentHeight > 0) {
      util.up(this.rl, bottomContentHeight);
    }

    // Reset cursor at the beginning of the line
    util.left(this.rl, stringWidth(lastLine(fullContent)));

    // Adjust cursor on the right
    if (cursorPos.cols > 0) {
      util.right(this.rl, cursorPos.cols);
    }

    /**
     * Set up state for next re-rendering
     */
    this.extraLinesUnderPrompt = bottomContentHeight;
    this.height = height(fullContent);

    this.rl.output.mute();
  }

  /**
   * Cleans up the output by moving the readline cursor down by a specified number of lines and clearing the current line.
   *
   * @param {number} extraLines - The number of lines to move the readline cursor down. If positive, it moves down; if negative, it moves up.
   */
  clean(extraLines) {
    if (extraLines > 0) {
      util.down(this.rl, extraLines);
    }

    util.clearLine(this.rl, this.height);
  }

  /**
   * Completes the current readline interface session by setting the prompt to an empty string,
   * unmuting the output, writing a newline character followed by ANSI escape codes to show the cursor,
   * and then closing the readline interface.
   *
   * @function
   * @name done
   * @returns {void}
   */
  done() {
    this.rl.setPrompt('');
    this.rl.output.unmute();
    this.rl.output.write(`\n${ansiEscapes.cursorShow}`);
  }

  /**
   * Releases the cursor from any extra lines under the prompt.
   *
   * This method is responsible for managing the cursor position after processing input or displaying additional content.
   * If there are extra lines beneath the prompt, it moves the cursor down by the specified number of lines to ensure proper positioning.
   */
  releaseCursor() {
    if (this.extraLinesUnderPrompt > 0) {
      util.down(this.rl, this.extraLinesUnderPrompt);
    }
  }

  /**
   * Calculates the normalized CLI width using the `cli-width` library.
   *
   * @returns {number} The calculated width of the command line interface.
   *
   * @throws {Error} If there is an issue with the `cli-width` library.
   */
  normalizedCliWidth() {
    const width = cliWidth({
      defaultWidth: 80,
      output: this.rl.output,
    });
    return width;
  }

  /**
   * Breaks lines that are longer than the CLI width to normalize line returns behavior across terminals.
   *
   * @param {string[]} lines - The array of lines to be broken.
   * @param {number} [width=this.normalizedCliWidth()] - The maximum width of each line. Defaults to the normalized CLI width.
   * @return {Array<Array<string>>} An array of arrays, where each sub-array contains the broken lines.
   *
   * @example
   * const result = breakLines(["This is a long line that needs to be wrapped.", "Short line."], 10);
   * console.log(result); // [["This", "is", "a", "long", "line"], ["that", "needs", "to", "be"], ["wrapped."], ["Short", "line."]]
   */
  breakLines(lines, width = this.normalizedCliWidth()) {
    // Break lines who're longer than the cli width so we can normalize the natural line
    // returns behavior across terminals.
    // re: trim: false; by default, `wrap-ansi` trims whitespace, which
    // is not what we want.
    // re: hard: true; by default', `wrap-ansi` does soft wrapping
    return lines.map((line) =>
      wrapAnsi(line, width, { trim: false, hard: true }).split('\n'),
    );
  }

  /**
   * Forces line returns in the given content to ensure it does not exceed the specified width.
   *
   * @param {string} content - The input content that may contain multiple lines.
   * @param {number} [width=this.normalizedCliWidth()] - The maximum allowed width for each line. Defaults to the normalized CLI width if not provided.
   * @return {string} - The content with forced line returns.
   *
   * Example:
   * const formatter = new ContentFormatter();
   * const formattedContent = formatter.forceLineReturn("This is a long sentence that needs to be wrapped at 40 characters.", 40);
   * console.log(formattedContent); // "This is a long sentence\nthat needs to be\nwrapped at 40 characters."
   */
  forceLineReturn(content, width = this.normalizedCliWidth()) {
    return this.breakLines(content.split('\n'), width).flat().join('\n');
  }
}
