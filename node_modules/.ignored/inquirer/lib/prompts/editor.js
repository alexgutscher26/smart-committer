/**
 * `editor` type prompt
 */

import colors from 'yoctocolors-cjs';
import { editAsync } from 'external-editor';
import { Subject } from 'rxjs';
import observe from '../utils/events.js';
import Base from './base.js';

export default class EditorPrompt extends Base {

  /**
   * Start the Inquiry session.
   *
   * @param {Function} cb - Callback function to be called when the prompt is done.
   * @return {this}
   */
  _run(cb) {
    this.done = cb;

    this.editorResult = new Subject();

    // Open Editor on "line" (Enter Key)
    const events = observe(this.rl);
    this.lineSubscription = events.line.subscribe(this.startExternalEditor.bind(this));
    const waitUserInput =
      this.opt.waitUserInput === undefined ? true : this.opt.waitUserInput;

    // Trigger Validation when editor closes
    const validation = this.handleSubmitEvents(this.editorResult);
    validation.success.forEach(this.onEnd.bind(this));
    validation.error.forEach(this.onError.bind(this));

    // Prevents default from being printed on screen (can look weird with multiple lines)
    this.currentText = this.opt.default;
    this.opt.default = null;

    // Init
    if (waitUserInput) {
      this.render();
    } else {
      this.startExternalEditor();
    }

    return this;
  }


  /**
   * Render the prompt to screen.
   *
   * @param {Error} [error] - An optional error object to display at the bottom of the prompt.
   * @returns {EditorPrompt} - Returns self for method chaining.
   */
  render(error) {
    let bottomContent = '';
    let message = this.getQuestion();

    message +=
      this.status === 'answered'
        ? colors.dim('Received')
        : colors.dim('Press <enter> to launch your preferred editor.');

    if (error) {
      bottomContent = colors.red('>> ') + error;
    }

    this.screen.render(message, bottomContent);
  }


  /**
   * Launches the default text editor set in $EDITOR on user press enter.
   *
   * This method is responsible for opening an external text editor where users can edit a piece of text stored in `currentText`. It temporarily pauses the readline interface to prevent any modifications to stdin and stdout while the editor is active. Once the user saves and closes the editor, control is returned to the application through the `endExternalEditor` callback.
   *
   * @param {Object} options - Optional configuration options for the external editor.
   * @param {string} [options.postfix=".txt"] - A postfix to be added to the filename when saving the text. If not provided, defaults to '.txt'.
   */
  startExternalEditor() {
    // Pause Readline to prevent stdin and stdout from being modified while the editor is showing
    this.rl.pause();
    editAsync(this.currentText, this.endExternalEditor.bind(this), {
      postfix: this.opt.postfix ?? '.txt',
    });
  }

  /**
   * Ends the external editor session, resuming the readline interface and handling the result.
   *
   * @param {Error} [error] - An error object if an error occurred during the editor session. If provided,
   *                          it indicates that the operation failed, and no result will be processed.
   * @param {*} [result] - The result of the external editor session. This is passed to `editorResult.next`
   *                        if there is no error.
   *
   * @returns {void}
   */
  endExternalEditor(error, result) {
    this.rl.resume();
    if (error) {
      this.editorResult.error(error);
    } else {
      this.editorResult.next(result);
    }
  }

  /**
   * Handles the end of the language processing.
   *
   * @param {Object} state - The current state object containing the value.
   */
  onEnd(state) {
    this.editorResult.unsubscribe();
    this.lineSubscription.unsubscribe();
    this.answer = state.value;
    this.status = 'answered';
    // Re-render prompt
    this.render();
    this.screen.done();
    this.done(this.answer);
  }

  /**
   * Handles error states by rendering the validity of the state.
   *
   * @param {Object} state - The current state object containing validation information.
   * @param {boolean} state.isValid - Indicates whether the state is valid or not.
   */
  onError(state) {
    this.render(state.isValid);
  }
}
