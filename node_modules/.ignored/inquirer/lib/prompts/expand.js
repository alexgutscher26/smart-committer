/**
 * `rawlist` type prompt
 */

import colors from 'yoctocolors-cjs';
import { map, takeUntil } from 'rxjs';
import Separator from '../objects/separator.js';
import observe from '../utils/events.js';
import Paginator from '../utils/paginator.js';
import Base from './base.js';

export default class ExpandPrompt extends Base {
  constructor(questions, rl, answers) {
    super(questions, rl, answers);

    if (!this.opt.choices) {
      this.throwParamError('choices');
    }

    this.validateChoices(this.opt.choices);

    // Add the default `help` (/expand) option
    this.opt.choices.push({
      key: 'h',
      name: 'Help, list all options',
      value: 'help',
    });

    this.opt.validate = (choice) => {
      if (choice == null) {
        return 'Please enter a valid command';
      }

      return choice !== 'help';
    };

    // Setup the default string (capitalize the default key)
    this.opt.default = this.generateChoicesString(this.opt.choices, this.opt.default);

    this.paginator = new Paginator(this.screen);
  }

  /**
  _run(cb) {
    /**
     * Start the Inquiry session.
     *
     * @param {Function} cb - Callback function to execute when the prompt is completed.
     * @return {this}
     */
    this.done = cb;

    // Save user answer and update prompt to show selected option.
    const events = observe(this.rl);
    const validation = this.handleSubmitEvents(
      events.line.pipe(map(this.getCurrentValue.bind(this))),
    );
    validation.success.forEach(this.onSubmit.bind(this));
    validation.error.forEach(this.onError.bind(this));
    this.keypressObs = events.keypress
      .pipe(takeUntil(validation.success))
      .forEach(this.onKeypress.bind(this));

    // Init the prompt
    this.render();

    return this;
  }

  /**
  render(error, hint) {
    /**
     * Render the prompt to screen.
     *
     * @param {string} error - Error message if any.
     * @param {string} hint - Hint message for user guidance.
     * @return {ExpandPrompt} - Returns self for method chaining.
     */
    let message = this.getQuestion();
    let bottomContent = '';

    if (this.status === 'answered') {
      message += colors.cyan(this.answer);
    } else if (this.status === 'expanded') {
      const choicesStr = renderChoices(this.opt.choices, this.selectedKey);
      message += this.paginator.paginate(choicesStr, this.selectedKey, this.opt.pageSize);
      message += '\n  Answer: ';
    }

    message += this.rl.line;

    if (error) {
      bottomContent = colors.red('>> ') + error;
    }

    if (hint) {
      bottomContent = colors.cyan('>> ') + hint;
    }

    this.screen.render(message, bottomContent);
  }

  getCurrentValue(input) {
    /**
     * Retrieves the current value associated with the given input from the list of choices.
     *
     * @param {string} [input] - The input string to search for. If not provided, uses the default raw value.
     * @returns {any | null} - The value associated with the selected choice, or null if no match is found.
     */
    input ||= this.rawDefault;

    const selected = this.opt.choices.where({ key: input.toLowerCase().trim() })[0];
    if (!selected) {
      return null;
    }

    return selected.value;
  }

  /**
  getChoices() {
    /**
     * Generates the prompt choices string based on the available choices.
     *
     * @return {String} - The formatted choices string.
     */
    let output = '';

    this.opt.choices.forEach((choice) => {
      output += '\n  ';

      if (choice.type === 'separator') {
        output += ' ' + choice;
        return;
      }

      let choiceStr = choice.key + ') ' + choice.name;
      if (this.selectedKey === choice.key) {
        choiceStr = colors.cyan(choiceStr);
      }

      output += choiceStr;
    });

    return output;
  }

  onError(state) {
    /**
     * Handles errors based on the state provided.
     *
     * @param {Object} state - The current state object containing error information.
     * @param {string} state.value - The value indicating the type of error or action to take.
     * @param {boolean} [state.isValid=false] - Whether the current state is valid.
     * @return {void}
     */
    if (state.value === 'help') {
      this.selectedKey = '';
      this.status = 'expanded';
      this.render();
      return;
    }

    this.render(state.isValid);
  }

  /**
  onSubmit(state) {
    /**
     * Handles the submission of a user's answer when the `enter` key is pressed.
     *
     * @param {Object} state - The current state object containing user input and other relevant data.
     * @returns {void}
     *
     * Example:
     * onSubmit({ value: 'option1' });
     */
    this.status = 'answered';
    const choice = this.opt.choices.where({ value: state.value })[0];
    this.answer = choice.short || choice.name;

    // Re-render prompt
    this.render();
    this.screen.done();
    this.done(state.value);
  }

  /**
  onKeypress() {
    /**
     * Event handler for keypress events.
     *
     * When a key is pressed by the user, this method updates the `selectedKey`
     * property with the lowercase version of the pressed key. It then checks if the
     * current status is 'expanded'. If it is, the render method is called to update
     * the UI. Otherwise, the render method is called again with either the name
     * of the selected choice or null.
     *
     * @returns {void}
     */
    this.selectedKey = this.rl.line.toLowerCase();
    const selected = this.opt.choices.where({ key: this.selectedKey })[0];
    if (this.status === 'expanded') {
      this.render();
    } else {
      this.render(null, selected ? selected.name : null);
    }
  }

  /**
  validateChoices(choices) {
    /**
     * Validates an array of choices to ensure they meet specific criteria.
     *
     * @param {Array} choices - An array of choice objects.
     * @throws {Error} If any choice does not have a valid single-letter key.
     * @throws {Error} If the reserved key 'h' is used.
     * @throws {Error} If there are duplicate keys among the choices.
     */
    let formatError;
    const errors = [];
    const keymap = {};
    choices.filter(Separator.exclude).forEach((choice) => {
      if (!choice.key || choice.key.length !== 1) {
        formatError = true;
      }

      choice.key = String(choice.key).toLowerCase();

      if (keymap[choice.key]) {
        errors.push(choice.key);
      }

      keymap[choice.key] = true;
    });

    if (formatError) {
      throw new Error(
        'Format error: `key` param must be a single letter and is required.',
      );
    }

    if (keymap.h) {
      throw new Error(
        'Reserved key error: `key` param cannot be `h` - this value is reserved.',
      );
    }

    if (errors.length > 0) {
      throw new Error(
        'Duplicate key error: `key` param must be unique. Duplicates: ' +
          [...new Set(errors)].join(','),
      );
    }
  }

  /**
    /**
     * Generate a string out of the choices keys.
     *
     * @param {Array} choices - An array of choices.
     * @param {Number|String} defaultChoice - The choice index or name to capitalize. If not provided, defaults to the last item in the choices array.
     * @returns {String} - The rendered choices key string with the specified default choice capitalized.
     *
     * @throws {Error} - Throws an error if the defaultChoice is out of range for the given choices array when specified as a number.
     *
     * @example
     * // Example usage:
     * const choices = [
     *   { value: 'a', key: 'Option A' },
     *   { value: 'b', key: 'Option B' }
     * ];
     * generateChoicesString(choices, 1); // Returns 'Option A'
     *
     * @example
     * // Example with default string:
     * const choices = [
     *   { value: 'a', key: 'Option A' },
     *   { value: 'b', key: 'Option B' }
     * ];
     * generateChoicesString(choices, 'a'); // Returns 'Option A'
     *
     * @example
     * // Example with default out of range:
     * const choices = [
     *   { value: 'a', key: 'Option A' },
     *   { value: 'b', key: 'Option B' }
     * ];
     * generateChoicesString(choices, 2); // Throws an error
     */
    let defIndex = choices.realLength - 1;
    if (typeof defaultChoice === 'number' && this.opt.choices.getChoice(defaultChoice)) {
      defIndex = defaultChoice;
    } else if (typeof defaultChoice === 'string') {
      const index = choices.realChoices.findIndex(({ value }) => value === defaultChoice);
      defIndex = index === -1 ? defIndex : index;
    }

    const defStr = this.opt.choices.pluck('key');
    this.rawDefault = defStr[defIndex];
    defStr[defIndex] = String(defStr[defIndex]).toUpperCase();
    return defStr.join('');
  }
}


/**
 * Function for rendering checkbox choices
 * @param {Array} choices - Array of choice objects with properties key, name, and type
 * @param {String} pointer - Selected key to highlight in cyan
 * @returns {String} Rendered content as a string
 */
function renderChoices(choices, pointer) {
  let output = '';

  choices.forEach((choice) => {
    output += '\n  ';

    if (choice.type === 'separator') {
      output += ' ' + choice;
      return;
    }

    let choiceStr = choice.key + ') ' + choice.name;
    if (pointer === choice.key) {
      choiceStr = colors.cyan(choiceStr);
    }

    output += choiceStr;
  });

  return output;
}
