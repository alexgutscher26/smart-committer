/**
 * `list` type prompt
 */

import ansiEscapes from 'ansi-escapes';
import colors from 'yoctocolors-cjs';
import figures from '@inquirer/figures';
import runAsync from 'run-async';
import { flatMap, map, take, takeUntil } from 'rxjs';
import observe from '../utils/events.js';
import Paginator from '../utils/paginator.js';
import incrementListIndex from '../utils/incrementListIndex.js';
import Base from './base.js';

export default class ListPrompt extends Base {
  constructor(questions, rl, answers) {
    super(questions, rl, answers);

    if (!this.opt.choices) {
      this.throwParamError('choices');
    }

    this.firstRender = true;
    this.selected = 0;

    const def = this.opt.default;

    // If def is a Number, then use as index. Otherwise, check for value.
    if (typeof def === 'number' && def >= 0 && def < this.opt.choices.realLength) {
      this.selected = def;
    } else if (typeof def !== 'number' && def != null) {
      const index = this.opt.choices.realChoices.findIndex(({ value }) => value === def);
      this.selected = Math.max(index, 0);
    }

    // Make sure no default is set (so it won't be printed)
    this.opt.default = null;

    const shouldLoop = this.opt.loop === undefined ? true : this.opt.loop;
    this.paginator = new Paginator(this.screen, { isInfinite: shouldLoop });
  }

  /**
   * Start the Inquiry session
   * @param  {Function} cb      Callback when prompt is done
   * @return {this}
   */

  _run(cb) {
    this.done = cb;

    const events = observe(this.rl);
    events.normalizedUpKey.pipe(takeUntil(events.line)).forEach(this.onUpKey.bind(this));
      .pipe(
        /**
         * Start the Inquiry session.
         *
         * @param {Function} cb - Callback function to execute when the prompt is done.
         * @return {this}
         */
        take(1),
        map(this.getCurrentValue.bind(this)),
        flatMap((value) =>
          runAsync(this.opt.filter)(value, this.answers).catch((error) => error),
        ),
      )
      .forEach(this.onSubmit.bind(this));

    // Init the prompt
    this.render();

    return this;
  }

  /**
   * Render the prompt to screen
   * @return {ListPrompt} self
   */

  render() {
    // Render question
    let message = this.getQuestion();

    if (this.firstRender) {
      message += colors.dim('(Use arrow keys)');
      message += colors.cyan(this.opt.choices.getChoice(this.selected).short);
    /**
     * Renders the prompt to the screen.
     *
     * @return {ListPrompt} - Returns the current instance of `ListPrompt` for method chaining.
     */
    } else {
      const choicesStr = listRender(this.opt.choices, this.selected);
      const indexPosition = this.opt.choices.indexOf(
        this.opt.choices.getChoice(this.selected),
      );
      const realIndexPosition =
        this.opt.choices.reduce((acc, value, i) => {
          // Dont count lines past the choice we are looking at
          if (i > indexPosition) {
            return acc;
          }
          // Add line if it's a separator
          if (value.type === 'separator') {
            return acc + 1;
          }

          let l = value.name;
          // Non-strings take up one line
          if (typeof l !== 'string') {
            return acc + 1;
          }

          // Calculate lines taken up by string
          l = l.split('\n');
          return acc + l.length;
        }, 0) - 1;
      message +=
        '\n' + this.paginator.paginate(choicesStr, realIndexPosition, this.opt.pageSize);
    }

    message += ansiEscapes.cursorHide;
    this.firstRender = false;

    this.screen.render(message);
  }

  /**
   * When user press `enter` key
   */

  onSubmit(value) {
    this.status = 'answered';

    // Rerender prompt
    this.render();

    this.screen.done();
  getCurrentValue() {
    /**
     * Handles the submission of user input when the `enter` key is pressed.
     *
     * @param {string} value - The value entered by the user.
     */
    return this.opt.choices.getChoice(this.selected).value;
  }

  /**
   * When user press a key
   */
  onUpKey() {
    this.selected = incrementListIndex(this.selected, 'up', this.opt);
    this.render();
  }
/**
 * Returns the current value based on the selected choice from the opt.choices object.
 *
 * @returns {any} The value of the currently selected choice.
 * @throws {Error} If the selected index is out of bounds or no choices are available.
 */

  onDownKey() {
    this.selected = incrementListIndex(this.selected, 'down', this.opt);
    this.render();
    /**
     * Handles the key press event when moving up in a list.
     *
     * Increments the selected index by one position upwards according to the provided options.
     * Then, re-renders the current state of the component or view.
     *
     * @param {Object} this - The context object representing the instance.
     * @param {number} this.selected - The currently selected index in the list.
     * @param {Object} this.opt - Options that dictate how the list should be traversed.
     * @param {function} incrementListIndex - A function to calculate the new selected index when moving up.
     * @returns {undefined}
     *
     * Example:
     * const instance = {
     *   selected: 2,
     *   opt: {},
     *   render() {}
     * };
     * const mockIncrementListIndex = jest.fn().mockReturnValue(1);
     * instance.onUpKey(mockIncrementListIndex);
     * expect(instance.selected).toBe(1);
     * expect(mockIncrementListIndex).toHaveBeenCalledWith(2, 'up', {});
     * instance.render.mock.calls.length.shouldBe(1);
     */
    if (input <= this.opt.choices.realLength) {
      this.selected = input - 1;
    }

    this.render();
  /**
   * Handles the down key press event.
   *
   * This method increments the index of the currently selected item in a list by one,
   * considering the options provided. After updating the selection, it triggers a re-render
   * of the display to reflect the change.
   */
  }
}

/**
 * Function for rendering list choices
 /**
  * Handles key input when a number is pressed.
  *
  * @param {number} input - The number key pressed by the user.
  */
 *
 * @param {Array<Object>} choices - Array of choices to render. Each choice is an object with properties like type, name, disabled.
 * @param {Number} pointer - Position of the pointer indicating the currently selected choice.
 * @return {String} renderedContent - Rendered content as a string.
 *
 * @example
 * // Example usage:
 * const choices = [
 *   { type: 'separator', separator: true },
 *   { name: 'Option 1' },
 *   { name: 'Option 2', disabled: 'Out of stock' }
 * ];
 * listRender(choices, 1); // Returns "  - Option 1 \n    Option 2 (Disabled) "
 */
function listRender(choices, pointer) {
  let output = '';
  let separatorOffset = 0;

  choices.forEach((choice, i) => {
    if (choice.type === 'separator') {
      separatorOffset++;
      output += '  ' + choice + '\n';
      return;
    }

    if (choice.disabled) {
      separatorOffset++;
      output += '  - ' + choice.name;
      output += ` (${
        typeof choice.disabled === 'string' ? choice.disabled : 'Disabled'
      })`;
      output += '\n';
      return;
    }

    const isSelected = i - separatorOffset === pointer;
    let line = (isSelected ? figures.pointer + ' ' : '  ') + choice.name;
    if (isSelected) {
      line = colors.cyan(line);
    }

    output += line + ' \n';
  });

  return output.replaceAll(/\n$/g, '');
}
