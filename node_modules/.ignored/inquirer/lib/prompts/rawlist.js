/**
 * `rawlist` type prompt
 */

import colors from 'yoctocolors-cjs';
import { map, takeUntil } from 'rxjs';
import Separator from '../objects/separator.js';
import observe from '../utils/events.js';
import Paginator from '../utils/paginator.js';
import incrementListIndex from '../utils/incrementListIndex.js';
import Base from './base.js';

export default class RawListPrompt extends Base {
  constructor(questions, rl, answers) {
    super(questions, rl, answers);

    this.hiddenLine = '';
    this.lastKey = '';

    if (!this.opt.choices) {
      this.throwParamError('choices');
    }

    this.opt.validChoices = this.opt.choices.filter(Separator.exclude);

    this.selected = 0;
    this.rawDefault = 0;

    Object.assign(this.opt, {
      validate(val) {
        return val != null;
      },
    });

    const def = this.opt.default;
    if (typeof def === 'number' && def >= 0 && def < this.opt.choices.realLength) {
      this.selected = def;
      this.rawDefault = def;
    } else if (typeof def !== 'number' && def != null) {
      const index = this.opt.choices.realChoices.findIndex(({ value }) => value === def);
      const safeIndex = Math.max(index, 0);
      this.selected = safeIndex;
      this.rawDefault = safeIndex;
    }

    // Make sure no default is set (so it won't be printed)
    this.opt.default = null;

    const shouldLoop = this.opt.loop === undefined ? true : this.opt.loop;
    this.paginator = new Paginator(undefined, { isInfinite: shouldLoop });
  }

  /**
   * Start the Inquiry session
   * @param  {Function} cb      Callback when prompt is done
   * @return {this}
   */

  _run(cb) {
    this.done = cb;

    // Once user confirm (enter key)
    const events = observe(this.rl);
    const submit = events.line.pipe(map(this.getCurrentValue.bind(this)));

      .pipe(takeUntil(validation.success))
      /**
       * Start the Inquiry session.
       *
       * @param {Function} cb - Callback function to execute when the prompt is completed.
       * @return {this} - Returns the current instance for method chaining.
       */
      .forEach(this.onUpKey.bind(this));
    events.normalizedDownKey
      .pipe(takeUntil(validation.success))
      .forEach(this.onDownKey.bind(this));
    events.keypress
      .pipe(takeUntil(validation.success))
      .forEach(this.onKeypress.bind(this));
    // Init the prompt
    this.render();

    return this;
  }

  /**
   * Render the prompt to screen
   * @return {RawListPrompt} self
   */

  render(error) {
    // Render question
    let message = this.getQuestion();
    let bottomContent = '';

    if (this.status === 'answered') {
      message += colors.cyan(this.opt.choices.getChoice(this.selected).short);
    } else {
    }
    /**
     * Render the prompt to screen.
     *
     * @param {string} error - Optional error message to display below the prompt.
     * @return {RawListPrompt} self - The current instance of the RawListPrompt for method chaining.
     */
    message += this.rl.line;

    if (error) {
      bottomContent = '\n' + colors.red('>> ') + error;
    }

    this.screen.render(message, bottomContent);
  }

  /**
   * When user press `enter` key
   */

  getCurrentValue(index) {
    if (index == null) {
      index = this.rawDefault;
    } else if (index === '') {
      this.selected = this.selected === undefined ? -1 : this.selected;
      index = this.selected;
    } else {
      index -= 1;
    }
  }
/**
 * Retrieves the value of the current selection based on the given index.
 *
 * @param {number} [index] - The index of the selected choice. If not provided, defaults to `this.rawDefault`.
 *                           If an empty string is passed, it uses the currently selected index or defaults to -1 if no selection has been made yet.
 * @returns {any | null} - The value of the selected choice or `null` if the choice does not exist.
 *
 * @throws {Error} - Throws an error if `index` is out of bounds for the choices array.
 *
 * @example
 * const currentValue = getCurrentValue(2); // Returns the value at index 2
 * const currentValueDefault = getCurrentValue(); // Returns the value at this.rawDefault
 */

  onEnd(state) {
    this.status = 'answered';
    this.answer = state.value;

    // Re-render prompt
    this.render();

    this.screen.done();
    this.done(state.value);
  }

  onError() {
    this.render('Please enter a valid index');
  /**
   * Handles the end of an interaction by setting the status to 'answered', storing the answer,
   * re-rendering the prompt, marking the screen as done, and completing the interaction with the answer.
   *
   * @param {Object} state - The current state object containing the value to be stored as the answer.
   * @returns {void}
   */
  }

  /**
   * When user press a key
   */

  onKeypress() {
    let index;

    if (this.lastKey === 'arrow') {
      index = this.hiddenLine.length > 0 ? Number(this.hiddenLine) - 1 : 0;
    /**
     * Handles an error by rendering a message prompting the user to enter a valid index.
     *
     * This method is typically called when an invalid index is detected during some operation that requires an index.
     *
     * @returns {void} This method does not return any value.
     */
    } else {
      index = this.rl.line.length > 0 ? Number(this.rl.line) - 1 : 0;
    }
    this.lastKey = '';
  }
/**
 * Handles the keypress event by updating the selected choice based on the user's input.
 *
 * This method is called when a key is pressed. It determines the index of the choice to be selected
 * based on whether the last key pressed was an arrow key or not. If the last key was an arrow key,
 * it uses the value in `hiddenLine` as the index; otherwise, it uses the current input line.
 *
 * @private
 * @returns {void}
 */

  /**
   * When user press up key
   */

  onUpKey() {
    this.onArrowKey('up');
  }

  /**
   * When user press down key
   */

  onDownKey() {
  /**
   /**
    * Handles the event when the user presses the up key.
    * This method internally calls `onArrowKey` with the argument 'up'.
    */
   * When user press up or down key
   * @param {String} type Arrow type: up or down
   */

    this.rl.line = '';
    /**
     * Handles the down arrow key press event.
     *
     * This method is called when the user presses the down arrow key. It triggers the
     * `onArrowKey` method with the argument 'down'.
     *
     * @param {string} direction - The direction of the key press ('down' in this case).
     */
    this.lastKey = 'arrow';
  }
}

 * @param {Array<Object>} choices - An array of choice objects. Each choice object can be a plain text or a separator.
 /**
  * Handles the arrow key event when the user presses up or down.
  *
  * @param {string} type - The type of arrow key pressed. Must be either 'up' or 'down'.
  */
 *   @property {String} [type='text'] - Type of the choice, either 'text' (default) or 'separator'.
 *   @property {String} name - The display name of the choice if type is 'text'.
 * @param {Number} pointer - Position of the pointer indicating the currently selected choice.
 * @returns {String} Rendered content as a string with choices formatted and optionally highlighted by the pointer.
 *
 * Example usage:
 * const choices = [
 *   { name: 'Option 1' },
 *   { type: 'separator', name: '-----' },
 *   { name: 'Option 2' }
 * ];
 * const renderedContent = renderChoices(choices, 1);
 * console.log(renderedContent); // Output will show 'Option 1\n ----- \n 2) Option 2' with the separator highlighted
 */
function renderChoices(choices, pointer) {
  let output = '';
  let separatorOffset = 0;

  choices.forEach((choice, i) => {
    output += output ? '\n  ' : '  ';

    if (choice.type === 'separator') {
      separatorOffset++;
      output += ' ' + choice;
      return;
    }

    const index = i - separatorOffset;
    let display = index + 1 + ') ' + choice.name;
    if (index === pointer) {
      display = colors.cyan(display);
    }

    output += display;
  });

  return output;
}
