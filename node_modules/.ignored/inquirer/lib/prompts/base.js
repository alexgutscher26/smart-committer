/**
 * Base prompt implementation
 * Should be extended by prompt types.
 */
import colors from 'yoctocolors-cjs';
import runAsync from 'run-async';
import { filter, mergeMap, share, take, takeUntil } from 'rxjs';
import Choices from '../objects/choices.js';
import ScreenManager from '../utils/screen-manager.js';

export default class Prompt {
  constructor(question, rl, answers) {
    // Setup instance defaults property
    Object.assign(this, {
      answers,
      status: 'pending',
    });

    // Set defaults prompt options
    this.opt = {
      validate: () => true,
      validatingText: '',
      filter: (val) => val,
      filteringText: '',
      when: () => true,
      suffix: '',
      prefix: colors.green('?'),
      transformer: (val) => val,
      ...question,
    };

    // Make sure name is present
    if (!this.opt.name) {
      this.throwParamError('name');
    }

    // Set default message if no message defined
    this.opt.message ||= this.opt.name + ':';

    // Normalize choices
    if (Array.isArray(this.opt.choices)) {
      this.opt.choices = new Choices(this.opt.choices, answers);
    }

    this.rl = rl;
    this.screen = new ScreenManager(this.rl);
  }


  /**
   * Start the Inquiry session and manage output value filtering.
   *
   * @return {Promise} A promise that resolves with the filtered output value or rejects with an error.
   */
  run() {
    return new Promise((resolve, reject) => {
      this._run(
        (value) => resolve(value),
        (error) => reject(error),
      );
    });
  }

  // Default noop (this one should be overwritten in prompts)
  /**
   * Executes a callback function provided as an argument.
   *
   * @param {Function} cb - The callback function to execute.
   */
  _run(cb) {
    cb();
  }


  /**
   * Throws an error indicating that a required parameter is missing.
   *
   * @param {string} name - The name of the missing parameter.
   */
  throwParamError(name) {
    throw new Error('You must provide a `' + name + '` parameter');
  }

  /**
   * Called when the UI closes. Override to do any specific cleanup necessary.
   */
  close() {
    this.screen.releaseCursor();
  }

  /**
   * Runs the provided validation method each time a submit event occurs.
   *
   * @param {Rx.Observable} submit - The observable representing the submit events flow.
   * @return {Object} An object containing two observables: `success` and `error`.
   * @throws Will throw an error if the provided submit parameter is not an instance of Rx.Observable.
   */
  handleSubmitEvents(submit) {
    const validate = runAsync(this.opt.validate);
    const asyncFilter = runAsync(this.opt.filter);
    const validation = submit.pipe(
      mergeMap((value) => {
        this.startSpinner(value, this.opt.filteringText);
        return asyncFilter(value, this.answers).then(
          (filteredValue) => {
            this.startSpinner(filteredValue, this.opt.validatingText);
            return validate(filteredValue, this.answers).then(
              (isValid) => ({ isValid, value: filteredValue }),
              (error_) => ({ isValid: error_, value: filteredValue }),
            );
          },
          (error_) => ({ isValid: error_ }),
        );
      }),
      share(),
    );

    const success = validation.pipe(
      filter((state) => state.isValid === true),
      take(1),
    );
    const error = validation.pipe(
      filter((state) => state.isValid !== true),
      takeUntil(success),
    );

    return {
      success,
      error,
    };
  }

  /**
   * Starts a spinner with a given value and optional bottom content.
   *
   * @param {string} value - The value to display in the spinner.
   * @param {string|undefined} [bottomContent=undefined] - Optional additional content to display below the spinner.
   */
  startSpinner(value, bottomContent) {
    value = this.getSpinningValue(value);
    // If the question will spin, cut off the prefix (for layout purposes)
    const content = bottomContent
      ? this.getQuestion() + value
      : this.getQuestion().slice(this.opt.prefix.length + 1) + value;

    this.screen.renderWithSpinner(content, bottomContent);
  }

  /**
   * Allow override, e.g. for password prompts.
   *
   * @param {string} value - The current value to display while spinning.
   * @return {string} The value to display while spinning.
   */
  getSpinningValue(value) {
    return value;
  }

  /**
   * Generate the prompt question string.
   *
   * @return {String} The prompt question string generated based on the current options and status.
   */
  getQuestion() {
    let message =
      (this.opt.prefix ? this.opt.prefix + ' ' : '') +
      colors.bold(this.opt.message) +
      this.opt.suffix +
      colors.reset(' ');

    // Append the default if available, and if question isn't touched/answered
    if (
      this.opt.default != null &&
      this.status !== 'touched' &&
      this.status !== 'answered'
    ) {
      // If default password is supplied, hide it
      message +=
        this.opt.type === 'password'
          ? colors.italic(colors.dim('[hidden] '))
          : colors.dim('(' + this.opt.default + ') ');
    }

    return message;
  }
}
