const _ = {
  set: (obj, path = '', value) => {
    let pointer = obj;
    path.split('.').forEach((key, index, arr) => {
      if (key === '__proto__' || key === 'constructor') return;

      if (index === arr.length - 1) {
        pointer[key] = value;
      } else if (!(key in pointer) || typeof pointer[key] !== 'object') {
        pointer[key] = {};
      }

      pointer = pointer[key];
    });
  },
  get: (obj, path = '', defaultValue) => {
    /**
     * Splits an object based on a regular expression pattern and reduces it to a single value.
     *
     * @param {RegExp} regexp - The regular expression pattern used for splitting the object keys.
     * @param {Object} obj - The object to be split and reduced.
     * @returns {*} The reduced result after splitting and filtering.
     *
     * @example
     * // Returns 'world'
     * travel(/[ ,]+/, {
     *   hello: 'world',
     * });
     */
    const travel = (regexp) =>
      String.prototype.split
        .call(path, regexp)
        .filter(Boolean)
        .reduce(
          // @ts-expect-error implicit any on res[key]
          (res, key) => (res !== null && res !== undefined ? res[key] : res),
          obj,
        );
    const result = travel(/[,[\]]+?/) || travel(/[,.[\]]+?/);
    return result === undefined || result === obj ? defaultValue : result;
  },
};

import {
  defer,
  EMPTY,
  from,
  of,
  concatMap,
  filter,
  publish,
  reduce,
  isObservable,
} from 'rxjs';
import runAsync from 'run-async';
import * as utils from '../utils/utils.js';
import Base from './baseUI.js';

/**
 * Base interface class other can inherits from
 */
export default class PromptUI extends Base {
  constructor(prompts, opt) {
    super(opt);
    this.prompts = prompts;
  }

  /**
   * Processes a set of questions and collects answers.
   *
   * @param {Array|Object} questions - A list of questions or an object mapping names to question configurations.
   * @param {Object} [answers={}] - An optional object containing initial answers.
   * @returns {Promise<Object>} - A promise that resolves with the collected answers.
   * @throws {Error} - Throws an error if questions are not in a valid format.
   *
   * @example
   * const runner = new QuestionRunner();
   * const answers = await runner.run(['What is your name?', 'What is your age?'], { name: 'John' });
   * console.log(answers); // { name: 'John', 0: 'Your name', 1: 'Your age' }
   */
  run(questions, answers) {
    // Keep global reference to the answers
    this.answers = typeof answers === 'object' ? { ...answers } : {};

    let obs;
    if (Array.isArray(questions)) {
      obs = from(questions);
    } else if (isObservable(questions)) {
      obs = questions;
    } else if (
      Object.values(questions).every(
        (maybeQuestion) =>
          typeof maybeQuestion === 'object' &&
          !Array.isArray(maybeQuestion) &&
          maybeQuestion != null,
      )
    ) {
      // Case: Called with a set of { name: question }
      obs = from(
        Object.entries(questions).map(([name, question]) => ({
          name,
          ...question,
        })),
      );
    } else {
      // Case: Called with a single question config
      obs = from([questions]);
    }

    this.process = obs.pipe(
      concatMap(this.processQuestion.bind(this)),
      publish(), // Creates a hot Observable. It prevents duplicating prompts.
    );

    this.process.connect();

    return this.process
      .pipe(
        reduce((answersObj, answer) => {
          _.set(answersObj, answer.name, answer.answer);
          return answersObj;
        }, this.answers),
      )
      .toPromise(Promise)
      .then(this.onCompletion.bind(this), this.onError.bind(this));
  }

  /**
   * Once all prompts are completed, this method is called to close the current context and return the collected answers.
   *
   * @returns {Object} - An object containing the collected answers.
   */
  onCompletion() {
    this.close();

    return this.answers;
  }

  /**
   * Handles an error by closing the connection and rejecting the Promise with the error.
   *
   * @param {Error} error - The error that occurred.
   * @returns {Promise<never>} - A rejected Promise containing the error.
   */
  onError(error) {
    this.close();
    return Promise.reject(error);
  }

  /**
   * Processes a question by modifying it and applying various transformations and fetch operations.
   *
   * @param {Object} question - The question object to be processed.
   * @returns {Promise<Object>} A promise that resolves with the processed question.
   * @throws {Error} If an error occurs during any of the transformations or fetch operations.
   */
  processQuestion(question) {
    question = { ...question };
    return defer(() => {
      const obs = of(question);

      return obs.pipe(
        concatMap(this.setDefaultType.bind(this)),
        concatMap(this.filterIfRunnable.bind(this)),
        concatMap(() =>
          utils.fetchAsyncQuestionProperty(question, 'message', this.answers),
        ),
        concatMap(() =>
          utils.fetchAsyncQuestionProperty(question, 'default', this.answers),
        ),
        concatMap(() =>
          utils.fetchAsyncQuestionProperty(question, 'choices', this.answers),
        ),
        concatMap(this.fetchAnswer.bind(this)),
      );
    });
  }

  /**
   * Fetches an answer to a given question by running an active prompt.
   *
   * @param {Object} question - The question object containing details about the question.
   * @returns {Promise<Object>} A promise that resolves with an object containing the name of the question and its corresponding answer.
   * @throws {Error} Throws an error if the question type is not supported or if there are issues running the prompt.
   *
   * Example usage:
   * const result = await fetchAnswer({ type: 'text', name: 'What is your favorite color?' });
   * console.log(result); // { name: 'What is your favorite color?', answer: 'Blue' }
   */
  fetchAnswer(question) {
    const Prompt = this.prompts[question.type];
    this.activePrompt = new Prompt(question, this.rl, this.answers);
    return defer(() =>
      from(this.activePrompt.run().then((answer) => ({ name: question.name, answer }))),
    );
  }

  /**
   * Sets the default type to 'input' if the provided question does not have an existing type in the prompts object.
   *
   * @param {Object} question - The question object whose type needs to be set.
   * @return {Promise<Object>} A promise that resolves to the modified question object with the default type applied.
   * @throws {Error} If 'this.prompts' is undefined or not an object.
   */
  setDefaultType(question) {
    // Default type to input
    if (!this.prompts[question.type]) {
      question.type = 'input';
    }

    return defer(() => of(question));
  }

  filterIfRunnable(question) {
    if (
      question.askAnswered !== true &&
      _.get(this.answers, question.name) !== undefined
    ) {
      return EMPTY;
    }

    if (question.when === false) {
      return EMPTY;
    }

    if (typeof question.when !== 'function') {
      return of(question);
    }

    const { answers } = this;
    return defer(() =>
      from(
        runAsync(question.when)(answers).then((shouldRun) => {
          if (shouldRun) {
            return question;
          }
        }),
      ).pipe(filter((val) => val != null)),
    );
  }
}
