/**
 * Sticky bottom bar user interface
 */

import { Writable } from 'node:stream';
import * as rlUtils from '../utils/readline.js';
import Base from './baseUI.js';

export default class BottomBar extends Base {
  constructor(opt = {}) {
    super(opt);

    this.log = new Writable({
      write: (chunk, encoding, cb) => {
        this.writeLog(chunk);
        cb();
      },
    });

    this.bottomBar = opt.bottomBar || '';
    this.render();
  }


  /**
   * Renders the prompt to the screen.
   *
   * @return {BottomBar} Returns the current instance of BottomBar.
   */
  render() {
    this.write(this.bottomBar);
    return this;
  }

  /**
   * Clears the line of input from the readline interface and updates the bottom bar if present.
   *
   * @return {object} The current instance of the object, allowing for method chaining.
   */
  clean() {
    rlUtils.clearLine(this.rl, this.bottomBar.split('\n').length);
    return this;
  }


  /**
   * Update the bottom bar content and rerender.
   *
   * @param {string} bottomBar - The new content for the bottom bar.
   * @returns {BottomBar} self - The instance of BottomBar for method chaining.
   */
  updateBottomBar(bottomBar) {
    rlUtils.clearLine(this.rl, 1);
    this.rl.output.unmute();
    this.clean();
    this.bottomBar = bottomBar;
    this.render();
    this.rl.output.mute();
    return this;
  }


  /**
   * Write out log data to the console.
   *
   * @param {string} data - The log data to be output.
   * @return {BottomBar} self - The instance of BottomBar for method chaining.
   */
  writeLog(data) {
    this.rl.output.unmute();
    this.clean();
    this.rl.output.write(this.enforceLF(data.toString()));
    this.render();
    this.rl.output.mute();
    return this;
  }


  /**
   * Ensures that the input string ends with a line feed character.
   *
   * @param {String} str - The input string to be checked and modified.
   * @returns {String} The modified string guaranteed to end with a line feed. If the original string already ended with a line feed or carriage return, it is returned unchanged. Otherwise, a line feed is appended to the end of the string.
   */
  enforceLF(str) {
    return /[\n\r]$/.test(str) ? str : str + '\n';
  }

  /**
   * Helper function to output a message in a prompt.
   *
   * @param {string} message - The message to be displayed.
   */
  write(message) {
    const msgLines = message.split(/\n/);
    this.height = msgLines.length;

    // Write message to screen and setPrompt to control backspace
    this.rl.setPrompt(msgLines.at(-1));

    if (this.rl.output.rows === 0 && this.rl.output.columns === 0) {
      /* When it's a tty through serial port there's no terminal info and the render will malfunction,
         so we need enforce the cursor to locate to the leftmost position for rendering. */
      rlUtils.left(this.rl, message.length + this.rl.line.length);
    }

    this.rl.output.write(message);
  }
}
