/**
 * Sticky bottom bar user interface
 */

import { Writable } from 'node:stream';
import * as rlUtils from '../utils/readline.js';
import Base from './baseUI.js';

export default class BottomBar extends Base {
  constructor(opt = {}) {
    super(opt);

    this.log = new Writable({
      write: (chunk, encoding, cb) => {
        this.writeLog(chunk);
        cb();
      },
    });

    this.bottomBar = opt.bottomBar || '';
    this.render();
  }


  /**
   * Render the prompt to screen
   *
   * @return {BottomBar} - Returns this instance of BottomBar for method chaining.
   */
  render() {
    this.write(this.bottomBar);
    return this;
  }

  /**
   * Clears the line where the readline interface is currently located by moving the cursor to the beginning of the line and deleting all characters up to the end of the line.
   *
   * @returns {Object} - Returns the current instance of the object, allowing for method chaining.
   */
  clean() {
    rlUtils.clearLine(this.rl, this.bottomBar.split('\n').length);
    return this;
  }


  /**
   * Update the bottom bar content and rerender.
   *
   * @param {string} bottomBar - The new content to display in the bottom bar.
   * @return {BottomBar} - Returns the current instance of BottomBar for method chaining.
   */
  updateBottomBar(bottomBar) {
    rlUtils.clearLine(this.rl, 1);
    this.rl.output.unmute();
    this.clean();
    this.bottomBar = bottomBar;
    this.render();
    this.rl.output.mute();
    return this;
  }


  /**
   * Write out log data
   *
   * @param {String} data - The log data to be output
   * @return {BottomBar} self
   */
  writeLog(data) {
    this.rl.output.unmute();
    this.clean();
    this.rl.output.write(this.enforceLF(data.toString()));
    this.render();
    this.rl.output.mute();
    return this;
  }


  /**
   * Ensures that the input string ends with a line feed character.
   *
   * @param {String} str - The input string to be processed.
   * @return {String} - The modified string with a final line feed if necessary.
   */
  enforceLF(str) {
    return /[\n\r]$/.test(str) ? str : str + '\n';
  }

  /**
   * Helper function to output a message in a Prompt.
   *
   * @param {string} message - The message to be output.
   */
  write(message) {
    const msgLines = message.split(/\n/);
    this.height = msgLines.length;

    // Write message to screen and setPrompt to control backspace
    this.rl.setPrompt(msgLines.at(-1));

    if (this.rl.output.rows === 0 && this.rl.output.columns === 0) {
      /* When it's a tty through serial port there's no terminal info and the render will malfunction,
         so we need enforce the cursor to locate to the leftmost position for rendering. */
      rlUtils.left(this.rl, message.length + this.rl.line.length);
    }

    this.rl.output.write(message);
  }
}
