import ansiEscapes from 'ansi-escapes';
import cliWidth from 'cli-width';
import wrapAnsi from 'wrap-ansi';
import stripAnsi from 'strip-ansi';
import stringWidth from 'string-width';
import ora from 'ora';
import * as util from './readline.js';

function height(content) {
  return content.split('\n').length;
}

/**
 * Retrieves the last line of a given string.
 *
 * @param {string} content - The string from which to extract the last line.
 * @returns {string} - The last line of the input string.
 * @throws {Error} - Throws an error if the input is not a valid string.
 *
 * @example
 * // Returns "world"
 * console.log(lastLine("Hello\nworld"));
 */
function lastLine(content) {
  return content.split('\n').pop();
}

export default class ScreenManager {
  constructor(rl) {
    // These variables are keeping information to allow correct prompt re-rendering
    this.height = 0;
    this.extraLinesUnderPrompt = 0;

    this.rl = rl;
  }

  renderWithSpinner(content, bottomContent) {
    if (this.spinnerId) {
      clearInterval(this.spinnerId);
    }

    let spinner;
    let contentFunc;
    let bottomContentFunc;

    if (bottomContent) {
      spinner = ora(bottomContent);
      contentFunc = () => content;
      bottomContentFunc = () => spinner.frame();
    } else {
      spinner = ora(content);
      contentFunc = () => spinner.frame();
      bottomContentFunc = () => '';
    }

    this.spinnerId = setInterval(
      () => this.render(contentFunc(), bottomContentFunc(), true),
      spinner.interval,
    );
  }

  render(content, bottomContent, spinning = false) {
    if (this.spinnerId && !spinning) {
      clearInterval(this.spinnerId);
    }

    this.rl.output.unmute();
    this.clean(this.extraLinesUnderPrompt);

    /**
     * Write message to screen and setPrompt to control backspace
     */

    const promptLine = lastLine(content);
    const rawPromptLine = stripAnsi(promptLine);

    // Remove the rl.line from our prompt. We can't rely on the content of
    // rl.line (mainly because of the password prompt), so just rely on it's
    // length.
    let prompt = rawPromptLine;
    if (this.rl.line.length > 0) {
      prompt = prompt.slice(0, -this.rl.line.length);
    }

    this.rl.setPrompt(prompt);

    // SetPrompt will change cursor position, now we can get correct value
    const cursorPos = this.rl._getCursorPos();
    const width = this.normalizedCliWidth();

    content = this.forceLineReturn(content, width);
    bottomContent &&= this.forceLineReturn(bottomContent, width);

    // Manually insert an extra line if we're at the end of the line.
    // This prevent the cursor from appearing at the beginning of the
    // current line.
    if (rawPromptLine.length % width === 0) {
      content += '\n';
    }

    const fullContent = content + (bottomContent ? '\n' + bottomContent : '');
    this.rl.output.write(fullContent);

    /**
     * Re-adjust the cursor at the correct position.
     */

    // We need to consider parts of the prompt under the cursor as part of the bottom
    // content in order to correctly cleanup and re-render.
    const promptLineUpDiff = Math.floor(rawPromptLine.length / width) - cursorPos.rows;
    const bottomContentHeight =
      promptLineUpDiff + (bottomContent ? height(bottomContent) : 0);
    if (bottomContentHeight > 0) {
      util.up(this.rl, bottomContentHeight);
    }

    // Reset cursor at the beginning of the line
    util.left(this.rl, stringWidth(lastLine(fullContent)));

    // Adjust cursor on the right
    if (cursorPos.cols > 0) {
      util.right(this.rl, cursorPos.cols);
    }

    /**
     * Set up state for next re-rendering
     */
    this.extraLinesUnderPrompt = bottomContentHeight;
    this.height = height(fullContent);

    this.rl.output.mute();
  }

  /**
   * Clears extra lines from the readline interface and clears the line.
   *
   * @param {number} extraLines - The number of extra lines to clear.
   */
  clean(extraLines) {
    if (extraLines > 0) {
      util.down(this.rl, extraLines);
    }

    util.clearLine(this.rl, this.height);
  }

  /**
   * Completes the process by setting the prompt to an empty string,
   * unmuting the output, and showing the cursor.
   *
   * @function done
   * @return {void}
   */
  done() {
    this.rl.setPrompt('');
    this.rl.output.unmute();
    this.rl.output.write(`\n${ansiEscapes.cursorShow}`);
  }

  /**
   * Releases the cursor by moving it down by `extraLinesUnderPrompt` lines using the readline module's `util.down` method.
   *
   * @returns {void}
   */
  releaseCursor() {
    if (this.extraLinesUnderPrompt > 0) {
      util.down(this.rl, this.extraLinesUnderPrompt);
    }
  }

  /**
   * Calculates and returns the normalized CLI width.
   *
   * @returns {number} The normalized CLI width.
   *
   * Example usage:
   *   const width = instance.normalizedCliWidth();
   *   console.log(`Normalized CLI Width: ${width}`);
   */
  normalizedCliWidth() {
    const width = cliWidth({
      defaultWidth: 80,
      output: this.rl.output,
    });
    return width;
  }

  /**
   * Breaks lines that are longer than the specified width to ensure consistent line returns behavior across terminals.
   *
   * @param {string[]} lines - The array of strings representing lines to be broken.
   * @param {number} [width=this.normalizedCliWidth()] - The maximum width for each line. If not provided, defaults to the normalized CLI width.
   * @returns {string[][]} An array of arrays where each inner array contains the broken lines.
   *
   * Example:
   *   breakLines(["This is a long line that needs to be broken.", "Short line."], 10)
   *   // Returns [["This is a", "long line", "that needs"], ["to be broken."], ["Short line."]]
   */
  breakLines(lines, width = this.normalizedCliWidth()) {
    // Break lines who're longer than the cli width so we can normalize the natural line
    // returns behavior across terminals.
    // re: trim: false; by default, `wrap-ansi` trims whitespace, which
    // is not what we want.
    // re: hard: true; by default', `wrap-ansi` does soft wrapping
    return lines.map((line) =>
      wrapAnsi(line, width, { trim: false, hard: true }).split('\n'),
    );
  }

  /**
   * Forces line returns in the provided content to ensure each line does not exceed a specified width.
   *
   * @param {string} content - The content to process, expected to be a string.
   * @param {number} [width=this.normalizedCliWidth()] - The maximum width of each line. Defaults to the normalized CLI width if not provided.
   * @return {string} - The processed content with forced line returns.
   */
  forceLineReturn(content, width = this.normalizedCliWidth()) {
    return this.breakLines(content.split('\n'), width).flat().join('\n');
  }
}
