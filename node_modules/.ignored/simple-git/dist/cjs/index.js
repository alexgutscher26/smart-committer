"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __defProps = Object.defineProperties;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
/**
 * Defines a normal property on an object with specified attributes.
 *
 * @param {Object} obj - The object to define the property on.
 * @param {string} key - The name of the property to define.
 * @param {*} value - The value to assign to the property.
 */
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
/**
 * Merges two objects into one. The second object's properties are copied to the first object.
 *
 * @param {Object} a - The target object where properties will be copied.
 * @param {Object} b - The source object whose properties will be merged into the target object.
 * @returns {Object} - The merged object with properties from both `a` and `b`.
 */
var __spreadValues = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp.call(b, prop))
      __defNormalProp(a, prop, b[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b)) {
      if (__propIsEnum.call(b, prop))
        __defNormalProp(a, prop, b[prop]);
    }
  return a;
};
/**
 * Merges properties from two objects, with properties from the second object spreading into the first.
 *
 * @param {Object} a - The target object to which properties will be merged.
 * @param {Object} b - The source object whose properties will be merged into the target object.
 * @returns {Object} The resulting object after merging properties from both input objects.
 */
var __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));
/**
 * Creates an ESM (ECMAScript Module) function that initializes and returns another function.
 *
 * @param {Function} fn - The function to initialize.
 * @param {Object} res - An object where the result will be stored.
 * @returns {Function} - A function that, when called, will execute the initialization logic if fn is provided.
 *
 * Example:
 * const myModule = __esm(
 *   () => {
 *     let count = 0;
 *     return {
 *       increment: () => count++,
 *       getCount: () => count
 *     };
 *   },
 *   {}
 * );
 *
 * const moduleInstance = myModule();
 * console.log(moduleInstance.getCount()); // Output: 0
 * moduleInstance.increment();
 * console.log(moduleInstance.getCount()); // Output: 1
 */
var __esm = (fn, res) => function __init() {
  return fn && (res = (0, fn[__getOwnPropNames(fn)[0]])(fn = 0)), res;
};
/**
 * A helper function used to define and execute CommonJS modules.
 *
 * @param {Function} cb - The callback function that defines the module.
 * @param {Object} mod - An optional object containing default properties for the module.
 * @returns {Object} - The exported module object.
 * @example
 * const myModule = __commonJS((exports, module) => {
 *   exports.sayHello = () => 'Hello, world!';
 * }, {});
 *
 * console.log(myModule.sayHello()); // Output: Hello, world!
 */
var __commonJS = (cb, mod) => function __require() {
  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
/**
 * Exports properties from one object to another.
 *
 * @param {Object} target - The target object to which properties will be exported.
 * @param {Object} all - The source object containing the properties to export.
 */
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
/**
 * Converts a module to an ES module format.
 *
 * @param {Object} mod - The module to convert.
 * @param {boolean} isNodeMode - Indicates if the conversion is in Node.js mode.
 * @param {Object} [target] - Optional target object for the conversion.
 * @returns {Object} - The converted ES module.
 *
 * @example
 * const myModule = { default: 'value' };
 * const esModule = __toESM(myModule, true);
 * console.log(esModule.default); // Output: value
 */
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
/**
 * Converts an object to a CommonJS module.
 *
 * @param {Object} mod - The module object to convert.
 * @returns {Object} - The converted module with `__esModule` property set to true.
 */
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
/**
 * A utility function to handle asynchronous operations using Promises and generators.
 *
 * @param {Object} __this - The context in which the generator function is executed.
 * @param {Array} __arguments - An array of arguments to pass to the generator function.
 * @param {GeneratorFunction} generator - A generator function that yields promises.
 * @returns {Promise<any>} - A Promise that resolves with the result of the generator function's final yield.
 *
 * @example
 * // Example usage:
 * const asyncResult = await __async(this, [], async function*() {
 *   return 'Hello, world!';
 * });
 */
var __async = (__this, __arguments, generator) => {
  return new Promise((resolve, reject) => {
    /**
     * Handles the resolution of a generator's next step.
     *
     * @param {any} value - The value to pass to the generator's next method.
     * @throws {Error} If an error occurs during the generator execution, it is rethrown.
     */
    var fulfilled = (value) => {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    };
    /**
     * Handles errors thrown during generator execution.
     *
     * @param {*} value - The value to throw as an error.
     */
    var rejected = (value) => {
      try {
        step(generator.throw(value));
      } catch (e) {
        reject(e);
      }
    };
    /**
     * Executes the next step of a promise chain.
     *
     * @param {Object} x - The current step object from a promise chain.
     * @param {Function} fulfilled - Callback function for handling fulfilled promises.
     * @param {Function} rejected - Callback function for handling rejected promises.
     * @returns {Promise} - A new Promise that resolves based on the current step's status.
     *
     * @example
     * const promise = Promise.resolve(42);
     * promise.then(step, handleRejection).then(value => console.log(value));
     */
    var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);
    step((generator = generator.apply(__this, __arguments)).next());
  });
};

// src/lib/errors/git-error.ts
var GitError;
var init_git_error = __esm({
  "src/lib/errors/git-error.ts"() {
    "use strict";
    GitError = class extends Error {
      constructor(task, message) {
        super(message);
        this.task = task;
        Object.setPrototypeOf(this, new.target.prototype);
      }
    };
  }
});

// src/lib/errors/git-response-error.ts
var GitResponseError;
var init_git_response_error = __esm({
  "src/lib/errors/git-response-error.ts"() {
    "use strict";
    init_git_error();
    GitResponseError = class extends GitError {
      constructor(git, message) {
        super(void 0, message || String(git));
        this.git = git;
      }
    };
  }
});

// src/lib/args/pathspec.ts
/**
 * Generates a unique key from multiple paths and caches it for future use.
 *
 * @param {...string} paths - One or more path strings to be combined into a single key.
 * @returns {String} A unique key representing the combination of provided paths.
 * @throws {TypeError} If any of the arguments is not a string.
 */
function pathspec(...paths) {
  const key = new String(paths);
  cache.set(key, paths);
  return key;
}
/**
 * Checks if a given path is a string that exists in the cache.
 *
 * @param {String} path - The path to check.
 * @returns {boolean} - Returns true if the path is a string and exists in the cache, otherwise false.
 *
 * @example
 * // Check if 'path/to/file' exists in the cache
 * const exists = isPathSpec('path/to/file');
 * console.log(exists); // Output: true or false based on cache content
 */
function isPathSpec(path) {
  return path instanceof String && cache.has(path);
}
/**
 * Converts a path specification into an array of paths. If no cache entry exists for the given path specification,
 * it returns an empty array.
 *
 * @param {string} pathSpec - The path specification to convert into an array of paths.
 * @returns {Array<string>} An array of paths corresponding to the path specification.
 */
function toPaths(pathSpec) {
  return cache.get(pathSpec) || [];
}
var cache;
var init_pathspec = __esm({
  "src/lib/args/pathspec.ts"() {
    "use strict";
    cache = /* @__PURE__ */ new WeakMap();
  }
});

// src/lib/errors/git-construct-error.ts
var GitConstructError;
var init_git_construct_error = __esm({
  "src/lib/errors/git-construct-error.ts"() {
    "use strict";
    init_git_error();
    GitConstructError = class extends GitError {
      constructor(config, message) {
        super(void 0, message);
        this.config = config;
      }
    };
  }
});

// src/lib/errors/git-plugin-error.ts
var GitPluginError;
var init_git_plugin_error = __esm({
  "src/lib/errors/git-plugin-error.ts"() {
    "use strict";
    init_git_error();
    GitPluginError = class extends GitError {
      constructor(task, plugin, message) {
        super(task, message);
        this.task = task;
        this.plugin = plugin;
        Object.setPrototypeOf(this, new.target.prototype);
      }
    };
  }
});

// src/lib/errors/task-configuration-error.ts
var TaskConfigurationError;
var init_task_configuration_error = __esm({
  "src/lib/errors/task-configuration-error.ts"() {
    "use strict";
    init_git_error();
    TaskConfigurationError = class extends GitError {
      constructor(message) {
        super(void 0, message);
      }
    };
  }
});

// src/lib/utils/util.ts
/**
 * Converts an input to a function if it is already one; otherwise returns a no-operation function.
 *
 * @param {any} source - The input that needs to be converted into a function.
 * @returns {function} - A function if the input is callable, otherwise a no-operation function.
 *
 * Example usage:
 * asFunction(function() { console.log('Hello'); }); // Returns the provided function
 * asFunction('not a function');                 // Returns NOOP (a no-operation function)
 */
function asFunction(source) {
  return typeof source === "function" ? source : NOOP;
}
/**
 * Determines whether the provided source is a user function.
 *
 * @param {any} source - The source to check.
 * @returns {boolean} - True if the source is a user function and not NOOP, false otherwise.
 */
function isUserFunction(source) {
  return typeof source === "function" && source !== NOOP;
}
/**
 * Splits a string into two parts at the first occurrence of a specified character.
 *
 * @param {string} input - The string to be split.
 * @param {string} char - The character that acts as the separator.
 * @returns {[string, string]} A tuple containing the part before the separator and the part after it.
 * @throws {Error} If `input` is not a string or if `char` is an empty string.
 *
 * @example
 * const result = splitOn("Hello,World", ",");
 * console.log(result); // ['Hello', 'World']
 */
function splitOn(input, char) {
  const index = input.indexOf(char);
  if (index <= 0) {
    return [input, ""];
  }
  return [input.substr(0, index), input.substr(index + 1)];
}
/**
 * Retrieves the first element of an array-like object or undefined if the offset is out of bounds.
 *
 * @param {ArrayLike} input - The array-like object to retrieve the element from.
 * @param {number} [offset=0] - The index of the element to retrieve. Defaults to 0.
 * @returns {*} The first element of the array-like object or undefined if the offset is out of bounds.
 *
 * @example
 * first([1, 2, 3], 0); // returns 1
 * first('hello', 1);   // returns 'e'
 * first(null, 0);      // returns undefined
 */
function first(input, offset = 0) {
  return isArrayLike(input) && input.length > offset ? input[offset] : void 0;
}
/**
 * Returns the last element of an array-like object, optionally offset by a given number.
 *
 * @param {ArrayLike} input - The array-like object to retrieve the last element from.
 * @param {number} [offset=0] - The number of elements to offset from the end. Defaults to 0.
 * @returns {*} - The last element of the array-like object, or undefined if out of bounds.
 *
 * @example
 * // Returns the last element of an array
 * console.log(last([1, 2, 3])); // Output: 3
 *
 * @example
 * // Returns the second to last element of a string
 * console.log(last("hello", 1)); // Output: 'l'
 */
function last(input, offset = 0) {
  if (isArrayLike(input) && input.length > offset) {
    return input[input.length - 1 - offset];
  }
}
/**
 * Determines if the provided input is array-like.
 *
 * An array-like object has a length property that is a non-negative integer.
 *
 * @param {any} input - The value to be checked.
 * @returns {boolean} - Returns true if the input is array-like, false otherwise.
 */
function isArrayLike(input) {
  return !!(input && typeof input.length === "number");
}
/**
 * Splits an input string into lines containing content based on a specified separator.
 *
 * @param {string} [input=""] - The input string to be split. Defaults to an empty string if not provided.
 * @param {boolean} [trimmed2=true] - Whether to trim each line before checking for content. Defaults to true.
 * @param {string} [separator="\n"] - The character used to separate lines in the input string. Defaults to a newline character.
 * @returns {Array<string>} An array of strings, each representing a non-empty line from the input.
 *
 * @example
 * const result = toLinesWithContent("Hello\n  \nWorld");
 * console.log(result); // Output: ["Hello", "World"]
 */
function toLinesWithContent(input = "", trimmed2 = true, separator = "\n") {
  return input.split(separator).reduce((output, line) => {
    const lineContent = trimmed2 ? line.trim() : line;
    if (lineContent) {
      output.push(lineContent);
    }
    return output;
  }, []);
}
/**
 * Iterates over each line with content in the input string, applying the provided callback function to each line.
 *
 * @param {string} input - The input string containing multiple lines.
 * @param {function(string): any} callback - The function to apply to each line. It receives the line as its parameter and returns a value.
 * @returns {Array<any>} An array of values returned by the callback function for each line.
 *
 * @example
 * const lines = "Hello\nWorld\n\nFoo";
 * const results = forEachLineWithContent(lines, (line) => line.toUpperCase());
 * console.log(results); // Output: ['HELLO', 'WORLD', 'FOO']
 */
function forEachLineWithContent(input, callback) {
  return toLinesWithContent(input, true).map((line) => callback(line));
}
/**
 * Checks if a folder exists at the specified path.
 *
 * @param {string} path - The path to check for the folder.
 * @returns {boolean} - Returns true if the folder exists, otherwise false.
 * @throws {Error} - Throws an error if there is an issue checking the existence of the path.
 * @example
 * const path = '/path/to/folder';
 * try {
 *   const exists = folderExists(path);
 *   console.log(`Folder exists: ${exists}`);
 * } catch (error) {
 *   console.error('Error checking folder existence:', error.message);
 * }
 */
function folderExists(path) {
  return (0, import_file_exists.exists)(path, import_file_exists.FOLDER);
}
/**
 * Appends an item to a target array or set.
 *
 * @param {Array|Set} target - The array or set to which the item will be appended.
 * @param {*} item - The item to append to the target.
 * @returns {*} The appended item.
 *
 * @example
 * // Appending to an array
 * let arr = [1, 2, 3];
 * append(arr, 4);
 * console.log(arr); // Output: [1, 2, 3, 4]
 *
 * // Appending to a set
 * let set = new Set([1, 2, 3]);
 * append(set, 4);
 * console.log([...set]); // Output: [1, 2, 3, 4]
 */
function append(target, item) {
  if (Array.isArray(target)) {
    if (!target.includes(item)) {
      target.push(item);
    }
  } else {
    target.add(item);
  }
  return item;
}
/**
 * Adds an item to the target if it is not already included.
 *
 * @param {Array} target - The array to which the item will be added.
 * @param {*} item - The item to add to the array.
 * @returns {Array} - The modified array with the item added if necessary.
 * @throws {TypeError} If `target` is not an array.
 *
 * @example
 * // Returns [1, 2]
 * including([], 1);
 *
 * @example
 * // Returns [1, 2]
 * including([1], 2);
 *
 * @example
 * // Throws TypeError: target must be an array
 * including('string', 1);
 */
function including(target, item) {
  if (Array.isArray(target) && !target.includes(item)) {
    target.push(item);
  }
  return target;
}
function remove(target, item) {
  if (Array.isArray(target)) {
    const index = target.indexOf(item);
    if (index >= 0) {
      target.splice(index, 1);
    }
  } else {
    target.delete(item);
  }
  return item;
}
/**
 * Converts a source to an array. If the source is already an array,
 * it returns the source; otherwise, it wraps the source in an array.
 *
 * @param {any} source - The source to convert to an array.
 * @returns {Array} An array containing the source element(s).
 */
function asArray(source) {
  return Array.isArray(source) ? source : [source];
}
function asCamelCase(str) {
  return str.replace(/[\s-]+(.)/g, (_all, chr) => {
    return chr.toUpperCase();
  });
}
/**
 * Converts an array-like object or iterable into an array of strings.
 *
 * @param {ArrayLike|string|Iterable} source - The source to convert into an array of strings.
 * @returns {string[]} An array where each element is converted to a string.
 * @throws {TypeError} If the source is not convertible to an array or iterable.
 *
 * Example:
 *   asStringArray([1, 2, 3]); // ['1', '2', '3']
 *   asStringArray('hello'); // ['h', 'e', 'l', 'l', 'o']
 */
function asStringArray(source) {
  return asArray(source).map(String);
}
function asNumber(source, onNaN = 0) {
  if (source == null) {
    return onNaN;
  }
  const num = parseInt(source, 10);
  return isNaN(num) ? onNaN : num;
}
/**
 * Creates an array with each element prefixed by a specified value.
 *
 * @param {Array} input - The array to prefix.
 * @param {*} prefix - The value to prepend before each element of the input array.
 * @returns {Array} A new array with the prefix added before each original element.
 *
 * @example
 * // Returns ['prefix', 1, 'prefix', 2]
 * prefixedArray([1, 2], 'prefix');
 */
function prefixedArray(input, prefix) {
  const output = [];
  for (let i = 0, max = input.length; i < max; i++) {
    output.push(prefix, input[i]);
  }
  return output;
}
function bufferToString(input) {
  return (Array.isArray(input) ? Buffer.concat(input) : input).toString("utf-8");
}
/**
 * Selects specified properties from an object and returns a new object containing those properties.
 *
 * @param {Object} source - The source object from which to select properties.
 * @param {Array<string>} properties - An array of property names to be selected from the source object.
 * @returns {Object} A new object containing only the specified properties from the source object.
 * @throws {TypeError} If `source` is not an object or if any element in `properties` is not a string.
 *
 * @example
 * const obj = { name: 'John', age: 30, city: 'New York' };
 * const selectedProps = pick(obj, ['name', 'city']);
 * console.log(selectedProps); // Output: { name: 'John', city: 'New York' }
 */
function pick(source, properties) {
  return Object.assign(
    {},
    ...properties.map((property) => property in source ? { [property]: source[property] } : {})
  );
}
/**
 * Returns a Promise that resolves after a specified duration of time.
 *
 * @param {number} [duration=0] - The duration in milliseconds to wait before resolving the Promise. Defaults to 0 if not provided.
 * @return {Promise<void>} A Promise that will resolve after the specified duration.
 */
function delay(duration = 0) {
  return new Promise((done) => setTimeout(done, duration));
}
/**
 * Returns the input if it is not false; otherwise, returns undefined.
 *
 * @param {any} input - The value to check.
 * @returns {any|undefined} - The input if it is not false, otherwise undefined.
 */
function orVoid(input) {
  if (input === false) {
    return void 0;
  }
  return input;
}
var import_file_exists, NULL, NOOP, objectToString;
var init_util = __esm({
  "src/lib/utils/util.ts"() {
    "use strict";
    import_file_exists = require("@kwsites/file-exists");
    NULL = "\0";
    NOOP = () => {
    };
    objectToString = Object.prototype.toString.call.bind(Object.prototype.toString);
  }
});

// src/lib/utils/argument-filters.ts
/**
 * Filters an input value based on a provided filter function.
 *
 * @param {any} input - The value to be filtered.
 * @param {Function} filter - A function that determines whether the input should pass the filter. It should return a boolean.
 * @param {any} [def=undefined] - The default value to return if the input does not pass the filter. Optional.
 * @returns {any} The filtered input if it passes the filter, otherwise the default value or undefined.
 *
 * Example:
 * const isNumber = (value) => typeof value === 'number';
 * console.log(filterType(5, isNumber)); // Output: 5
 * console.log(filterType('hello', isNumber)); // Output: undefined
 */
function filterType(input, filter, def) {
  if (filter(input)) {
    return input;
  }
  return arguments.length > 2 ? def : void 0;
}
/**
 * Filters primitives from the given input based on type and omit criteria.
 *
 * @param {any} input - The input to be filtered. Can be of any type.
 * @param {(Array<string>|null)} [omit=null] - An array of types to omit from the result. If null, no types will be omitted.
 * @returns {boolean} - Returns true if the input is a primitive and not in the omit list; otherwise, false.
 *
 * Example:
 *   filterPrimitives(123)        // returns true
 *   filterPrimitives("hello")    // returns true
 *   filterPrimitives(true)       // returns true
 *   filterPrimitives([], [Array])  // returns false
 */
function filterPrimitives(input, omit) {
  const type = isPathSpec(input) ? "string" : typeof input;
  return /number|string|boolean/.test(type) && (!omit || !omit.includes(type));
}
/**
 * Filters and returns true if the input is a plain JavaScript object.
 *
 * @param {any} input - The input value to be checked.
 * @returns {boolean} - Returns true if the input is a plain JavaScript object, false otherwise.
 */
function filterPlainObject(input) {
  return !!input && objectToString(input) === "[object Object]";
}
/**
 * Filters an input to determine if it is a function.
 *
 * @param {any} input - The input to be checked.
 * @returns {boolean} - True if the input is a function, false otherwise.
 *
 * Example:
 *   filterFunction(function() {}); // returns true
 *   filterFunction("not a function"); // returns false
 */
function filterFunction(input) {
  return typeof input === "function";
}
var filterArray, filterString, filterStringArray, filterStringOrStringArray, filterHasLength;
var init_argument_filters = __esm({
  "src/lib/utils/argument-filters.ts"() {
    "use strict";
    init_util();
    init_pathspec();
    filterArray = (input) => {
      return Array.isArray(input);
    };
    filterString = (input) => {
      return typeof input === "string";
    };
    filterStringArray = (input) => {
      return Array.isArray(input) && input.every(filterString);
    };
    filterStringOrStringArray = (input) => {
      return filterString(input) || Array.isArray(input) && input.every(filterString);
    };
    filterHasLength = (input) => {
      if (input == null || "number|boolean|function".includes(typeof input)) {
        return false;
      }
      return Array.isArray(input) || typeof input === "string" || typeof input.length === "number";
    };
  }
});

// src/lib/utils/exit-codes.ts
var ExitCodes;
var init_exit_codes = __esm({
  "src/lib/utils/exit-codes.ts"() {
    "use strict";
    ExitCodes = /* @__PURE__ */ ((ExitCodes2) => {
      ExitCodes2[ExitCodes2["SUCCESS"] = 0] = "SUCCESS";
      ExitCodes2[ExitCodes2["ERROR"] = 1] = "ERROR";
      ExitCodes2[ExitCodes2["NOT_FOUND"] = -2] = "NOT_FOUND";
      ExitCodes2[ExitCodes2["UNCLEAN"] = 128] = "UNCLEAN";
      return ExitCodes2;
    })(ExitCodes || {});
  }
});

// src/lib/utils/git-output-streams.ts
var GitOutputStreams;
var init_git_output_streams = __esm({
  "src/lib/utils/git-output-streams.ts"() {
    "use strict";
    GitOutputStreams = class {
      constructor(stdOut, stdErr) {
        this.stdOut = stdOut;
        this.stdErr = stdErr;
      }
      asStrings() {
        return new GitOutputStreams(this.stdOut.toString("utf8"), this.stdErr.toString("utf8"));
      }
    };
  }
});

// src/lib/utils/line-parser.ts
var LineParser, RemoteLineParser;
var init_line_parser = __esm({
  "src/lib/utils/line-parser.ts"() {
    "use strict";
    LineParser = class {
      constructor(regExp, useMatches) {
        this.matches = [];
        this.parse = (line, target) => {
          this.resetMatches();
          if (!this._regExp.every((reg, index) => this.addMatch(reg, index, line(index)))) {
            return false;
          }
          return this.useMatches(target, this.prepareMatches()) !== false;
        };
        this._regExp = Array.isArray(regExp) ? regExp : [regExp];
        if (useMatches) {
          this.useMatches = useMatches;
        }
      }
      useMatches(target, match) {
        throw new Error(`LineParser:useMatches not implemented`);
      }
      resetMatches() {
        this.matches.length = 0;
      }
      prepareMatches() {
        return this.matches;
      }
      addMatch(reg, index, line) {
        const matched = line && reg.exec(line);
        if (matched) {
          this.pushMatch(index, matched);
        }
        return !!matched;
      }
      pushMatch(_index, matched) {
        this.matches.push(...matched.slice(1));
      }
    };
    RemoteLineParser = class extends LineParser {
      addMatch(reg, index, line) {
        return /^remote:\s/.test(String(line)) && super.addMatch(reg, index, line);
      }
      pushMatch(index, matched) {
        if (index > 0 || matched.length > 1) {
          super.pushMatch(index, matched);
        }
      }
    };
  }
});

// src/lib/utils/simple-git-options.ts
/**
 * Creates an instance configuration object with default options and additional provided options.
 *
 * @param {...Object} [options] - Additional options to merge into the base configuration. Only objects are considered.
 * @return {Object} The merged configuration object, which includes a `baseDir` property and a `trimmed` property.
 *
 * Example:
 *   const config = createInstanceConfig({ baseDir: '/custom/dir', trimmed: true });
 *   // config will be { baseDir: '/custom/dir', trimmed: true }
 */
function createInstanceConfig(...options) {
  const baseDir = process.cwd();
  const config = Object.assign(
    __spreadValues({ baseDir }, defaultOptions),
    ...options.filter((o) => typeof o === "object" && o)
  );
  config.baseDir = config.baseDir || baseDir;
  config.trimmed = config.trimmed === true;
  return config;
}
var defaultOptions;
var init_simple_git_options = __esm({
  "src/lib/utils/simple-git-options.ts"() {
    "use strict";
    defaultOptions = {
      binary: "git",
      maxConcurrentProcesses: 5,
      config: [],
      trimmed: false
    };
  }
});

// src/lib/utils/task-options.ts
/**
 * Appends task options to a commands array based on the provided options object.
 *
 * @param {Object} options - The options object containing key-value pairs for task configuration.
 * @param {string[]} [commands=[]] - The initial array of command strings to which options will be appended.
 * @returns {string[]} The updated array of command strings with options appended.
 * @throws {Error} If the options parameter is not a plain object.
 *
 * @example
 * const commands = appendTaskOptions({ outputPath: "/path/to/output", verbose: true }, ["run"]);
 * console.log(commands); // Output: ["/path/to/output", "verbose=true", "run"]
 */
function appendTaskOptions(options, commands = []) {
  if (!filterPlainObject(options)) {
    return commands;
  }
  return Object.keys(options).reduce((commands2, key) => {
    const value = options[key];
    if (isPathSpec(value)) {
      commands2.push(value);
    } else if (filterPrimitives(value, ["boolean"])) {
      commands2.push(key + "=" + value);
    } else {
      commands2.push(key);
    }
    return commands2;
  }, commands);
}
/**
 * Retrieves trailing options from an array of arguments based on specified criteria.
 *
 * @param {Array} args - The array of arguments to process.
 * @param {number} initialPrimitive - The number of initial primitive elements to consider. Default is 0.
 * @param {boolean} objectOnly - Flag indicating whether to include only objects in the result. Default is false.
 * @returns {Array} An array containing the trailing options based on the provided criteria.
 *
 * @example
 * getTrailingOptions(['a', 1, true, {}, []], 2); // returns ['true', '{}', '[]']
 * getTrailingOptions([false, null, undefined], -1, true); // returns [false]
 */
function getTrailingOptions(args, initialPrimitive = 0, objectOnly = false) {
  const command = [];
  for (let i = 0, max = initialPrimitive < 0 ? args.length : initialPrimitive; i < max; i++) {
    if ("string|number".includes(typeof args[i])) {
      command.push(String(args[i]));
    }
  }
  appendTaskOptions(trailingOptionsArgument(args), command);
  if (!objectOnly) {
    command.push(...trailingArrayArgument(args));
  }
  return command;
}
/**
 * Determines if the last argument of an array is a callback function.
 *
 * @param {Array} args - The array to check.
 * @return {boolean} True if the last argument is a function, false otherwise.
 */
function trailingArrayArgument(args) {
  const hasTrailingCallback = typeof last(args) === "function";
  return filterType(last(args, hasTrailingCallback ? 1 : 0), filterArray, []);
}
/**
 * Determines if the last argument of an array is a callback function.
 *
 * @param {Array} args - The array to check.
 * @returns {boolean} True if the last argument is a callback, false otherwise.
 */
function trailingOptionsArgument(args) {
  const hasTrailingCallback = filterFunction(last(args));
  return filterType(last(args, hasTrailingCallback ? 1 : 0), filterPlainObject);
}
/**
 * Extracts the last function from an array of arguments, optionally including no-operation functions.
 *
 * @param {Array} args - The array of arguments to process.
 * @param {boolean} [includeNoop=true] - If true, includes no-operation (void 0) functions in the result. Defaults to true.
 * @returns {(Function|undefined)} - The last function from the arguments, or undefined if no function is found and includeNoop is false.
 *
 * @example
 * const result = trailingFunctionArgument([1, 2, () => console.log('Hello')]);
 * // result will be () => console.log('Hello')
 */
function trailingFunctionArgument(args, includeNoop = true) {
  const callback = asFunction(last(args));
  return includeNoop || isUserFunction(callback) ? callback : void 0;
}
var init_task_options = __esm({
  "src/lib/utils/task-options.ts"() {
    "use strict";
    init_argument_filters();
    init_util();
    init_pathspec();
  }
});

// src/lib/utils/task-parser.ts
/**
 * Calls a task parser with provided standard output and error streams.
 *
 * @param {Function} parser4 - The parser function to be called. It should accept two parameters: `stdOut` and `stdErr`.
 * @param {Object} streams - An object containing the streams for standard output (`stdOut`) and standard error (`stdErr`).
 * @returns {*} The result of calling the parser function with the provided streams.
 *
 * @example
 * const parser = (out, err) => {
 *   return { out: out.toString(), err: err.toString() };
 * };
 * const streams = { stdOut: process.stdout, stdErr: process.stderr };
 * const result = callTaskParser(parser, streams);
 * console.log(result); // { out: '...', err: '...' }
 */
function callTaskParser(parser4, streams) {
  return parser4(streams.stdOut, streams.stdErr);
}
/**
 * Parses a string response using provided parsers.
 *
 * @param {any} result - The initial result object to be populated by parsers.
 * @param {Array<{parse: Function}>} parsers12 - An array of parser objects, each with a `parse` function.
 * @param {Array<string>|string} texts - An array or string containing the text(s) to parse.
 * @param {boolean} [trim=true] - Whether to trim the lines before parsing. Defaults to true.
 * @returns {any} The updated result object after all parsers have been applied.
 *
 * @example
 * const result = {};
 * const parsers12 = [
 *   {
 *     parse: (line, result) => {
 *       if (line.includes('data')) {
 *         result.data = line.split(': ')[1];
 *       }
 *     }
 *   },
 *   // Add more parsers as needed
 * ];
 *
 * const text = "This is a sample response.\nData: 1234";
 * parseStringResponse(result, parsers12, text);
 * console.log(result); // { data: '1234' }
 */
function parseStringResponse(result, parsers12, texts, trim = true) {
  asArray(texts).forEach((text) => {
    for (let lines = toLinesWithContent(text, trim), i = 0, max = lines.length; i < max; i++) {
      /**
       * Retrieves a line from an array of lines at a specified offset.
       *
       * @param {number} [offset=0] - The offset from the current index to retrieve the line. Defaults to 0.
       * @returns {string|undefined} - The line at the specified offset if within bounds, otherwise undefined.
       *
       * Example usage:
       * const lines = ['Hello', 'World'];
       * const result = line(1); // returns 'World'
       */
      const line = (offset = 0) => {
        if (i + offset >= max) {
          return;
        }
        return lines[i + offset];
      };
      parsers12.some(({ parse }) => parse(line, result));
    }
  });
  return result;
}
var init_task_parser = __esm({
  "src/lib/utils/task-parser.ts"() {
    "use strict";
    init_util();
  }
});

// src/lib/utils/index.ts
var utils_exports = {};
__export(utils_exports, {
  ExitCodes: () => ExitCodes,
  GitOutputStreams: () => GitOutputStreams,
  LineParser: () => LineParser,
  NOOP: () => NOOP,
  NULL: () => NULL,
  RemoteLineParser: () => RemoteLineParser,
  append: () => append,
  appendTaskOptions: () => appendTaskOptions,
  asArray: () => asArray,
  asCamelCase: () => asCamelCase,
  asFunction: () => asFunction,
  asNumber: () => asNumber,
  asStringArray: () => asStringArray,
  bufferToString: () => bufferToString,
  callTaskParser: () => callTaskParser,
  createInstanceConfig: () => createInstanceConfig,
  delay: () => delay,
  filterArray: () => filterArray,
  filterFunction: () => filterFunction,
  filterHasLength: () => filterHasLength,
  filterPlainObject: () => filterPlainObject,
  filterPrimitives: () => filterPrimitives,
  filterString: () => filterString,
  filterStringArray: () => filterStringArray,
  filterStringOrStringArray: () => filterStringOrStringArray,
  filterType: () => filterType,
  first: () => first,
  folderExists: () => folderExists,
  forEachLineWithContent: () => forEachLineWithContent,
  getTrailingOptions: () => getTrailingOptions,
  including: () => including,
  isUserFunction: () => isUserFunction,
  last: () => last,
  objectToString: () => objectToString,
  orVoid: () => orVoid,
  parseStringResponse: () => parseStringResponse,
  pick: () => pick,
  prefixedArray: () => prefixedArray,
  remove: () => remove,
  splitOn: () => splitOn,
  toLinesWithContent: () => toLinesWithContent,
  trailingFunctionArgument: () => trailingFunctionArgument,
  trailingOptionsArgument: () => trailingOptionsArgument
});
var init_utils = __esm({
  "src/lib/utils/index.ts"() {
    "use strict";
    init_argument_filters();
    init_exit_codes();
    init_git_output_streams();
    init_line_parser();
    init_simple_git_options();
    init_task_options();
    init_task_parser();
    init_util();
  }
});

// src/lib/tasks/check-is-repo.ts
var check_is_repo_exports = {};
__export(check_is_repo_exports, {
  CheckRepoActions: () => CheckRepoActions,
  checkIsBareRepoTask: () => checkIsBareRepoTask,
  checkIsRepoRootTask: () => checkIsRepoRootTask,
  checkIsRepoTask: () => checkIsRepoTask
});
/**
 * Determines if the provided action corresponds to a repository task.
 *
 * @param {string} action - The action to check. Expected values are "bare" and "root".
 * @returns {Object|string|boolean} - Depending on the action, returns either an object with commands,
 *    format, onError, and parser properties, or a boolean indicating if the repository is root.
 * @throws {Error} - If an unrecognized action is provided.
 */
function checkIsRepoTask(action) {
  switch (action) {
    case "bare" /* BARE */:
      return checkIsBareRepoTask();
    case "root" /* IS_REPO_ROOT */:
      return checkIsRepoRootTask();
  }
  const commands = ["rev-parse", "--is-inside-work-tree"];
  return {
    commands,
    format: "utf-8",
    onError,
    parser
  };
}
/**
 * Generates a task to check if the current directory is the root of a Git repository.
 *
 * @returns {Object} - An object containing the following properties:
 *   commands {Array<string>} - The commands to be executed for this task.
 *   format {string} - The expected format of the output (e.g., "utf-8").
 *   onError {Function} - A function to handle errors that may occur during execution.
 *   parser {Function} - A function used to parse the output and determine if the directory is a Git repository root.
 */
function checkIsRepoRootTask() {
  const commands = ["rev-parse", "--git-dir"];
  return {
    commands,
    format: "utf-8",
    onError,
    parser(path) {
      return /^\.(git)?$/.test(path.trim());
    }
  };
}
/**
 * Generates a task configuration to check if a repository is bare.
 *
 * @returns {Object} A configuration object containing the commands for checking if a repository is bare, the expected output format,
 * and error handling functions.
 * @property {string[]} commands - The array of Git commands to execute. In this case, it contains "rev-parse --is-bare-repository".
 * @property {string} format - The expected format of the output from running the commands. Here, it's set to "utf-8".
 * @property {Function} onError - A function to handle errors that occur during the execution of the task.
 * @property {Function} parser - A function to parse the output of the command and return a meaningful result.
 */
function checkIsBareRepoTask() {
  const commands = ["rev-parse", "--is-bare-repository"];
  return {
    commands,
    format: "utf-8",
    onError,
    parser
  };
}
function isNotRepoMessage(error) {
  return /(Not a git repository|Kein Git-Repository)/i.test(String(error));
}
var CheckRepoActions, onError, parser;
var init_check_is_repo = __esm({
  "src/lib/tasks/check-is-repo.ts"() {
    "use strict";
    init_utils();
    CheckRepoActions = /* @__PURE__ */ ((CheckRepoActions2) => {
      CheckRepoActions2["BARE"] = "bare";
      CheckRepoActions2["IN_TREE"] = "tree";
      CheckRepoActions2["IS_REPO_ROOT"] = "root";
      return CheckRepoActions2;
    })(CheckRepoActions || {});
    onError = ({ exitCode }, error, done, fail) => {
      if (exitCode === 128 /* UNCLEAN */ && isNotRepoMessage(error)) {
        return done(Buffer.from("false"));
      }
      fail(error);
    };
    parser = (text) => {
      return text.trim() === "true";
    };
  }
});

// src/lib/responses/CleanSummary.ts
/**
 * Parses the input text to extract paths, segregating them into files and folders based on whether they match a folder pattern.
 *
 * @param {boolean} dryRun - Indicates if this is a dry run (whether to remove certain patterns or not).
 * @param {string} text - The input text containing lines of file and folder paths to be processed.
 * @returns {CleanResponse} - An object containing the parsed paths, segregated into files and folders.
 *
 * @example
 * const result = cleanSummaryParser(false, "src/index.js\nlib/utils.js\ndata/config.json");
 * console.log(result);
 * // Output: {
 * //   dryRun: false,
 * //   paths: ["src/index.js", "lib/utils.js", "data/config.json"],
 * //   folders: [],
 * //   files: ["src/index.js", "lib/utils.js", "data/config.json"]
 * // }
 */
function cleanSummaryParser(dryRun, text) {
  const summary = new CleanResponse(dryRun);
  const regexp = dryRun ? dryRunRemovalRegexp : removalRegexp;
  toLinesWithContent(text).forEach((line) => {
    const removed = line.replace(regexp, "");
    summary.paths.push(removed);
    (isFolderRegexp.test(removed) ? summary.folders : summary.files).push(removed);
  });
  return summary;
}
var CleanResponse, removalRegexp, dryRunRemovalRegexp, isFolderRegexp;
var init_CleanSummary = __esm({
  "src/lib/responses/CleanSummary.ts"() {
    "use strict";
    init_utils();
    CleanResponse = class {
      constructor(dryRun) {
        this.dryRun = dryRun;
        this.paths = [];
        this.files = [];
        this.folders = [];
      }
    };
    removalRegexp = /^[a-z]+\s*/i;
    dryRunRemovalRegexp = /^[a-z]+\s+[a-z]+\s*/i;
    isFolderRegexp = /\/$/;
  }
});

// src/lib/tasks/task.ts
var task_exports = {};
__export(task_exports, {
  EMPTY_COMMANDS: () => EMPTY_COMMANDS,
  adhocExecTask: () => adhocExecTask,
  configurationErrorTask: () => configurationErrorTask,
  isBufferTask: () => isBufferTask,
  isEmptyTask: () => isEmptyTask,
  straightThroughBufferTask: () => straightThroughBufferTask,
  straightThroughStringTask: () => straightThroughStringTask
});
/**
 * Executes an ad-hoc task using the provided parser.
 *
 * @param {Parser} parser4 - The parser to use for executing the task.
 * @returns {Object} An object containing properties for commands, format, and parser.
 * @property {Array} commands - A list of commands. Defaults to an empty array.
 * @property {string} format - The format of the output. Defaults to "empty".
 * @property {Parser} parser - The parser used for executing the task.
 *
 * @example
 * const parser = new MyParser();
 * const result = adhocExecTask(parser);
 * console.log(result); // { commands: [], format: 'empty', parser: MyParser {} }
 */
function adhocExecTask(parser4) {
  return {
    commands: EMPTY_COMMANDS,
    format: "empty",
    parser: parser4
  };
}
/**
 * Creates an error task configuration.
 *
 * @param {string|Error} error - The error to throw when parsing. If a string is provided, it will be converted into a `TaskConfigurationError`.
 * @returns {Object} A task configuration object with empty commands and format set to "empty".
 * @throws {TaskConfigurationError} Throws the provided error or a new `TaskConfigurationError` if the error is a string.
 */
function configurationErrorTask(error) {
  return {
    commands: EMPTY_COMMANDS,
    format: "empty",
    parser() {
      throw typeof error === "string" ? new TaskConfigurationError(error) : error;
    }
  };
}
/**
 * Creates an object with command data and a parser for text formatting.
 *
 * @param {string[]} commands - An array of command strings to be executed.
 * @param {boolean} [trimmed2=false] - If true, trims the input text before parsing.
 * @returns {{commands: string[], format: string, parser: function}} An object containing the commands,
 *                      a fixed format set to "utf-8", and a parser function that optionally trims the text.
 *
 * Example:
 * const task = straightThroughStringTask(["echo Hello"], true);
 * console.log(task.parser("   Hello   ")); // Output: "Hello"
 */
function straightThroughStringTask(commands, trimmed2 = false) {
  return {
    commands,
    format: "utf-8",
    parser(text) {
      return trimmed2 ? String(text).trim() : text;
    }
  };
}
/**
 * Creates a task that processes commands directly without any transformation.
 *
 * @param {Array<Object>} commands - The array of commands to be processed.
 * @returns {Object} A task object containing the commands, format, and parser.
 * @throws {Error} If the input commands are not an array or if it's empty.
 */
function straightThroughBufferTask(commands) {
  return {
    commands,
    format: "buffer",
    parser(buffer) {
      return buffer;
    }
  };
}
function isBufferTask(task) {
  return task.format === "buffer";
}
/**
 * Determines if a given task is empty.
 *
 * @param {Object} task - The task object to check.
 * @returns {boolean} - Returns true if the task is empty, otherwise false.
 *
 * Example:
 * const task = { format: "empty", commands: [] };
 * console.log(isEmptyTask(task)); // Output: true
 */
function isEmptyTask(task) {
  return task.format === "empty" || !task.commands.length;
}
var EMPTY_COMMANDS;
var init_task = __esm({
  "src/lib/tasks/task.ts"() {
    "use strict";
    init_task_configuration_error();
    EMPTY_COMMANDS = [];
  }
});

// src/lib/tasks/clean.ts
var clean_exports = {};
__export(clean_exports, {
  CONFIG_ERROR_INTERACTIVE_MODE: () => CONFIG_ERROR_INTERACTIVE_MODE,
  CONFIG_ERROR_MODE_REQUIRED: () => CONFIG_ERROR_MODE_REQUIRED,
  CONFIG_ERROR_UNKNOWN_OPTION: () => CONFIG_ERROR_UNKNOWN_OPTION,
  CleanOptions: () => CleanOptions,
  cleanTask: () => cleanTask,
  cleanWithOptionsTask: () => cleanWithOptionsTask,
  isCleanOptionsArray: () => isCleanOptionsArray
});
/**
 * Executes a cleaning task with custom options.
 *
 * @param {string} mode - The mode for the cleaning process, which determines the type of cleaning to be performed.
 * @param {Array<string>} customArgs - Additional arguments to be passed to the cleaning task.
 * @returns {Promise<void>} A promise that resolves when the cleaning task has been executed successfully.
 *
 * @throws {Error} Throws an error if the clean mode is not provided or if there are unknown options in the mode configuration.
 * @throws {Error} Throws an error if any of the options indicate interactive mode, which is not supported for this task.
 */
function cleanWithOptionsTask(mode, customArgs) {
  const { cleanMode, options, valid } = getCleanOptions(mode);
  if (!cleanMode) {
    return configurationErrorTask(CONFIG_ERROR_MODE_REQUIRED);
  }
  if (!valid.options) {
    return configurationErrorTask(CONFIG_ERROR_UNKNOWN_OPTION + JSON.stringify(mode));
  }
  options.push(...customArgs);
  if (options.some(isInteractiveMode)) {
    return configurationErrorTask(CONFIG_ERROR_INTERACTIVE_MODE);
  }
  return cleanTask(cleanMode, options);
}
/**
 * Generates a command object for cleaning tasks based on the specified mode and custom arguments.
 *
 * @param {string} mode - The mode of the clean task, which determines the type of cleaning to be performed.
 * @param {Array<string>} [customArgs=[]] - Additional arguments that can be passed to the clean command.
 * @returns {Object} An object containing the commands array, format, and a parser function.
 *
 * @example
 * const task = cleanTask("n", ["--force"]);
 * console.log(task.commands); // Output: ["clean", "-n", "--force"]
 */
function cleanTask(mode, customArgs) {
  const commands = ["clean", `-${mode}`, ...customArgs];
  return {
    commands,
    format: "utf-8",
    parser(text) {
      return cleanSummaryParser(mode === "n" /* DRY_RUN */, text);
    }
  };
}
/**
 * Checks if the input is a clean array of options.
 *
 * @param {any[]} input - The input to check.
 * @returns {boolean} - True if the input is a clean array of options, false otherwise.
 */
function isCleanOptionsArray(input) {
  return Array.isArray(input) && input.every((test) => CleanOptionValues.has(test));
}
/**
 * Cleans and parses input string to extract clean mode and options.
 *
 * @param {string} input - The input string containing clean mode and options.
 * @returns {{cleanMode: string, options: Array<string>, valid: {cleanMode: boolean, options: boolean}}} An object containing the clean mode, an array of options, and validation flags.
 * @throws {Error} If the input string is invalid.
 *
 * @example
 * const result = getCleanOptions("--option1 -modeA");
 * console.log(result);
 * // Output: {
 * //   cleanMode: "modeA",
 * //   options: ["-option1"],
 * //   valid: { cleanMode: true, options: true }
 * // }
 */
function getCleanOptions(input) {
  let cleanMode;
  let options = [];
  let valid = { cleanMode: false, options: true };
  input.replace(/[^a-z]i/g, "").split("").forEach((char) => {
    if (isCleanMode(char)) {
      cleanMode = char;
      valid.cleanMode = true;
    } else {
      valid.options = valid.options && isKnownOption(options[options.length] = `-${char}`);
    }
  });
  return {
    cleanMode,
    options,
    valid
  };
}
/**
 * Determines if the provided clean mode is either "f" (FORCE) or "n" (DRY_RUN).
 *
 * @param {string} cleanMode - The clean mode to check.
 * @return {boolean} - Returns true if the clean mode is "f" or "n", false otherwise.
 */
function isCleanMode(cleanMode) {
  return cleanMode === "f" /* FORCE */ || cleanMode === "n" /* DRY_RUN */;
}
/**
 * Determines if the given option is a known command-line option based on a predefined set of clean option values.
 *
 * @param {string} option - The command-line option to check.
 * @returns {boolean} - Returns true if the option is known, false otherwise.
 * @throws {TypeError} - If the provided argument is not a string.
 */
function isKnownOption(option) {
  return /^-[a-z]$/i.test(option) && CleanOptionValues.has(option.charAt(1));
}
/**
 * Determines if the given option indicates interactive mode.
 *
 * @param {string} option - The command line option to check.
 * @returns {boolean} True if the option indicates interactive mode, false otherwise.
 *
 * Example:
 *   isInteractiveMode("-i")       // returns true
 *   isInteractiveMode("--interactive") // returns true
 *   isInteractiveMode("-s")       // returns false
 */
function isInteractiveMode(option) {
  if (/^-[^\-]/.test(option)) {
    return option.indexOf("i") > 0;
  }
  return option === "--interactive";
}
var CONFIG_ERROR_INTERACTIVE_MODE, CONFIG_ERROR_MODE_REQUIRED, CONFIG_ERROR_UNKNOWN_OPTION, CleanOptions, CleanOptionValues;
var init_clean = __esm({
  "src/lib/tasks/clean.ts"() {
    "use strict";
    init_CleanSummary();
    init_utils();
    init_task();
    CONFIG_ERROR_INTERACTIVE_MODE = "Git clean interactive mode is not supported";
    CONFIG_ERROR_MODE_REQUIRED = 'Git clean mode parameter ("n" or "f") is required';
    CONFIG_ERROR_UNKNOWN_OPTION = "Git clean unknown option found in: ";
    CleanOptions = /* @__PURE__ */ ((CleanOptions2) => {
      CleanOptions2["DRY_RUN"] = "n";
      CleanOptions2["FORCE"] = "f";
      CleanOptions2["IGNORED_INCLUDED"] = "x";
      CleanOptions2["IGNORED_ONLY"] = "X";
      CleanOptions2["EXCLUDING"] = "e";
      CleanOptions2["QUIET"] = "q";
      CleanOptions2["RECURSIVE"] = "d";
      return CleanOptions2;
    })(CleanOptions || {});
    CleanOptionValues = /* @__PURE__ */ new Set([
      "i",
      ...asStringArray(Object.values(CleanOptions))
    ]);
  }
});

// src/lib/responses/ConfigList.ts
/**
 * Parses a text input to create a configuration list.
 *
 * @param {string} text - The input text containing configuration items.
 * @return {ConfigList} A ConfigList object populated with parsed values.
 * @throws {Error} If the input text is invalid or cannot be parsed.
 */
function configListParser(text) {
  const config = new ConfigList();
  for (const item of configParser(text)) {
    config.addValue(item.file, String(item.key), item.value);
  }
  return config;
}
/**
 * Parses configuration text to extract values for a given key.
 *
 * @param {string} text - The configuration text to parse.
 * @param {string} key - The key whose values are to be extracted.
 * @returns {Object} An object containing the parsed data.
 * @property {string} key - The key for which values were extracted.
 * @property {Array<string>} paths - An array of unique file paths where the key is defined.
 * @property {Map<string, Array<any>>} scopes - A map where keys are file paths and values are arrays of corresponding parsed values.
 * @property {*} value - The last value associated with the given key (or null if no value was found).
 * @property {Array<*>} values - An array of all values associated with the given key.
 *
 * @example
 * const result = configGetParser("file1.js:option=value\nfile2.js:option=anotherValue", "option");
 * console.log(result);
 * // Output:
 * // {
 * //   key: 'option',
 * //   paths: ['file1.js', 'file2.js'],
 * //   scopes: Map { 'file1.js' => [ 'value' ], 'file2.js' => [ 'anotherValue' ] },
 * //   value: 'anotherValue',
 * //   values: [ 'value', 'anotherValue' ]
 * // }
 */
function configGetParser(text, key) {
  let value = null;
  const values = [];
  const scopes = /* @__PURE__ */ new Map();
  for (const item of configParser(text, key)) {
    if (item.key !== key) {
      continue;
    }
    values.push(value = item.value);
    if (!scopes.has(item.file)) {
      scopes.set(item.file, []);
    }
    scopes.get(item.file).push(value);
  }
  return {
    key,
    paths: Array.from(scopes.keys()),
    scopes,
    value,
    values
  };
}
/**
 * Removes the 'file:' prefix from a given file path if present.
 *
 * @param {string} filePath - The file path to process.
 * @returns {string} The processed file path with the 'file:' prefix removed.
 *
 * @example
 * configFilePath('file:/path/to/file.txt');
 * // returns '/path/to/file.txt'
 */
function configFilePath(filePath) {
  return filePath.replace(/^(file):/, "");
}
/**
 * Parses configuration text and yields key-value pairs with associated file paths.
 *
 * @generator
 * @param {string} text - The configuration text to parse.
 * @param {string|null} [requestedKey=null] - An optional key to filter the results. If provided, only entries with this key will be yielded.
 * @yields {{ file: string, key: string, value: string }} - An object containing the file path, key, and value of each configuration entry.
 *
 * @example
 * for (const entry of configParser("file1.conf\nkey1=value1", "key1")) {
 *   console.log(entry);
 * }
 * // Output:
 * // { file: 'file1.conf', key: 'key1', value: 'value1' }
 *
 * @throws {Error} - If the input text is not a valid configuration format.
 */
function* configParser(text, requestedKey = null) {
  const lines = text.split("\0");
  for (let i = 0, max = lines.length - 1; i < max; ) {
    const file = configFilePath(lines[i++]);
    let value = lines[i++];
    let key = requestedKey;
    if (value.includes("\n")) {
      const line = splitOn(value, "\n");
      key = line[0];
      value = line[1];
    }
    yield { file, key, value };
  }
}
var ConfigList;
var init_ConfigList = __esm({
  "src/lib/responses/ConfigList.ts"() {
    "use strict";
    init_utils();
    ConfigList = class {
      constructor() {
        this.files = [];
        this.values = /* @__PURE__ */ Object.create(null);
      }
      get all() {
        if (!this._all) {
          this._all = this.files.reduce((all, file) => {
            return Object.assign(all, this.values[file]);
          }, {});
        }
        return this._all;
      }
      addFile(file) {
        if (!(file in this.values)) {
          const latest = last(this.files);
          this.values[file] = latest ? Object.create(this.values[latest]) : {};
          this.files.push(file);
        }
        return this.values[file];
      }
      addValue(file, key, value) {
        const values = this.addFile(file);
        if (!values.hasOwnProperty(key)) {
          values[key] = value;
        } else if (Array.isArray(values[key])) {
          values[key].push(value);
        } else {
          values[key] = [values[key], value];
        }
        this._all = void 0;
      }
    };
  }
});

// src/lib/tasks/config.ts
/**
 * Returns a configuration scope based on the provided input.
 *
 * @param {string} scope - The configuration scope to check.
 * @param {string} fallback - The default configuration scope if the input is not valid.
 * @returns {string} - A valid GitConfigScope value or the fallback value.
 *
 * @example
 * // Returns 'global' as it is a valid GitConfigScope value
 * const configScope = asConfigScope('global', 'user');
 *
 * @example
 * // Returns 'user' as 'system' is not a valid GitConfigScope value
 * const configScope = asConfigScope('system', 'user');
 */
function asConfigScope(scope, fallback) {
  if (typeof scope === "string" && GitConfigScope.hasOwnProperty(scope)) {
    return scope;
  }
  return fallback;
}
/**
 * Adds a configuration task with the given key and value.
 *
 * @param {string} key - The key for the configuration.
 * @param {string} value - The value for the configuration.
 * @param {boolean} [append2=false] - If true, appends to the configuration.
 * @param {string} [scope="user"] - The scope of the configuration. Default is "user".
 * @returns {Object} An object containing the commands and parser function.
 * @property {Array<string>} commands - Array of command strings for the task.
 * @property {string} format - The expected output format, default is "utf-8".
 * @property {function} parser - Function to parse the text output, returns text as is.
 */
function addConfigTask(key, value, append2, scope) {
  const commands = ["config", `--${scope}`];
  if (append2) {
    commands.push("--add");
  }
  commands.push(key, value);
  return {
    commands,
    format: "utf-8",
    parser(text) {
      return text;
    }
  };
}
/**
 * Constructs a configuration task with specified key and scope.
 *
 * @param {string} key - The configuration key to retrieve.
 * @param {string} [scope] - (Optional) The scope of the configuration.
 * @returns {Object} A configuration task object containing commands, format, and parser.
 *
 * Example:
 * const task = getConfigTask('user.name', 'global');
 * console.log(task.commands); // ['config', '--null', '--show-origin', '--get-all', 'user.name', '--global']
 */
function getConfigTask(key, scope) {
  const commands = ["config", "--null", "--show-origin", "--get-all", key];
  if (scope) {
    commands.splice(1, 0, `--${scope}`);
  }
  return {
    commands,
    format: "utf-8",
    parser(text) {
      return configGetParser(text, key);
    }
  };
}
/**
 * Generates a configuration task with specified scope.
 *
 * @param {string} [scope] - The scope of the configuration to list. Optional.
 * @returns {Object} - An object containing commands, format, and parser method.
 * @returns {Array<string>} returns.commands - Commands array for the configuration listing.
 * @returns {string} returns.format - Output format, defaults to 'utf-8'.
 * @returns {function} returns.parser - Function to parse the output text.
 *
 * @example
 * const task = listConfigTask('global');
 * console.log(task.commands); // ['config', '--list', '--show-origin', '--null', '--global']
 */
function listConfigTask(scope) {
  const commands = ["config", "--list", "--show-origin", "--null"];
  if (scope) {
    commands.push(`--${scope}`);
  }
  return {
    commands,
    format: "utf-8",
    parser(text) {
      return configListParser(text);
    }
  };
}
/**
 * Returns an object with methods to manage configuration settings.
 * @returns {Object} An object containing the `addConfig`, `getConfig`, and `listConfig` methods.
 */
function config_default() {
  return {
    addConfig(key, value, ...rest) {
      return this._runTask(
        addConfigTask(
          key,
          value,
          rest[0] === true,
          asConfigScope(rest[1], "local" /* local */)
        ),
        trailingFunctionArgument(arguments)
      );
    },
    getConfig(key, scope) {
      return this._runTask(
        getConfigTask(key, asConfigScope(scope, void 0)),
        trailingFunctionArgument(arguments)
      );
    },
    listConfig(...rest) {
      return this._runTask(
        listConfigTask(asConfigScope(rest[0], void 0)),
        trailingFunctionArgument(arguments)
      );
    }
  };
}
var GitConfigScope;
var init_config = __esm({
  "src/lib/tasks/config.ts"() {
    "use strict";
    init_ConfigList();
    init_utils();
    GitConfigScope = /* @__PURE__ */ ((GitConfigScope2) => {
      GitConfigScope2["system"] = "system";
      GitConfigScope2["global"] = "global";
      GitConfigScope2["local"] = "local";
      GitConfigScope2["worktree"] = "worktree";
      return GitConfigScope2;
    })(GitConfigScope || {});
  }
});

// src/lib/tasks/diff-name-status.ts
/**
 * Checks if the input string exists as a key in the `diffNameStatus` set.
 *
 * @param {string} input - The string to check.
 * @returns {boolean} - Returns true if the input is found in `diffNameStatus`, false otherwise.
 */
function isDiffNameStatus(input) {
  return diffNameStatus.has(input);
}
var DiffNameStatus, diffNameStatus;
var init_diff_name_status = __esm({
  "src/lib/tasks/diff-name-status.ts"() {
    "use strict";
    DiffNameStatus = /* @__PURE__ */ ((DiffNameStatus2) => {
      DiffNameStatus2["ADDED"] = "A";
      DiffNameStatus2["COPIED"] = "C";
      DiffNameStatus2["DELETED"] = "D";
      DiffNameStatus2["MODIFIED"] = "M";
      DiffNameStatus2["RENAMED"] = "R";
      DiffNameStatus2["CHANGED"] = "T";
      DiffNameStatus2["UNMERGED"] = "U";
      DiffNameStatus2["UNKNOWN"] = "X";
      DiffNameStatus2["BROKEN"] = "B";
      return DiffNameStatus2;
    })(DiffNameStatus || {});
    diffNameStatus = new Set(Object.values(DiffNameStatus));
  }
});

// src/lib/tasks/grep.ts
/**
 * Creates an instance of GrepQuery and calls its param method with the provided parameters.
 *
 * @param {...*} params - The parameters to be passed to the GrepQuery's param method.
 * @returns {GrepQuery} An instance of GrepQuery with the parameters applied.
 */
function grepQueryBuilder(...params) {
  return new GrepQuery().param(...params);
}
/**
 * Parses grep output to extract paths and their corresponding line details.
 *
 * @param {string} grep - The input string in grep format.
 * @returns {{paths: Set<string>, results: Object}} An object containing a set of unique file paths and an object mapping each path to its line details.
 *
 * @example
 * const result = parseGrep('file1.txt:10:This is a preview');
 * console.log(result.paths); // Set { 'file1.txt' }
 * console.log(result.results); // { 'file1.txt': [ { line: 10, path: 'file1.txt', preview: 'This is a preview' } ] }
 *
 * @throws Will throw an error if the input string is not in the expected grep format.
 */
function parseGrep(grep) {
  const paths = /* @__PURE__ */ new Set();
  const results = {};
  forEachLineWithContent(grep, (input) => {
    const [path, line, preview] = input.split(NULL);
    paths.add(path);
    (results[path] = results[path] || []).push({
      line: asNumber(line),
      path,
      preview
    });
  });
  return {
    paths,
    results
  };
}
/**
 * Returns an object with a method to search for text patterns using `grep`.
 *
 * @return {Object} An object containing the `grep` method.
 */
function grep_default() {
  return {
    grep(searchTerm) {
      const then = trailingFunctionArgument(arguments);
      const options = getTrailingOptions(arguments);
      for (const option of disallowedOptions) {
        if (options.includes(option)) {
          return this._runTask(
            configurationErrorTask(`git.grep: use of "${option}" is not supported.`),
            then
          );
        }
      }
      if (typeof searchTerm === "string") {
        searchTerm = grepQueryBuilder().param(searchTerm);
      }
      const commands = ["grep", "--null", "-n", "--full-name", ...options, ...searchTerm];
      return this._runTask(
        {
          commands,
          format: "utf-8",
          parser(stdOut) {
            return parseGrep(stdOut);
          }
        },
        then
      );
    }
  };
}
var disallowedOptions, Query, _a, GrepQuery;
var init_grep = __esm({
  "src/lib/tasks/grep.ts"() {
    "use strict";
    init_utils();
    init_task();
    disallowedOptions = ["-h"];
    Query = Symbol("grepQuery");
    GrepQuery = class {
      constructor() {
        this[_a] = [];
      }
      *[(_a = Query, Symbol.iterator)]() {
        for (const query of this[Query]) {
          yield query;
        }
      }
      and(...and) {
        and.length && this[Query].push("--and", "(", ...prefixedArray(and, "-e"), ")");
        return this;
      }
      param(...param) {
        this[Query].push(...prefixedArray(param, "-e"));
        return this;
      }
    };
  }
});

// src/lib/tasks/reset.ts
var reset_exports = {};
__export(reset_exports, {
  ResetMode: () => ResetMode,
  getResetMode: () => getResetMode,
  resetTask: () => resetTask
});
/**
 * Resets a task with the specified mode and custom arguments.
 *
 * @param {string} mode - The mode in which to reset the task. Must be a valid reset mode.
 * @param {Array<string>} [customArgs=[]] - An array of custom arguments to pass along with the reset command.
 * @returns {Task} A task that will execute the 'reset' command with the specified mode and custom arguments.
 * @throws {Error} Throws an error if the provided mode is not a valid reset mode.
 *
 * Example:
 * const task = await resetTask('hard', ['--force']);
 * ```
 * // This will run the command: 'reset --hard --force'
 * ```
 */
function resetTask(mode, customArgs) {
  const commands = ["reset"];
  if (isValidResetMode(mode)) {
    commands.push(`--${mode}`);
  }
  commands.push(...customArgs);
  return straightThroughStringTask(commands);
}
/**
 * Retrieves the reset mode based on the provided value.
 *
 * @param {string | undefined} mode - The reset mode to validate. Can be a string or undefined.
 * @returns {string} The valid reset mode, defaulting to "soft" if the input is invalid.
 * @throws {Error} If an invalid reset mode is provided and cannot be handled.
 */
function getResetMode(mode) {
  if (isValidResetMode(mode)) {
    return mode;
  }
  switch (typeof mode) {
    case "string":
    case "undefined":
      return "soft" /* SOFT */;
  }
  return;
}
/**
 * Checks if the provided reset mode is valid.
 *
 * @param {string} mode - The reset mode to validate.
 * @returns {boolean} - Returns true if the mode is valid, false otherwise.
 * @throws {Error} - Throws an error if the input is not a string.
 */
function isValidResetMode(mode) {
  return ResetModes.includes(mode);
}
var ResetMode, ResetModes;
var init_reset = __esm({
  "src/lib/tasks/reset.ts"() {
    "use strict";
    init_task();
    ResetMode = /* @__PURE__ */ ((ResetMode2) => {
      ResetMode2["MIXED"] = "mixed";
      ResetMode2["SOFT"] = "soft";
      ResetMode2["HARD"] = "hard";
      ResetMode2["MERGE"] = "merge";
      ResetMode2["KEEP"] = "keep";
      return ResetMode2;
    })(ResetMode || {});
    ResetModes = Array.from(Object.values(ResetMode));
  }
});

// src/lib/api.ts
var api_exports = {};
__export(api_exports, {
  CheckRepoActions: () => CheckRepoActions,
  CleanOptions: () => CleanOptions,
  DiffNameStatus: () => DiffNameStatus,
  GitConfigScope: () => GitConfigScope,
  GitConstructError: () => GitConstructError,
  GitError: () => GitError,
  GitPluginError: () => GitPluginError,
  GitResponseError: () => GitResponseError,
  ResetMode: () => ResetMode,
  TaskConfigurationError: () => TaskConfigurationError,
  grepQueryBuilder: () => grepQueryBuilder,
  pathspec: () => pathspec
});
var init_api = __esm({
  "src/lib/api.ts"() {
    "use strict";
    init_pathspec();
    init_git_construct_error();
    init_git_error();
    init_git_plugin_error();
    init_git_response_error();
    init_task_configuration_error();
    init_check_is_repo();
    init_clean();
    init_config();
    init_diff_name_status();
    init_grep();
    init_reset();
  }
});

// src/lib/plugins/abort-plugin.ts
/**
 * Aborts a plugin when an abort signal is received.
 *
 * @param {AbortSignal} signal - The AbortSignal to listen for the "abort" event.
 * @returns {Array<{ type: string, action: Function }>} An array of plugins that will be executed before and after the spawn event.
 */
function abortPlugin(signal) {
  if (!signal) {
    return;
  }
  const onSpawnAfter = {
    type: "spawn.after",
    action(_data, context) {
      /**
       * Aborts an operation by throwing a GitPluginError with the specified message.
       *
       * @param {string} [message="abort"] - The error message to include in the GitPluginError. Default is "abort".
       */
      function kill() {
        context.kill(new GitPluginError(void 0, "abort", "Abort signal received"));
      }
      signal.addEventListener("abort", kill);
      context.spawned.on("close", () => signal.removeEventListener("abort", kill));
    }
  };
  const onSpawnBefore = {
    type: "spawn.before",
    action(_data, context) {
      if (signal.aborted) {
        context.kill(new GitPluginError(void 0, "abort", "Abort already signaled"));
      }
    }
  };
  return [onSpawnBefore, onSpawnAfter];
}
var init_abort_plugin = __esm({
  "src/lib/plugins/abort-plugin.ts"() {
    "use strict";
    init_git_plugin_error();
  }
});

// src/lib/plugins/block-unsafe-operations-plugin.ts
function isConfigSwitch(arg) {
  return typeof arg === "string" && arg.trim().toLowerCase() === "-c";
}
/**
 * Prevents protocol override if the argument is not a configuration switch or does not match the specified pattern.
 *
 * @param {string} arg - The configuration argument to check.
 * @param {string} next - The configuration value to validate against the pattern.
 * @throws {GitPluginError} - Throws an error if protocol.allow is configured without enabling allowUnsafeExtProtocol.
 */
function preventProtocolOverride(arg, next) {
  if (!isConfigSwitch(arg)) {
    return;
  }
  if (!/^\s*protocol(.[a-z]+)?.allow/.test(next)) {
    return;
  }
  throw new GitPluginError(
    void 0,
    "unsafe",
    "Configuring protocol.allow is not permitted without enabling allowUnsafeExtProtocol"
  );
}
/**
 * Prevents certain Git operations that could potentially lead to data corruption or security issues.
 *
 * @param {string} arg - The command-line argument being processed.
 * @param {string} method - The type of Git operation being performed (e.g., "clone", "push").
 * @throws {GitPluginError} If the operation is unsafe and 'allowUnsafePack' is not enabled.
 */
function preventUploadPack(arg, method) {
  if (/^\s*--(upload|receive)-pack/.test(arg)) {
    throw new GitPluginError(
      void 0,
      "unsafe",
      `Use of --upload-pack or --receive-pack is not permitted without enabling allowUnsafePack`
    );
  }
  if (method === "clone" && /^\s*-u\b/.test(arg)) {
    throw new GitPluginError(
      void 0,
      "unsafe",
      `Use of clone with option -u is not permitted without enabling allowUnsafePack`
    );
  }
  if (method === "push" && /^\s*--exec\b/.test(arg)) {
    throw new GitPluginError(
      void 0,
      "unsafe",
      `Use of push with option --exec is not permitted without enabling allowUnsafePack`
    );
  }
}
/**
 * Creates a plugin to block unsafe operations in spawn.args actions based on given configuration.
 *
 * @param {Object} options - The configuration options for the plugin.
 * @param {boolean} [options.allowUnsafeProtocolOverride=false] - Whether to allow overriding of unsafe protocols.
 * @param {boolean} [options.allowUnsafePack=false] - Whether to allow uploading a pack.
 * @returns {Object} - A plugin object with an `action` method that modifies arguments based on configuration.
 *
 * @example
 * const config = {
 *   allowUnsafeProtocolOverride: true,
 *   allowUnsafePack: false
 * };
 * const plugin = blockUnsafeOperationsPlugin(config);
 */
function blockUnsafeOperationsPlugin({
  allowUnsafeProtocolOverride = false,
  allowUnsafePack = false
} = {}) {
  return {
    type: "spawn.args",
    action(args, context) {
      args.forEach((current, index) => {
        const next = index < args.length ? args[index + 1] : "";
        allowUnsafeProtocolOverride || preventProtocolOverride(current, next);
        allowUnsafePack || preventUploadPack(current, context.method);
      });
      return args;
    }
  };
}
var init_block_unsafe_operations_plugin = __esm({
  "src/lib/plugins/block-unsafe-operations-plugin.ts"() {
    "use strict";
    init_git_plugin_error();
  }
});

// src/lib/plugins/command-config-prefixing-plugin.ts
/**
 * Plugin to prefix commands with a configuration-based array of strings.
 *
 * @param {Object} configuration - The configuration object containing the settings.
 * @return {Object} An object with a `type` and an `action` function.
 * @throws {Error} If the `configuration` parameter is not provided or is invalid.
 */
function commandConfigPrefixingPlugin(configuration) {
  const prefix = prefixedArray(configuration, "-c");
  return {
    type: "spawn.args",
    action(data) {
      return [...prefix, ...data];
    }
  };
}
var init_command_config_prefixing_plugin = __esm({
  "src/lib/plugins/command-config-prefixing-plugin.ts"() {
    "use strict";
    init_utils();
  }
});

// src/lib/plugins/completion-detection.plugin.ts
/**
 * Creates a plugin for detecting completion of a process based on specified conditions.
 *
 * @param {Object} [options] - Configuration options for the plugin.
 * @param {boolean} [options.onClose=true] - Whether to wait for the close event. If false, it won't wait for the close event.
 * @param {number|false} [options.onExit=50] - The timeout in milliseconds for the exit event. If set to false, it won't wait for the exit event.
 *
 * @returns {Object} - An object containing the plugin type and action.
 */
function completionDetectionPlugin({
  onClose = true,
  onExit = 50
} = {}) {
  /**
   * Creates an object containing events and their associated promises for managing exit codes.
   *
   * @param {boolean} onClose - Whether to handle the close event. If false, the closeTimeout will not be considered.
   * @param {boolean} onExit - Whether to handle the exit event. If false, the exitTimeout will not be considered.
   * @returns {Object} An object containing:
   *   - `close`: A method to set the exit code and resolve the close promise.
   *   - `exit`: A method to set the exit code and resolve the exit promise.
   *   - `get exitCode`: A getter to retrieve the current exit code.
   *   - `result`: A Promise that resolves when either the close or exit timeout occurs.
   *
   * @example
   * const eventManager = createEvents(true, true);
   * eventManager.close(0); // Resolve the close promise with exit code 0
   * eventManager.exit(1); // Resolve the exit promise with exit code 1
   */
  function createEvents() {
    let exitCode = -1;
    const events = {
      close: (0, import_promise_deferred.deferred)(),
      closeTimeout: (0, import_promise_deferred.deferred)(),
      exit: (0, import_promise_deferred.deferred)(),
      exitTimeout: (0, import_promise_deferred.deferred)()
    };
    const result = Promise.race([
      onClose === false ? never : events.closeTimeout.promise,
      onExit === false ? never : events.exitTimeout.promise
    ]);
    configureTimeout(onClose, events.close, events.closeTimeout);
    configureTimeout(onExit, events.exit, events.exitTimeout);
    return {
      close(code) {
        exitCode = code;
        events.close.done();
      },
      exit(code) {
        exitCode = code;
        events.exit.done();
      },
      get exitCode() {
        return exitCode;
      },
      result
    };
  }
  /**
   * Configures a timeout for an event based on a flag.
   *
   * @param {boolean} flag - A flag indicating whether the timeout should be applied immediately or after an event resolves.
   * @param {Object} event - An object containing a promise that will resolve when the event occurs.
   * @param {Object} timeout - An object with a done method to signal the completion of the timeout.
   *
   * This function checks if the flag is false. If so, it returns immediately without setting any timeout.
   * If the flag is true, it either applies the timeout immediately or waits for the event's promise to resolve before applying the timeout.
   * The done method of the timeout object is called when the timeout completes.
   *
   * @example
   * configureTimeout(true, {promise: somePromise}, {done: () => console.log('Timeout completed')});
   */
  function configureTimeout(flag, event, timeout) {
    if (flag === false) {
      return;
    }
    (flag === true ? event.promise : event.promise.then(() => delay(flag))).then(timeout.done);
  }
  return {
    type: "spawn.after",
    action(_0, _1) {
      return __async(this, arguments, function* (_data, { spawned, close }) {
        var _a3, _b;
        const events = createEvents();
        let deferClose = true;
        /**
         * Closes the current window or tab without prompting for confirmation.
         *
         * @returns {void}
         */
        let quickClose = () => void (deferClose = false);
        (_a3 = spawned.stdout) == null ? void 0 : _a3.on("data", quickClose);
        (_b = spawned.stderr) == null ? void 0 : _b.on("data", quickClose);
        spawned.on("error", quickClose);
        spawned.on("close", (code) => events.close(code));
        spawned.on("exit", (code) => events.exit(code));
        try {
          yield events.result;
          if (deferClose) {
            yield delay(50);
          }
          close(events.exitCode);
        } catch (err) {
          close(events.exitCode, err);
        }
      });
    }
  };
}
var import_promise_deferred, never;
var init_completion_detection_plugin = __esm({
  "src/lib/plugins/completion-detection.plugin.ts"() {
    "use strict";
    import_promise_deferred = require("@kwsites/promise-deferred");
    init_utils();
    never = (0, import_promise_deferred.deferred)().promise;
  }
});

// src/lib/plugins/custom-binary.plugin.ts
/**
 * Determines if the provided argument is considered bad based on specific criteria.
 *
 * @param {string} arg - The argument to be evaluated.
 * @returns {boolean} - Returns true if the argument is considered bad, otherwise false.
 *
 * @example
 * // Returns false as 'C:\\Users\\Username' is a valid path
 * isBadArgument('C:\\Users\\Username');
 *
 * @example
 * // Returns true as '' is an invalid empty string
 * isBadArgument('');
 */
function isBadArgument(arg) {
  return !arg || !/^([a-z]:)?([a-z0-9/.\\_-]+)$/i.test(arg);
}
function toBinaryConfig(input, allowUnsafe) {
  if (input.length < 1 || input.length > 2) {
    throw new GitPluginError(void 0, "binary", WRONG_NUMBER_ERR);
  }
  const isBad = input.some(isBadArgument);
  if (isBad) {
    if (allowUnsafe) {
      console.warn(WRONG_CHARS_ERR);
    } else {
      throw new GitPluginError(void 0, "binary", WRONG_CHARS_ERR);
    }
  }
  const [binary, prefix] = input;
  return {
    binary,
    prefix
  };
}
/**
 * Custom binary plugin function that configures binary settings based on input and allows for unsafe operations if specified.
 *
 * @param {Array|string} plugins - The plugins array or string to be configured.
 * @param {Array|string} [input=["git"]] - The input array or string specifying the commands or files to process. Default is ["git"].
 * @param {boolean} [allowUnsafe=false] - Flag indicating whether unsafe operations are allowed. Default is false.
 */
function customBinaryPlugin(plugins, input = ["git"], allowUnsafe = false) {
  let config = toBinaryConfig(asArray(input), allowUnsafe);
  plugins.on("binary", (input2) => {
    config = toBinaryConfig(asArray(input2), allowUnsafe);
  });
  plugins.append("spawn.binary", () => {
    return config.binary;
  });
  plugins.append("spawn.args", (data) => {
    return config.prefix ? [config.prefix, ...data] : data;
  });
}
var WRONG_NUMBER_ERR, WRONG_CHARS_ERR;
var init_custom_binary_plugin = __esm({
  "src/lib/plugins/custom-binary.plugin.ts"() {
    "use strict";
    init_git_plugin_error();
    init_utils();
    WRONG_NUMBER_ERR = `Invalid value supplied for custom binary, requires a single string or an array containing either one or two strings`;
    WRONG_CHARS_ERR = `Invalid value supplied for custom binary, restricted characters must be removed or supply the unsafe.allowUnsafeCustomBinary option`;
  }
});

// src/lib/plugins/error-detection.plugin.ts
function isTaskError(result) {
  return !!(result.exitCode && result.stdErr.length);
}
/**
 * Converts an array of Buffer objects representing standard output and standard error into a single Buffer object containing the combined content.
 *
 * @param {Object} result - The result object containing stdOut and stdErr buffers.
 * @param {Buffer[]} result.stdOut - An array of Buffer objects representing standard output.
 * @param {Buffer[]} result.stdErr - An array of Buffer objects representing standard error.
 * @returns {Buffer} A single Buffer object containing the combined content of stdOut and stdErr.
 */
function getErrorMessage(result) {
  return Buffer.concat([...result.stdOut, ...result.stdErr]);
}
/**
 * Creates an error detection handler function.
 *
 * @param {boolean} [overwrite=false] - If true, overwrites the result with the error message.
 * @param {Function} [isError=isTaskError] - Function to determine if the result is an error.
 * @param {Function} [errorMessage=getErrorMessage] - Function to retrieve the error message from the result.
 * @returns {Function} A function that takes an error and a result, returns the error or its message based on the conditions.
 *
 * @example
 * const handler = errorDetectionHandler(true);
 * const errorResult = { isError: true, message: 'Error occurred' };
 * console.log(handler(null, errorResult)); // Output: Error occurred
 */
function errorDetectionHandler(overwrite = false, isError = isTaskError, errorMessage = getErrorMessage) {
  return (error, result) => {
    if (!overwrite && error || !isError(result)) {
      return error;
    }
    return errorMessage(result);
  };
}
/**
 * Creates an error detection plugin that can be used to process errors in task execution.
 *
 * @param {Object} config - The configuration object for the error detector.
 * @returns {Object} - An object containing a type and action method.
 */
function errorDetectionPlugin(config) {
  return {
    type: "task.error",
    action(data, context) {
      const error = config(data.error, {
        stdErr: context.stdErr,
        stdOut: context.stdOut,
        exitCode: context.exitCode
      });
      if (Buffer.isBuffer(error)) {
        return { error: new GitError(void 0, error.toString("utf-8")) };
      }
      return {
        error
      };
    }
  };
}
var init_error_detection_plugin = __esm({
  "src/lib/plugins/error-detection.plugin.ts"() {
    "use strict";
    init_git_error();
  }
});

// src/lib/plugins/plugin-store.ts
var import_node_events, PluginStore;
var init_plugin_store = __esm({
  "src/lib/plugins/plugin-store.ts"() {
    "use strict";
    import_node_events = require("node:events");
    init_utils();
    PluginStore = class {
      constructor() {
        this.plugins = /* @__PURE__ */ new Set();
        this.events = new import_node_events.EventEmitter();
      }
      on(type, listener) {
        this.events.on(type, listener);
      }
      reconfigure(type, data) {
        this.events.emit(type, data);
      }
      append(type, action) {
        const plugin = append(this.plugins, { type, action });
        return () => this.plugins.delete(plugin);
      }
      add(plugin) {
        const plugins = [];
        asArray(plugin).forEach((plugin2) => plugin2 && this.plugins.add(append(plugins, plugin2)));
        return () => {
          plugins.forEach((plugin2) => this.plugins.delete(plugin2));
        };
      }
      exec(type, data, context) {
        let output = data;
        const contextual = Object.freeze(Object.create(context));
        for (const plugin of this.plugins) {
          if (plugin.type === type) {
            output = plugin.action(output, contextual);
          }
        }
        return output;
      }
    };
  }
});

// src/lib/plugins/progress-monitor-plugin.ts
/**
 * A plugin to monitor the progress of certain Git commands.
 *
 * @param {Function} progress - The callback function that will be called with progress updates.
 * @return {[Object, Object]} - An array containing two objects:
 *   1. `onArgs` object for modifying spawn arguments.
 *   2. `onProgress` object for handling progress events.
 *
 * @example
 * const plugin = progressMonitorPlugin((progress) => {
 *   console.log(`Stage: ${progress.stage}, Progress: ${progress.progress}%`);
 * });
 */
function progressMonitorPlugin(progress) {
  const progressCommand = "--progress";
  const progressMethods = ["checkout", "clone", "fetch", "pull", "push"];
  const onProgress = {
    type: "spawn.after",
    action(_data, context) {
      var _a2;
      if (!context.commands.includes(progressCommand)) {
        return;
      }
      (_a2 = context.spawned.stderr) == null ? void 0 : _a2.on("data", (chunk) => {
        const message = /^([\s\S]+?):\s*(\d+)% \((\d+)\/(\d+)\)/.exec(chunk.toString("utf8"));
        if (!message) {
          return;
        }
        progress({
          method: context.method,
          stage: progressEventStage(message[1]),
          progress: asNumber(message[2]),
          processed: asNumber(message[3]),
          total: asNumber(message[4])
        });
      });
    }
  };
  const onArgs = {
    type: "spawn.args",
    action(args, context) {
      if (!progressMethods.includes(context.method)) {
        return args;
      }
      return including(args, progressCommand);
    }
  };
  return [onArgs, onProgress];
}
/**
 * Extracts the first word from a given string and converts it to lowercase.
 *
 * @param {string} input - The input string from which the first word is extracted.
 * @returns {string} The first word of the input string in lowercase, or "unknown" if no words are present.
 *
 * @example
 * progressEventStage("Hello World"); // Returns "hello"
 * progressEventStage("123 Start");   // Returns "123"
 * progressEventStage("");          // Returns "unknown"
 */
function progressEventStage(input) {
  return String(input.toLowerCase().split(" ", 1)) || "unknown";
}
var init_progress_monitor_plugin = __esm({
  "src/lib/plugins/progress-monitor-plugin.ts"() {
    "use strict";
    init_utils();
  }
});

// src/lib/plugins/simple-git-plugin.ts
var init_simple_git_plugin = __esm({
  "src/lib/plugins/simple-git-plugin.ts"() {
    "use strict";
  }
});

// src/lib/plugins/spawn-options-plugin.ts
/**
 * Creates a plugin to modify spawn options by selecting specific properties from the input.
 *
 * @param {Object} spawnOptions - The original spawn options object containing various properties.
 * @returns {Object} A plugin object with type and action method.
 * @throws {Error} If `spawnOptions` is not an object.
 * @example
 * const options = {
 *   uid: 1000,
 *   gid: 2000,
 *   otherProp: 'value'
 * };
 *
 * const plugin = spawnOptionsPlugin(options);
 * console.log(plugin.action({ newProp: 'newValue' }));
 * // Output: { uid: 1000, gid: 2000, newProp: 'newValue' }
 */
function spawnOptionsPlugin(spawnOptions) {
  const options = pick(spawnOptions, ["uid", "gid"]);
  return {
    type: "spawn.options",
    action(data) {
      return __spreadValues(__spreadValues({}, options), data);
    }
  };
}
var init_spawn_options_plugin = __esm({
  "src/lib/plugins/spawn-options-plugin.ts"() {
    "use strict";
    init_utils();
  }
});

// src/lib/plugins/timout-plugin.ts
/**
 * Creates a plugin that kills a spawned process if it exceeds a specified block time.
 *
 * @param {Object} options - Configuration options for the timeout plugin.
 * @param {number} options.block - The maximum number of milliseconds to wait before killing the process. If 0, no timeout is applied.
 * @param {boolean} [options.stdErr=true] - Whether to monitor and respond to stderr data events to trigger the timeout.
 * @param {boolean} [options.stdOut=true] - Whether to monitor and respond to stdout data events to trigger the timeout.
 *
 * @returns {Object} A plugin object that can be used with a spawned process.
 *
 * @throws {GitPluginError} Throws an error if the block time is reached and the process has not completed.
 */
function timeoutPlugin({
  block,
  stdErr = true,
  stdOut = true
}) {
  if (block > 0) {
    return {
      type: "spawn.after",
      action(_data, context) {
        var _a2, _b;
        let timeout;
        /**
         * Clears any existing timeout and sets a new one to call the 'kill' function after 'block' milliseconds.
         *
         * @function wait
         * @param {number} block - The time in milliseconds after which the 'kill' function should be called.
         */
        function wait() {
          timeout && clearTimeout(timeout);
          timeout = setTimeout(kill, block);
        }
        /**
         * Stops all event listeners and clears any timeout associated with the context.spawned object.
         *
         * This function is designed to clean up resources and ensure that no further events are triggered on the stdout, stderr,
         * exit, and close events of the context.spawned object. It also cancels any active timeouts.
         *
         * @function
         * @returns {void}
         */
        function stop() {
          var _a3, _b2;
          (_a3 = context.spawned.stdout) == null ? void 0 : _a3.off("data", wait);
          (_b2 = context.spawned.stderr) == null ? void 0 : _b2.off("data", wait);
          context.spawned.off("exit", stop);
          context.spawned.off("close", stop);
          timeout && clearTimeout(timeout);
        }
        /**
         * Terminates the current operation due to a timeout.
         *
         * This function is responsible for stopping any ongoing processes and killing the context with an error indicating a timeout.
         *
         * @throws {GitPluginError} - Throws an error if the operation times out.
         */
        function kill() {
          stop();
          context.kill(new GitPluginError(void 0, "timeout", `block timeout reached`));
        }
        stdOut && ((_a2 = context.spawned.stdout) == null ? void 0 : _a2.on("data", wait));
        stdErr && ((_b = context.spawned.stderr) == null ? void 0 : _b.on("data", wait));
        context.spawned.on("exit", stop);
        context.spawned.on("close", stop);
        wait();
      }
    };
  }
}
var init_timout_plugin = __esm({
  "src/lib/plugins/timout-plugin.ts"() {
    "use strict";
    init_git_plugin_error();
  }
});

// src/lib/plugins/index.ts
var init_plugins = __esm({
  "src/lib/plugins/index.ts"() {
    "use strict";
    init_abort_plugin();
    init_block_unsafe_operations_plugin();
    init_command_config_prefixing_plugin();
    init_completion_detection_plugin();
    init_custom_binary_plugin();
    init_error_detection_plugin();
    init_plugin_store();
    init_progress_monitor_plugin();
    init_simple_git_plugin();
    init_spawn_options_plugin();
    init_timout_plugin();
  }
});

// src/lib/plugins/suffix-paths.plugin.ts
/**
 * Generates a plugin that processes an array of arguments and appends paths to them.
 *
 * @returns {Object} A plugin object with a `type` property set to "spawn.args" and an `action` method.
 */
function suffixPathsPlugin() {
  return {
    type: "spawn.args",
    action(data) {
      const prefix = [];
      let suffix;
      /**
       * Appends elements to an array. If no suffix is provided, it initializes with an empty array.
       *
       * @param {Array} [suffix=[]] - The array to which elements will be appended. Defaults to a new empty array if not provided.
       * @param {...*} args - The elements to append to the array.
       * @returns {void}
       */
      function append2(args) {
        (suffix = suffix || []).push(...args);
      }
      for (let i = 0; i < data.length; i++) {
        const param = data[i];
        if (isPathSpec(param)) {
          append2(toPaths(param));
          continue;
        }
        if (param === "--") {
          append2(
            data.slice(i + 1).flatMap((item) => isPathSpec(item) && toPaths(item) || item)
          );
          break;
        }
        prefix.push(param);
      }
      return !suffix ? prefix : [...prefix, "--", ...suffix.map(String)];
    }
  };
}
var init_suffix_paths_plugin = __esm({
  "src/lib/plugins/suffix-paths.plugin.ts"() {
    "use strict";
    init_pathspec();
  }
});

// src/lib/git-logger.ts
/**
 * Creates a logger instance using the 'debug' library for logging messages with a specific namespace ('simple-git').
 *
 * @returns {Function} - A function that can be used to log messages. The function takes a message string as its parameter.
 *
 * Example usage:
 * const logger = createLog();
 * logger('This is an informational message');
 */
function createLog() {
  return (0, import_debug.default)("simple-git");
}
/**
 * Logs messages with a specified prefix and optionally forwards them to another logging function.
 *
 * @param {Function} to - The primary logger function that accepts the message and arguments.
 * @param {string} [prefix] - An optional string that will be prepended to each logged message. It must not be empty or contain only whitespace.
 * @param {Function} [forward] - An optional logging function that will receive the same message and arguments as the primary logger.
 * @returns {Function} A new function that logs messages with the prefix and forwards them if a forwarder is provided.
 *
 * @example
 * const consoleLogger = (message) => console.log(message);
 * const prefixedConsoleLogger = prefixedLogger(consoleLogger, 'INFO:');
 * prefixedConsoleLogger('This is a test'); // Output: INFO: This is a test
 */
function prefixedLogger(to, prefix, forward) {
  if (!prefix || !String(prefix).replace(/\s*/, "")) {
    return !forward ? to : (message, ...args) => {
      to(message, ...args);
      forward(message, ...args);
    };
  }
  return (message, ...args) => {
    to(`%s ${message}`, prefix, ...args);
    if (forward) {
      forward(message, ...args);
    }
  };
}
/**
 * Generates a child logger name based on the provided parameters.
 *
 * @param {string} name - The name to be used for the child logger. If it's not a string, it defaults to an empty string.
 * @param {Object|undefined} childDebugger - An optional object containing the namespace of the parent debugger.
 * @param {Object} options - An object containing configuration options.
 * @param {string} options.namespace - The namespace of the parent logger.
 *
 * @returns {string} - The generated child logger name.
 *
 * @example
 * // Example usage:
 * const childName = childLoggerName('myChild', undefined, { namespace: 'parent' });
 * console.log(childName); // Output: 'parent'
 */
function childLoggerName(name, childDebugger, { namespace: parentNamespace }) {
  if (typeof name === "string") {
    return name;
  }
  const childNamespace = childDebugger && childDebugger.namespace || "";
  if (childNamespace.startsWith(parentNamespace)) {
    return childNamespace.substr(parentNamespace.length + 1);
  }
  return childNamespace || parentNamespace;
}
/**
 * Creates a logger function that can be used to log messages with optional labels and verbosity levels.
 *
 * @param {string} label - Optional label for the logger. If provided, it will be prefixed to all log messages.
 * @param {boolean|string|Function} verbose - Determines the verbosity level of the logger. Can be a boolean,
 * string (for extending an existing debugger), or a function that creates a new debugger instance.
 * @param {number} initialStep - Optional initial step number for logging.
 * @param {Function} [infoDebugger=createLog()] - Optional debugger instance to use for info level logs. Defaults
 * to `createLog()`.
 *
 * @returns {Object} - A logger object with methods for logging at different levels (info, step).
 *
 * @example
 * const logger = createLogger('myApp', true);
 * logger.info('This is an info message');
 * logger.step(1, 'Starting step 1');
 */
function createLogger(label, verbose, initialStep, infoDebugger = createLog()) {
  const labelPrefix = label && `[${label}]` || "";
  const spawned = [];
  const debugDebugger = typeof verbose === "string" ? infoDebugger.extend(verbose) : verbose;
  const key = childLoggerName(filterType(verbose, filterString), debugDebugger, infoDebugger);
  return step(initialStep);
  /**
   * Creates a new logger with updated label and key.
   *
   * @param {string} name - The new label for the logger.
   * @param {string} initial - The initial value for the logger.
   * @returns {Logger} - A new instance of Logger with the updated configurations.
   */
  function sibling(name, initial) {
    return append(
      spawned,
      createLogger(label, key.replace(/^[^:]+/, name), initial, infoDebugger)
    );
  }
  /**
   * Executes a step with logging functionality based on the phase provided.
   *
   * @param {string} [phase] - The current phase of execution. If provided, it will be prefixed in logs.
   * @returns {Object} An object containing various logging functions and properties related to the step.
   */
  function step(phase) {
    const stepPrefix = phase && `[${phase}]` || "";
    const debug2 = debugDebugger && prefixedLogger(debugDebugger, stepPrefix) || NOOP;
    const info = prefixedLogger(infoDebugger, `${labelPrefix} ${stepPrefix}`, debug2);
    return Object.assign(debugDebugger ? debug2 : info, {
      label,
      sibling,
      info,
      step
    });
  }
}
var import_debug;
var init_git_logger = __esm({
  "src/lib/git-logger.ts"() {
    "use strict";
    import_debug = __toESM(require("debug"));
    init_utils();
    import_debug.default.formatters.L = (value) => String(filterHasLength(value) ? value.length : "-");
    import_debug.default.formatters.B = (value) => {
      if (Buffer.isBuffer(value)) {
        return value.toString("utf8");
      }
      return objectToString(value);
    };
  }
});

// src/lib/runners/tasks-pending-queue.ts
var _TasksPendingQueue, TasksPendingQueue;
var init_tasks_pending_queue = __esm({
  "src/lib/runners/tasks-pending-queue.ts"() {
    "use strict";
    init_git_error();
    init_git_logger();
    _TasksPendingQueue = class {
      constructor(logLabel = "GitExecutor") {
        this.logLabel = logLabel;
        this._queue = /* @__PURE__ */ new Map();
      }
      withProgress(task) {
        return this._queue.get(task);
      }
      createProgress(task) {
        const name = _TasksPendingQueue.getName(task.commands[0]);
        const logger = createLogger(this.logLabel, name);
        return {
          task,
          logger,
          name
        };
      }
      push(task) {
        const progress = this.createProgress(task);
        progress.logger("Adding task to the queue, commands = %o", task.commands);
        this._queue.set(task, progress);
        return progress;
      }
      fatal(err) {
        for (const [task, { logger }] of Array.from(this._queue.entries())) {
          if (task === err.task) {
            logger.info(`Failed %o`, err);
            logger(
              `Fatal exception, any as-yet un-started tasks run through this executor will not be attempted`
            );
          } else {
            logger.info(
              `A fatal exception occurred in a previous task, the queue has been purged: %o`,
              err.message
            );
          }
          this.complete(task);
        }
        if (this._queue.size !== 0) {
          throw new Error(`Queue size should be zero after fatal: ${this._queue.size}`);
        }
      }
      complete(task) {
        const progress = this.withProgress(task);
        if (progress) {
          this._queue.delete(task);
        }
      }
      attempt(task) {
        const progress = this.withProgress(task);
        if (!progress) {
          throw new GitError(void 0, "TasksPendingQueue: attempt called for an unknown task");
        }
        progress.logger("Starting task");
        return progress;
      }
      static getName(name = "empty") {
        return `task:${name}:${++_TasksPendingQueue.counter}`;
      }
    };
    TasksPendingQueue = _TasksPendingQueue;
    TasksPendingQueue.counter = 0;
  }
});

// src/lib/runners/git-executor-chain.ts
/**
 * Creates an object containing method and commands from the given task.
 *
 * @param {Object} task - The task object which contains the command list.
 * @param {Array<Object>} commands - The array of command objects.
 * @returns {Object} An object with 'method' and 'commands' properties.
 * @throws {Error} If no commands are provided in the task.
 *
 * Example:
 * const task = { commands: [{ name: "start" }] };
 * const commands = [{ name: "stop" }];
 * const result = pluginContext(task, commands);
 * // result will be { method: "start", commands: [ ... ] }
 */
function pluginContext(task, commands) {
  return {
    method: first(task.commands) || "",
    commands
  };
}
/**
 * Handles errors received from child processes by logging them and appending their stack trace to an array.
 *
 * @param {Array} target - The array to which the error stack trace will be appended.
 * @param {Function} logger - A function used for logging messages. It should accept a string as its first argument.
 * @returns {Function} - A callback function that logs the error and appends its stack trace to the target array.
 *
 * @example
 * const errors = [];
 * const errorHandler = onErrorReceived(errors, console.log);
 * // Simulate an error being thrown by a child process
 * try {
 *   throw new Error('Something went wrong');
 * } catch (err) {
 *   errorHandler(err);
 * }
 * console.log(errors); // Output: [Buffer]
 */
function onErrorReceived(target, logger) {
  return (err) => {
    logger(`[ERROR] child process exception %o`, err);
    target.push(Buffer.from(String(err.stack), "ascii"));
  };
}
/**
 * Function to handle data received by a target object.
 *
 * @function onDataReceived
 * @param {Object} target - The target object that will receive the buffer.
 * @param {string} name - The name of the buffer being received.
 * @param {Function} logger - A logging function to log messages.
 * @param {Function} output - An output function to handle the buffer.
 * @returns {function(Buffer): void} A callback function that processes the buffer.
 *
 * @example
 * const target = [];
 * const logger = (msg) => console.log(msg);
 * const output = (buf) => console.log(buf.toString());
 * const onDataCallback = onDataReceived(target, 'data', logger, output);
 * onDataCallback(Buffer.from('Hello World'));
 *
 * @throws {TypeError} If any of the parameters are not of the expected type.
 */
function onDataReceived(target, name, logger, output) {
  return (buffer) => {
    logger(`%s received %L bytes`, name, buffer);
    output(`%B`, buffer);
    target.push(buffer);
  };
}
var import_child_process, GitExecutorChain;
var init_git_executor_chain = __esm({
  "src/lib/runners/git-executor-chain.ts"() {
    "use strict";
    import_child_process = require("child_process");
    init_git_error();
    init_task();
    init_utils();
    init_tasks_pending_queue();
    GitExecutorChain = class {
      constructor(_executor, _scheduler, _plugins) {
        this._executor = _executor;
        this._scheduler = _scheduler;
        this._plugins = _plugins;
        this._chain = Promise.resolve();
        this._queue = new TasksPendingQueue();
      }
      get cwd() {
        return this._cwd || this._executor.cwd;
      }
      set cwd(cwd) {
        this._cwd = cwd;
      }
      get env() {
        return this._executor.env;
      }
      get outputHandler() {
        return this._executor.outputHandler;
      }
      chain() {
        return this;
      }
      push(task) {
        this._queue.push(task);
        return this._chain = this._chain.then(() => this.attemptTask(task));
      }
      attemptTask(task) {
        return __async(this, null, function* () {
          const onScheduleComplete = yield this._scheduler.next();
          /**
           * Completes the current task in the queue.
           *
           * @returns {undefined} - This method does not return any value.
           *
           * @throws {Error} - Throws an error if there is no active task to complete.
           *
           * @example
           * // Example usage of onQueueComplete method
           * const instance = new QueueManager();
           * instance.onQueueComplete(); // Completes the current task in the queue
           */
          const onQueueComplete = () => this._queue.complete(task);
          try {
            const { logger } = this._queue.attempt(task);
            return yield isEmptyTask(task) ? this.attemptEmptyTask(task, logger) : this.attemptRemoteTask(task, logger);
          } catch (e) {
            throw this.onFatalException(task, e);
          } finally {
            onQueueComplete();
            onScheduleComplete();
          }
        });
      }
      onFatalException(task, e) {
        const gitError = e instanceof GitError ? Object.assign(e, { task }) : new GitError(task, e && String(e));
        this._chain = Promise.resolve();
        this._queue.fatal(gitError);
        return gitError;
      }
      attemptRemoteTask(task, logger) {
        return __async(this, null, function* () {
          const binary = this._plugins.exec("spawn.binary", "", pluginContext(task, task.commands));
          const args = this._plugins.exec(
            "spawn.args",
            [...task.commands],
            pluginContext(task, task.commands)
          );
          const raw = yield this.gitResponse(
            task,
            binary,
            args,
            this.outputHandler,
            logger.step("SPAWN")
          );
          const outputStreams = yield this.handleTaskData(task, args, raw, logger.step("HANDLE"));
          logger(`passing response to task's parser as a %s`, task.format);
          if (isBufferTask(task)) {
            return callTaskParser(task.parser, outputStreams);
          }
          return callTaskParser(task.parser, outputStreams.asStrings());
        });
      }
      attemptEmptyTask(task, logger) {
        return __async(this, null, function* () {
          logger(`empty task bypassing child process to call to task's parser`);
          return task.parser(this);
        });
      }
      handleTaskData(task, args, result, logger) {
        const { exitCode, rejection, stdOut, stdErr } = result;
        return new Promise((done, fail) => {
          logger(`Preparing to handle process response exitCode=%d stdOut=`, exitCode);
          const { error } = this._plugins.exec(
            "task.error",
            { error: rejection },
            __spreadValues(__spreadValues({}, pluginContext(task, args)), result)
          );
          if (error && task.onError) {
            logger.info(`exitCode=%s handling with custom error handler`);
            return task.onError(
              result,
              error,
              (newStdOut) => {
                logger.info(`custom error handler treated as success`);
                logger(`custom error returned a %s`, objectToString(newStdOut));
                done(
                  new GitOutputStreams(
                    Array.isArray(newStdOut) ? Buffer.concat(newStdOut) : newStdOut,
                    Buffer.concat(stdErr)
                  )
                );
              },
              fail
            );
          }
          if (error) {
            logger.info(
              `handling as error: exitCode=%s stdErr=%s rejection=%o`,
              exitCode,
              stdErr.length,
              rejection
            );
            return fail(error);
          }
          logger.info(`retrieving task output complete`);
          done(new GitOutputStreams(Buffer.concat(stdOut), Buffer.concat(stdErr)));
        });
      }
      gitResponse(task, command, args, outputHandler, logger) {
        return __async(this, null, function* () {
          const outputLogger = logger.sibling("output");
          const spawnOptions = this._plugins.exec(
            "spawn.options",
            {
              cwd: this.cwd,
              env: this.env,
              windowsHide: true
            },
            pluginContext(task, task.commands)
          );
          return new Promise((done) => {
            const stdOut = [];
            const stdErr = [];
            logger.info(`%s %o`, command, args);
            logger("%O", spawnOptions);
            let rejection = this._beforeSpawn(task, args);
            if (rejection) {
              return done({
                stdOut,
                stdErr,
                exitCode: 9901,
                rejection
              });
            }
            this._plugins.exec("spawn.before", void 0, __spreadProps(__spreadValues({}, pluginContext(task, args)), {
              kill(reason) {
                rejection = reason || rejection;
              }
            }));
            const spawned = (0, import_child_process.spawn)(command, args, spawnOptions);
            spawned.stdout.on(
              "data",
              onDataReceived(stdOut, "stdOut", logger, outputLogger.step("stdOut"))
            );
            spawned.stderr.on(
              "data",
              onDataReceived(stdErr, "stdErr", logger, outputLogger.step("stdErr"))
            );
            spawned.on("error", onErrorReceived(stdErr, logger));
            if (outputHandler) {
              logger(`Passing child process stdOut/stdErr to custom outputHandler`);
              outputHandler(command, spawned.stdout, spawned.stderr, [...args]);
            }
            this._plugins.exec("spawn.after", void 0, __spreadProps(__spreadValues({}, pluginContext(task, args)), {
              spawned,
              close(exitCode, reason) {
                done({
                  stdOut,
                  stdErr,
                  exitCode,
                  rejection: rejection || reason
                });
              },
              kill(reason) {
                if (spawned.killed) {
                  return;
                }
                rejection = reason;
                spawned.kill("SIGINT");
              }
            }));
          });
        });
      }
      _beforeSpawn(task, args) {
        let rejection;
        this._plugins.exec("spawn.before", void 0, __spreadProps(__spreadValues({}, pluginContext(task, args)), {
          kill(reason) {
            rejection = reason || rejection;
          }
        }));
        return rejection;
      }
    };
  }
});

// src/lib/runners/git-executor.ts
var git_executor_exports = {};
__export(git_executor_exports, {
  GitExecutor: () => GitExecutor
});
var GitExecutor;
var init_git_executor = __esm({
  "src/lib/runners/git-executor.ts"() {
    "use strict";
    init_git_executor_chain();
    GitExecutor = class {
      constructor(cwd, _scheduler, _plugins) {
        this.cwd = cwd;
        this._scheduler = _scheduler;
        this._plugins = _plugins;
        this._chain = new GitExecutorChain(this, this._scheduler, this._plugins);
      }
      chain() {
        return new GitExecutorChain(this, this._scheduler, this._plugins);
      }
      push(task) {
        return this._chain.push(task);
      }
    };
  }
});

// src/lib/task-callback.ts
/**
 * Executes a callback function when a task is completed or fails.
 *
 * @param {string} task - The identifier for the task.
 * @param {Promise<any>} response - A Promise that resolves or rejects based on the task outcome.
 * @param {Function} [callback=NOOP] - An optional callback function to be executed upon task completion or failure. It receives two arguments: an error (if any) and data (if successful).
 *
 * @returns {void}
 *
 * @example
 * taskCallback('task1', somePromise, (err, data) => {
 *   if (err) {
 *     console.error('Task failed:', err);
 *   } else {
 *     console.log('Task succeeded with data:', data);
 *   }
 * });
 */
function taskCallback(task, response, callback = NOOP) {
  /**
   * Callback function to handle successful data retrieval.
   *
   * @callback SuccessCallback
   * @param {Error} error - An error object if an error occurred, otherwise null.
   * @param {Object} data - The retrieved data.
   */
  const onSuccess = (data) => {
    callback(null, data);
  };
  /**
   * Handles errors related to tasks by checking if the error task matches the current task.
   * If it does, the error is passed to the callback function along with an undefined value.
   *
   * @param {Error} err - The error object that occurred.
   * @returns {void}
   */
  const onError2 = (err) => {
    if ((err == null ? void 0 : err.task) === task) {
      callback(
        err instanceof GitResponseError ? addDeprecationNoticeToError(err) : err,
        void 0
      );
    }
  };
  response.then(onSuccess, onError2);
}
/**
 * Adds deprecation notices to properties of a GitResponseError object.
 *
 * This function enhances the given `err` object by intercepting accesses to its properties and logging deprecation warnings when accessed. It ensures that accessing properties directly on the error object is deprecated in favor of accessing them through the `.git` namespace. This change will be discontinued in version 3.
 *
 * @param {GitResponseError} err - The GitResponseError object to enhance with deprecation notices.
 * @returns {GitResponseError} A new object that has the same properties as `err`, but with deprecation notices added.
 */
function addDeprecationNoticeToError(err) {
  let log = (name) => {
    console.warn(
      `simple-git deprecation notice: accessing GitResponseError.${name} should be GitResponseError.git.${name}, this will no longer be available in version 3`
    );
    log = NOOP;
  };
  return Object.create(err, Object.getOwnPropertyNames(err.git).reduce(descriptorReducer, {}));
  /**
   /**
    * Logs a deprecation notice for accessing GitResponseError properties directly.
    *
    * @param {string} name - The name of the property being accessed.
    * @returns {void}
    * @deprecated Direct access to GitResponseError properties is deprecated and will be removed in version 3. Use `GitResponseError.git[name]` instead.
    */
   * Reduces an array of names into an object with getter functions for each name.
   * Each getter logs the name before returning the corresponding value from `err.git`.
   *
   * @param {Object} all - The accumulator object to store the properties.
   * @param {string} name - The current name being processed.
   * @returns {Object} - The updated accumulator object with a new property.
   */
  function descriptorReducer(all, name) {
    if (name in err) {
      return all;
    }
    all[name] = {
      enumerable: false,
      configurable: false,
      get() {
        log(name);
        return err.git[name];
      }
    };
    return all;
  }
}
var init_task_callback = __esm({
  "src/lib/task-callback.ts"() {
    "use strict";
    init_git_response_error();
    init_utils();
  }
});

// src/lib/tasks/change-working-directory.ts
function changeWorkingDirectoryTask(directory, root) {
  return adhocExecTask((instance) => {
    if (!folderExists(directory)) {
      throw new Error(`Git.cwd: cannot change to non-directory "${directory}"`);
    }
    return (root || instance).cwd = directory;
  });
}
var init_change_working_directory = __esm({
  "src/lib/tasks/change-working-directory.ts"() {
    "use strict";
    init_utils();
    init_task();
  }
});

// src/lib/tasks/checkout.ts
/**
 * Executes a 'checkout' task with provided arguments.
 *
 * This function constructs a command array for checking out a branch or file using the specified arguments.
 * It ensures that if both "-b" and "-B" options are present, the "-B" option is removed.
 *
 * @param {string[]} args - An array of strings representing the arguments to pass to the 'checkout' command.
 * @returns {Object} - The result of executing a straight-through string task with the constructed commands.
 * @throws {Error} - Throws an error if the '-B' option is found without a branch name after '-b'.
 *
 * @example
 * // Example usage:
 * const result = checkoutTask(["-b", "newBranch"]);
 * console.log(result); // Output depends on the task execution
 */
function checkoutTask(args) {
  const commands = ["checkout", ...args];
  if (commands[1] === "-b" && commands.includes("-B")) {
    commands[1] = remove(commands, "-B");
  }
  return straightThroughStringTask(commands);
}
/**
 * Creates an object with methods for checking out branches or creating new branches.
 * @returns {Object} An object containing checkout-related functions.
 */
function checkout_default() {
  return {
    checkout() {
      return this._runTask(
        checkoutTask(getTrailingOptions(arguments, 1)),
        trailingFunctionArgument(arguments)
      );
    },
    checkoutBranch(branchName, startPoint) {
      return this._runTask(
        checkoutTask(["-b", branchName, startPoint, ...getTrailingOptions(arguments)]),
        trailingFunctionArgument(arguments)
      );
    },
    checkoutLocalBranch(branchName) {
      return this._runTask(
        checkoutTask(["-b", branchName, ...getTrailingOptions(arguments)]),
        trailingFunctionArgument(arguments)
      );
    }
  };
}
var init_checkout = __esm({
  "src/lib/tasks/checkout.ts"() {
    "use strict";
    init_utils();
    init_task();
  }
});

// src/lib/tasks/count-objects.ts
/**
 * Creates an object containing various properties initialized to zero. This method is likely used to initialize counters or statistics for objects in a system.
 *
 * @returns {Object} An object with the following properties:
 *   - count (number): The total count of objects, initially set to 0.
 *   - garbage (number): The count of garbage objects, initially set to 0.
 *   - inPack (number): The count of objects in a pack, initially set to 0.
 *   - packs (number): The number of packs, initially set to 0.
 *   - prunePackable (number): The count of objects that can be pruned from a pack, initially set to 0.
 *   - size (number): The total size of objects, initially set to 0.
 *   - sizeGarbage (number): The size of garbage objects, initially set to 0.
 *   - sizePack (number): The total size of objects in a pack, initially set to 0.
 *
 * @example
 * const response = countObjectsResponse();
 * console.log(response.count); // Output: 0
 */
function countObjectsResponse() {
  return {
    count: 0,
    garbage: 0,
    inPack: 0,
    packs: 0,
    prunePackable: 0,
    size: 0,
    sizeGarbage: 0,
    sizePack: 0
  };
}
/**
 * Returns an object with a method to count objects using a specific task.
 * @return {Object} An object containing a method `countObjects` that runs a task to count objects.
 */
function count_objects_default() {
  return {
    countObjects() {
      return this._runTask({
        commands: ["count-objects", "--verbose"],
        format: "utf-8",
        parser(stdOut) {
          return parseStringResponse(countObjectsResponse(), [parser2], stdOut);
        }
      });
    }
  };
}
var parser2;
var init_count_objects = __esm({
  "src/lib/tasks/count-objects.ts"() {
    "use strict";
    init_utils();
    parser2 = new LineParser(
      /([a-z-]+): (\d+)$/,
      (result, [key, value]) => {
        const property = asCamelCase(key);
        if (result.hasOwnProperty(property)) {
          result[property] = asNumber(value);
        }
      }
    );
  }
});

// src/lib/parsers/parse-commit.ts
/**
 * Parses the commit result from the standard output of a git command.
 *
 * @param {string} stdOut - The standard output string containing the commit details.
 * @return {Object} An object representing the parsed commit result with properties like author, branch, commit, root, and summary.
 * @throws {Error} If the input stdOut is not a valid string or does not contain expected data.
 */
function parseCommitResult(stdOut) {
  const result = {
    author: null,
    branch: "",
    commit: "",
    root: false,
    summary: {
      changes: 0,
      insertions: 0,
      deletions: 0
    }
  };
  return parseStringResponse(result, parsers, stdOut);
}
var parsers;
var init_parse_commit = __esm({
  "src/lib/parsers/parse-commit.ts"() {
    "use strict";
    init_utils();
    parsers = [
      new LineParser(/^\[([^\s]+)( \([^)]+\))? ([^\]]+)/, (result, [branch, root, commit]) => {
        result.branch = branch;
        result.commit = commit;
        result.root = !!root;
      }),
      new LineParser(/\s*Author:\s(.+)/i, (result, [author]) => {
        const parts = author.split("<");
        const email = parts.pop();
        if (!email || !email.includes("@")) {
          return;
        }
        result.author = {
          email: email.substr(0, email.length - 1),
          name: parts.join("<").trim()
        };
      }),
      new LineParser(
        /(\d+)[^,]*(?:,\s*(\d+)[^,]*)(?:,\s*(\d+))/g,
        (result, [changes, insertions, deletions]) => {
          result.summary.changes = parseInt(changes, 10) || 0;
          result.summary.insertions = parseInt(insertions, 10) || 0;
          result.summary.deletions = parseInt(deletions, 10) || 0;
        }
      ),
      new LineParser(
        /^(\d+)[^,]*(?:,\s*(\d+)[^(]+\(([+-]))?/,
        (result, [changes, lines, direction]) => {
          result.summary.changes = parseInt(changes, 10) || 0;
          const count = parseInt(lines, 10) || 0;
          if (direction === "-") {
            result.summary.deletions = count;
          } else if (direction === "+") {
            result.summary.insertions = count;
          }
        }
      )
    ];
  }
});

// src/lib/tasks/commit.ts
/**
 * Commits changes to a version control system.
 *
 * @param {string} message - The commit message.
 * @param {Array<string>} files - Array of file paths to include in the commit.
 * @param {Array<string>} customArgs - Additional arguments for the commit command.
 * @returns {{commands: Array<string>, format: string, parser: function}} An object containing the commands to run, the expected output format, and a parser function.
 * @throws {Error} If there is an error in parsing the commit result.
 */
function commitTask(message, files, customArgs) {
  const commands = [
    "-c",
    "core.abbrev=40",
    "commit",
    ...prefixedArray(message, "-m"),
    ...files,
    ...customArgs
  ];
  return {
    commands,
    format: "utf-8",
    parser: parseCommitResult
  };
}
/**
 * Creates an object with a `commit` method for committing changes.
 *
 * @returns {Object} An object containing the `commit` method.
 */
function commit_default() {
  return {
    commit(message, ...rest) {
      const next = trailingFunctionArgument(arguments);
      const task = rejectDeprecatedSignatures(message) || commitTask(
        asArray(message),
        asArray(filterType(rest[0], filterStringOrStringArray, [])),
        [...filterType(rest[1], filterArray, []), ...getTrailingOptions(arguments, 0, true)]
      );
      return this._runTask(task, next);
    }
  };
  /**
   * Rejects deprecated signatures by checking if the provided message is falsy and throwing a configuration error if true.
   *
   * @param {string|string[]} message - The commit message to be validated. Must be a string or an array of strings.
   * @returns {boolean} - Returns false if the message is valid, otherwise throws an error.
   * @throws {ConfigurationErrorTask} - Throws a configuration error task with a specific message indicating that a commit message is required as a string or an array of strings.
   *
   * @example
   * // Example usage:
   * try {
   *   if (rejectDeprecatedSignatures('')) {
   *     console.log('Invalid commit message');
   *   }
   * } catch (error) {
   *   console.error(error.message); // Logs: git.commit: requires the commit message to be supplied as a string/string[]
   * }
   */
  function rejectDeprecatedSignatures(message) {
    return !filterStringOrStringArray(message) && configurationErrorTask(
      `git.commit: requires the commit message to be supplied as a string/string[]`
    );
  }
}
var init_commit = __esm({
  "src/lib/tasks/commit.ts"() {
    "use strict";
    init_parse_commit();
    init_utils();
    init_task();
  }
});

// src/lib/tasks/first-commit.ts
/**
 * Returns an object with a `firstCommit` method for retrieving the hash of the first commit in a repository.
 *
 * @returns {Object} An object containing the `firstCommit` method.
 */
function first_commit_default() {
  return {
    firstCommit() {
      return this._runTask(
        straightThroughStringTask(["rev-list", "--max-parents=0", "HEAD"], true),
        trailingFunctionArgument(arguments)
      );
    }
  };
}
var init_first_commit = __esm({
  "src/lib/tasks/first-commit.ts"() {
    "use strict";
    init_utils();
    init_task();
  }
});

// src/lib/tasks/hash-object.ts
/**
 * Generates a hash object task for a given file path.
 *
 * @param {string} filePath - The path to the file for which the hash object is to be generated.
 * @param {boolean} [write=false] - Optional. If true, adds the "-w" flag to write the object to the database.
 * @returns {Promise<string>} A promise that resolves with the result of the task.
 *
 * @example
 * hashObjectTask('path/to/file.txt', true)
 *   .then(result => console.log(result))
 *   .catch(error => console.error(error));
 *
 * @throws {Error} If there is an error executing the task.
 */
function hashObjectTask(filePath, write) {
  const commands = ["hash-object", filePath];
  if (write) {
    commands.push("-w");
  }
  return straightThroughStringTask(commands, true);
}
var init_hash_object = __esm({
  "src/lib/tasks/hash-object.ts"() {
    "use strict";
    init_task();
  }
});

// src/lib/responses/InitSummary.ts
/**
 * Parses initialization responses based on regex patterns and returns an InitSummary object.
 *
 * @param {boolean} bare - Indicates if the response is in a bare format.
 * @param {string} path - The file or directory path associated with the response.
 * @param {string} text - The text content to be parsed for initialization information.
 * @returns {InitSummary} An InitSummary object containing parsed information.
 *
 * @throws {Error} If no matching regex pattern is found in the response.
 */
function parseInit(bare, path, text) {
  const response = String(text).trim();
  let result;
  if (result = initResponseRegex.exec(response)) {
    return new InitSummary(bare, path, false, result[1]);
  }
  if (result = reInitResponseRegex.exec(response)) {
    return new InitSummary(bare, path, true, result[1]);
  }
  let gitDir = "";
  const tokens = response.split(" ");
  while (tokens.length) {
    const token = tokens.shift();
    if (token === "in") {
      gitDir = tokens.join(" ");
      break;
    }
  }
  return new InitSummary(bare, path, /^re/i.test(response), gitDir);
}
var InitSummary, initResponseRegex, reInitResponseRegex;
var init_InitSummary = __esm({
  "src/lib/responses/InitSummary.ts"() {
    "use strict";
    InitSummary = class {
      constructor(bare, path, existing, gitDir) {
        this.bare = bare;
        this.path = path;
        this.existing = existing;
        this.gitDir = gitDir;
      }
    };
    initResponseRegex = /^Init.+ repository in (.+)$/;
    reInitResponseRegex = /^Rein.+ in (.+)$/;
  }
});

// src/lib/tasks/init.ts
/**
 * Determines if the provided command contains a bare command string.
 *
 * @param {string} command - The command to be checked.
 * @returns {boolean} - True if the command includes a bare command, false otherwise.
 *
 * @example
 * hasBareCommand('run script');
 * // returns true
 *
 * hasBareCommand('check status');
 * // returns false
 */
function hasBareCommand(command) {
  return command.includes(bareCommand);
}
/**
 * Initializes a task with optional custom arguments and handling for bare mode.
 *
 * @param {boolean} [bare=false] - Whether to enable bare mode.
 * @param {string} path - The path related to the task.
 * @param {Array<string>} [customArgs=[]] - Custom arguments for the task initialization.
 * @returns {{commands: Array<string>, format: string, parser: function}} An object containing the commands, output format, and a parser function.
 *
 * @example
 * const taskConfig = initTask(true, '/project/path', ['--custom']);
 * console.log(taskConfig.commands); // Output might be ["init", "--bare", "--custom"]
 */
function initTask(bare = false, path, customArgs) {
  const commands = ["init", ...customArgs];
  if (bare && !hasBareCommand(commands)) {
    commands.splice(1, 0, bareCommand);
  }
  return {
    commands,
    format: "utf-8",
    parser(text) {
      return parseInit(commands.includes("--bare"), path, text);
    }
  };
}
var bareCommand;
var init_init = __esm({
  "src/lib/tasks/init.ts"() {
    "use strict";
    init_InitSummary();
    bareCommand = "--bare";
  }
});

// src/lib/args/log-format.ts
/**
 * Extracts the logging format from an array of custom arguments.
 *
 * @param {string[]} customArgs - An array of strings representing custom command-line arguments.
 * @returns {string} The extracted log format if found, otherwise returns an empty string.
 * @throws {Error} If the input is not an array or contains non-string elements.
 */
function logFormatFromCommand(customArgs) {
  for (let i = 0; i < customArgs.length; i++) {
    const format = logFormatRegex.exec(customArgs[i]);
    if (format) {
      return `--${format[1]}`;
    }
  }
  return "" /* NONE */;
}
/**
 * Checks if the provided custom argument matches the log format regex.
 *
 * @param {string} customArg - The custom argument to check.
 * @returns {boolean} - Returns true if the custom argument matches the log format regex, false otherwise.
 */
function isLogFormat(customArg) {
  return logFormatRegex.test(customArg);
}
var logFormatRegex;
var init_log_format = __esm({
  "src/lib/args/log-format.ts"() {
    "use strict";
    logFormatRegex = /^--(stat|numstat|name-only|name-status)(=|$)/;
  }
});

// src/lib/responses/DiffSummary.ts
var DiffSummary;
var init_DiffSummary = __esm({
  "src/lib/responses/DiffSummary.ts"() {
    "use strict";
    DiffSummary = class {
      constructor() {
        this.changed = 0;
        this.deletions = 0;
        this.insertions = 0;
        this.files = [];
      }
    };
  }
});

// src/lib/parsers/parse-diff-summary.ts
/**
 * Returns a function to parse the standard output (stdOut) based on the specified format.
 *
 * @param {string} [format=NONE] - The format of the diff summary. Default is "NONE".
 * @returns {function(string): DiffSummary} A parser function that takes the stdOut and returns a parsed DiffSummary object.
 *
 * @example
 * const parseDiff = getDiffParser("JSON");
 * const result = parseDiff("{ \"added\": 2, \"removed\": 1 }");
 */
function getDiffParser(format = "" /* NONE */) {
  const parser4 = diffSummaryParsers[format];
  return (stdOut) => parseStringResponse(new DiffSummary(), parser4, stdOut, false);
}
var statParser, numStatParser, nameOnlyParser, nameStatusParser, diffSummaryParsers;
var init_parse_diff_summary = __esm({
  "src/lib/parsers/parse-diff-summary.ts"() {
    "use strict";
    init_log_format();
    init_DiffSummary();
    init_diff_name_status();
    init_utils();
    statParser = [
      new LineParser(
        /^(.+)\s+\|\s+(\d+)(\s+[+\-]+)?$/,
        (result, [file, changes, alterations = ""]) => {
          result.files.push({
            file: file.trim(),
            changes: asNumber(changes),
            insertions: alterations.replace(/[^+]/g, "").length,
            deletions: alterations.replace(/[^-]/g, "").length,
            binary: false
          });
        }
      ),
      new LineParser(
        /^(.+) \|\s+Bin ([0-9.]+) -> ([0-9.]+) ([a-z]+)/,
        (result, [file, before, after]) => {
          result.files.push({
            file: file.trim(),
            before: asNumber(before),
            after: asNumber(after),
            binary: true
          });
        }
      ),
      new LineParser(
        /(\d+) files? changed\s*((?:, \d+ [^,]+){0,2})/,
        (result, [changed, summary]) => {
          const inserted = /(\d+) i/.exec(summary);
          const deleted = /(\d+) d/.exec(summary);
          result.changed = asNumber(changed);
          result.insertions = asNumber(inserted == null ? void 0 : inserted[1]);
          result.deletions = asNumber(deleted == null ? void 0 : deleted[1]);
        }
      )
    ];
    numStatParser = [
      new LineParser(
        /(\d+)\t(\d+)\t(.+)$/,
        (result, [changesInsert, changesDelete, file]) => {
          const insertions = asNumber(changesInsert);
          const deletions = asNumber(changesDelete);
          result.changed++;
          result.insertions += insertions;
          result.deletions += deletions;
          result.files.push({
            file,
            changes: insertions + deletions,
            insertions,
            deletions,
            binary: false
          });
        }
      ),
      new LineParser(/-\t-\t(.+)$/, (result, [file]) => {
        result.changed++;
        result.files.push({
          file,
          after: 0,
          before: 0,
          binary: true
        });
      })
    ];
    nameOnlyParser = [
      new LineParser(/(.+)$/, (result, [file]) => {
        result.changed++;
        result.files.push({
          file,
          changes: 0,
          insertions: 0,
          deletions: 0,
          binary: false
        });
      })
    ];
    nameStatusParser = [
      new LineParser(
        /([ACDMRTUXB])([0-9]{0,3})\t(.[^\t]*)(\t(.[^\t]*))?$/,
        (result, [status, similarity, from, _to, to]) => {
          result.changed++;
          result.files.push({
            file: to != null ? to : from,
            changes: 0,
            insertions: 0,
            deletions: 0,
            binary: false,
            status: orVoid(isDiffNameStatus(status) && status),
            from: orVoid(!!to && from !== to && from),
            similarity: asNumber(similarity)
          });
        }
      )
    ];
    diffSummaryParsers = {
      ["" /* NONE */]: statParser,
      ["--stat" /* STAT */]: statParser,
      ["--numstat" /* NUM_STAT */]: numStatParser,
      ["--name-status" /* NAME_STATUS */]: nameStatusParser,
      ["--name-only" /* NAME_ONLY */]: nameOnlyParser
    };
  }
});

// src/lib/parsers/parse-list-log-summary.ts
/**
 * Builds a line object by mapping tokens to specified fields.
 *
 * @param {string[]} tokens - An array of token strings.
 * @param {string[]} fields - An array of field names corresponding to the tokens.
 * @returns {Object} - An object with properties based on the `fields` array, where each property corresponds to a token from the `tokens` array. If a token is not provided, it defaults to an empty string.
 *
 * @example
 * const result = lineBuilder(['foo', 'bar'], ['id', 'name']);
 * console.log(result); // { id: 'foo', name: 'bar' }
 */
function lineBuilder(tokens, fields) {
  return fields.reduce(
    (line, field, index) => {
      line[field] = tokens[index] || "";
      return line;
    },
    /* @__PURE__ */ Object.create({ diff: null })
  );
}
function createListLogSummaryParser(splitter = SPLITTER, fields = defaultFieldNames, logFormat = "" /* NONE */) {
  const parseDiffResult = getDiffParser(logFormat);
  return function(stdOut) {
    const all = toLinesWithContent(
      stdOut.trim(),
      false,
      START_BOUNDARY
    ).map(function(item) {
      const lineDetail = item.split(COMMIT_BOUNDARY);
      const listLogLine = lineBuilder(lineDetail[0].split(splitter), fields);
      if (lineDetail.length > 1 && !!lineDetail[1].trim()) {
        listLogLine.diff = parseDiffResult(lineDetail[1]);
      }
      return listLogLine;
    });
    return {
      all,
      latest: all.length && all[0] || null,
      total: all.length
    };
  };
}
var START_BOUNDARY, COMMIT_BOUNDARY, SPLITTER, defaultFieldNames;
var init_parse_list_log_summary = __esm({
  "src/lib/parsers/parse-list-log-summary.ts"() {
    "use strict";
    init_utils();
    init_parse_diff_summary();
    init_log_format();
    START_BOUNDARY = "\xF2\xF2\xF2\xF2\xF2\xF2 ";
    COMMIT_BOUNDARY = " \xF2\xF2";
    SPLITTER = " \xF2 ";
    defaultFieldNames = ["hash", "date", "message", "refs", "author_name", "author_email"];
  }
});

// src/lib/tasks/diff.ts
var diff_exports = {};
__export(diff_exports, {
  diffSummaryTask: () => diffSummaryTask,
  validateLogFormatConfig: () => validateLogFormatConfig
});
/**
 * Generates a summary of differences using provided custom arguments.
 *
 * @param {Object} customArgs - Custom arguments for the diff command.
 * @returns {Object} An object containing commands, format, and parser information.
 * @throws {Error} If log format configuration is invalid.
 */
function diffSummaryTask(customArgs) {
  let logFormat = logFormatFromCommand(customArgs);
  const commands = ["diff"];
  if (logFormat === "" /* NONE */) {
    logFormat = "--stat" /* STAT */;
    commands.push("--stat=4096");
  }
  commands.push(...customArgs);
  return validateLogFormatConfig(commands) || {
    commands,
    format: "utf-8",
    parser: getDiffParser(logFormat)
  };
}
/**
 * Validates the configuration flags provided for log format.
 *
 * This function checks if there are mutually exclusive summary flags in the custom arguments.
 * If a summary flag is present with the null termination option '-z', it returns an error.
 *
 * @param {string[]} customArgs - The array of custom arguments to be validated.
 * @return {Promise} A promise that resolves to undefined if validation passes, or rejects with an error message if validation fails.
 * @throws {Error} If more than one summary flag is present in the custom arguments.
 * @throws {Error} If a summary flag and the null termination option '-z' are both present.
 *
 * Example:
 * validateLogFormatConfig(['-a', '-b']).then(() => {
 *   console.log('Validation passed');
 * }).catch(error => {
 *   console.error(error.message);
 * });
 */
function validateLogFormatConfig(customArgs) {
  const flags = customArgs.filter(isLogFormat);
  if (flags.length > 1) {
    return configurationErrorTask(
      `Summary flags are mutually exclusive - pick one of ${flags.join(",")}`
    );
  }
  if (flags.length && customArgs.includes("-z")) {
    return configurationErrorTask(
      `Summary flag ${flags} parsing is not compatible with null termination option '-z'`
    );
  }
}
var init_diff = __esm({
  "src/lib/tasks/diff.ts"() {
    "use strict";
    init_log_format();
    init_parse_diff_summary();
    init_task();
  }
});

// src/lib/tasks/log.ts
/**
 * Formats an object into two arrays - one with field names and another with their corresponding values.
 *
 * @param {Object} format - The object to be formatted.
 * @param {string} splitter - The string used to split the fields in the formatStr array.
 * @returns {[Array, Array]} A tuple containing two arrays: the first with field names and the second with their corresponding values joined by the splitter.
 *
 * Example:
 * ```javascript
 * const result = prettyFormat({name: 'John', age: 30}, ',');
 * console.log(result); // [['name', 'age'], ['John,30']]
 * ```
 */
function prettyFormat(format, splitter) {
  const fields = [];
  const formatStr = [];
  Object.keys(format).forEach((field) => {
    fields.push(field);
    formatStr.push(String(format[field]));
  });
  return [fields, formatStr.join(splitter)];
}
/**
 * Filters out excluded options from the input object.
 *
 * @param {Object} input - The object containing various options.
 * @returns {Object} A new object with only the options that are not in the excludeOptions list.
 * @throws {TypeError} If `input` is not an object.
 */
function userOptions(input) {
  return Object.keys(input).reduce((out, key) => {
    if (!(key in excludeOptions)) {
      out[key] = input[key];
    }
    return out;
  }, {});
}
/**
 * Parses log options to generate commands for pretty printing commit logs.
 *
 * @param {Object} [opt={}] - The options object containing various settings.
 * @param {Array} [customArgs=[]] - An array of custom arguments to append to the command.
 * @returns {Object} - An object containing parsed fields, splitter, and commands.
 * @throws {Error} - Throws an error if invalid options are provided.
 *
 * @example
 * const result = parseLogOptions({ splitter: "\n", format: "%H %s" }, ["--color"]);
 * console.log(result);
 */
function parseLogOptions(opt = {}, customArgs = []) {
  const splitter = filterType(opt.splitter, filterString, SPLITTER);
  const format = !filterPrimitives(opt.format) && opt.format ? opt.format : {
    hash: "%H",
    date: opt.strictDate === false ? "%ai" : "%aI",
    message: "%s",
    refs: "%D",
    body: opt.multiLine ? "%B" : "%b",
    author_name: opt.mailMap !== false ? "%aN" : "%an",
    author_email: opt.mailMap !== false ? "%aE" : "%ae"
  };
  const [fields, formatStr] = prettyFormat(format, splitter);
  const suffix = [];
  const command = [
    `--pretty=format:${START_BOUNDARY}${formatStr}${COMMIT_BOUNDARY}`,
    ...customArgs
  ];
  const maxCount = opt.n || opt["max-count"] || opt.maxCount;
  if (maxCount) {
    command.push(`--max-count=${maxCount}`);
  }
  if (opt.from || opt.to) {
    const rangeOperator = opt.symmetric !== false ? "..." : "..";
    suffix.push(`${opt.from || ""}${rangeOperator}${opt.to || ""}`);
  }
  if (filterString(opt.file)) {
    command.push("--follow", pathspec(opt.file));
  }
  appendTaskOptions(userOptions(opt), command);
  return {
    fields,
    splitter,
    commands: [...command, ...suffix]
  };
}
/**
 * Generates a task object for logging purposes with specified splitter, fields, and custom arguments.
 *
 * @param {string} splitter - The delimiter used to split the log entries.
 * @param {Array<string>} fields - An array of field names to include in the log summary.
 * @param {Object} customArgs - Custom arguments for the logging task.
 * @returns {Object} A task object with commands, format, and parser properties.
 *
 * @example
 * const task = logTask(',', ['timestamp', 'message'], { verbose: true });
 * console.log(task);
 * // Output:
 * // {
 * //   commands: ["log", "--verbose"],
 * //   format: "utf-8",
 * //   parser: <Parser object>
 * // }
 */
function logTask(splitter, fields, customArgs) {
  const parser4 = createListLogSummaryParser(splitter, fields, logFormatFromCommand(customArgs));
  return {
    commands: ["log", ...customArgs],
    format: "utf-8",
    parser: parser4
  };
}
/**
 * Default logging function generator.
 *
 * @returns {Object} - An object containing the `log` method for logging operations.
 */
function log_default() {
  return {
    log(...rest) {
      const next = trailingFunctionArgument(arguments);
      const options = parseLogOptions(
        trailingOptionsArgument(arguments),
        filterType(arguments[0], filterArray)
      );
      const task = rejectDeprecatedSignatures(...rest) || validateLogFormatConfig(options.commands) || createLogTask(options);
      return this._runTask(task, next);
    }
  };
  /**
   * Creates a log task with the specified options.
   *
   * @param {Object} options - The options for the log task.
   * @param {string} options.splitter - The delimiter used to split fields in the input data.
   * @param {Array<string>} options.fields - An array of field names to be included in the log output.
   * @param {Array<string>} options.commands - An array of commands to execute for processing the log data.
   *
   * @returns {Object} - The created log task object.
   */
  function createLogTask(options) {
    return logTask(options.splitter, options.fields, options.commands);
  }
  /**
   * Rejects deprecated signatures for `git.log` by filtering strings and throwing a configuration error task.
   *
   * @param {string} from - The starting string of the commit range.
   * @param {string} to - The ending string of the commit range.
   * @returns {boolean} - True if both strings are filtered successfully, false otherwise.
   * @throws {ConfigurationErrorTask} - Throws an error task if deprecated signature is used.
   *
   * @example
   * // Example usage will be provided in actual documentation
   */
  function rejectDeprecatedSignatures(from, to) {
    return filterString(from) && filterString(to) && configurationErrorTask(
      `git.log(string, string) should be replaced with git.log({ from: string, to: string })`
    );
  }
}
var excludeOptions;
var init_log = __esm({
  "src/lib/tasks/log.ts"() {
    "use strict";
    init_log_format();
    init_pathspec();
    init_parse_list_log_summary();
    init_utils();
    init_task();
    init_diff();
    excludeOptions = /* @__PURE__ */ ((excludeOptions2) => {
      excludeOptions2[excludeOptions2["--pretty"] = 0] = "--pretty";
      excludeOptions2[excludeOptions2["max-count"] = 1] = "max-count";
      excludeOptions2[excludeOptions2["maxCount"] = 2] = "maxCount";
      excludeOptions2[excludeOptions2["n"] = 3] = "n";
      excludeOptions2[excludeOptions2["file"] = 4] = "file";
      excludeOptions2[excludeOptions2["format"] = 5] = "format";
      excludeOptions2[excludeOptions2["from"] = 6] = "from";
      excludeOptions2[excludeOptions2["to"] = 7] = "to";
      excludeOptions2[excludeOptions2["splitter"] = 8] = "splitter";
      excludeOptions2[excludeOptions2["symmetric"] = 9] = "symmetric";
      excludeOptions2[excludeOptions2["mailMap"] = 10] = "mailMap";
      excludeOptions2[excludeOptions2["multiLine"] = 11] = "multiLine";
      excludeOptions2[excludeOptions2["strictDate"] = 12] = "strictDate";
      return excludeOptions2;
    })(excludeOptions || {});
  }
});

// src/lib/responses/MergeSummary.ts
var MergeSummaryConflict, MergeSummaryDetail;
var init_MergeSummary = __esm({
  "src/lib/responses/MergeSummary.ts"() {
    "use strict";
    MergeSummaryConflict = class {
      constructor(reason, file = null, meta) {
        this.reason = reason;
        this.file = file;
        this.meta = meta;
      }
      toString() {
        return `${this.file}:${this.reason}`;
      }
    };
    MergeSummaryDetail = class {
      constructor() {
        this.conflicts = [];
        this.merges = [];
        this.result = "success";
      }
      get failed() {
        return this.conflicts.length > 0;
      }
      get reason() {
        return this.result;
      }
      toString() {
        if (this.conflicts.length) {
          return `CONFLICTS: ${this.conflicts.join(", ")}`;
        }
        return "OK";
      }
    };
  }
});

// src/lib/responses/PullSummary.ts
var PullSummary, PullFailedSummary;
var init_PullSummary = __esm({
  "src/lib/responses/PullSummary.ts"() {
    "use strict";
    PullSummary = class {
      constructor() {
        this.remoteMessages = {
          all: []
        };
        this.created = [];
        this.deleted = [];
        this.files = [];
        this.deletions = {};
        this.insertions = {};
        this.summary = {
          changes: 0,
          deletions: 0,
          insertions: 0
        };
      }
    };
    PullFailedSummary = class {
      constructor() {
        this.remote = "";
        this.hash = {
          local: "",
          remote: ""
        };
        this.branch = {
          local: "",
          remote: ""
        };
        this.message = "";
      }
      toString() {
        return this.message;
      }
    };
  }
});

// src/lib/parsers/parse-remote-objects.ts
/**
 * Enumerates objects from remote messages.
 *
 * @param {Object} remoteMessages - The object containing remote messages.
 * @returns {Object} An object with properties for various enumerations and counts.
 */
function objectEnumerationResult(remoteMessages) {
  return remoteMessages.objects = remoteMessages.objects || {
    compressing: 0,
    counting: 0,
    enumerating: 0,
    packReused: 0,
    reused: { count: 0, delta: 0 },
    total: { count: 0, delta: 0 }
  };
}
/**
 * Parses a source string to extract count and delta values and returns an object with these values.
 *
 * @param {string} source - The source string containing count and/or delta values.
 * @returns {object} An object containing the parsed count and delta as numbers.
 *
 * @example
 * // Example usage:
 * const result = asObjectCount("count 10 delta 5");
 * console.log(result); // Output: { count: 10, delta: 5 }
 */
function asObjectCount(source) {
  const count = /^\s*(\d+)/.exec(source);
  const delta = /delta (\d+)/i.exec(source);
  return {
    count: asNumber(count && count[1] || "0"),
    delta: asNumber(delta && delta[1] || "0")
  };
}
var remoteMessagesObjectParsers;
var init_parse_remote_objects = __esm({
  "src/lib/parsers/parse-remote-objects.ts"() {
    "use strict";
    init_utils();
    remoteMessagesObjectParsers = [
      new RemoteLineParser(
        /^remote:\s*(enumerating|counting|compressing) objects: (\d+),/i,
        (result, [action, count]) => {
          const key = action.toLowerCase();
          const enumeration = objectEnumerationResult(result.remoteMessages);
          Object.assign(enumeration, { [key]: asNumber(count) });
        }
      ),
      new RemoteLineParser(
        /^remote:\s*(enumerating|counting|compressing) objects: \d+% \(\d+\/(\d+)\),/i,
        (result, [action, count]) => {
          const key = action.toLowerCase();
          const enumeration = objectEnumerationResult(result.remoteMessages);
          Object.assign(enumeration, { [key]: asNumber(count) });
        }
      ),
      new RemoteLineParser(
        /total ([^,]+), reused ([^,]+), pack-reused (\d+)/i,
        (result, [total, reused, packReused]) => {
          const objects = objectEnumerationResult(result.remoteMessages);
          objects.total = asObjectCount(total);
          objects.reused = asObjectCount(reused);
          objects.packReused = asNumber(packReused);
        }
      )
    ];
  }
});

// src/lib/parsers/parse-remote-messages.ts
/**
 * Parses remote messages from standard output and error.
 *
 * @param {string} _stdOut - The standard output containing the remote messages.
 * @param {string} stdErr - The standard error containing any errors during parsing.
 * @returns {Object} An object containing a RemoteMessageSummary instance.
 */
function parseRemoteMessages(_stdOut, stdErr) {
  return parseStringResponse({ remoteMessages: new RemoteMessageSummary() }, parsers2, stdErr);
}
var parsers2, RemoteMessageSummary;
var init_parse_remote_messages = __esm({
  "src/lib/parsers/parse-remote-messages.ts"() {
    "use strict";
    init_utils();
    init_parse_remote_objects();
    parsers2 = [
      new RemoteLineParser(/^remote:\s*(.+)$/, (result, [text]) => {
        result.remoteMessages.all.push(text.trim());
        return false;
      }),
      ...remoteMessagesObjectParsers,
      new RemoteLineParser(
        [/create a (?:pull|merge) request/i, /\s(https?:\/\/\S+)$/],
        (result, [pullRequestUrl]) => {
          result.remoteMessages.pullRequestUrl = pullRequestUrl;
        }
      ),
      new RemoteLineParser(
        [/found (\d+) vulnerabilities.+\(([^)]+)\)/i, /\s(https?:\/\/\S+)$/],
        (result, [count, summary, url]) => {
          result.remoteMessages.vulnerabilities = {
            count: asNumber(count),
            summary,
            url
          };
        }
      )
    ];
    RemoteMessageSummary = class {
      constructor() {
        this.all = [];
      }
    };
  }
});

// src/lib/parsers/parse-pull.ts
/**
 * Parses the result of a pull operation for errors.
 *
 * @param {string} stdOut - The standard output from the pull command.
 * @param {string} stdErr - The standard error from the pull command.
 * @returns {(PullFailedSummary | null)} Returns an instance of PullFailedSummary if an error is found, otherwise null.
 * @throws {Error} Throws an error if there are parsing issues.
 */
function parsePullErrorResult(stdOut, stdErr) {
  const pullError = parseStringResponse(new PullFailedSummary(), errorParsers, [stdOut, stdErr]);
  return pullError.message && pullError;
}
var FILE_UPDATE_REGEX, SUMMARY_REGEX, ACTION_REGEX, parsers3, errorParsers, parsePullDetail, parsePullResult;
var init_parse_pull = __esm({
  "src/lib/parsers/parse-pull.ts"() {
    "use strict";
    init_PullSummary();
    init_utils();
    init_parse_remote_messages();
    FILE_UPDATE_REGEX = /^\s*(.+?)\s+\|\s+\d+\s*(\+*)(-*)/;
    SUMMARY_REGEX = /(\d+)\D+((\d+)\D+\(\+\))?(\D+(\d+)\D+\(-\))?/;
    ACTION_REGEX = /^(create|delete) mode \d+ (.+)/;
    parsers3 = [
      new LineParser(FILE_UPDATE_REGEX, (result, [file, insertions, deletions]) => {
        result.files.push(file);
        if (insertions) {
          result.insertions[file] = insertions.length;
        }
        if (deletions) {
          result.deletions[file] = deletions.length;
        }
      }),
      new LineParser(SUMMARY_REGEX, (result, [changes, , insertions, , deletions]) => {
        if (insertions !== void 0 || deletions !== void 0) {
          result.summary.changes = +changes || 0;
          result.summary.insertions = +insertions || 0;
          result.summary.deletions = +deletions || 0;
          return true;
        }
        return false;
      }),
      new LineParser(ACTION_REGEX, (result, [action, file]) => {
        append(result.files, file);
        append(action === "create" ? result.created : result.deleted, file);
      })
    ];
    errorParsers = [
      new LineParser(/^from\s(.+)$/i, (result, [remote]) => void (result.remote = remote)),
      new LineParser(/^fatal:\s(.+)$/, (result, [message]) => void (result.message = message)),
      new LineParser(
        /([a-z0-9]+)\.\.([a-z0-9]+)\s+(\S+)\s+->\s+(\S+)$/,
        (result, [hashLocal, hashRemote, branchLocal, branchRemote]) => {
          result.branch.local = branchLocal;
          result.hash.local = hashLocal;
          result.branch.remote = branchRemote;
          result.hash.remote = hashRemote;
        }
      )
    ];
    parsePullDetail = (stdOut, stdErr) => {
      return parseStringResponse(new PullSummary(), parsers3, [stdOut, stdErr]);
    };
    parsePullResult = (stdOut, stdErr) => {
      return Object.assign(
        new PullSummary(),
        parsePullDetail(stdOut, stdErr),
        parseRemoteMessages(stdOut, stdErr)
      );
    };
  }
});

// src/lib/parsers/parse-merge.ts
var parsers4, parseMergeResult, parseMergeDetail;
var init_parse_merge = __esm({
  "src/lib/parsers/parse-merge.ts"() {
    "use strict";
    init_MergeSummary();
    init_utils();
    init_parse_pull();
    parsers4 = [
      new LineParser(/^Auto-merging\s+(.+)$/, (summary, [autoMerge]) => {
        summary.merges.push(autoMerge);
      }),
      new LineParser(/^CONFLICT\s+\((.+)\): Merge conflict in (.+)$/, (summary, [reason, file]) => {
        summary.conflicts.push(new MergeSummaryConflict(reason, file));
      }),
      new LineParser(
        /^CONFLICT\s+\((.+\/delete)\): (.+) deleted in (.+) and/,
        (summary, [reason, file, deleteRef]) => {
          summary.conflicts.push(new MergeSummaryConflict(reason, file, { deleteRef }));
        }
      ),
      new LineParser(/^CONFLICT\s+\((.+)\):/, (summary, [reason]) => {
        summary.conflicts.push(new MergeSummaryConflict(reason, null));
      }),
      new LineParser(/^Automatic merge failed;\s+(.+)$/, (summary, [result]) => {
        summary.result = result;
      })
    ];
    parseMergeResult = (stdOut, stdErr) => {
      return Object.assign(parseMergeDetail(stdOut, stdErr), parsePullResult(stdOut, stdErr));
    };
    parseMergeDetail = (stdOut) => {
      return parseStringResponse(new MergeSummaryDetail(), parsers4, stdOut);
    };
  }
});

// src/lib/tasks/merge.ts
/**
 * Merges branches using Git with specified custom arguments.
 *
 * @param {Array<string>} customArgs - An array of strings representing the options to pass to the 'git merge' command.
 * @returns {Object} - An object containing the commands, format, and parser for merging branches.
 * @throws {GitResponseError} - Throws an error if the merge operation fails.
 *
 * @example
 * const result = await mergeTask(['--no-ff', 'feature-branch']);
 * console.log(result);
 */
function mergeTask(customArgs) {
  if (!customArgs.length) {
    return configurationErrorTask("Git.merge requires at least one option");
  }
  return {
    commands: ["merge", ...customArgs],
    format: "utf-8",
    parser(stdOut, stdErr) {
      const merge = parseMergeResult(stdOut, stdErr);
      if (merge.failed) {
        throw new GitResponseError(merge);
      }
      return merge;
    }
  };
}
var init_merge = __esm({
  "src/lib/tasks/merge.ts"() {
    "use strict";
    init_git_response_error();
    init_parse_merge();
    init_task();
  }
});

// src/lib/parsers/parse-push.ts
/**
 * Creates an object representing the status of a pushed item with various properties indicating different conditions.
 *
 * @param {string} local - The local reference (branch or tag) of the pushed item.
 * @param {string} remote - The remote reference of the pushed item.
 * @param {string} status - A string describing the status of the push, which may include indicators like "deleted", "tag", and "new".
 * @returns {Object} An object with properties:
 *   - deleted {boolean}: True if the status includes "deleted", false otherwise.
 *   - tag {boolean}: True if the status includes "tag" or the local reference matches /^refs\/tags/, false otherwise.
 *   - branch {boolean}: True if not a tag, i.e., if the status does not include "tag".
 *   - new {boolean}: True if the item is new (i.e., not already updated), false otherwise.
 *   - alreadyUpdated {boolean}: True if the item was already updated, false otherwise.
 *   - local {string}: The local reference of the pushed item.
 *   - remote {string}: The remote reference of the pushed item.
 */
function pushResultPushedItem(local, remote, status) {
  const deleted = status.includes("deleted");
  const tag = status.includes("tag") || /^refs\/tags/.test(local);
  const alreadyUpdated = !status.includes("new");
  return {
    deleted,
    tag,
    branch: !tag,
    new: !alreadyUpdated,
    alreadyUpdated,
    local,
    remote
  };
}
var parsers5, parsePushResult, parsePushDetail;
var init_parse_push = __esm({
  "src/lib/parsers/parse-push.ts"() {
    "use strict";
    init_utils();
    init_parse_remote_messages();
    parsers5 = [
      new LineParser(/^Pushing to (.+)$/, (result, [repo]) => {
        result.repo = repo;
      }),
      new LineParser(/^updating local tracking ref '(.+)'/, (result, [local]) => {
        result.ref = __spreadProps(__spreadValues({}, result.ref || {}), {
          local
        });
      }),
      new LineParser(/^[=*-]\s+([^:]+):(\S+)\s+\[(.+)]$/, (result, [local, remote, type]) => {
        result.pushed.push(pushResultPushedItem(local, remote, type));
      }),
      new LineParser(
        /^Branch '([^']+)' set up to track remote branch '([^']+)' from '([^']+)'/,
        (result, [local, remote, remoteName]) => {
          result.branch = __spreadProps(__spreadValues({}, result.branch || {}), {
            local,
            remote,
            remoteName
          });
        }
      ),
      new LineParser(
        /^([^:]+):(\S+)\s+([a-z0-9]+)\.\.([a-z0-9]+)$/,
        (result, [local, remote, from, to]) => {
          result.update = {
            head: {
              local,
              remote
            },
            hash: {
              from,
              to
            }
          };
        }
      )
    ];
    parsePushResult = (stdOut, stdErr) => {
      const pushDetail = parsePushDetail(stdOut, stdErr);
      const responseDetail = parseRemoteMessages(stdOut, stdErr);
      return __spreadValues(__spreadValues({}, pushDetail), responseDetail);
    };
    parsePushDetail = (stdOut, stdErr) => {
      return parseStringResponse({ pushed: [] }, parsers5, [stdOut, stdErr]);
    };
  }
});

// src/lib/tasks/push.ts
var push_exports = {};
__export(push_exports, {
  pushTagsTask: () => pushTagsTask,
  pushTask: () => pushTask
});
/**
 * Adds the "--tags" argument to the custom arguments and then calls the `pushTask` function with the provided reference object.
 *
 * @param {Object} ref - The reference object that will be passed to the `pushTask` function. Defaults to an empty object if not provided.
 * @param {Array|string} [customArgs] - An array or string of additional arguments to pass to the task. If a string is provided, it will be converted into an array containing the single argument.
 * @returns {Promise<void>} A promise that resolves when the `pushTask` function has completed.
 *
 * @example
 * // Example usage:
 * await pushTagsTask({ taskId: '123' }, ['--tag', 'feature']);
 */
function pushTagsTask(ref = {}, customArgs) {
  append(customArgs, "--tags");
  return pushTask(ref, customArgs);
}
/**
 * Generates an object with commands to perform a Git push operation based on the provided reference and custom arguments.
 *
 * @param {Object} [ref={}] - An optional object containing branch and remote information for the push operation.
 * @param {string[]} [customArgs=[]] - Custom arguments that can be appended to the command.
 * @returns {Object} An object containing the commands, format, and parser for the push operation.
 *
 * @example
 * const result = pushTask({ branch: 'main', remote: 'origin' }, ['--force']);
 * console.log(result);
 * // Output:
 * // {
 * //   commands: ['push', 'origin', 'main', '--force', '-v', '--verbose', '--porcelain'],
 * //   format: 'utf-8',
 * //   parser: parsePushResult
 * // }
 */
function pushTask(ref = {}, customArgs) {
  const commands = ["push", ...customArgs];
  if (ref.branch) {
    commands.splice(1, 0, ref.branch);
  }
  if (ref.remote) {
    commands.splice(1, 0, ref.remote);
  }
  remove(commands, "-v");
  append(commands, "--verbose");
  append(commands, "--porcelain");
  return {
    commands,
    format: "utf-8",
    parser: parsePushResult
  };
}
var init_push = __esm({
  "src/lib/tasks/push.ts"() {
    "use strict";
    init_parse_push();
    init_utils();
  }
});

// src/lib/tasks/show.ts
/**
 * Generates default methods for showing content with different options.
 *
 * @returns {Object} An object containing two methods `showBuffer` and `show`.
 */
function show_default() {
  return {
    showBuffer() {
      const commands = ["show", ...getTrailingOptions(arguments, 1)];
      if (!commands.includes("--binary")) {
        commands.splice(1, 0, "--binary");
      }
      return this._runTask(
        straightThroughBufferTask(commands),
        trailingFunctionArgument(arguments)
      );
    },
    show() {
      const commands = ["show", ...getTrailingOptions(arguments, 1)];
      return this._runTask(
        straightThroughStringTask(commands),
        trailingFunctionArgument(arguments)
      );
    }
  };
}
var init_show = __esm({
  "src/lib/tasks/show.ts"() {
    "use strict";
    init_utils();
    init_task();
  }
});

// src/lib/responses/FileStatusSummary.ts
var fromPathRegex, FileStatusSummary;
var init_FileStatusSummary = __esm({
  "src/lib/responses/FileStatusSummary.ts"() {
    "use strict";
    fromPathRegex = /^(.+)\0(.+)$/;
    FileStatusSummary = class {
      constructor(path, index, working_dir) {
        this.path = path;
        this.index = index;
        this.working_dir = working_dir;
        if (index === "R" || working_dir === "R") {
          const detail = fromPathRegex.exec(path) || [null, path, path];
          this.from = detail[2] || "";
          this.path = detail[1] || "";
        }
      }
    };
  }
});

// src/lib/responses/StatusSummary.ts
/**
 * Renames or modifies a line based on a delimiter.
 *
 * This function takes a string `line` and splits it using the `NULL` delimiter (which is assumed to be a placeholder for actual delimiter).
 * If the split results in only one element, that element is considered as both `to` and `from`. Otherwise, the first element
 * is taken as `from`, and the second as `to`.
 *
 * @param {string} line - The input line to be processed.
 * @return {{from: string, to: string}} An object containing two properties: `from` and `to`. If only one element was found
 *         in the split, both properties will have the same value. Otherwise, they represent the two parts of the split line.
 *
 * Example:
 *   Input: "example|value"
 *   Output: { from: "example", to: "value" }
 */
function renamedFile(line) {
  const [to, from] = line.split(NULL);
  return {
    from: from || to,
    to
  };
}
/**
 * Parses an index pair into a string and applies a handler function to it.
 *
 * @param {number} indexX - The X coordinate of the index pair.
 * @param {number} indexY - The Y coordinate of the index pair.
 * @param {function(string): any} handler - A function that takes a string parameter and returns any type.
 * @returns {[string, any]} An array containing a string representation of the index pair and the result of the handler function.
 *
 * @example
 * const [indexString, result] = parser3(1, 2, (str) => str.length);
 * console.log(indexString); // Output: "12"
 * console.log(result);      // Output: 2
 */
function parser3(indexX, indexY, handler) {
  return [`${indexX}${indexY}`, handler];
}
/**
 * Determines if there are conflicts between an index and multiple other indices using a parser function.
 *
 * @param {number} indexX - The base index to compare against.
 * @param {...number} indexY - One or more additional indices to check for conflicts with the base index.
 * @returns {Promise<Array<File>>} A promise that resolves to an array of files that are in conflict with the base index.
 *
 * @example
 * conflicts(1, 2, 3)
 *   .then((conflictedFiles) => {
 *     console.log('Conflicted Files:', conflictedFiles);
 *   })
 *   .catch((error) => {
 *     console.error('Error finding conflicting files:', error);
 *   });
 */
function conflicts(indexX, ...indexY) {
  return indexY.map((y) => parser3(indexX, y, (result, file) => append(result.conflicted, file)));
}
/**
 * Splits a line string into parts and processes it based on specific conditions.
 *
 * @param {Object} result - The object where the processed data will be stored.
 * @param {string} lineStr - The input string to be processed.
 * @returns {undefined}
 * @throws {Error} Throws an error if the trimmed input string length is less than 3 characters.
 */
function splitLine(result, lineStr) {
  const trimmed2 = lineStr.trim();
  switch (" ") {
    case trimmed2.charAt(2):
      return data(trimmed2.charAt(0), trimmed2.charAt(1), trimmed2.substr(3));
    case trimmed2.charAt(1):
      return data(" " /* NONE */, trimmed2.charAt(0), trimmed2.substr(2));
    default:
      return;
  }
  /**
   * Processes data by handling it with appropriate parsers and updating result object.
   *
   * @param {number} index - The index of the current data entry.
   * @param {string} workingDir - The directory where the data is currently being processed.
   * @param {string} path - The path to the file or resource being processed.
   * @throws {Error} If no handler is found for the combination of index and workingDir.
   */
  function data(index, workingDir, path) {
    const raw = `${index}${workingDir}`;
    const handler = parsers6.get(raw);
    if (handler) {
      handler(result, path);
    }
    if (raw !== "##" && raw !== "!!") {
      result.files.push(new FileStatusSummary(path, index, workingDir));
    }
  }
}
var StatusSummary, parsers6, parseStatusSummary;
var init_StatusSummary = __esm({
  "src/lib/responses/StatusSummary.ts"() {
    "use strict";
    init_utils();
    init_FileStatusSummary();
    StatusSummary = class {
      constructor() {
        this.not_added = [];
        this.conflicted = [];
        this.created = [];
        this.deleted = [];
        this.ignored = void 0;
        this.modified = [];
        this.renamed = [];
        this.files = [];
        this.staged = [];
        this.ahead = 0;
        this.behind = 0;
        this.current = null;
        this.tracking = null;
        this.detached = false;
        this.isClean = () => {
          return !this.files.length;
        };
      }
    };
    parsers6 = new Map([
      parser3(
        " " /* NONE */,
        "A" /* ADDED */,
        (result, file) => append(result.created, file)
      ),
      parser3(
        " " /* NONE */,
        "D" /* DELETED */,
        (result, file) => append(result.deleted, file)
      ),
      parser3(
        " " /* NONE */,
        "M" /* MODIFIED */,
        (result, file) => append(result.modified, file)
      ),
      parser3(
        "A" /* ADDED */,
        " " /* NONE */,
        (result, file) => append(result.created, file) && append(result.staged, file)
      ),
      parser3(
        "A" /* ADDED */,
        "M" /* MODIFIED */,
        (result, file) => append(result.created, file) && append(result.staged, file) && append(result.modified, file)
      ),
      parser3(
        "D" /* DELETED */,
        " " /* NONE */,
        (result, file) => append(result.deleted, file) && append(result.staged, file)
      ),
      parser3(
        "M" /* MODIFIED */,
        " " /* NONE */,
        (result, file) => append(result.modified, file) && append(result.staged, file)
      ),
      parser3(
        "M" /* MODIFIED */,
        "M" /* MODIFIED */,
        (result, file) => append(result.modified, file) && append(result.staged, file)
      ),
      parser3("R" /* RENAMED */, " " /* NONE */, (result, file) => {
        append(result.renamed, renamedFile(file));
      }),
      parser3("R" /* RENAMED */, "M" /* MODIFIED */, (result, file) => {
        const renamed = renamedFile(file);
        append(result.renamed, renamed);
        append(result.modified, renamed.to);
      }),
      parser3("!" /* IGNORED */, "!" /* IGNORED */, (_result, _file) => {
        append(_result.ignored = _result.ignored || [], _file);
      }),
      parser3(
        "?" /* UNTRACKED */,
        "?" /* UNTRACKED */,
        (result, file) => append(result.not_added, file)
      ),
      ...conflicts("A" /* ADDED */, "A" /* ADDED */, "U" /* UNMERGED */),
      ...conflicts(
        "D" /* DELETED */,
        "D" /* DELETED */,
        "U" /* UNMERGED */
      ),
      ...conflicts(
        "U" /* UNMERGED */,
        "A" /* ADDED */,
        "D" /* DELETED */,
        "U" /* UNMERGED */
      ),
      [
        "##",
        (result, line) => {
          const aheadReg = /ahead (\d+)/;
          const behindReg = /behind (\d+)/;
          const currentReg = /^(.+?(?=(?:\.{3}|\s|$)))/;
          const trackingReg = /\.{3}(\S*)/;
          const onEmptyBranchReg = /\son\s([\S]+)$/;
          let regexResult;
          regexResult = aheadReg.exec(line);
          result.ahead = regexResult && +regexResult[1] || 0;
          regexResult = behindReg.exec(line);
          result.behind = regexResult && +regexResult[1] || 0;
          regexResult = currentReg.exec(line);
          result.current = regexResult && regexResult[1];
          regexResult = trackingReg.exec(line);
          result.tracking = regexResult && regexResult[1];
          regexResult = onEmptyBranchReg.exec(line);
          result.current = regexResult && regexResult[1] || result.current;
          result.detached = /\(no branch\)/.test(line);
        }
      ]
    ]);
    parseStatusSummary = function(text) {
      const lines = text.split(NULL);
      const status = new StatusSummary();
      for (let i = 0, l = lines.length; i < l; ) {
        let line = lines[i++].trim();
        if (!line) {
          continue;
        }
        if (line.charAt(0) === "R" /* RENAMED */) {
          line += NULL + (lines[i++] || "");
        }
        splitLine(status, line);
      }
      return status;
    };
  }
});

// src/lib/tasks/status.ts
/**
 * Generates a command configuration to retrieve the current status of a Git repository.
 *
 * @param {Array<string>} customArgs - An array of additional arguments to pass to the 'git status' command.
 * @returns {Object} - A configuration object containing the format, commands, and parser function for executing the git status command.
 */
function statusTask(customArgs) {
  const commands = [
    "status",
    "--porcelain",
    "-b",
    "-u",
    "--null",
    ...customArgs.filter((arg) => !ignoredOptions.includes(arg))
  ];
  return {
    format: "utf-8",
    commands,
    parser(text) {
      return parseStatusSummary(text);
    }
  };
}
var ignoredOptions;
var init_status = __esm({
  "src/lib/tasks/status.ts"() {
    "use strict";
    init_StatusSummary();
    ignoredOptions = ["--null", "-z"];
  }
});

// src/lib/tasks/version.ts
/**
 * Creates a version response object with specified major, minor, patch, agent, and installation status.
 *
 * @param {number} [major=0] - The major version number. Defaults to 0 if not provided.
 * @param {number} [minor=0] - The minor version number. Defaults to 0 if not provided.
 * @param {number} [patch=0] - The patch version number. Defaults to 0 if not provided.
 * @param {string} [agent=""] - The agent string. Defaults to an empty string if not provided.
 * @param {boolean} [installed=true] - Whether the version is installed. Defaults to true if not provided.
 * @returns {Object} - An object representing a version response with a custom `toString` method.
 *
 * @example
 * const version = versionResponse(1, 2, 3);
 * console.log(version.toString()); // Outputs: "1.2.3"
 */
function versionResponse(major = 0, minor = 0, patch = 0, agent = "", installed = true) {
  return Object.defineProperty(
    {
      major,
      minor,
      patch,
      agent,
      installed
    },
    "toString",
    {
      value() {
        return `${this.major}.${this.minor}.${this.patch}`;
      },
      configurable: false,
      enumerable: false
    }
  );
}
/**
 * Generates a response indicating that a language is not installed.
 *
 * @returns {Object} - An object representing the version response with default values for an uninstalled language.
 */
function notInstalledResponse() {
  return versionResponse(0, 0, 0, "", false);
}
function version_default() {
  return {
    version() {
      return this._runTask({
        commands: ["--version"],
        format: "utf-8",
        parser: versionParser,
        onError(result, error, done, fail) {
          if (result.exitCode === -2 /* NOT_FOUND */) {
            return done(Buffer.from(NOT_INSTALLED));
          }
          fail(error);
        }
      });
    }
  };
}
/**
 * Parses the output of a command to determine its version.
 *
 * @param {string} stdOut - The standard output string from a command execution.
 * @returns {Object} - An object containing the parsed version information or an error response.
 *
 * @example
 * versionParser("1.2.3");
 * // Returns: { major: 1, minor: 2, patch: 3 }
 */
function versionParser(stdOut) {
  if (stdOut === NOT_INSTALLED) {
    return notInstalledResponse();
  }
  return parseStringResponse(versionResponse(0, 0, 0, stdOut), parsers7, stdOut);
}
var NOT_INSTALLED, parsers7;
var init_version = __esm({
  "src/lib/tasks/version.ts"() {
    "use strict";
    init_utils();
    NOT_INSTALLED = "installed=false";
    parsers7 = [
      new LineParser(
        /version (\d+)\.(\d+)\.(\d+)(?:\s*\((.+)\))?/,
        (result, [major, minor, patch, agent = ""]) => {
          Object.assign(
            result,
            versionResponse(asNumber(major), asNumber(minor), asNumber(patch), agent)
          );
        }
      ),
      new LineParser(
        /version (\d+)\.(\d+)\.(\D+)(.+)?$/,
        (result, [major, minor, patch, agent = ""]) => {
          Object.assign(result, versionResponse(asNumber(major), asNumber(minor), patch, agent));
        }
      )
    ];
  }
});

// src/lib/simple-git-api.ts
var simple_git_api_exports = {};
__export(simple_git_api_exports, {
  SimpleGitApi: () => SimpleGitApi
});
var SimpleGitApi;
var init_simple_git_api = __esm({
  "src/lib/simple-git-api.ts"() {
    "use strict";
    init_task_callback();
    init_change_working_directory();
    init_checkout();
    init_count_objects();
    init_commit();
    init_config();
    init_first_commit();
    init_grep();
    init_hash_object();
    init_init();
    init_log();
    init_merge();
    init_push();
    init_show();
    init_status();
    init_task();
    init_version();
    init_utils();
    SimpleGitApi = class {
      constructor(_executor) {
        this._executor = _executor;
      }
      _runTask(task, then) {
        const chain = this._executor.chain();
        const promise = chain.push(task);
        if (then) {
          taskCallback(task, promise, then);
        }
        return Object.create(this, {
          then: { value: promise.then.bind(promise) },
          catch: { value: promise.catch.bind(promise) },
          _executor: { value: chain }
        });
      }
      add(files) {
        return this._runTask(
          straightThroughStringTask(["add", ...asArray(files)]),
          trailingFunctionArgument(arguments)
        );
      }
      cwd(directory) {
        const next = trailingFunctionArgument(arguments);
        if (typeof directory === "string") {
          return this._runTask(changeWorkingDirectoryTask(directory, this._executor), next);
        }
        if (typeof (directory == null ? void 0 : directory.path) === "string") {
          return this._runTask(
            changeWorkingDirectoryTask(
              directory.path,
              directory.root && this._executor || void 0
            ),
            next
          );
        }
        return this._runTask(
          configurationErrorTask("Git.cwd: workingDirectory must be supplied as a string"),
          next
        );
      }
      hashObject(path, write) {
        return this._runTask(
          hashObjectTask(path, write === true),
          trailingFunctionArgument(arguments)
        );
      }
      init(bare) {
        return this._runTask(
          initTask(bare === true, this._executor.cwd, getTrailingOptions(arguments)),
          trailingFunctionArgument(arguments)
        );
      }
      merge() {
        return this._runTask(
          mergeTask(getTrailingOptions(arguments)),
          trailingFunctionArgument(arguments)
        );
      }
      mergeFromTo(remote, branch) {
        if (!(filterString(remote) && filterString(branch))) {
          return this._runTask(
            configurationErrorTask(
              `Git.mergeFromTo requires that the 'remote' and 'branch' arguments are supplied as strings`
            )
          );
        }
        return this._runTask(
          mergeTask([remote, branch, ...getTrailingOptions(arguments)]),
          trailingFunctionArgument(arguments, false)
        );
      }
      outputHandler(handler) {
        this._executor.outputHandler = handler;
        return this;
      }
      push() {
        const task = pushTask(
          {
            remote: filterType(arguments[0], filterString),
            branch: filterType(arguments[1], filterString)
          },
          getTrailingOptions(arguments)
        );
        return this._runTask(task, trailingFunctionArgument(arguments));
      }
      stash() {
        return this._runTask(
          straightThroughStringTask(["stash", ...getTrailingOptions(arguments)]),
          trailingFunctionArgument(arguments)
        );
      }
      status() {
        return this._runTask(
          statusTask(getTrailingOptions(arguments)),
          trailingFunctionArgument(arguments)
        );
      }
    };
    Object.assign(
      SimpleGitApi.prototype,
      checkout_default(),
      commit_default(),
      config_default(),
      count_objects_default(),
      first_commit_default(),
      grep_default(),
      log_default(),
      show_default(),
      version_default()
    );
  }
});

// src/lib/runners/scheduler.ts
var scheduler_exports = {};
__export(scheduler_exports, {
  Scheduler: () => Scheduler
});
var import_promise_deferred2, createScheduledTask, Scheduler;
var init_scheduler = __esm({
  "src/lib/runners/scheduler.ts"() {
    "use strict";
    init_utils();
    import_promise_deferred2 = require("@kwsites/promise-deferred");
    init_git_logger();
    createScheduledTask = (() => {
      let id = 0;
      return () => {
        id++;
        const { promise, done } = (0, import_promise_deferred2.createDeferred)();
        return {
          promise,
          done,
          id
        };
      };
    })();
    Scheduler = class {
      constructor(concurrency = 2) {
        this.concurrency = concurrency;
        this.logger = createLogger("", "scheduler");
        this.pending = [];
        this.running = [];
        this.logger(`Constructed, concurrency=%s`, concurrency);
      }
      schedule() {
        if (!this.pending.length || this.running.length >= this.concurrency) {
          this.logger(
            `Schedule attempt ignored, pending=%s running=%s concurrency=%s`,
            this.pending.length,
            this.running.length,
            this.concurrency
          );
          return;
        }
        const task = append(this.running, this.pending.shift());
        this.logger(`Attempting id=%s`, task.id);
        task.done(() => {
          this.logger(`Completing id=`, task.id);
          remove(this.running, task);
          this.schedule();
        });
      }
      next() {
        const { promise, id } = append(this.pending, createScheduledTask());
        this.logger(`Scheduling id=%s`, id);
        this.schedule();
        return promise;
      }
    };
  }
});

// src/lib/tasks/apply-patch.ts
var apply_patch_exports = {};
__export(apply_patch_exports, {
  applyPatchTask: () => applyPatchTask
});
/**
 * Applies patches to a project using a task runner.
 *
 * @param {Array<string>} patches - An array of patch files or commands to be applied.
 * @param {Array<string>} customArgs - Additional arguments to pass to the task.
 * @returns {Promise<void>}
 * @throws {Error} If an error occurs during the application of patches.
 *
 * Example:
 * applyPatchTask(["patch1.js", "patch2.js"], ["--force"]).then(() => {
 *   console.log("Patches applied successfully");
 * }).catch((error) => {
 *   console.error("Error applying patches:", error);
 * });
 */
function applyPatchTask(patches, customArgs) {
  return straightThroughStringTask(["apply", ...customArgs, ...patches]);
}
var init_apply_patch = __esm({
  "src/lib/tasks/apply-patch.ts"() {
    "use strict";
    init_task();
  }
});

// src/lib/responses/BranchDeleteSummary.ts
/**
 * Constructs an object indicating successful deletion of a branch.
 *
 * @param {string} branch - The name of the deleted branch.
 * @param {string} hash - The commit hash associated with the deletion.
 * @returns {Object} An object containing the branch name, commit hash, and success status.
 */
function branchDeletionSuccess(branch, hash) {
  return {
    branch,
    hash,
    success: true
  };
}
/**
 * Creates an object indicating a failure to delete a branch.
 *
 * @param {string} branch - The name of the branch that failed to be deleted.
 * @returns {Object} An object with properties `branch`, `hash`, and `success`.
 *   - `branch`: The name of the branch.
 *   - `hash`: Always null, indicating no hash is available.
 *   - `success`: A boolean value set to false, indicating the deletion was not successful.
 *
 * @example
 * const failure = branchDeletionFailure('feature-branch');
 * console.log(failure);
 * // Output: { branch: 'feature-branch', hash: null, success: false }
 */
function branchDeletionFailure(branch) {
  return {
    branch,
    hash: null,
    success: false
  };
}
var BranchDeletionBatch;
var init_BranchDeleteSummary = __esm({
  "src/lib/responses/BranchDeleteSummary.ts"() {
    "use strict";
    BranchDeletionBatch = class {
      constructor() {
        this.all = [];
        this.branches = {};
        this.errors = [];
      }
      get success() {
        return !this.errors.length;
      }
    };
  }
});

// src/lib/parsers/parse-branch-delete.ts
/**
 * Checks if the provided data indicates a branch deletion error based on the process exit code.
 *
 * @param {string} data - The data to check, typically output from a command or log.
 * @param {number} processExitCode - The exit code of the process that produced the data. An exit code of 1 is considered an error.
 * @returns {boolean} - Returns true if the process exit code is 1 and the data matches the deleteErrorRegex pattern, indicating a branch deletion error; otherwise, returns false.
 *
 * Example usage:
 * hasBranchDeletionError("Branch deletion successful", 0); // Returns false
 * hasBranchDeletionError("Failed to delete branch", 1); // Returns true if deleteErrorRegex matches "Failed to delete branch"
 */
function hasBranchDeletionError(data, processExitCode) {
  return processExitCode === 1 /* ERROR */ && deleteErrorRegex.test(data);
}
var deleteSuccessRegex, deleteErrorRegex, parsers8, parseBranchDeletions;
var init_parse_branch_delete = __esm({
  "src/lib/parsers/parse-branch-delete.ts"() {
    "use strict";
    init_BranchDeleteSummary();
    init_utils();
    deleteSuccessRegex = /(\S+)\s+\(\S+\s([^)]+)\)/;
    deleteErrorRegex = /^error[^']+'([^']+)'/m;
    parsers8 = [
      new LineParser(deleteSuccessRegex, (result, [branch, hash]) => {
        const deletion = branchDeletionSuccess(branch, hash);
        result.all.push(deletion);
        result.branches[branch] = deletion;
      }),
      new LineParser(deleteErrorRegex, (result, [branch]) => {
        const deletion = branchDeletionFailure(branch);
        result.errors.push(deletion);
        result.all.push(deletion);
        result.branches[branch] = deletion;
      })
    ];
    parseBranchDeletions = (stdOut, stdErr) => {
      return parseStringResponse(new BranchDeletionBatch(), parsers8, [stdOut, stdErr]);
    };
  }
});

// src/lib/responses/BranchSummary.ts
var BranchSummaryResult;
var init_BranchSummary = __esm({
  "src/lib/responses/BranchSummary.ts"() {
    "use strict";
    BranchSummaryResult = class {
      constructor() {
        this.all = [];
        this.branches = {};
        this.current = "";
        this.detached = false;
      }
      push(status, detached, name, commit, label) {
        if (status === "*" /* CURRENT */) {
          this.detached = detached;
          this.current = name;
        }
        this.all.push(name);
        this.branches[name] = {
          current: status === "*" /* CURRENT */,
          linkedWorkTree: status === "+" /* LINKED */,
          name,
          commit,
          label
        };
      }
    };
  }
});

// src/lib/parsers/parse-branch.ts
/**
 * Determines the status of a branch based on its input.
 *
 * @param {string} input - The input string to determine the branch status from.
 * @return {string} - The first character of the input if it exists, otherwise an empty string.
 * @throws {TypeError} If the input is not a string.
 */
function branchStatus(input) {
  return input ? input.charAt(0) : "";
}
/**
 * Parses the branch summary from the standard output of a command.
 *
 * @param {string} stdOut - The standard output string to be parsed.
 * @returns {BranchSummaryResult} - The parsed branch summary result object.
 * @throws {Error} - If there is an error during parsing.
 */
function parseBranchSummary(stdOut) {
  return parseStringResponse(new BranchSummaryResult(), parsers9, stdOut);
}
var parsers9;
var init_parse_branch = __esm({
  "src/lib/parsers/parse-branch.ts"() {
    "use strict";
    init_BranchSummary();
    init_utils();
    parsers9 = [
      new LineParser(
        /^([*+]\s)?\((?:HEAD )?detached (?:from|at) (\S+)\)\s+([a-z0-9]+)\s(.*)$/,
        (result, [current, name, commit, label]) => {
          result.push(branchStatus(current), true, name, commit, label);
        }
      ),
      new LineParser(
        new RegExp("^([*+]\\s)?(\\S+)\\s+([a-z0-9]+)\\s?(.*)$", "s"),
        (result, [current, name, commit, label]) => {
          result.push(branchStatus(current), false, name, commit, label);
        }
      )
    ];
  }
});

// src/lib/tasks/branch.ts
var branch_exports = {};
__export(branch_exports, {
  branchLocalTask: () => branchLocalTask,
  branchTask: () => branchTask,
  containsDeleteBranchCommand: () => containsDeleteBranchCommand,
  deleteBranchTask: () => deleteBranchTask,
  deleteBranchesTask: () => deleteBranchesTask
});
/**
 * Determines if the provided array of commands includes any delete branch command options.
 *
 * @param {string[]} commands - An array of strings representing Git commands.
 * @returns {boolean} - Returns `true` if any delete branch command option is found, otherwise `false`.
 *
 * Example usage:
 * console.log(containsDeleteBranchCommand(["-d", "feature"])); // Output: true
 * console.log(containsDeleteBranchCommand(["checkout", "-b", "new-feature"])); // Output: false
 */
function containsDeleteBranchCommand(commands) {
  const deleteCommands = ["-d", "-D", "--delete"];
  return commands.some((command) => deleteCommands.includes(command));
}
/**
 * Executes a branch task with specified custom arguments.
 *
 * @param {Array<string>} customArgs - An array of custom arguments to be passed to the branch command.
 * @return {Object} An object containing format, commands, and a parser function.
 * @throws {Error} If an error occurs during the execution of the branch task.
 */
function branchTask(customArgs) {
  const isDelete = containsDeleteBranchCommand(customArgs);
  const commands = ["branch", ...customArgs];
  if (commands.length === 1) {
    commands.push("-a");
  }
  if (!commands.includes("-v")) {
    commands.splice(1, 0, "-v");
  }
  return {
    format: "utf-8",
    commands,
    parser(stdOut, stdErr) {
      if (isDelete) {
        return parseBranchDeletions(stdOut, stdErr).all[0];
      }
      return parseBranchSummary(stdOut);
    }
  };
}
/**
 * Returns a configuration object for fetching local Git branch information.
 *
 * @returns {Object} - An object containing the following properties:
 *   - format (string): The encoding format of the output, set to "utf-8".
 *   - commands (Array<string>): An array of Git commands to execute. In this case, it contains ["branch", "-v"].
 *   - parser (function): A function reference that should be used for parsing the command output.
 *
 * @example
 * const config = branchLocalTask();
 * console.log(config.format); // Output: "utf-8"
 * console.log(config.commands); // Output: ["branch", "-v"]
 */
function branchLocalTask() {
  const parser4 = parseBranchSummary;
  return {
    format: "utf-8",
    commands: ["branch", "-v"],
    parser: parser4
  };
}
/**
 * Creates a task to delete branches using Git commands.
 *
 * @param {string[]} branches - The array of branch names to be deleted.
 * @param {boolean} [forceDelete=false] - If true, forces the deletion of branches even if they are not merged.
 * @return {{
 *   format: string,
 *   commands: string[],
 *   parser: function(string, string): Object,
 *   onError: function(Object, Error, function, function): void
 * }}
 */
function deleteBranchesTask(branches, forceDelete = false) {
  return {
    format: "utf-8",
    commands: ["branch", "-v", forceDelete ? "-D" : "-d", ...branches],
    parser(stdOut, stdErr) {
      return parseBranchDeletions(stdOut, stdErr);
    },
    onError({ exitCode, stdOut }, error, done, fail) {
      if (!hasBranchDeletionError(String(error), exitCode)) {
        return fail(error);
      }
      done(stdOut);
    }
  };
}
/**
 * Creates a task to delete a branch in a Git repository.
 *
 * @param {string} branch - The name of the branch to be deleted.
 * @param {boolean} [forceDelete=false] - If true, deletes the branch even if it has unmerged changes.
 * @returns {Object} - An object representing the task with properties format, commands, parser, and onError.
 *
 * @example
 * const deleteTask = deleteBranchTask('feature-branch', true);
 * // Use the task to perform the deletion operation in a Git context
 */
function deleteBranchTask(branch, forceDelete = false) {
  const task = {
    format: "utf-8",
    commands: ["branch", "-v", forceDelete ? "-D" : "-d", branch],
    parser(stdOut, stdErr) {
      return parseBranchDeletions(stdOut, stdErr).branches[branch];
    },
    onError({ exitCode, stdErr, stdOut }, error, _, fail) {
      if (!hasBranchDeletionError(String(error), exitCode)) {
        return fail(error);
      }
      throw new GitResponseError(
        task.parser(bufferToString(stdOut), bufferToString(stdErr)),
        String(error)
      );
    }
  };
  return task;
}
var init_branch = __esm({
  "src/lib/tasks/branch.ts"() {
    "use strict";
    init_git_response_error();
    init_parse_branch_delete();
    init_parse_branch();
    init_utils();
  }
});

// src/lib/responses/CheckIgnore.ts
var parseCheckIgnore;
var init_CheckIgnore = __esm({
  "src/lib/responses/CheckIgnore.ts"() {
    "use strict";
    parseCheckIgnore = (text) => {
      return text.split(/\n/g).map((line) => line.trim()).filter((file) => !!file);
    };
  }
});

// src/lib/tasks/check-ignore.ts
var check_ignore_exports = {};
__export(check_ignore_exports, {
  checkIgnoreTask: () => checkIgnoreTask
});
/**
 * Generates a command object to check if paths are ignored by version control.
 *
 * @function
 * @param {Array<string>} paths - An array of file or directory paths to check for ignoring.
 * @returns {Object} A command object with properties `commands`, `format`, and `parser`.
 *   - commands {Array<string>}: The command to run, followed by the paths.
 *   - format {string}: The expected output format ('utf-8' in this case).
 *   - parser {Function}: The function to parse the command's output.
 *
 * @example
 * const ignoreCommand = checkIgnoreTask(['file.txt', 'dir/']);
 * console.log(ignoreCommand);
 * // Output: {
 * //   commands: ["check-ignore", "file.txt", "dir/"],
 * //   format: "utf-8",
 * //   parser: parseCheckIgnore
 * // }
 */
function checkIgnoreTask(paths) {
  return {
    commands: ["check-ignore", ...paths],
    format: "utf-8",
    parser: parseCheckIgnore
  };
}
var init_check_ignore = __esm({
  "src/lib/tasks/check-ignore.ts"() {
    "use strict";
    init_CheckIgnore();
  }
});

// src/lib/tasks/clone.ts
var clone_exports = {};
__export(clone_exports, {
  cloneMirrorTask: () => cloneMirrorTask,
  cloneTask: () => cloneTask
});
/**
 * Checks if the given command is a disallowed command based on a specific pattern.
 *
 * @param {string} command - The command to check.
 * @return {boolean} - Returns true if the command matches the disallowed pattern, false otherwise.
 *
 * Example:
 *   disallowedCommand("--upload-pack") returns true
 *   disallowedCommand("git pull") returns false
 */
function disallowedCommand(command) {
  return /^--upload-pack(=|$)/.test(command);
}
/**
 * Clones a Git repository into a specified directory using custom arguments.
 *
 * @param {string} repo - The URL or path of the Git repository to clone. Must not contain disallowed commands.
 * @param {string} [directory] - Optional directory where the repository should be cloned.
 * @param {string[]} [customArgs] - Additional custom arguments to pass to the `git clone` command.
 * @returns {Task} A Task object that will execute the git clone command with the provided arguments.
 * @throws {ConfigurationError} If the repository URL contains disallowed commands.
 *
 * @example
 * const task = cloneTask('https://github.com/example/repo.git', '/path/to/clone');
 * task.execute();
 */
function cloneTask(repo, directory, customArgs) {
  const commands = ["clone", ...customArgs];
  filterString(repo) && commands.push(repo);
  filterString(directory) && commands.push(directory);
  const banned = commands.find(disallowedCommand);
  if (banned) {
    return configurationErrorTask(`git.fetch: potential exploit argument blocked.`);
  }
  return straightThroughStringTask(commands);
}
/**
 * Clones a repository into a specified directory with mirror mode enabled.
 *
 * @param {string} repo - The URL of the repository to be cloned.
 * @param {string} directory - The local path where the repository should be cloned.
 * @param {Array<string>} customArgs - Additional arguments to pass to the clone command.
 * @returns {Promise<void>}
 * @throws {Error} If the cloning process encounters an error.
 *
 * Example:
 * await cloneMirrorTask('https://github.com/user/repo.git', '/path/to/local/directory', ['--depth=1']);
 */
function cloneMirrorTask(repo, directory, customArgs) {
  append(customArgs, "--mirror");
  return cloneTask(repo, directory, customArgs);
}
var init_clone = __esm({
  "src/lib/tasks/clone.ts"() {
    "use strict";
    init_task();
    init_utils();
  }
});

// src/lib/parsers/parse-fetch.ts
/**
 * Parses the result of a fetch operation.
 *
 * @param {string} stdOut - The standard output from the fetch operation.
 * @param {string} stdErr - The standard error from the fetch operation.
 * @returns {Object} An object containing parsed information including raw output, remote details,
 * branches, tags, updated and deleted items.
 * @throws {Error} Throws an error if parsing fails.
 */
function parseFetchResult(stdOut, stdErr) {
  const result = {
    raw: stdOut,
    remote: null,
    branches: [],
    tags: [],
    updated: [],
    deleted: []
  };
  return parseStringResponse(result, parsers10, [stdOut, stdErr]);
}
var parsers10;
var init_parse_fetch = __esm({
  "src/lib/parsers/parse-fetch.ts"() {
    "use strict";
    init_utils();
    parsers10 = [
      new LineParser(/From (.+)$/, (result, [remote]) => {
        result.remote = remote;
      }),
      new LineParser(/\* \[new branch]\s+(\S+)\s*-> (.+)$/, (result, [name, tracking]) => {
        result.branches.push({
          name,
          tracking
        });
      }),
      new LineParser(/\* \[new tag]\s+(\S+)\s*-> (.+)$/, (result, [name, tracking]) => {
        result.tags.push({
          name,
          tracking
        });
      }),
      new LineParser(/- \[deleted]\s+\S+\s*-> (.+)$/, (result, [tracking]) => {
        result.deleted.push({
          tracking
        });
      }),
      new LineParser(
        /\s*([^.]+)\.\.(\S+)\s+(\S+)\s*-> (.+)$/,
        (result, [from, to, name, tracking]) => {
          result.updated.push({
            name,
            tracking,
            to,
            from
          });
        }
      )
    ];
  }
});

// src/lib/tasks/fetch.ts
var fetch_exports = {};
__export(fetch_exports, {
  fetchTask: () => fetchTask
});
/**
 * Checks if the given command is considered disallowed due to containing '--upload-pack'.
 *
 * @param {string} command - The command string to check.
 * @returns {boolean} - Returns true if the command contains '--upload-pack', otherwise false.
 *
 * Example:
 *   disallowedCommand2('--upload-pack=true') // returns true
 *   disallowedCommand2('git pull origin master') // returns false
 */
function disallowedCommand2(command) {
  return /^--upload-pack(=|$)/.test(command);
}
/**
 * Fetches data from a remote repository branch using git.
 *
 * @param {string} remote - The name of the remote repository. Optional if branch is not provided.
 * @param {string} branch - The branch to fetch. Optional if remote is not provided.
 * @param {Array<string>} customArgs - An array of custom arguments for the git command.
 * @returns {{commands: Array<string>, format: string, parser: function}} An object containing the commands to run, the expected output format, and a parser function.
 *
 * @throws {Error} Throws an error if a disallowed command argument is provided.
 */
function fetchTask(remote, branch, customArgs) {
  const commands = ["fetch", ...customArgs];
  if (remote && branch) {
    commands.push(remote, branch);
  }
  const banned = commands.find(disallowedCommand2);
  if (banned) {
    return configurationErrorTask(`git.fetch: potential exploit argument blocked.`);
  }
  return {
    commands,
    format: "utf-8",
    parser: parseFetchResult
  };
}
var init_fetch = __esm({
  "src/lib/tasks/fetch.ts"() {
    "use strict";
    init_parse_fetch();
    init_task();
  }
});

// src/lib/parsers/parse-move.ts
/**
 * Parses the result of a move operation from standard output.
 *
 * @param {string} stdOut - The standard output string containing the move result.
 * @returns {Object} - An object representing the parsed move result.
 * @throws {Error} - If an error occurs during parsing, an error is thrown.
 */
function parseMoveResult(stdOut) {
  return parseStringResponse({ moves: [] }, parsers11, stdOut);
}
var parsers11;
var init_parse_move = __esm({
  "src/lib/parsers/parse-move.ts"() {
    "use strict";
    init_utils();
    parsers11 = [
      new LineParser(/^Renaming (.+) to (.+)$/, (result, [from, to]) => {
        result.moves.push({ from, to });
      })
    ];
  }
});

// src/lib/tasks/move.ts
var move_exports = {};
__export(move_exports, {
  moveTask: () => moveTask
});
/**
 * Moves a task from one location to another using the 'mv' command with verbose output.
 *
 * @param {string|string[]} from - The source path or array of paths of the task(s) to be moved.
 * @param {string} to - The destination path where the task(s) should be moved.
 * @return {Object} An object containing the command, format, and parser for moving tasks.
 * @throws {Error} If 'from' is not a valid string or array of strings.
 * @throws {Error} If 'to' is not a valid string.
 */
function moveTask(from, to) {
  return {
    commands: ["mv", "-v", ...asArray(from), to],
    format: "utf-8",
    parser: parseMoveResult
  };
}
var init_move = __esm({
  "src/lib/tasks/move.ts"() {
    "use strict";
    init_parse_move();
    init_utils();
  }
});

// src/lib/tasks/pull.ts
var pull_exports = {};
__export(pull_exports, {
  pullTask: () => pullTask
});
/**
 * Executes a 'pull' command to fetch updates from a remote repository and merge them into the current branch.
 *
 * @param {string} [remote] - The name of the remote repository. If not provided, the default remote is used.
 * @param {string} [branch] - The name of the branch. If not provided, the current branch is used.
 * @param {Array<string>} [customArgs] - Additional arguments to pass to the 'pull' command.
 * @returns {Object} A configuration object for executing the command.
 */
function pullTask(remote, branch, customArgs) {
  const commands = ["pull", ...customArgs];
  if (remote && branch) {
    commands.splice(1, 0, remote, branch);
  }
  return {
    commands,
    format: "utf-8",
    parser(stdOut, stdErr) {
      return parsePullResult(stdOut, stdErr);
    },
    onError(result, _error, _done, fail) {
      const pullError = parsePullErrorResult(
        bufferToString(result.stdOut),
        bufferToString(result.stdErr)
      );
      if (pullError) {
        return fail(new GitResponseError(pullError));
      }
      fail(_error);
    }
  };
}
var init_pull = __esm({
  "src/lib/tasks/pull.ts"() {
    "use strict";
    init_git_response_error();
    init_parse_pull();
    init_utils();
  }
});

// src/lib/responses/GetRemoteSummary.ts
/**
 * Parses the provided text to extract remote information.
 *
 * @param {string} text - The input text containing remote data.
 * @returns {Array<{name: string}>} An array of objects, each representing a remote with its name.
 * @throws {Error} If the input text is invalid or cannot be parsed.
 */
function parseGetRemotes(text) {
  const remotes = {};
  forEach(text, ([name]) => remotes[name] = { name });
  return Object.values(remotes);
}
/**
 * Parses verbose text to extract remote repositories information.
 *
 * @param {string} text - The verbose text containing remotes information.
 * @returns {Array<Object>} An array of objects representing the remotes with their names and URLs.
 * @throws {Error} If the input text is invalid or cannot be parsed.
 */
function parseGetRemotesVerbose(text) {
  const remotes = {};
  forEach(text, ([name, url, purpose]) => {
    if (!remotes.hasOwnProperty(name)) {
      remotes[name] = {
        name,
        refs: { fetch: "", push: "" }
      };
    }
    if (purpose && url) {
      remotes[name].refs[purpose.replace(/[^a-z]/g, "")] = url;
    }
  });
  return Object.values(remotes);
}
/**
 * Iterates over each line of text that contains content and applies a handler function to it.
 *
 * @param {string} text - The input text to be processed.
 * @param {function(string[]): void} handler - A callback function that will be called for each non-empty line. The handler receives an array of words from the line.
 */
function forEach(text, handler) {
  forEachLineWithContent(text, (line) => handler(line.split(/\s+/)));
}
var init_GetRemoteSummary = __esm({
  "src/lib/responses/GetRemoteSummary.ts"() {
    "use strict";
    init_utils();
  }
});

// src/lib/tasks/remote.ts
var remote_exports = {};
__export(remote_exports, {
  addRemoteTask: () => addRemoteTask,
  getRemotesTask: () => getRemotesTask,
  listRemotesTask: () => listRemotesTask,
  remoteTask: () => remoteTask,
  removeRemoteTask: () => removeRemoteTask
});
function addRemoteTask(remoteName, remoteRepo, customArgs) {
  return straightThroughStringTask(["remote", "add", ...customArgs, remoteName, remoteRepo]);
}
/**
 * Generates a task object for retrieving remote information.
 *
 * @param {boolean} verbose - Whether to include verbose output in the command.
 * @return {{commands: string[], format: string, parser: function}} A task object with commands, expected output format, and parser function.
 *
 * Example usage:
 * ```javascript
 * const task = getRemotesTask(true);
 * console.log(task.commands); // ['remote', '-v']
 * ```
 */
function getRemotesTask(verbose) {
  const commands = ["remote"];
  if (verbose) {
    commands.push("-v");
  }
  return {
    commands,
    format: "utf-8",
    parser: verbose ? parseGetRemotesVerbose : parseGetRemotes
  };
}
/**
 * Constructs and executes an `ls-remote` command task with custom arguments.
 *
 * @param {Array<string>} customArgs - An array of strings representing additional arguments to pass to the `ls-remote` command.
 * @returns {Function} A function that, when called, returns a promise resolving to the output of the `ls-remote` command task.
 * @throws {Error} Throws an error if the input is not an array or contains non-string elements.
 *
 * Example usage:
 * listRemotesTask(["origin", "refs/heads/master"]).then(output => {
 *   console.log(output);
 * });
 */
function listRemotesTask(customArgs) {
  const commands = [...customArgs];
  if (commands[0] !== "ls-remote") {
    commands.unshift("ls-remote");
  }
  return straightThroughStringTask(commands);
}
/**
 * Executes a task by prepending "remote" to the command list if it's not already present.
 *
 * @param {Array<string>} customArgs - The array of commands to be executed.
 * @returns {Function} A function representing the straight-through string task with the modified commands.
 * @throws {Error} If no commands are provided.
 */
function remoteTask(customArgs) {
  const commands = [...customArgs];
  if (commands[0] !== "remote") {
    commands.unshift("remote");
  }
  return straightThroughStringTask(commands);
}
/**
 * Removes a remote task with the specified name.
 *
 * @param {string} remoteName - The name of the remote task to be removed.
 * @returns {function} - A function that executes the 'remote remove' command with the given remote name.
 */
function removeRemoteTask(remoteName) {
  return straightThroughStringTask(["remote", "remove", remoteName]);
}
var init_remote = __esm({
  "src/lib/tasks/remote.ts"() {
    "use strict";
    init_GetRemoteSummary();
    init_task();
  }
});

// src/lib/tasks/stash-list.ts
var stash_list_exports = {};
__export(stash_list_exports, {
  stashListTask: () => stashListTask
});
/**
 * Stashes changes to the index or working tree of a git repository and returns a summary parser for the stashed items.
 *
 * @param {Object} [opt={}] - Optional parameters object that can include commands and formatting options.
 * @param {string[]} [customArgs=[]] - Array of custom arguments to pass to the command.
 * @returns {Object} An object containing the commands, format, and parser for the stash list task.
 * @throws {Error} Throws an error if there are issues with log format configuration.
 *
 * Example:
 * const result = stashListTask({
 *   commands: ['--oneline'],
 *   splitter: '\n',
 *   fields: ['hash', 'message']
 * }, ['--all']);
 * console.log(result);
 */
function stashListTask(opt = {}, customArgs) {
  const options = parseLogOptions(opt);
  const commands = ["stash", "list", ...options.commands, ...customArgs];
  const parser4 = createListLogSummaryParser(
    options.splitter,
    options.fields,
    logFormatFromCommand(commands)
  );
  return validateLogFormatConfig(commands) || {
    commands,
    format: "utf-8",
    parser: parser4
  };
}
var init_stash_list = __esm({
  "src/lib/tasks/stash-list.ts"() {
    "use strict";
    init_log_format();
    init_parse_list_log_summary();
    init_diff();
    init_log();
  }
});

// src/lib/tasks/sub-module.ts
var sub_module_exports = {};
__export(sub_module_exports, {
  addSubModuleTask: () => addSubModuleTask,
  initSubModuleTask: () => initSubModuleTask,
  subModuleTask: () => subModuleTask,
  updateSubModuleTask: () => updateSubModuleTask
});
/**
 * Adds a sub-module task to the repository.
 *
 * @param {string} repo - The path to the repository where the sub-module should be added.
 * @param {string} path - The relative path within the repository where the sub-module should be located.
 * @returns {Promise<void>} A promise that resolves when the sub-module task has been successfully added.
 *
 * @throws {Error} If there is an error adding the sub-module task.
 */
function addSubModuleTask(repo, path) {
  return subModuleTask(["add", repo, path]);
}
/**
 * Initializes a submodule task with custom arguments.
 *
 * @param {Array} customArgs - An array of custom arguments to pass to the submodule task.
 * @returns {Promise} A promise that resolves when the submodule task is initialized.
 * @throws {Error} Throws an error if the initialization fails.
 */
function initSubModuleTask(customArgs) {
  return subModuleTask(["init", ...customArgs]);
}
/**
 * Processes a task by ensuring it starts with "submodule" command.
 *
 * @param {Array<string>} customArgs - The arguments to be processed.
 * @return {Array<string>} The processed arguments array, prefixed with "submodule".
 * @throws {Error} If the input is not an array or if any element in the array is not a string.
 */
function subModuleTask(customArgs) {
  const commands = [...customArgs];
  if (commands[0] !== "submodule") {
    commands.unshift("submodule");
  }
  return straightThroughStringTask(commands);
}
/**
 * Updates a submodule task with additional custom arguments.
 *
 * @param {Array|string} customArgs - Custom arguments to be passed to the submodule task. Can be either an array of strings or a single string.
 * @returns {Array} - The updated arguments for the submodule task, including "update" and the provided custom arguments.
 *
 * Example:
 *   updateSubModuleTask(["version", "1.0.0"]);
 *   // Returns: ["update", "version", "1.0.0"]
 */
function updateSubModuleTask(customArgs) {
  return subModuleTask(["update", ...customArgs]);
}
var init_sub_module = __esm({
  "src/lib/tasks/sub-module.ts"() {
    "use strict";
    init_task();
  }
});

// src/lib/responses/TagList.ts
/**
 * Compares two values with special handling for numbers and non-numbers.
 *
 * @param {*} a - The first value to compare.
 * @param {*} b - The second value to compare.
 * @returns {number} - A negative number if `a` should come before `b`, zero if they are equal, or a positive number if `a` should come after `b`.
 *
 * @example
 * singleSorted(3, '5'); // Returns 1 because numbers come before strings.
 * singleSorted('2', 2); // Returns -1 because strings come after numbers.
 * singleSorted(4, 2); // Returns 1 because 4 is greater than 2.
 * singleSorted('apple', 'banana'); // Returns -1 because 'apple' comes before 'banana'.
 */
function singleSorted(a, b) {
  const aIsNum = isNaN(a);
  const bIsNum = isNaN(b);
  if (aIsNum !== bIsNum) {
    return aIsNum ? 1 : -1;
  }
  return aIsNum ? sorted(a, b) : 0;
}
/**
 * Compares two values and returns a negative, zero, or positive number depending on their order.
 *
 * @param {any} a - The first value to compare.
 * @param {any} b - The second value to compare.
 * @returns {number} A negative number if `a` should be sorted before `b`, zero if they are equal, or a positive number if `a` should be sorted after `b`.
 *
 * Example usage:
 * console.log(sorted(5, 3)); // Outputs: 1
 * console.log(sorted(2, 2)); // Outputs: 0
 * console.log(sorted('apple', 'banana')); // Outputs: -1
 */
function sorted(a, b) {
  return a === b ? 0 : a > b ? 1 : -1;
}
/**
 * Removes leading and trailing whitespace from a string.
 *
 * @param {string} input - The string to trim.
 * @returns {string} - The trimmed string.
 *
 * @example
 * // Returns 'Hello, World!'
 * trimmed('  Hello, World!  ');
 */
function trimmed(input) {
  return input.trim();
}
function toNumber(input) {
  if (typeof input === "string") {
    return parseInt(input.replace(/^\D+/g, ""), 10) || 0;
  }
  return 0;
}
var TagList, parseTagList;
var init_TagList = __esm({
  "src/lib/responses/TagList.ts"() {
    "use strict";
    TagList = class {
      constructor(all, latest) {
        this.all = all;
        this.latest = latest;
      }
    };
    parseTagList = function(data, customSort = false) {
      const tags = data.split("\n").map(trimmed).filter(Boolean);
      if (!customSort) {
        tags.sort(function(tagA, tagB) {
          const partsA = tagA.split(".");
          const partsB = tagB.split(".");
          if (partsA.length === 1 || partsB.length === 1) {
            return singleSorted(toNumber(partsA[0]), toNumber(partsB[0]));
          }
          for (let i = 0, l = Math.max(partsA.length, partsB.length); i < l; i++) {
            const diff = sorted(toNumber(partsA[i]), toNumber(partsB[i]));
            if (diff) {
              return diff;
            }
          }
          return 0;
        });
      }
      const latest = customSort ? tags[0] : [...tags].reverse().find((tag) => tag.indexOf(".") >= 0);
      return new TagList(tags, latest);
    };
  }
});

// src/lib/tasks/tag.ts
var tag_exports = {};
__export(tag_exports, {
  addAnnotatedTagTask: () => addAnnotatedTagTask,
  addTagTask: () => addTagTask,
  tagListTask: () => tagListTask
});
/**
 * Creates a task to list tags with custom arguments.
 *
 * @param {string[]} [customArgs=[]] - Custom arguments for the tag list command. Default is an empty array.
 * @returns {Object} An object containing the format, commands, and parser for the task.
 * @example
 * const task = tagListTask(['--sort=name']);
 * console.log(task.commands); // ['tag', '-l', '--sort=name']
 */
function tagListTask(customArgs = []) {
  const hasCustomSort = customArgs.some((option) => /^--sort=/.test(option));
  return {
    format: "utf-8",
    commands: ["tag", "-l", ...customArgs],
    parser(text) {
      return parseTagList(text, hasCustomSort);
    }
  };
}
/**
 * Creates a new task to tag something with a given name.
 *
 * @param {string} name - The name to tag.
 * @returns {Object} - An object representing the task.
 *   - format {string}: "utf-8" indicating the character encoding.
 *   - commands {Array<string>}: An array of strings representing the command and its arguments.
 *   - parser {Function}: A function that parses the output and returns an object containing the name.
 *
 * @example
 * const tagTask = addTagTask("important");
 * console.log(tagTask);
 * // Output: {
 * //   format: "utf-8",
 * //   commands: ["tag", "important"],
 * //   parser: [Function]
 * // }
 *
 * @throws {Error} - Throws an error if the name is not a string.
 */
function addTagTask(name) {
  return {
    format: "utf-8",
    commands: ["tag", name],
    parser() {
      return { name };
    }
  };
}
/**
 * Creates a function that generates an annotated tag task for Git.
 *
 * @param {string} name - The name of the tag to create.
 * @param {string} tagMessage - The message associated with the tag.
 * @returns {Object} An object containing the format, commands, and parser for the task.
 * @example
 * // Creating a new annotated tag named 'v1.0' with the message 'Release version 1.0'
 * const addTagTask = addAnnotatedTagTask('v1.0', 'Release version 1.0');
 * console.log(addTagTask);
 * // Output: { format: "utf-8", commands: [ 'tag', '-a', '-m', 'Release version 1.0', 'v1.0' ], parser: [Function: parser] }
 */
function addAnnotatedTagTask(name, tagMessage) {
  return {
    format: "utf-8",
    commands: ["tag", "-a", "-m", tagMessage, name],
    parser() {
      return { name };
    }
  };
}
var init_tag = __esm({
  "src/lib/tasks/tag.ts"() {
    "use strict";
    init_TagList();
  }
});

// src/git.js
var require_git = __commonJS({
  "src/git.js"(exports2, module2) {
    "use strict";
    var { GitExecutor: GitExecutor2 } = (init_git_executor(), __toCommonJS(git_executor_exports));
    var { SimpleGitApi: SimpleGitApi2 } = (init_simple_git_api(), __toCommonJS(simple_git_api_exports));
    var { Scheduler: Scheduler2 } = (init_scheduler(), __toCommonJS(scheduler_exports));
    var { configurationErrorTask: configurationErrorTask2 } = (init_task(), __toCommonJS(task_exports));
    var {
      asArray: asArray2,
      filterArray: filterArray2,
      filterPrimitives: filterPrimitives2,
      filterString: filterString2,
      filterStringOrStringArray: filterStringOrStringArray2,
      filterType: filterType2,
      getTrailingOptions: getTrailingOptions2,
      trailingFunctionArgument: trailingFunctionArgument2,
      trailingOptionsArgument: trailingOptionsArgument2
    } = (init_utils(), __toCommonJS(utils_exports));
    var { applyPatchTask: applyPatchTask2 } = (init_apply_patch(), __toCommonJS(apply_patch_exports));
    var {
      branchTask: branchTask2,
      branchLocalTask: branchLocalTask2,
      deleteBranchesTask: deleteBranchesTask2,
      deleteBranchTask: deleteBranchTask2
    } = (init_branch(), __toCommonJS(branch_exports));
    var { checkIgnoreTask: checkIgnoreTask2 } = (init_check_ignore(), __toCommonJS(check_ignore_exports));
    var { checkIsRepoTask: checkIsRepoTask2 } = (init_check_is_repo(), __toCommonJS(check_is_repo_exports));
    var { cloneTask: cloneTask2, cloneMirrorTask: cloneMirrorTask2 } = (init_clone(), __toCommonJS(clone_exports));
    var { cleanWithOptionsTask: cleanWithOptionsTask2, isCleanOptionsArray: isCleanOptionsArray2 } = (init_clean(), __toCommonJS(clean_exports));
    var { diffSummaryTask: diffSummaryTask2 } = (init_diff(), __toCommonJS(diff_exports));
    var { fetchTask: fetchTask2 } = (init_fetch(), __toCommonJS(fetch_exports));
    var { moveTask: moveTask2 } = (init_move(), __toCommonJS(move_exports));
    var { pullTask: pullTask2 } = (init_pull(), __toCommonJS(pull_exports));
    var { pushTagsTask: pushTagsTask2 } = (init_push(), __toCommonJS(push_exports));
    var {
      addRemoteTask: addRemoteTask2,
      getRemotesTask: getRemotesTask2,
      listRemotesTask: listRemotesTask2,
      remoteTask: remoteTask2,
      removeRemoteTask: removeRemoteTask2
    } = (init_remote(), __toCommonJS(remote_exports));
    var { getResetMode: getResetMode2, resetTask: resetTask2 } = (init_reset(), __toCommonJS(reset_exports));
    var { stashListTask: stashListTask2 } = (init_stash_list(), __toCommonJS(stash_list_exports));
    var {
      addSubModuleTask: addSubModuleTask2,
      initSubModuleTask: initSubModuleTask2,
      subModuleTask: subModuleTask2,
      updateSubModuleTask: updateSubModuleTask2
    } = (init_sub_module(), __toCommonJS(sub_module_exports));
    var { addAnnotatedTagTask: addAnnotatedTagTask2, addTagTask: addTagTask2, tagListTask: tagListTask2 } = (init_tag(), __toCommonJS(tag_exports));
    var { straightThroughBufferTask: straightThroughBufferTask2, straightThroughStringTask: straightThroughStringTask2 } = (init_task(), __toCommonJS(task_exports));
    /**
     * Constructor for creating an instance of Git2.
     *
     * @class Git2
     * @param {Object} options - Configuration options for the Git2 instance.
     * @param {Array} plugins - An array of plugins to be used by the Git2 instance.
     */
    function Git2(options, plugins) {
      this._plugins = plugins;
      this._executor = new GitExecutor2(
        options.baseDir,
        new Scheduler2(options.maxConcurrentProcesses),
        plugins
      );
      this._trimmed = options.trimmed;
    }
    (Git2.prototype = Object.create(SimpleGitApi2.prototype)).constructor = Git2;
    Git2.prototype.customBinary = function(command) {
      this._plugins.reconfigure("binary", command);
      return this;
    };
    Git2.prototype.env = function(name, value) {
      if (arguments.length === 1 && typeof name === "object") {
        this._executor.env = name;
      } else {
        (this._executor.env = this._executor.env || {})[name] = value;
      }
      return this;
    };
    Git2.prototype.stashList = function(options) {
      return this._runTask(
        stashListTask2(
          trailingOptionsArgument2(arguments) || {},
          filterArray2(options) && options || []
        ),
        trailingFunctionArgument2(arguments)
      );
    };
    /**
     * Creates a clone task using the provided API, task function, repository path, and local path.
     *
     * @param {string} api - The API method to be used for cloning.
     * @param {Function} task - The function that will handle the actual cloning logic.
     * @param {string} repoPath - The path of the repository to clone. Must be a string.
     * @param {string} localPath - The local path where the repository should be cloned. Will be filtered using `filterType2` and `filterString2`.
     * @returns {Function|Error} - Returns the result of the task function if successful, or an error object if the repoPath is not a string.
     *
     * @throws {Error} - Throws an error if 'repoPath' is not a valid string.
     *
     * Example:
     * ```
     * const cloneTask = createCloneTask('clone', gitCloneTask, '/path/to/repo.git', '/local/path');
     * try {
     *   const result = await cloneTask();
     *   console.log(result);
     * } catch (error) {
     *   console.error(error);
     * }
     * ```
     */
    function createCloneTask(api, task, repoPath, localPath) {
      if (typeof repoPath !== "string") {
        return configurationErrorTask2(`git.${api}() requires a string 'repoPath'`);
      }
      return task(repoPath, filterType2(localPath, filterString2), getTrailingOptions2(arguments));
    }
    Git2.prototype.clone = function() {
      return this._runTask(
        createCloneTask("clone", cloneTask2, ...arguments),
        trailingFunctionArgument2(arguments)
      );
    };
    Git2.prototype.mirror = function() {
      return this._runTask(
        createCloneTask("mirror", cloneMirrorTask2, ...arguments),
        trailingFunctionArgument2(arguments)
      );
    };
    Git2.prototype.mv = function(from, to) {
      return this._runTask(moveTask2(from, to), trailingFunctionArgument2(arguments));
    };
    Git2.prototype.checkoutLatestTag = function(then) {
      var git = this;
      return this.pull(function() {
        git.tags(function(err, tags) {
          git.checkout(tags.latest, then);
        });
      });
    };
    Git2.prototype.pull = function(remote, branch, options, then) {
      return this._runTask(
        pullTask2(
          filterType2(remote, filterString2),
          filterType2(branch, filterString2),
          getTrailingOptions2(arguments)
        ),
        trailingFunctionArgument2(arguments)
      );
    };
    Git2.prototype.fetch = function(remote, branch) {
      return this._runTask(
        fetchTask2(
          filterType2(remote, filterString2),
          filterType2(branch, filterString2),
          getTrailingOptions2(arguments)
        ),
        trailingFunctionArgument2(arguments)
      );
    };
    Git2.prototype.silent = function(silence) {
      console.warn(
        "simple-git deprecation notice: git.silent: logging should be configured using the `debug` library / `DEBUG` environment variable, this will be an error in version 3"
      );
      return this;
    };
    Git2.prototype.tags = function(options, then) {
      return this._runTask(
        tagListTask2(getTrailingOptions2(arguments)),
        trailingFunctionArgument2(arguments)
      );
    };
    Git2.prototype.rebase = function() {
      return this._runTask(
        straightThroughStringTask2(["rebase", ...getTrailingOptions2(arguments)]),
        trailingFunctionArgument2(arguments)
      );
    };
    Git2.prototype.reset = function(mode) {
      return this._runTask(
        resetTask2(getResetMode2(mode), getTrailingOptions2(arguments)),
        trailingFunctionArgument2(arguments)
      );
    };
    Git2.prototype.revert = function(commit) {
      const next = trailingFunctionArgument2(arguments);
      if (typeof commit !== "string") {
        return this._runTask(configurationErrorTask2("Commit must be a string"), next);
      }
      return this._runTask(
        straightThroughStringTask2(["revert", ...getTrailingOptions2(arguments, 0, true), commit]),
        next
      );
    };
    Git2.prototype.addTag = function(name) {
      const task = typeof name === "string" ? addTagTask2(name) : configurationErrorTask2("Git.addTag requires a tag name");
      return this._runTask(task, trailingFunctionArgument2(arguments));
    };
    Git2.prototype.addAnnotatedTag = function(tagName, tagMessage) {
      return this._runTask(
        addAnnotatedTagTask2(tagName, tagMessage),
        trailingFunctionArgument2(arguments)
      );
    };
    Git2.prototype.deleteLocalBranch = function(branchName, forceDelete, then) {
      return this._runTask(
        deleteBranchTask2(branchName, typeof forceDelete === "boolean" ? forceDelete : false),
        trailingFunctionArgument2(arguments)
      );
    };
    Git2.prototype.deleteLocalBranches = function(branchNames, forceDelete, then) {
      return this._runTask(
        deleteBranchesTask2(branchNames, typeof forceDelete === "boolean" ? forceDelete : false),
        trailingFunctionArgument2(arguments)
      );
    };
    Git2.prototype.branch = function(options, then) {
      return this._runTask(
        branchTask2(getTrailingOptions2(arguments)),
        trailingFunctionArgument2(arguments)
      );
    };
    Git2.prototype.branchLocal = function(then) {
      return this._runTask(branchLocalTask2(), trailingFunctionArgument2(arguments));
    };
    Git2.prototype.raw = function(commands) {
      const createRestCommands = !Array.isArray(commands);
      const command = [].slice.call(createRestCommands ? arguments : commands, 0);
      for (let i = 0; i < command.length && createRestCommands; i++) {
        if (!filterPrimitives2(command[i])) {
          command.splice(i, command.length - i);
          break;
        }
      }
      command.push(...getTrailingOptions2(arguments, 0, true));
      var next = trailingFunctionArgument2(arguments);
      if (!command.length) {
        return this._runTask(
          configurationErrorTask2("Raw: must supply one or more command to execute"),
          next
        );
      }
      return this._runTask(straightThroughStringTask2(command, this._trimmed), next);
    };
    Git2.prototype.submoduleAdd = function(repo, path, then) {
      return this._runTask(addSubModuleTask2(repo, path), trailingFunctionArgument2(arguments));
    };
    Git2.prototype.submoduleUpdate = function(args, then) {
      return this._runTask(
        updateSubModuleTask2(getTrailingOptions2(arguments, true)),
        trailingFunctionArgument2(arguments)
      );
    };
    Git2.prototype.submoduleInit = function(args, then) {
      return this._runTask(
        initSubModuleTask2(getTrailingOptions2(arguments, true)),
        trailingFunctionArgument2(arguments)
      );
    };
    Git2.prototype.subModule = function(options, then) {
      return this._runTask(
        subModuleTask2(getTrailingOptions2(arguments)),
        trailingFunctionArgument2(arguments)
      );
    };
    Git2.prototype.listRemote = function() {
      return this._runTask(
        listRemotesTask2(getTrailingOptions2(arguments)),
        trailingFunctionArgument2(arguments)
      );
    };
    Git2.prototype.addRemote = function(remoteName, remoteRepo, then) {
      return this._runTask(
        addRemoteTask2(remoteName, remoteRepo, getTrailingOptions2(arguments)),
        trailingFunctionArgument2(arguments)
      );
    };
    Git2.prototype.removeRemote = function(remoteName, then) {
      return this._runTask(removeRemoteTask2(remoteName), trailingFunctionArgument2(arguments));
    };
    Git2.prototype.getRemotes = function(verbose, then) {
      return this._runTask(getRemotesTask2(verbose === true), trailingFunctionArgument2(arguments));
    };
    Git2.prototype.remote = function(options, then) {
      return this._runTask(
        remoteTask2(getTrailingOptions2(arguments)),
        trailingFunctionArgument2(arguments)
      );
    };
    Git2.prototype.tag = function(options, then) {
      const command = getTrailingOptions2(arguments);
      if (command[0] !== "tag") {
        command.unshift("tag");
      }
      return this._runTask(straightThroughStringTask2(command), trailingFunctionArgument2(arguments));
    };
    Git2.prototype.updateServerInfo = function(then) {
      return this._runTask(
        straightThroughStringTask2(["update-server-info"]),
        trailingFunctionArgument2(arguments)
      );
    };
    Git2.prototype.pushTags = function(remote, then) {
      const task = pushTagsTask2(
        { remote: filterType2(remote, filterString2) },
        getTrailingOptions2(arguments)
      );
      return this._runTask(task, trailingFunctionArgument2(arguments));
    };
    Git2.prototype.rm = function(files) {
      return this._runTask(
        straightThroughStringTask2(["rm", "-f", ...asArray2(files)]),
        trailingFunctionArgument2(arguments)
      );
    };
    Git2.prototype.rmKeepLocal = function(files) {
      return this._runTask(
        straightThroughStringTask2(["rm", "--cached", ...asArray2(files)]),
        trailingFunctionArgument2(arguments)
      );
    };
    Git2.prototype.catFile = function(options, then) {
      return this._catFile("utf-8", arguments);
    };
    Git2.prototype.binaryCatFile = function() {
      return this._catFile("buffer", arguments);
    };
    Git2.prototype._catFile = function(format, args) {
      var handler = trailingFunctionArgument2(args);
      var command = ["cat-file"];
      var options = args[0];
      if (typeof options === "string") {
        return this._runTask(
          configurationErrorTask2("Git.catFile: options must be supplied as an array of strings"),
          handler
        );
      }
      if (Array.isArray(options)) {
        command.push.apply(command, options);
      }
      const task = format === "buffer" ? straightThroughBufferTask2(command) : straightThroughStringTask2(command);
      return this._runTask(task, handler);
    };
    Git2.prototype.diff = function(options, then) {
      const task = filterString2(options) ? configurationErrorTask2(
        "git.diff: supplying options as a single string is no longer supported, switch to an array of strings"
      ) : straightThroughStringTask2(["diff", ...getTrailingOptions2(arguments)]);
      return this._runTask(task, trailingFunctionArgument2(arguments));
    };
    Git2.prototype.diffSummary = function() {
      return this._runTask(
        diffSummaryTask2(getTrailingOptions2(arguments, 1)),
        trailingFunctionArgument2(arguments)
      );
    };
    Git2.prototype.applyPatch = function(patches) {
      const task = !filterStringOrStringArray2(patches) ? configurationErrorTask2(
        `git.applyPatch requires one or more string patches as the first argument`
      ) : applyPatchTask2(asArray2(patches), getTrailingOptions2([].slice.call(arguments, 1)));
      return this._runTask(task, trailingFunctionArgument2(arguments));
    };
    Git2.prototype.revparse = function() {
      const commands = ["rev-parse", ...getTrailingOptions2(arguments, true)];
      return this._runTask(
        straightThroughStringTask2(commands, true),
        trailingFunctionArgument2(arguments)
      );
    };
    Git2.prototype.clean = function(mode, options, then) {
      const usingCleanOptionsArray = isCleanOptionsArray2(mode);
      const cleanMode = usingCleanOptionsArray && mode.join("") || filterType2(mode, filterString2) || "";
      const customArgs = getTrailingOptions2([].slice.call(arguments, usingCleanOptionsArray ? 1 : 0));
      return this._runTask(
        cleanWithOptionsTask2(cleanMode, customArgs),
        trailingFunctionArgument2(arguments)
      );
    };
    Git2.prototype.exec = function(then) {
      const task = {
        commands: [],
        format: "utf-8",
        parser() {
          if (typeof then === "function") {
            then();
          }
        }
      };
      return this._runTask(task);
    };
    Git2.prototype.clearQueue = function() {
      return this;
    };
    Git2.prototype.checkIgnore = function(pathnames, then) {
      return this._runTask(
        checkIgnoreTask2(asArray2(filterType2(pathnames, filterStringOrStringArray2, []))),
        trailingFunctionArgument2(arguments)
      );
    };
    Git2.prototype.checkIsRepo = function(checkType, then) {
      return this._runTask(
        checkIsRepoTask2(filterType2(checkType, filterString2)),
        trailingFunctionArgument2(arguments)
      );
    };
    module2.exports = Git2;
  }
});

// src/lib/git-factory.ts
var git_factory_exports = {};
__export(git_factory_exports, {
  esModuleFactory: () => esModuleFactory,
  gitExportFactory: () => gitExportFactory,
  gitInstanceFactory: () => gitInstanceFactory
});
/**
 * Creates an ES module object with a default export.
 *
 * @param {any} defaultExport - The value to be exported as the default.
 * @returns {Object} An object representing an ES module with `__esModule` and `default` properties.
 *
 * Example:
 * ```
 * const myModule = esModuleFactory({ key: 'value' });
 * console.log(myModule);
 * // Output: { __esModule: true, default: { key: 'value' } }
 * ```
 */
function esModuleFactory(defaultExport) {
  return Object.defineProperties(defaultExport, {
    __esModule: { value: true },
    default: { value: defaultExport }
  });
}
/**
 * Creates a factory function that combines the provided factory with API exports.
 *
 * @function gitExportFactory
 * @param {Function} factory - The factory function to be combined with API exports.
 * @returns {Function} A new function that is bound to null and includes all methods from the provided factory and api_exports.
 * @throws {TypeError} If the provided parameter is not a function.
 *
 * Example:
 * const myFactory = () => {};
 * const combinedFactory = gitExportFactory(myFactory);
 * console.log(combinedFactory instanceof myFactory); // true
 * console.log(typeof combinedFactory.someApiMethod); // 'function'
 */
function gitExportFactory(factory) {
  return Object.assign(factory.bind(null), api_exports);
}
function gitInstanceFactory(baseDir, options) {
  var _a2;
  const plugins = new PluginStore();
  const config = createInstanceConfig(
    baseDir && (typeof baseDir === "string" ? { baseDir } : baseDir) || {},
    options
  );
  if (!folderExists(config.baseDir)) {
    throw new GitConstructError(
      config,
      `Cannot use simple-git on a directory that does not exist`
    );
  }
  if (Array.isArray(config.config)) {
    plugins.add(commandConfigPrefixingPlugin(config.config));
  }
  plugins.add(blockUnsafeOperationsPlugin(config.unsafe));
  plugins.add(suffixPathsPlugin());
  plugins.add(completionDetectionPlugin(config.completion));
  config.abort && plugins.add(abortPlugin(config.abort));
  config.progress && plugins.add(progressMonitorPlugin(config.progress));
  config.timeout && plugins.add(timeoutPlugin(config.timeout));
  config.spawnOptions && plugins.add(spawnOptionsPlugin(config.spawnOptions));
  plugins.add(errorDetectionPlugin(errorDetectionHandler(true)));
  config.errors && plugins.add(errorDetectionPlugin(config.errors));
  customBinaryPlugin(plugins, config.binary, (_a2 = config.unsafe) == null ? void 0 : _a2.allowUnsafeCustomBinary);
  return new Git(config, plugins);
}
var Git;
var init_git_factory = __esm({
  "src/lib/git-factory.ts"() {
    "use strict";
    init_api();
    init_plugins();
    init_suffix_paths_plugin();
    init_utils();
    Git = require_git();
  }
});

// src/lib/runners/promise-wrapped.ts
var promise_wrapped_exports = {};
__export(promise_wrapped_exports, {
  gitP: () => gitP
});
/**
 * Creates a promise-based interface for interacting with Git.
 *
 * @param {...*} args - Arguments passed to the `gitInstanceFactory` function.
 * @returns {Object} - An object that provides both builder and promise interfaces for Git commands.
 */
function gitP(...args) {
  let git;
  let chain = Promise.resolve();
  try {
    git = gitInstanceFactory(...args);
  } catch (e) {
    chain = Promise.reject(e);
  }
  /**
   * Returns a promise API object.
   *
   * @returns {Promise} A promise API object.
   */
  function builderReturn() {
    return promiseApi;
  }
  /**
   * Returns the current chain value.
   *
   * @returns {any} The current chain value.
   */
  function chainReturn() {
    return chain;
  }
  const promiseApi = [...functionNamesBuilderApi, ...functionNamesPromiseApi].reduce(
    (api, name) => {
      const isAsync = functionNamesPromiseApi.includes(name);
      const valid = isAsync ? asyncWrapper(name, git) : syncWrapper(name, git, api);
      const alternative = isAsync ? chainReturn : builderReturn;
      Object.defineProperty(api, name, {
        enumerable: false,
        configurable: false,
        value: git ? valid : alternative
      });
      return api;
    },
    {}
  );
  return promiseApi;
  /**
   * Wraps an asynchronous function to return a Promise instead of accepting a callback.
   *
   * @param {Function} fn - The original asynchronous function to wrap.
   * @param {Object} git2 - The object that contains the original function.
   * @returns {Function} A new function that returns a Promise when called.
   * @throws {TypeError} If a trailing function is provided as a callback.
   *
   * @example
   * const wrapped = asyncWrapper('someAsyncFunction', someGit2Instance);
   * wrapped(arg1, arg2).then(result => {
   *   // Handle the result
   * }).catch(error => {
   *   // Handle the error
   * });
   */
  function asyncWrapper(fn, git2) {
    return function(...args2) {
      if (typeof args2[args2.length] === "function") {
        throw new TypeError(
          "Promise interface requires that handlers are not supplied inline, trailing function not allowed in call to " + fn
        );
      }
      return chain.then(function() {
        return new Promise(function(resolve, reject) {
          const callback = (err, result) => {
            if (err) {
              return reject(toError(err));
            }
            resolve(result);
          };
          args2.push(callback);
          git2[fn].apply(git2, args2);
        });
      });
    };
  }
  /**
   * Wraps a function from `git2` to ensure that it is executed synchronously and returns the provided API object.
   *
   * @param {string} fn - The name of the function in `git2` to be wrapped.
   * @param {Object} git2 - An object containing functions to be wrapped.
   /**
    * Callback function used to handle errors and results from an asynchronous operation.
    *
    * @callback callback
    * @param {Error} err - Error object if an error occurred; null otherwise.
    * @param {*} result - Result of the asynchronous operation.
    */
   * @param {Object} api - The API object to return after executing the wrapped function.
   * @returns {Function} - A new function that, when called, executes the specified `git2` function and returns the provided `api`.
   *
   * Example:
   * const git2 = {
   *   commit: (message) => console.log(`Committing with message: ${message}`)
   * };
   * const api = { status: 'success' };
   * const wrappedCommit = syncWrapper('commit', git2, api);
   * wrappedCommit('Initial commit');
   * // Output: Committing with message: Initial commit
   */
  function syncWrapper(fn, git2, api) {
    return (...args2) => {
      git2[fn](...args2);
      return api;
    };
  }
}
function toError(error) {
  if (error instanceof Error) {
    return error;
  }
  if (typeof error === "string") {
    return new Error(error);
  }
  return new GitResponseError(error);
}
var functionNamesBuilderApi, functionNamesPromiseApi;
var init_promise_wrapped = __esm({
  "src/lib/runners/promise-wrapped.ts"() {
    "use strict";
    init_git_response_error();
    init_git_factory();
    functionNamesBuilderApi = ["customBinary", "env", "outputHandler", "silent"];
    functionNamesPromiseApi = [
      "add",
      "addAnnotatedTag",
      "addConfig",
      "addRemote",
      "addTag",
      "applyPatch",
      "binaryCatFile",
      "branch",
      "branchLocal",
      "catFile",
      "checkIgnore",
      "checkIsRepo",
      "checkout",
      "checkoutBranch",
      "checkoutLatestTag",
      "checkoutLocalBranch",
      "clean",
      "clone",
      "commit",
      "cwd",
      "deleteLocalBranch",
      "deleteLocalBranches",
      "diff",
      "diffSummary",
      "exec",
      "fetch",
      "getRemotes",
      "init",
      "listConfig",
      "listRemote",
      "log",
      "merge",
      "mergeFromTo",
      "mirror",
      "mv",
      "pull",
      "push",
      "pushTags",
      "raw",
      "rebase",
      "remote",
      "removeRemote",
      "reset",
      "revert",
      "revparse",
      "rm",
      "rmKeepLocal",
      "show",
      "stash",
      "stashList",
      "status",
      "subModule",
      "submoduleAdd",
      "submoduleInit",
      "submoduleUpdate",
      "tag",
      "tags",
      "updateServerInfo"
    ];
  }
});

// src/index.js
var { gitP: gitP2 } = (init_promise_wrapped(), __toCommonJS(promise_wrapped_exports));
var { esModuleFactory: esModuleFactory2, gitInstanceFactory: gitInstanceFactory2, gitExportFactory: gitExportFactory2 } = (init_git_factory(), __toCommonJS(git_factory_exports));
var simpleGit = esModuleFactory2(gitExportFactory2(gitInstanceFactory2));
module.exports = Object.assign(simpleGit, { gitP: gitP2, simpleGit });
//# sourceMappingURL=index.js.map
