var __defProp = Object.defineProperty;
var __defProps = Object.defineProperties;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
/**
 * Defines a normal property on an object if it doesn't already exist.
 *
 * @param {Object} obj - The object to define the property on.
 * @param {string} key - The name of the property to define.
 * @param {*} value - The value to set for the property.
 */
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
/**
 * Merges two objects into one, prioritizing properties from the second object in case of conflicts.
 *
 * @param {Object} a - The first object to merge.
 * @param {Object} b - The second object to merge and overwrite properties from `a`.
 * @returns {Object} - A new object containing all properties from both input objects.
 *
 * Example:
 * const obj1 = { a: 1, b: 2 };
 * const obj2 = { b: 3, c: 4 };
 * const result = __spreadValues(obj1, obj2);
 * console.log(result); // Output: { a: 1, b: 3, c: 4 }
 */
var __spreadValues = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp.call(b, prop))
      __defNormalProp(a, prop, b[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b)) {
      if (__propIsEnum.call(b, prop))
        __defNormalProp(a, prop, b[prop]);
    }
  return a;
};
/**
 * A utility function to spread properties from one object into another.
 *
 * @param {Object} a - The target object where properties will be added.
 * @param {Object} b - The source object whose properties are to be copied.
 * @returns {Object} - The target object with properties from the source object added.
 */
var __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));
/**
 * A function to initialize and execute an ES module.
 *
 * @param {Function} fn - The function containing the ES module code.
 * @param {Object} res - An object used to store the result of executing the module.
 * @returns {any} The result of executing the module.
 */
var __esm = (fn, res) => function __init() {
  return fn && (res = (0, fn[__getOwnPropNames(fn)[0]])(fn = 0)), res;
};
/**
 * A function to create a common JS module loader.
 * @param {Function} cb - The callback function that will execute the module loading logic.
 * @param {Object} mod - The module object that holds the exports.
 * @returns {Object} The exported module object.
 * @example
 * const myModule = __commonJS((cb, mod) => {
 *   return (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
 * }, {});
 */
var __commonJS = (cb, mod) => function __require() {
  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
/**
 * Exports all properties from one object to another.
 *
 * @param {Object} target - The target object to receive the exported properties.
 * @param {Object} all - The source object containing the properties to be exported.
 * @returns {void}
 * @example
 * const target = {};
 * const all = { prop1: 'value1', prop2: 'value2' };
 * __export(target, all);
 * console.log(target); // { prop1: 'value1', prop2: 'value2' }
 */
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
/**
 * Copies properties from one object to another, excluding a specific property.
 *
 * @param {Object} to - The target object to copy properties to.
 * @param {Object} from - The source object to copy properties from.
 * @param {string} except - The name of the property to exclude from copying.
 * @param {PropertyDescriptor?} desc - Optional descriptor for properties.
 * @returns {Object} - The target object with copied properties.
 *
 * @example
 * const target = {};
 * const source = { a: 1, b: 2 };
 * __copyProps(target, source, 'a');
 * console.log(target); // Output: { b: 2 }
 */
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
/**
 * Converts a module to CommonJS format.
 *
 * @param {Object} mod - The module object to convert.
 * @returns {Object} - An object with the '__esModule' property set to true.
 * @throws {Error} If the input is not an object.
 */
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
/**
 * Wraps a generator function to handle asynchronous operations using Promises.
 *
 * @param {Object} __this - The context (`this`) for the generator function.
 * @param {Array} __arguments - An array of arguments passed to the generator function.
 * @param {GeneratorFunction} generator - The generator function to be wrapped.
 * @returns {Promise} A Promise that resolves when the generator completes, or rejects if an error occurs.
 */
var __async = (__this, __arguments, generator) => {
  return new Promise((resolve, reject) => {
    /**
     * A function that handles the resolution of a generator step.
     *
     * @param {any} value - The value to pass to the next step of the generator.
     * @returns {void}
     * @throws {Error} If an error occurs during the execution of the generator step.
     */
    var fulfilled = (value) => {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    };
    /**
     * Handles the rejection of a promise by throwing an error to the generator.
     *
     * @param {any} value - The value to reject with.
     * @returns {void}
     *
     * @throws {Error} If there is an error during the rejection process.
     */
    var rejected = (value) => {
      try {
        step(generator.throw(value));
      } catch (e) {
        reject(e);
      }
    };
    /**
     * Processes a given value or promise by resolving it if done, otherwise chaining it with provided fulfilled and rejected handlers.
     *
     * @param {Object} x - The object containing the result of an asynchronous operation.
     * @param {Function} fulfilled - A function to handle successful resolution of the promise.
     * @param {Function} rejected - A function to handle rejection of the promise.
     * @returns {Promise} - A new promise that resolves or rejects based on the input object's state.
     *
     * @example
     * step({ done: true, value: 'success' }, console.log, console.error);
     * // Returns: Promise resolved with 'success'
     *
     * @example
     * step(Promise.resolve('success'), console.log, console.error);
     * // Returns: Promise resolved with 'success'
     */
    var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);
    step((generator = generator.apply(__this, __arguments)).next());
  });
};

// src/lib/args/pathspec.ts
/**
 * Creates a unique key from multiple paths and caches it for future use.
 *
 * @param {...string} paths - Multiple string paths to be combined into a single key.
 * @returns {String} A unique key representing the combination of the provided paths.
 */
function pathspec(...paths) {
  const key = new String(paths);
  cache.set(key, paths);
  return key;
}
/**
 * Checks if the provided path is a specified path.
 *
 * @param {String} path - The path to check.
 * @returns {boolean} - Returns true if the path is specified, otherwise false.
 * @throws {TypeError} - If the provided path is not an instance of String.
 */
function isPathSpec(path) {
  return path instanceof String && cache.has(path);
}
function toPaths(pathSpec) {
  return cache.get(pathSpec) || [];
}
var cache;
var init_pathspec = __esm({
  "src/lib/args/pathspec.ts"() {
    "use strict";
    cache = /* @__PURE__ */ new WeakMap();
  }
});

// src/lib/errors/git-error.ts
var GitError;
var init_git_error = __esm({
  "src/lib/errors/git-error.ts"() {
    "use strict";
    GitError = class extends Error {
      constructor(task, message) {
        super(message);
        this.task = task;
        Object.setPrototypeOf(this, new.target.prototype);
      }
    };
  }
});

// src/lib/errors/git-response-error.ts
var GitResponseError;
var init_git_response_error = __esm({
  "src/lib/errors/git-response-error.ts"() {
    "use strict";
    init_git_error();
    GitResponseError = class extends GitError {
      constructor(git, message) {
        super(void 0, message || String(git));
        this.git = git;
      }
    };
  }
});

// src/lib/errors/task-configuration-error.ts
var TaskConfigurationError;
var init_task_configuration_error = __esm({
  "src/lib/errors/task-configuration-error.ts"() {
    "use strict";
    init_git_error();
    TaskConfigurationError = class extends GitError {
      constructor(message) {
        super(void 0, message);
      }
    };
  }
});

// src/lib/utils/util.ts
import { exists, FOLDER } from "@kwsites/file-exists";
/**
 * Checks if the provided source is a function. If it is, returns the function; otherwise, returns a no-operation function.
 *
 * @param {any} source - The source to check.
 * @returns {Function} - A function or a no-operation function if the source is not a function.
 */
function asFunction(source) {
  return typeof source === "function" ? source : NOOP;
}
/**
 * Determines if the provided source is a user-defined function.
 *
 * @param {any} source - The source to check.
 * @returns {boolean} - True if the source is a user-defined function, false otherwise.
 */
function isUserFunction(source) {
  return typeof source === "function" && source !== NOOP;
}
/**
 * Splits a given string into two parts at the first occurrence of a specified character.
 *
 * @param {string} input - The string to be split.
 * @param {string} char - The character where the string should be split.
 * @returns {[string, string]} An array containing two elements: the part before the character and the part after the character. If the character is not found or is at the beginning of the string, returns the original string as the first element and an empty string as the second element.
 *
 * @example
 * splitOn("hello world", " "); // ["hello", "world"]
 * splitOn("hello world", "x"); // ["hello world", ""]
 */
function splitOn(input, char) {
  const index = input.indexOf(char);
  if (index <= 0) {
    return [input, ""];
  }
  return [input.substr(0, index), input.substr(index + 1)];
}
/**
 * Returns the element at the specified index from the input if it is an array-like object.
 *
 * @param {ArrayLike} input - The input to retrieve the element from.
 * @param {number} [offset=0] - The index of the element to retrieve. Defaults to 0.
 * @returns {*} - The element at the specified index, or undefined if the input is not an array-like object or if the offset is out of bounds.
 */
function first(input, offset = 0) {
  return isArrayLike(input) && input.length > offset ? input[offset] : void 0;
}
/**
 * Retrieves the last element of an array or string.
 *
 * @param {Array|string} input - The array or string to retrieve the last element from.
 * @param {number} [offset=0] - The number of elements to offset from the end. Defaults to 0.
 * @returns {*} - The last element of the array or string, considering the optional offset.
 *
 * @example
 * // Returns the last element of an array
 * console.log(last([1, 2, 3])); // Output: 3
 *
 * // Returns the second-to-last element of an array
 * console.log(last([1, 2, 3], 1)); // Output: 2
 */
function last(input, offset = 0) {
  if (isArrayLike(input) && input.length > offset) {
    return input[input.length - 1 - offset];
  }
}
/**
 * Determines if an input is array-like. An array-like object has a `length` property that is a non-negative integer.
 *
 * @param {any} input - The object to check if it is array-like.
 * @return {boolean} - Returns true if the input is array-like, false otherwise.
 */
function isArrayLike(input) {
  return !!(input && typeof input.length === "number");
}
/**
 * Splits an input string into lines that contain content, optionally trimming each line.
 *
 * @param {string} input - The input string to be processed. Defaults to an empty string if not provided.
 * @param {boolean} [trimmed2=true] - If true, trims each line before checking for content. Defaults to true.
 * @param {string} [separator="\n"] - The character used to separate lines in the input string. Defaults to a newline character.
 * @returns {Array<string>} An array of strings, each representing a non-empty line from the input, after optional trimming.
 *
 * Example:
 *   const result = toLinesWithContent("Hello\n\nWorld", false);
 *   console.log(result); // Output: ["Hello", "", "World"]
 */
function toLinesWithContent(input = "", trimmed2 = true, separator = "\n") {
  return input.split(separator).reduce((output, line) => {
    const lineContent = trimmed2 ? line.trim() : line;
    if (lineContent) {
      output.push(lineContent);
    }
    return output;
  }, []);
}
/**
 * Executes a callback function on each line of text that contains content within an input string.
 *
 * @param {string} input - The input string containing lines of text.
 * @param {function(string): void} callback - A function to execute on each non-empty line.
 * @returns {Array|string} - The result of applying the map operation to the filtered lines.
 * @throws {Error} If the input is not a valid string or if the callback is not a function.
 *
 * Example:
 *   forEachLineWithContent("Hello\nWorld", (line) => console.log(line));
 *   // Output: ["Hello", "World"]
 */
function forEachLineWithContent(input, callback) {
  return toLinesWithContent(input, true).map((line) => callback(line));
}
/**
 * Checks if a given path is an existing folder.
 *
 * @param {string} path - The file or directory path to check.
 * @returns {boolean} Returns true if the path exists and is a folder, otherwise false.
 * @throws {Error} Throws an error if the input path is invalid.
 *
 * Example:
 * // Check if '/home/user/documents' exists and is a folder
 * const exists = folderExists('/home/user/documents');
 */
function folderExists(path) {
  return exists(path, FOLDER);
}
function append(target, item) {
  if (Array.isArray(target)) {
    if (!target.includes(item)) {
      target.push(item);
    }
  } else {
    target.add(item);
  }
  return item;
}
function including(target, item) {
  if (Array.isArray(target) && !target.includes(item)) {
    target.push(item);
  }
  return target;
}
/**
 * Removes an item from either an array or a Set.
 *
 * @param {Array|Set} target - The array or set from which to remove the item.
 * @param {*} item - The item to remove from the target.
 * @returns {*} The removed item if it was found and removed; otherwise, undefined.
 * @throws {TypeError} If the target is neither an Array nor a Set.
 *
 * @example
 * // Removing an element from an array
 * const numbers = [1, 2, 3, 4];
 * remove(numbers, 3);
 * console.log(numbers); // Output: [1, 2, 4]
 *
 * @example
 * // Removing an element from a Set
 * const fruits = new Set(['apple', 'banana', 'cherry']);
 * remove(fruits, 'banana');
 * console.log(fruits); // Output: Set { 'apple', 'cherry' }
 */
function remove(target, item) {
  if (Array.isArray(target)) {
    const index = target.indexOf(item);
    if (index >= 0) {
      target.splice(index, 1);
    }
  } else {
    target.delete(item);
  }
  return item;
}
function asArray(source) {
  return Array.isArray(source) ? source : [source];
}
function asCamelCase(str) {
  return str.replace(/[\s-]+(.)/g, (_all, chr) => {
    return chr.toUpperCase();
  });
}
/**
 * Converts an input source to an array of strings.
 *
 * @function
 * @name asStringArray
 * @param {any} source - The input source that can be converted to an array.
 * @returns {string[]} An array where each element is a string representation of the corresponding element in the input source.
 * @throws {Error} If the conversion process encounters an error.
 * @example
 * asStringArray(123); // returns ["123"]
 * asStringArray([true, false]); // returns ["true", "false"]
 */
function asStringArray(source) {
  return asArray(source).map(String);
}
function asNumber(source, onNaN = 0) {
  if (source == null) {
    return onNaN;
  }
  const num = parseInt(source, 10);
  return isNaN(num) ? onNaN : num;
}
/**
 * Creates an array with a prefix prepended to each element of the input array.
 *
 * @param {any[]} input - The array to which the prefix will be added.
 * @param {*} prefix - The value to prepend before each element in the input array.
 * @return {any[]} A new array containing the prefix followed by each element from the input array.
 *
 * @example
 * // Returns ['prefix', 'value1', 'prefix', 'value2']
 * prefixedArray(['value1', 'value2'], 'prefix');
 */
function prefixedArray(input, prefix) {
  const output = [];
  for (let i = 0, max = input.length; i < max; i++) {
    output.push(prefix, input[i]);
  }
  return output;
}
function bufferToString(input) {
  return (Array.isArray(input) ? Buffer.concat(input) : input).toString("utf-8");
}
function pick(source, properties) {
  return Object.assign(
    {},
    ...properties.map((property) => property in source ? { [property]: source[property] } : {})
  );
}
/**
 * Delays execution by a specified duration.
 *
 * @param {number} [duration=0] - The duration in milliseconds to delay the execution. Defaults to 0.
 * @returns {Promise<void>} A Promise that resolves after the specified duration.
 *
 * @example
 * async function example() {
 *   console.log('Start');
 *   await delay(1000);
 *   console.log('End');
 * }
 *
 * example();
 */
function delay(duration = 0) {
  return new Promise((done) => setTimeout(done, duration));
}
/**
 * Checks if the input is false and returns void if true; otherwise returns the input.
 *
 * @param {any} input - The value to check.
 * @returns {void|*} - Returns undefined if input is false, otherwise returns the original input.
 */
function orVoid(input) {
  if (input === false) {
    return void 0;
  }
  return input;
}
var NULL, NOOP, objectToString;
var init_util = __esm({
  "src/lib/utils/util.ts"() {
    "use strict";
    NULL = "\0";
    NOOP = () => {
    };
    objectToString = Object.prototype.toString.call.bind(Object.prototype.toString);
  }
});

// src/lib/utils/argument-filters.ts
/**
 * Filters an input value based on a provided filter function and returns a default value if the filter condition is not met.
 *
 * @param {*} input - The value to be filtered.
 * @param {Function} filter - A function that takes the input as an argument and returns a boolean indicating whether the input meets the criteria.
 * @param {*|undefined} [def=undefined] - The default value to return if the filter condition is not met. If not provided, void 0 (undefined) will be returned.
 * @returns {*} - The filtered input or the default value based on the filter condition.
 *
 * @example
 * const result1 = filterType('hello', (str) => str.includes('o'));
 * // result1 is 'hello'
 *
 * const result2 = filterType('world', (str) => str.includes('a'), 'default');
 * // result2 is 'default'
 */
function filterType(input, filter, def) {
  if (filter(input)) {
    return input;
  }
  return arguments.length > 2 ? def : void 0;
}
function filterPrimitives(input, omit) {
  const type = isPathSpec(input) ? "string" : typeof input;
  return /number|string|boolean/.test(type) && (!omit || !omit.includes(type));
}
/**
 * Filters an input to check if it is a plain JavaScript object.
 *
 * @param {any} input - The value to be checked.
 * @returns {boolean} - Returns true if the input is a plain JavaScript object, false otherwise.
 *
 * Example:
 * // returns true
 * filterPlainObject({});
 *
 * // returns false
 * filterPlainObject(new Date());
 */
function filterPlainObject(input) {
  return !!input && objectToString(input) === "[object Object]";
}
/**
 * Determines if the provided input is a function.
 *
 * @param {*} input - The value to check.
 * @returns {boolean} - Returns true if the input is a function, false otherwise.
 *
 * Example:
 *   const result = filterFunction(() => {});
 *   console.log(result); // Output: true
 */
function filterFunction(input) {
  return typeof input === "function";
}
var filterArray, filterString, filterStringArray, filterStringOrStringArray, filterHasLength;
var init_argument_filters = __esm({
  "src/lib/utils/argument-filters.ts"() {
    "use strict";
    init_util();
    init_pathspec();
    filterArray = (input) => {
      return Array.isArray(input);
    };
    filterString = (input) => {
      return typeof input === "string";
    };
    filterStringArray = (input) => {
      return Array.isArray(input) && input.every(filterString);
    };
    filterStringOrStringArray = (input) => {
      return filterString(input) || Array.isArray(input) && input.every(filterString);
    };
    filterHasLength = (input) => {
      if (input == null || "number|boolean|function".includes(typeof input)) {
        return false;
      }
      return Array.isArray(input) || typeof input === "string" || typeof input.length === "number";
    };
  }
});

// src/lib/utils/exit-codes.ts
var ExitCodes;
var init_exit_codes = __esm({
  "src/lib/utils/exit-codes.ts"() {
    "use strict";
    ExitCodes = /* @__PURE__ */ ((ExitCodes2) => {
      ExitCodes2[ExitCodes2["SUCCESS"] = 0] = "SUCCESS";
      ExitCodes2[ExitCodes2["ERROR"] = 1] = "ERROR";
      ExitCodes2[ExitCodes2["NOT_FOUND"] = -2] = "NOT_FOUND";
      ExitCodes2[ExitCodes2["UNCLEAN"] = 128] = "UNCLEAN";
      return ExitCodes2;
    })(ExitCodes || {});
  }
});

// src/lib/utils/git-output-streams.ts
var GitOutputStreams;
var init_git_output_streams = __esm({
  "src/lib/utils/git-output-streams.ts"() {
    "use strict";
    GitOutputStreams = class {
      constructor(stdOut, stdErr) {
        this.stdOut = stdOut;
        this.stdErr = stdErr;
      }
      asStrings() {
        return new GitOutputStreams(this.stdOut.toString("utf8"), this.stdErr.toString("utf8"));
      }
    };
  }
});

// src/lib/utils/line-parser.ts
var LineParser, RemoteLineParser;
var init_line_parser = __esm({
  "src/lib/utils/line-parser.ts"() {
    "use strict";
    LineParser = class {
      constructor(regExp, useMatches) {
        this.matches = [];
        this.parse = (line, target) => {
          this.resetMatches();
          if (!this._regExp.every((reg, index) => this.addMatch(reg, index, line(index)))) {
            return false;
          }
          return this.useMatches(target, this.prepareMatches()) !== false;
        };
        this._regExp = Array.isArray(regExp) ? regExp : [regExp];
        if (useMatches) {
          this.useMatches = useMatches;
        }
      }
      useMatches(target, match) {
        throw new Error(`LineParser:useMatches not implemented`);
      }
      resetMatches() {
        this.matches.length = 0;
      }
      prepareMatches() {
        return this.matches;
      }
      addMatch(reg, index, line) {
        const matched = line && reg.exec(line);
        if (matched) {
          this.pushMatch(index, matched);
        }
        return !!matched;
      }
      pushMatch(_index, matched) {
        this.matches.push(...matched.slice(1));
      }
    };
    RemoteLineParser = class extends LineParser {
      addMatch(reg, index, line) {
        return /^remote:\s/.test(String(line)) && super.addMatch(reg, index, line);
      }
      pushMatch(index, matched) {
        if (index > 0 || matched.length > 1) {
          super.pushMatch(index, matched);
        }
      }
    };
  }
});

// src/lib/utils/simple-git-options.ts
/**
 * Creates an instance configuration object with default options overridden by provided options.
 *
 * @param {...Object} options - Variable number of option objects to override defaults.
 * @returns {Object} - The created configuration object.
 */
function createInstanceConfig(...options) {
  const baseDir = process.cwd();
  const config = Object.assign(
    __spreadValues({ baseDir }, defaultOptions),
    ...options.filter((o) => typeof o === "object" && o)
  );
  config.baseDir = config.baseDir || baseDir;
  config.trimmed = config.trimmed === true;
  return config;
}
var defaultOptions;
var init_simple_git_options = __esm({
  "src/lib/utils/simple-git-options.ts"() {
    "use strict";
    defaultOptions = {
      binary: "git",
      maxConcurrentProcesses: 5,
      config: [],
      trimmed: false
    };
  }
});

// src/lib/utils/task-options.ts
/**
 * Appends task options to an array of commands based on their value type.
 *
 * @param {Object} options - An object containing key-value pairs representing the task options.
 * @param {Array<string>} [commands=[]] - An optional array of strings representing the existing commands. Defaults to an empty array if not provided.
 * @returns {Array<string>} - The updated array of commands with the new task options appended.
 *
 * @example
 * const options = { output: "/path/to/output", silent: true };
 * const commands = appendTaskOptions(options);
 * console.log(commands); // ['/path/to/output', 'silent=true']
 */
function appendTaskOptions(options, commands = []) {
  if (!filterPlainObject(options)) {
    return commands;
  }
  return Object.keys(options).reduce((commands2, key) => {
    const value = options[key];
    if (isPathSpec(value)) {
      commands2.push(value);
    } else if (filterPrimitives(value, ["boolean"])) {
      commands2.push(key + "=" + value);
    } else {
      commands2.push(key);
    }
    return commands2;
  }, commands);
}
/**
 * Extracts trailing options from an array of arguments.
 *
 * @param {Array} args - The array containing the arguments.
 * @param {number} [initialPrimitive=0] - The index to start checking from. If negative, it starts from the end of the array.
 * @param {boolean} [objectOnly=false] - Whether to include only object types in the result.
 * @returns {Array} An array containing the trailing options as strings.
 *
 * @example
 * getTrailingOptions(['--option1', 'value1', '--option2'], 1);
 * // returns ['--option2']
 *
 * @example
 * getTrailingOptions([1, 'string', {}, null], -1, true);
 * // returns [{}, null]
 */
function getTrailingOptions(args, initialPrimitive = 0, objectOnly = false) {
  const command = [];
  for (let i = 0, max = initialPrimitive < 0 ? args.length : initialPrimitive; i < max; i++) {
    if ("string|number".includes(typeof args[i])) {
      command.push(String(args[i]));
    }
  }
  appendTaskOptions(trailingOptionsArgument(args), command);
  if (!objectOnly) {
    command.push(...trailingArrayArgument(args));
  }
  return command;
}
/**
 * Determines if the last argument of an array is a function and filters the array accordingly.
 *
 * @param {Array} args - The array to check and filter.
 * @returns {Array} A new array filtered based on whether the last element is a function.
 * @throws {TypeError} If the input is not an array.
 */
function trailingArrayArgument(args) {
  const hasTrailingCallback = typeof last(args) === "function";
  return filterType(last(args, hasTrailingCallback ? 1 : 0), filterArray, []);
}
/**
 * Determines if the last argument of the provided array is a callback function or an object.
 *
 * @param {Array} args - The array containing arguments to be checked.
 * @return {(function|Object|null)} Returns a callback function, an object, or null based on the condition.
 */
function trailingOptionsArgument(args) {
  const hasTrailingCallback = filterFunction(last(args));
  return filterType(last(args, hasTrailingCallback ? 1 : 0), filterPlainObject);
}
/**
 * Extracts the last function argument from an array of arguments, optionally including noops.
 *
 * @param {Array} args - The array of arguments to process.
 * @param {boolean} [includeNoop=true] - Indicates whether to include no-op functions as valid callbacks. Defaults to true.
 * @returns {(Function|undefined)} - The last function found in the arguments, or undefined if no function is present and includeNoop is false.
 *
 * Example:
 * const args = [1, 2, () => {}];
 * trailingFunctionArgument(args); // Returns: () => {}
 */
function trailingFunctionArgument(args, includeNoop = true) {
  const callback = asFunction(last(args));
  return includeNoop || isUserFunction(callback) ? callback : void 0;
}
var init_task_options = __esm({
  "src/lib/utils/task-options.ts"() {
    "use strict";
    init_argument_filters();
    init_util();
    init_pathspec();
  }
});

// src/lib/utils/task-parser.ts
/**
 * Calls a task parser function with standard output and error streams.
 *
 * @param {Function} parser4 - The parser function to be called. It should take two arguments: standard output stream (stdOut) and standard error stream (stdErr).
 * @param {Object} streams - An object containing the standard output and error streams.
 * @param {Stream} streams.stdOut - The standard output stream.
 * @param {Stream} streams.stdErr - The standard error stream.
 * @returns {*} The result of calling the parser function with the provided streams.
 * @throws {Error} If there is an issue during the execution of the parser function, it may throw an Error.
 *
 * Example usage:
 * const result = callTaskParser(myParser, { stdOut: process.stdout, stdErr: process.stderr });
 */
function callTaskParser(parser4, streams) {
  return parser4(streams.stdOut, streams.stdErr);
}
/**
 * Parses a string response using an array of parsers and processes each line.
 *
 * @param {Object} result - The object where parsed data will be stored.
 * @param {Array<{parse: Function}>} parsers12 - An array of parser objects, each with a `parse` method.
 * @param {string|string[]} texts - A string or an array of strings to be processed.
 * @param {boolean} [trim=true] - Whether to trim lines before processing. Defaults to true.
 * @returns {Object} The updated result object with parsed data.
 *
 * @throws {Error} If the parsers12 array is empty or does not contain a valid `parse` method.
 */
function parseStringResponse(result, parsers12, texts, trim = true) {
  asArray(texts).forEach((text) => {
    for (let lines = toLinesWithContent(text, trim), i = 0, max = lines.length; i < max; i++) {
      /**
       * Retrieves a line from the lines array at the specified offset.
       *
       * @param {number} [offset=0] - The index to offset the current line by.
       * @returns {(string|undefined)} - The line at the specified offset, or undefined if out of bounds.
       */
      const line = (offset = 0) => {
        if (i + offset >= max) {
          return;
        }
        return lines[i + offset];
      };
      parsers12.some(({ parse }) => parse(line, result));
    }
  });
  return result;
}
var init_task_parser = __esm({
  "src/lib/utils/task-parser.ts"() {
    "use strict";
    init_util();
  }
});

// src/lib/utils/index.ts
var utils_exports = {};
__export(utils_exports, {
  ExitCodes: () => ExitCodes,
  GitOutputStreams: () => GitOutputStreams,
  LineParser: () => LineParser,
  NOOP: () => NOOP,
  NULL: () => NULL,
  RemoteLineParser: () => RemoteLineParser,
  append: () => append,
  appendTaskOptions: () => appendTaskOptions,
  asArray: () => asArray,
  asCamelCase: () => asCamelCase,
  asFunction: () => asFunction,
  asNumber: () => asNumber,
  asStringArray: () => asStringArray,
  bufferToString: () => bufferToString,
  callTaskParser: () => callTaskParser,
  createInstanceConfig: () => createInstanceConfig,
  delay: () => delay,
  filterArray: () => filterArray,
  filterFunction: () => filterFunction,
  filterHasLength: () => filterHasLength,
  filterPlainObject: () => filterPlainObject,
  filterPrimitives: () => filterPrimitives,
  filterString: () => filterString,
  filterStringArray: () => filterStringArray,
  filterStringOrStringArray: () => filterStringOrStringArray,
  filterType: () => filterType,
  first: () => first,
  folderExists: () => folderExists,
  forEachLineWithContent: () => forEachLineWithContent,
  getTrailingOptions: () => getTrailingOptions,
  including: () => including,
  isUserFunction: () => isUserFunction,
  last: () => last,
  objectToString: () => objectToString,
  orVoid: () => orVoid,
  parseStringResponse: () => parseStringResponse,
  pick: () => pick,
  prefixedArray: () => prefixedArray,
  remove: () => remove,
  splitOn: () => splitOn,
  toLinesWithContent: () => toLinesWithContent,
  trailingFunctionArgument: () => trailingFunctionArgument,
  trailingOptionsArgument: () => trailingOptionsArgument
});
var init_utils = __esm({
  "src/lib/utils/index.ts"() {
    "use strict";
    init_argument_filters();
    init_exit_codes();
    init_git_output_streams();
    init_line_parser();
    init_simple_git_options();
    init_task_options();
    init_task_parser();
    init_util();
  }
});

// src/lib/tasks/check-is-repo.ts
var check_is_repo_exports = {};
__export(check_is_repo_exports, {
  CheckRepoActions: () => CheckRepoActions,
  checkIsBareRepoTask: () => checkIsBareRepoTask,
  checkIsRepoRootTask: () => checkIsRepoRootTask,
  checkIsRepoTask: () => checkIsRepoTask
});
/**
 * Determines if the given action corresponds to a repository task.
 *
 * @param {string} action - The action to check. Can be either "bare" or "root".
 * @returns {boolean|Object} - Returns `true` if the action is "bare" or "root", and returns an object with commands for other actions.
 */
function checkIsRepoTask(action) {
  switch (action) {
    case "bare" /* BARE */:
      return checkIsBareRepoTask();
    case "root" /* IS_REPO_ROOT */:
      return checkIsRepoRootTask();
  }
  const commands = ["rev-parse", "--is-inside-work-tree"];
  return {
    commands,
    format: "utf-8",
    onError,
    parser
  };
}
/**
 * Generates a task configuration to check if the current directory is the root of a Git repository.
 *
 * @returns {Object} - A task configuration object with properties for commands, format, onError, and parser.
 */
function checkIsRepoRootTask() {
  const commands = ["rev-parse", "--git-dir"];
  return {
    commands,
    format: "utf-8",
    onError,
    parser(path) {
      return /^\.(git)?$/.test(path.trim());
    }
  };
}
/**
 * Generates a task configuration to check if a Git repository is bare.
 *
 * @returns {Object} A task configuration object with the following properties:
 *   - commands {Array<String>} An array containing the command to execute ('rev-parse --is-bare-repository').
 *   - format {String} The expected format of the output ('utf-8').
 *   - onError {Function} A callback function to handle errors.
 *   - parser {Function} A parser function to process the output.
 *
 * Example usage:
 * const taskConfig = checkIsBareRepoTask();
 * console.log(taskConfig);
 */
function checkIsBareRepoTask() {
  const commands = ["rev-parse", "--is-bare-repository"];
  return {
    commands,
    format: "utf-8",
    onError,
    parser
  };
}
/**
 * Determines if the given error message indicates that the current directory is not a Git repository.
 *
 * @param {Error} error - The error object to check.
 * @returns {boolean} - Returns `true` if the error message matches the pattern indicating it's not a git repository, otherwise `false`.
 */
function isNotRepoMessage(error) {
  return /(Not a git repository|Kein Git-Repository)/i.test(String(error));
}
var CheckRepoActions, onError, parser;
var init_check_is_repo = __esm({
  "src/lib/tasks/check-is-repo.ts"() {
    "use strict";
    init_utils();
    CheckRepoActions = /* @__PURE__ */ ((CheckRepoActions2) => {
      CheckRepoActions2["BARE"] = "bare";
      CheckRepoActions2["IN_TREE"] = "tree";
      CheckRepoActions2["IS_REPO_ROOT"] = "root";
      return CheckRepoActions2;
    })(CheckRepoActions || {});
    onError = ({ exitCode }, error, done, fail) => {
      if (exitCode === 128 /* UNCLEAN */ && isNotRepoMessage(error)) {
        return done(Buffer.from("false"));
      }
      fail(error);
    };
    parser = (text) => {
      return text.trim() === "true";
    };
  }
});

// src/lib/responses/CleanSummary.ts
/**
 * Parses the given text to extract paths and categorizes them into files and folders.
 *
 * @param {boolean} dryRun - Indicates whether this is a dry run, affecting the regular expressions used.
 * @param {string} text - The input text containing paths.
 * @returns {CleanResponse} A CleanResponse object with extracted paths categorized by type.
 *
 * @example
 * const result = cleanSummaryParser(true, "src/index.js\nlib/config.json");
 * console.log(result);
 * // Output:
 * // {
 * //   dryRun: true,
 * //   paths: ["src/index.js", "lib/config.json"],
 * //   folders: [],
 * //   files: ["src/index.js", "lib/config.json"]
 * // }
 *
 * @throws {Error} If the input text is not a string.
 */
function cleanSummaryParser(dryRun, text) {
  const summary = new CleanResponse(dryRun);
  const regexp = dryRun ? dryRunRemovalRegexp : removalRegexp;
  toLinesWithContent(text).forEach((line) => {
    const removed = line.replace(regexp, "");
    summary.paths.push(removed);
    (isFolderRegexp.test(removed) ? summary.folders : summary.files).push(removed);
  });
  return summary;
}
var CleanResponse, removalRegexp, dryRunRemovalRegexp, isFolderRegexp;
var init_CleanSummary = __esm({
  "src/lib/responses/CleanSummary.ts"() {
    "use strict";
    init_utils();
    CleanResponse = class {
      constructor(dryRun) {
        this.dryRun = dryRun;
        this.paths = [];
        this.files = [];
        this.folders = [];
      }
    };
    removalRegexp = /^[a-z]+\s*/i;
    dryRunRemovalRegexp = /^[a-z]+\s+[a-z]+\s*/i;
    isFolderRegexp = /\/$/;
  }
});

// src/lib/tasks/task.ts
var task_exports = {};
__export(task_exports, {
  EMPTY_COMMANDS: () => EMPTY_COMMANDS,
  adhocExecTask: () => adhocExecTask,
  configurationErrorTask: () => configurationErrorTask,
  isBufferTask: () => isBufferTask,
  isEmptyTask: () => isEmptyTask,
  straightThroughBufferTask: () => straightThroughBufferTask,
  straightThroughStringTask: () => straightThroughStringTask
});
/**
 * Executes an ad-hoc task using a specified parser.
 *
 * @param {Object} parser4 - The parser to be used for executing the task.
 * @returns {Object} An object containing the commands, format, and parser.
 */
function adhocExecTask(parser4) {
  return {
    commands: EMPTY_COMMANDS,
    format: "empty",
    parser: parser4
  };
}
/**
 * Creates an error task with no commands and an "empty" format.
 * Throws a TaskConfigurationError with the provided error message or rethrows the error if it's not a string.
 *
 * @param {string|Error} error - The error to throw or the error message.
 * @returns {{commands: [], format: string, parser: function}} - An object containing commands, format, and a parser that throws the error.
 */
function configurationErrorTask(error) {
  return {
    commands: EMPTY_COMMANDS,
    format: "empty",
    parser() {
      throw typeof error === "string" ? new TaskConfigurationError(error) : error;
    }
  };
}
/**
 * Creates a task object that processes strings directly.
 *
 * @param {Array} commands - The list of commands to be executed.
 * @param {boolean} [trimmed2=false] - If true, the parser will trim the input text.
 * @returns {Object} A task object with properties `commands`, `format`, and a `parser` function.
 *
 * @example
 * const task = straightThroughStringTask(["echo", "hello"], true);
 * console.log(task.parser("  hello  ")); // Output: "hello"
 */
function straightThroughStringTask(commands, trimmed2 = false) {
  return {
    commands,
    format: "utf-8",
    parser(text) {
      return trimmed2 ? String(text).trim() : text;
    }
  };
}
/**
 * Creates a buffer task that processes commands directly without any transformation.
 *
 * @param {Array} commands - The array of commands to be processed.
 * @returns {Object} An object representing the buffer task with properties `commands`, `format`, and `parser`.
 * @property {Array} commands - The array of commands provided as input.
 * @property {string} format - The format of the output, which is always "buffer".
 * @property {Function} parser - A function that takes a buffer and returns it unchanged.
 *
 * @example
 * const task = straightThroughBufferTask(['command1', 'command2']);
 * console.log(task);
 * // Output: { commands: ['command1', 'command2'], format: 'buffer', parser: [Function] }
 */
function straightThroughBufferTask(commands) {
  return {
    commands,
    format: "buffer",
    parser(buffer) {
      return buffer;
    }
  };
}
/**
 * Determines if a given task has a format of "buffer".
 *
 * @param {Object} task - The task object to check.
 * @property {string} format - The format of the task.
 * @returns {boolean} - Returns true if the task's format is "buffer", otherwise false.
 *
 * @example
 * const task = { format: "buffer" };
 * console.log(isBufferTask(task)); // Output: true
 */
function isBufferTask(task) {
  return task.format === "buffer";
}
/**
 * Determines if a task is empty based on its format or command length.
 *
 * @param {Object} task - The task object to check.
 * @property {string} task.format - The format of the task, should be "empty" for an empty task.
 * @property {Array} task.commands - An array of commands associated with the task. If it's empty or not provided, the task is considered empty.
 * @returns {boolean} - Returns true if the task is empty, false otherwise.
 *
 * @example
 * const task = {
 *   format: "empty",
 *   commands: []
 * };
 * console.log(isEmptyTask(task)); // Output: true
 */
function isEmptyTask(task) {
  return task.format === "empty" || !task.commands.length;
}
var EMPTY_COMMANDS;
var init_task = __esm({
  "src/lib/tasks/task.ts"() {
    "use strict";
    init_task_configuration_error();
    EMPTY_COMMANDS = [];
  }
});

// src/lib/tasks/clean.ts
var clean_exports = {};
__export(clean_exports, {
  CONFIG_ERROR_INTERACTIVE_MODE: () => CONFIG_ERROR_INTERACTIVE_MODE,
  CONFIG_ERROR_MODE_REQUIRED: () => CONFIG_ERROR_MODE_REQUIRED,
  CONFIG_ERROR_UNKNOWN_OPTION: () => CONFIG_ERROR_UNKNOWN_OPTION,
  CleanOptions: () => CleanOptions,
  cleanTask: () => cleanTask,
  cleanWithOptionsTask: () => cleanWithOptionsTask,
  isCleanOptionsArray: () => isCleanOptionsArray
});
/**
 * Executes the cleaning process with specified mode and custom options.
 *
 * @param {string} mode - The mode for cleaning operation.
 * @param {Array} customArgs - Custom arguments to be added to the options.
 * @returns {Promise} A promise that resolves when the cleaning task is completed or rejects if an error occurs.
 *
 * @throws {Error} Throws an error if the clean mode is not specified.
 * @throws {Error} Throws an error if any unknown options are provided in the mode.
 * @throws {Error} Throws an error if interactive mode is detected among custom options.
 */
function cleanWithOptionsTask(mode, customArgs) {
  const { cleanMode, options, valid } = getCleanOptions(mode);
  if (!cleanMode) {
    return configurationErrorTask(CONFIG_ERROR_MODE_REQUIRED);
  }
  if (!valid.options) {
    return configurationErrorTask(CONFIG_ERROR_UNKNOWN_OPTION + JSON.stringify(mode));
  }
  options.push(...customArgs);
  if (options.some(isInteractiveMode)) {
    return configurationErrorTask(CONFIG_ERROR_INTERACTIVE_MODE);
  }
  return cleanTask(cleanMode, options);
}
/**
 * Cleans tasks based on the specified mode and custom arguments.
 *
 * @param {string} mode - The cleaning mode. Can be "n" for DRY_RUN or another valid mode.
 * @param {Array<string>} customArgs - Additional arguments to pass to the clean command.
 * @returns {Object} An object containing the commands, format, and parser function.
 *
 * @example
 * const task = cleanTask("n", ["-f"]);
 * console.log(task.commands); // Output: ['clean', '-n', '-f']
 */
function cleanTask(mode, customArgs) {
  const commands = ["clean", `-${mode}`, ...customArgs];
  return {
    commands,
    format: "utf-8",
    parser(text) {
      return cleanSummaryParser(mode === "n" /* DRY_RUN */, text);
    }
  };
}
/**
 * Checks if the provided input is an array of clean option values.
 *
 * @param {any} input - The value to check.
 * @returns {boolean} - Returns true if the input is an array and every element is a clean option value, otherwise false.
 *
 * Example:
 *   const options = ['option1', 'option2'];
 *   console.log(isCleanOptionsArray(options)); // Output: true
 *
 *   const invalidOption = ['option1', 123];
 *   console.log(isCleanOptionsArray(invalidOption)); // Output: false
 */
function isCleanOptionsArray(input) {
  return Array.isArray(input) && input.every((test) => CleanOptionValues.has(test));
}
/**
 * Parses input string to extract clean mode and options.
 *
 * @param {string} input - The input string to parse.
 * @return {{
 *   cleanMode: (string|undefined),
 *   options: Array<string>,
 *   valid: {
 *     cleanMode: boolean,
 *     options: boolean
 *   }
 * }}
 * Returns an object containing the extracted clean mode, options, and validation results.
 *
 * Example:
 * getCleanOptions('-c-a-b');
 * // Returns { cleanMode: 'c', options: ['a', 'b'], valid: { cleanMode: true, options: true } }
 */
function getCleanOptions(input) {
  let cleanMode;
  let options = [];
  let valid = { cleanMode: false, options: true };
  input.replace(/[^a-z]i/g, "").split("").forEach((char) => {
    if (isCleanMode(char)) {
      cleanMode = char;
      valid.cleanMode = true;
    } else {
      valid.options = valid.options && isKnownOption(options[options.length] = `-${char}`);
    }
  });
  return {
    cleanMode,
    options,
    valid
  };
}
/**
 * Checks if the provided clean mode is either "f" (FORCE) or "n" (DRY_RUN).
 *
 * @param {string} cleanMode - The clean mode to check.
 * @returns {boolean} True if the clean mode is "f" or "n", false otherwise.
 * @throws {Error} If the clean mode is neither "f" nor "n".
 */
function isCleanMode(cleanMode) {
  return cleanMode === "f" /* FORCE */ || cleanMode === "n" /* DRY_RUN */;
}
function isKnownOption(option) {
  return /^-[a-z]$/i.test(option) && CleanOptionValues.has(option.charAt(1));
}
/**
 * Determines if the given option indicates interactive mode.
 *
 * @param {string} option - The command-line option to check.
 * @returns {boolean} - Returns true if the option indicates interactive mode, false otherwise.
 *
 * @example
 * isInteractiveMode("-i"); // returns true
 * isInteractiveMode("--non-interactive"); // returns false
 */
function isInteractiveMode(option) {
  if (/^-[^\-]/.test(option)) {
    return option.indexOf("i") > 0;
  }
  return option === "--interactive";
}
var CONFIG_ERROR_INTERACTIVE_MODE, CONFIG_ERROR_MODE_REQUIRED, CONFIG_ERROR_UNKNOWN_OPTION, CleanOptions, CleanOptionValues;
var init_clean = __esm({
  "src/lib/tasks/clean.ts"() {
    "use strict";
    init_CleanSummary();
    init_utils();
    init_task();
    CONFIG_ERROR_INTERACTIVE_MODE = "Git clean interactive mode is not supported";
    CONFIG_ERROR_MODE_REQUIRED = 'Git clean mode parameter ("n" or "f") is required';
    CONFIG_ERROR_UNKNOWN_OPTION = "Git clean unknown option found in: ";
    CleanOptions = /* @__PURE__ */ ((CleanOptions2) => {
      CleanOptions2["DRY_RUN"] = "n";
      CleanOptions2["FORCE"] = "f";
      CleanOptions2["IGNORED_INCLUDED"] = "x";
      CleanOptions2["IGNORED_ONLY"] = "X";
      CleanOptions2["EXCLUDING"] = "e";
      CleanOptions2["QUIET"] = "q";
      CleanOptions2["RECURSIVE"] = "d";
      return CleanOptions2;
    })(CleanOptions || {});
    CleanOptionValues = /* @__PURE__ */ new Set([
      "i",
      ...asStringArray(Object.values(CleanOptions))
    ]);
  }
});

// src/lib/responses/ConfigList.ts
/**
 * Parses a text string into a configuration list.
 *
 * @param {string} text - The text to be parsed. It should contain items in a format that the `configParser` function can understand.
 * @returns {ConfigList} A new ConfigList object populated with values from the parsed text.
 *
 * @example
 * const configText = "file1.key1=value1\nfile2.key2=value2";
 * const config = configListParser(configText);
 * console.log(config); // Output: ConfigList instance with values added for file1.key1 and file2.key2
 *
 * @throws {Error} If the input text is not in a format that `configParser` can understand, an error will be thrown.
 */
function configListParser(text) {
  const config = new ConfigList();
  for (const item of configParser(text)) {
    config.addValue(item.file, String(item.key), item.value);
  }
  return config;
}
/**
 * Parses a configuration text to extract values for a specific key and categorizes them by file scope.
 *
 * @param {string} text - The configuration text to parse.
 * @param {string} key - The key whose values need to be extracted.
 * @returns {Object} An object containing the key, paths, scopes, value, and values.
 *   - key: The key that was parsed.
 *   - paths: An array of file paths where the key's values were found.
 *   - scopes: A Map where keys are file paths and values are arrays of corresponding key values.
 *   - value: The last value associated with the key. If no values are found, it is null.
 *   - values: An array of all values associated with the key.
 *
 * @example
 * const result = configGetParser("path/to/file1.js=10\npath/to/file2.js=20\npath/to/file1.js=30", "path/to/file1.js");
 * console.log(result);
 * // Output: {
 * //   key: "path/to/file1.js",
 * //   paths: ["path/to/file1.js"],
 * //   scopes: Map { "path/to/file1.js" => [ 10, 30 ] },
 * //   value: 30,
 * //   values: [ 10, 30 ]
 * // }
 */
function configGetParser(text, key) {
  let value = null;
  const values = [];
  const scopes = /* @__PURE__ */ new Map();
  for (const item of configParser(text, key)) {
    if (item.key !== key) {
      continue;
    }
    values.push(value = item.value);
    if (!scopes.has(item.file)) {
      scopes.set(item.file, []);
    }
    scopes.get(item.file).push(value);
  }
  return {
    key,
    paths: Array.from(scopes.keys()),
    scopes,
    value,
    values
  };
}
/**
 * Removes the protocol prefix 'file:' from the given file path.
 *
 * @param {string} filePath - The file path to process.
 * @returns {string} The processed file path without the 'file:' prefix.
 *
 * @example
 * // Example usage:
 * const result = configFilePath("file:///path/to/file.txt");
 * console.log(result); // Output: "/path/to/file.txt"
 */
function configFilePath(filePath) {
  return filePath.replace(/^(file):/, "");
}
/**
 * Parses configuration text into an iterable generator of objects containing file paths, keys, and values.
 *
 * @generator
 * @function
 * @param {string} text - The input text to parse, expected to contain file paths followed by key-value pairs.
 * @param {string|null} [requestedKey=null] - An optional key to filter the results. If provided, only entries with this key will be yielded.
 * @yields {Object} - Objects containing properties `file`, `key`, and `value`.
 *   - `file` {string}: The path of the configuration file.
 *   - `key` {string|null}: The key associated with the value. If a `requestedKey` is provided, this will be that key; otherwise, it may vary.
 *   - `value` {string}: The corresponding value for the key.
 *
 * @example
 * // Usage example:
 * for (const config of configParser("file1.txt\nkey1=value1\nfile2.txt\nkey2=value2", "key1")) {
 *   console.log(config.file, config.key, config.value); // Outputs: file1.txt key1 value1
 * }
 *
 * @throws {Error} - Throws an error if the input text is not properly formatted.
 */
function* configParser(text, requestedKey = null) {
  const lines = text.split("\0");
  for (let i = 0, max = lines.length - 1; i < max; ) {
    const file = configFilePath(lines[i++]);
    let value = lines[i++];
    let key = requestedKey;
    if (value.includes("\n")) {
      const line = splitOn(value, "\n");
      key = line[0];
      value = line[1];
    }
    yield { file, key, value };
  }
}
var ConfigList;
var init_ConfigList = __esm({
  "src/lib/responses/ConfigList.ts"() {
    "use strict";
    init_utils();
    ConfigList = class {
      constructor() {
        this.files = [];
        this.values = /* @__PURE__ */ Object.create(null);
      }
      get all() {
        if (!this._all) {
          this._all = this.files.reduce((all, file) => {
            return Object.assign(all, this.values[file]);
          }, {});
        }
        return this._all;
      }
      addFile(file) {
        if (!(file in this.values)) {
          const latest = last(this.files);
          this.values[file] = latest ? Object.create(this.values[latest]) : {};
          this.files.push(file);
        }
        return this.values[file];
      }
      addValue(file, key, value) {
        const values = this.addFile(file);
        if (!values.hasOwnProperty(key)) {
          values[key] = value;
        } else if (Array.isArray(values[key])) {
          values[key].push(value);
        } else {
          values[key] = [values[key], value];
        }
        this._all = void 0;
      }
    };
  }
});

// src/lib/tasks/config.ts
/**
 * Converts a given scope to a Git configuration scope if it is a recognized type; otherwise returns a fallback value.
 *
 * @param {string} scope - The scope string to convert. Should be one of the properties defined in GitConfigScope.
 * @param {string} fallback - The default value to return if the provided scope is not a recognized GitConfigScope property.
 * @returns {string} - The converted scope if it's valid, otherwise the fallback value.
 *
 * Example usage:
 * asConfigScope("global", "user"); // Returns "global" if it exists in GitConfigScope
 * asConfigScope("unknown", "user"); // Returns "user"
 */
function asConfigScope(scope, fallback) {
  if (typeof scope === "string" && GitConfigScope.hasOwnProperty(scope)) {
    return scope;
  }
  return fallback;
}
/**
 * Adds a configuration task with the specified key and value.
 *
 * @param {string} key - The key of the configuration setting.
 * @param {string} value - The value to set for the configuration setting.
 * @param {boolean} append2 - Determines if the task should be appended or not. Default is false.
 * @param {string} scope - The scope of the configuration, e.g., 'global', 'user'.
 * @returns {Object} An object containing an array of commands and a parser function.
 * @throws {Error} If any parameter is invalid.
 *
 * @example
 * const task = addConfigTask("theme", "dark", true, "user");
 * console.log(task.commands); // ['config', '--user', '--add', 'theme', 'dark']
 */
function addConfigTask(key, value, append2, scope) {
  const commands = ["config", `--${scope}`];
  if (append2) {
    commands.push("--add");
  }
  commands.push(key, value);
  return {
    commands,
    format: "utf-8",
    parser(text) {
      return text;
    }
  };
}
/**
 * Constructs a configuration task object that includes commands to get configuration values from a specified scope.
 *
 * @param {string} key - The specific configuration key for which the value is requested.
 * @param {string} [scope] - Optional. The scope in which the configuration key should be searched. If not provided, it defaults to the global scope.
 * @returns {Object} - An object containing an array of commands and a parser function.
 * @property {string[]} commands - An array of strings representing the command and its arguments.
 * @property {string} format - The expected format of the output text, which is "utf-8" in this case.
 * @property {function(string): any} parser - A function that takes a string (the command output) as input and returns the parsed configuration value.
 *
 * @example
 * const task = getConfigTask('user.name');
 * console.log(task.commands); // Output: ['config', '--null', '--show-origin', '--get-all', 'user.name']
 */
function getConfigTask(key, scope) {
  const commands = ["config", "--null", "--show-origin", "--get-all", key];
  if (scope) {
    commands.splice(1, 0, `--${scope}`);
  }
  return {
    commands,
    format: "utf-8",
    parser(text) {
      return configGetParser(text, key);
    }
  };
}
/**
 * Generates a configuration list task with optional scope.
 *
 * @param {string} [scope] - Optional scope to filter the config items. If provided, it will be added as an argument to the command.
 * @returns {Object} An object containing the commands array and parser function.
 * @returns {Array<string>} commands.commands - Array of commands to run for listing configuration.
 * @returns {string} commands.format - Output format of the commands (default is "utf-8").
 * @returns {function(string): Object} commands.parser - Function to parse the output text from running the commands.
 * @throws Will throw an error if the parser function fails to correctly parse the input text.
 *
 * @example
 * const configTask = listConfigTask();
 * console.log(configTask);
 * // Output: { commands: [ 'config', '--list', '--show-origin', '--null' ], format: 'utf-8', parser: [Function] }
 *
 * const scopedConfigTask = listConfigTask('user');
 * console.log(scopedConfigTask.commands);
 * // Output: [ 'config', '--list', '--show-origin', '--null', '--user' ]
 */
function listConfigTask(scope) {
  const commands = ["config", "--list", "--show-origin", "--null"];
  if (scope) {
    commands.push(`--${scope}`);
  }
  return {
    commands,
    format: "utf-8",
    parser(text) {
      return configListParser(text);
    }
  };
}
/**
 * Returns default configuration settings.
 *
 * @returns {Object} - An object containing methods for configuring settings.
 */
function config_default() {
  return {
    addConfig(key, value, ...rest) {
      return this._runTask(
        addConfigTask(
          key,
          value,
          rest[0] === true,
          asConfigScope(rest[1], "local" /* local */)
        ),
        trailingFunctionArgument(arguments)
      );
    },
    getConfig(key, scope) {
      return this._runTask(
        getConfigTask(key, asConfigScope(scope, void 0)),
        trailingFunctionArgument(arguments)
      );
    },
    listConfig(...rest) {
      return this._runTask(
        listConfigTask(asConfigScope(rest[0], void 0)),
        trailingFunctionArgument(arguments)
      );
    }
  };
}
var GitConfigScope;
var init_config = __esm({
  "src/lib/tasks/config.ts"() {
    "use strict";
    init_ConfigList();
    init_utils();
    GitConfigScope = /* @__PURE__ */ ((GitConfigScope2) => {
      GitConfigScope2["system"] = "system";
      GitConfigScope2["global"] = "global";
      GitConfigScope2["local"] = "local";
      GitConfigScope2["worktree"] = "worktree";
      return GitConfigScope2;
    })(GitConfigScope || {});
  }
});

// src/lib/tasks/diff-name-status.ts
/**
 * Checks if the input string exists as a key in the `diffNameStatus` set.
 *
 * @param {string} input - The string to check.
 * @returns {boolean} True if the input exists in `diffNameStatus`, false otherwise.
 * @throws {TypeError} If the input is not a string.
 */
function isDiffNameStatus(input) {
  return diffNameStatus.has(input);
}
var DiffNameStatus, diffNameStatus;
var init_diff_name_status = __esm({
  "src/lib/tasks/diff-name-status.ts"() {
    "use strict";
    DiffNameStatus = /* @__PURE__ */ ((DiffNameStatus2) => {
      DiffNameStatus2["ADDED"] = "A";
      DiffNameStatus2["COPIED"] = "C";
      DiffNameStatus2["DELETED"] = "D";
      DiffNameStatus2["MODIFIED"] = "M";
      DiffNameStatus2["RENAMED"] = "R";
      DiffNameStatus2["CHANGED"] = "T";
      DiffNameStatus2["UNMERGED"] = "U";
      DiffNameStatus2["UNKNOWN"] = "X";
      DiffNameStatus2["BROKEN"] = "B";
      return DiffNameStatus2;
    })(DiffNameStatus || {});
    diffNameStatus = new Set(Object.values(DiffNameStatus));
  }
});

// src/lib/tasks/grep.ts
/**
 * Constructs a new GrepQuery instance with parameters provided.
 *
 * @param {...*} params - The parameters to pass to the GrepQuery constructor.
 * @returns {GrepQuery} A new instance of GrepQuery initialized with the given parameters.
 */
function grepQueryBuilder(...params) {
  return new GrepQuery().param(...params);
}
/**
 * Parses grep output to extract paths and their corresponding line numbers and previews.
 *
 * @param {string} grep - The grep output string to be parsed.
 * @returns {Object} An object containing paths as keys and arrays of results as values.
 * @property {Set<string>} paths - A set of unique file paths found in the grep output.
 * @property {Object} results - An object where each key is a file path, and the value is an array of objects
 *                              with properties 'line', 'path', and 'preview'.
 */
function parseGrep(grep) {
  const paths = /* @__PURE__ */ new Set();
  const results = {};
  forEachLineWithContent(grep, (input) => {
    const [path, line, preview] = input.split(NULL);
    paths.add(path);
    (results[path] = results[path] || []).push({
      line: asNumber(line),
      path,
      preview
    });
  });
  return {
    paths,
    results
  };
}
/**
 * Creates a default grep function with specific configurations.
 *
 * @returns {Object} An object containing the grep method.
 */
function grep_default() {
  return {
    grep(searchTerm) {
      const then = trailingFunctionArgument(arguments);
      const options = getTrailingOptions(arguments);
      for (const option of disallowedOptions) {
        if (options.includes(option)) {
          return this._runTask(
            configurationErrorTask(`git.grep: use of "${option}" is not supported.`),
            then
          );
        }
      }
      if (typeof searchTerm === "string") {
        searchTerm = grepQueryBuilder().param(searchTerm);
      }
      const commands = ["grep", "--null", "-n", "--full-name", ...options, ...searchTerm];
      return this._runTask(
        {
          commands,
          format: "utf-8",
          parser(stdOut) {
            return parseGrep(stdOut);
          }
        },
        then
      );
    }
  };
}
var disallowedOptions, Query, _a, GrepQuery;
var init_grep = __esm({
  "src/lib/tasks/grep.ts"() {
    "use strict";
    init_utils();
    init_task();
    disallowedOptions = ["-h"];
    Query = Symbol("grepQuery");
    GrepQuery = class {
      constructor() {
        this[_a] = [];
      }
      *[(_a = Query, Symbol.iterator)]() {
        for (const query of this[Query]) {
          yield query;
        }
      }
      and(...and) {
        and.length && this[Query].push("--and", "(", ...prefixedArray(and, "-e"), ")");
        return this;
      }
      param(...param) {
        this[Query].push(...prefixedArray(param, "-e"));
        return this;
      }
    };
  }
});

// src/lib/tasks/reset.ts
var reset_exports = {};
__export(reset_exports, {
  ResetMode: () => ResetMode,
  getResetMode: () => getResetMode,
  resetTask: () => resetTask
});
/**
 * Resets a task based on the provided mode and custom arguments.
 *
 * @param {string} mode - The mode to use for resetting the task. Must be a valid mode as determined by `isValidResetMode`.
 * @param {Array<string>} [customArgs=[]] - Additional arguments to pass to the reset command.
 * @returns {Promise} A promise that resolves when the task has been reset.
 * @throws Will throw an error if the provided mode is not valid.
 *
 * Example:
 *   resetTask('full', ['--force']).then(() => {
 *     console.log('Task reset successfully');
 *   }).catch((error) => {
 *     console.error('Failed to reset task:', error);
 *   });
 */
function resetTask(mode, customArgs) {
  const commands = ["reset"];
  if (isValidResetMode(mode)) {
    commands.push(`--${mode}`);
  }
  commands.push(...customArgs);
  return straightThroughStringTask(commands);
}
/**
 * Determines the reset mode based on the input value.
 *
 * @param {string|undefined} mode - The mode to check. Can be a string or undefined.
 * @returns {string} - The reset mode, either "soft" (default) or the provided valid mode.
 * @throws {Error} - Throws an error if the input is neither a string nor undefined.
 *
 * @example
 * // Returns "soft"
 * getResetMode(undefined);
 *
 * @example
 * // Returns "soft"
 * getResetMode("invalid");
 *
 * @example
 * // Returns "hard"
 * getResetMode("hard");
 */
function getResetMode(mode) {
  if (isValidResetMode(mode)) {
    return mode;
  }
  switch (typeof mode) {
    case "string":
    case "undefined":
      return "soft" /* SOFT */;
  }
  return;
}
/**
 * Checks if the provided reset mode is valid.
 *
 * @param {string} mode - The reset mode to check.
 * @returns {boolean} True if the mode is valid, false otherwise.
 * @throws {Error} If the mode is not a string.
 */
function isValidResetMode(mode) {
  return ResetModes.includes(mode);
}
var ResetMode, ResetModes;
var init_reset = __esm({
  "src/lib/tasks/reset.ts"() {
    "use strict";
    init_task();
    ResetMode = /* @__PURE__ */ ((ResetMode2) => {
      ResetMode2["MIXED"] = "mixed";
      ResetMode2["SOFT"] = "soft";
      ResetMode2["HARD"] = "hard";
      ResetMode2["MERGE"] = "merge";
      ResetMode2["KEEP"] = "keep";
      return ResetMode2;
    })(ResetMode || {});
    ResetModes = Array.from(Object.values(ResetMode));
  }
});

// src/lib/git-logger.ts
import debug from "debug";
/**
 * Creates a debug logger using the 'simple-git' library.
 *
 * @returns {Function} - A function that logs messages with debugging information.
 * @throws {Error} - Throws an error if the 'debug' module is not available or fails to initialize.
 */
function createLog() {
  return debug("simple-git");
}
function prefixedLogger(to, prefix, forward) {
  if (!prefix || !String(prefix).replace(/\s*/, "")) {
    return !forward ? to : (message, ...args) => {
      to(message, ...args);
      forward(message, ...args);
    };
  }
  return (message, ...args) => {
    to(`%s ${message}`, prefix, ...args);
    if (forward) {
      forward(message, ...args);
    }
  };
}
/**
 * Generates a child logger name based on the given parameters.
 *
 * @param {string} name - The base name for the child logger.
 * @param {Object} [childDebugger] - An optional object containing debugger information.
 * @param {Object} [childDebugger.namespace=""] - The namespace of the child debugger, defaults to an empty string if not provided.
 * @param {string} parentNamespace - The namespace of the parent logger.
 * @returns {string} - The generated child logger name.
 *
 * @example
 * // Example usage:
 * const namespace = "app.module";
 * const childName = childLoggerName("info", { namespace: "app" }, { namespace });
 * console.log(childName); // Output: "module"
 */
function childLoggerName(name, childDebugger, { namespace: parentNamespace }) {
  if (typeof name === "string") {
    return name;
  }
  const childNamespace = childDebugger && childDebugger.namespace || "";
  if (childNamespace.startsWith(parentNamespace)) {
    return childNamespace.substr(parentNamespace.length + 1);
  }
  return childNamespace || parentNamespace;
}
/**
 * Creates a logger function with optional label, verbosity level, initial step, and custom debugger.
 *
 * @param {string} [label] - A label for the logger to help identify logs.
 * @param {boolean|string|Object} verbose - Controls the verbosity of the logger. If false, no logging; if string, extends the infoDebugger; if object, uses the provided debugger.
 * @param {number} initialStep - The initial step number for the logger.
 * @param {Function} [infoDebugger=createLog()] - A custom debugger function to handle informational logs.
 * @returns {Object} - An object containing logging functions and properties.
 *
 * @example
 * const logger = createLogger('MyApp', true, 1);
 * logger.info('This is an info message');
 * logger.step(2).info('Step 2 completed');
 */
function createLogger(label, verbose, initialStep, infoDebugger = createLog()) {
  const labelPrefix = label && `[${label}]` || "";
  const spawned = [];
  const debugDebugger = typeof verbose === "string" ? infoDebugger.extend(verbose) : verbose;
  const key = childLoggerName(filterType(verbose, filterString), debugDebugger, infoDebugger);
  return step(initialStep);
  /**
   * Creates a sibling by appending it to a spawned entity with a new logger.
   *
   * @param {string} name - The new name for the sibling entity.
   * @param {boolean} initial - Indicates if this is an initial setup.
   * @returns {Entity} - The newly created sibling entity.
   * @throws {Error} - Throws an error if the key is undefined or invalid.
   *
   * Example:
   * const newSibling = sibling('newName', true);
   */
  function sibling(name, initial) {
    return append(
      spawned,
      createLogger(label, key.replace(/^[^:]+/, name), initial, infoDebugger)
    );
  }
  /**
   * Executes a step in a given phase with debugging and logging capabilities.
   *
   * @param {string} [phase] - The current phase of the execution. If provided, it will be included in logs.
   * @return {Object} An object containing debug and info functions along with other properties.
   * @throws {Error} Throws an error if required dependencies are not met.
   *
   * @example
   * const stepInfo = step('Initialization');
   * stepInfo.info('Step completed successfully.');
   */
  function step(phase) {
    const stepPrefix = phase && `[${phase}]` || "";
    const debug2 = debugDebugger && prefixedLogger(debugDebugger, stepPrefix) || NOOP;
    const info = prefixedLogger(infoDebugger, `${labelPrefix} ${stepPrefix}`, debug2);
    return Object.assign(debugDebugger ? debug2 : info, {
      label,
      sibling,
      info,
      step
    });
  }
}
var init_git_logger = __esm({
  "src/lib/git-logger.ts"() {
    "use strict";
    init_utils();
    debug.formatters.L = (value) => String(filterHasLength(value) ? value.length : "-");
    debug.formatters.B = (value) => {
      if (Buffer.isBuffer(value)) {
        return value.toString("utf8");
      }
      return objectToString(value);
    };
  }
});

// src/lib/runners/tasks-pending-queue.ts
var _TasksPendingQueue, TasksPendingQueue;
var init_tasks_pending_queue = __esm({
  "src/lib/runners/tasks-pending-queue.ts"() {
    "use strict";
    init_git_error();
    init_git_logger();
    _TasksPendingQueue = class {
      constructor(logLabel = "GitExecutor") {
        this.logLabel = logLabel;
        this._queue = /* @__PURE__ */ new Map();
      }
      withProgress(task) {
        return this._queue.get(task);
      }
      createProgress(task) {
        const name = _TasksPendingQueue.getName(task.commands[0]);
        const logger = createLogger(this.logLabel, name);
        return {
          task,
          logger,
          name
        };
      }
      push(task) {
        const progress = this.createProgress(task);
        progress.logger("Adding task to the queue, commands = %o", task.commands);
        this._queue.set(task, progress);
        return progress;
      }
      fatal(err) {
        for (const [task, { logger }] of Array.from(this._queue.entries())) {
          if (task === err.task) {
            logger.info(`Failed %o`, err);
            logger(
              `Fatal exception, any as-yet un-started tasks run through this executor will not be attempted`
            );
          } else {
            logger.info(
              `A fatal exception occurred in a previous task, the queue has been purged: %o`,
              err.message
            );
          }
          this.complete(task);
        }
        if (this._queue.size !== 0) {
          throw new Error(`Queue size should be zero after fatal: ${this._queue.size}`);
        }
      }
      complete(task) {
        const progress = this.withProgress(task);
        if (progress) {
          this._queue.delete(task);
        }
      }
      attempt(task) {
        const progress = this.withProgress(task);
        if (!progress) {
          throw new GitError(void 0, "TasksPendingQueue: attempt called for an unknown task");
        }
        progress.logger("Starting task");
        return progress;
      }
      static getName(name = "empty") {
        return `task:${name}:${++_TasksPendingQueue.counter}`;
      }
    };
    TasksPendingQueue = _TasksPendingQueue;
    TasksPendingQueue.counter = 0;
  }
});

// src/lib/runners/git-executor-chain.ts
import { spawn } from "child_process";
/**
 * Creates a context object for a plugin task.
 *
 * @param {Object} task - The task configuration object.
 * @param {Array<Object>} commands - An array of command objects associated with the task.
 * @returns {Object} A context object containing the method and commands from the task.
 * @throws {Error} Throws an error if the task or commands are not provided.
 *
 * @example
 * const task = {
 *   commands: [{ name: 'compile' }, { name: 'run' }]
 * };
 * const context = pluginContext(task, task.commands);
 * console.log(context); // { method: 'compile', commands: [ { name: 'compile' }, { name: 'run' } ] }
 */
function pluginContext(task, commands) {
  return {
    method: first(task.commands) || "",
    commands
  };
}
/**
 * Creates an error handler function to handle exceptions from child processes.
 *
 * @param {Array} target - The array where the error buffer will be pushed.
 * @param {Function} logger - A logging function that takes a string and logs it.
 * @returns {Function} - An error handling function that logs the error and pushes its stack trace to the target array.
 */
function onErrorReceived(target, logger) {
  return (err) => {
    logger(`[ERROR] child process exception %o`, err);
    target.push(Buffer.from(String(err.stack), "ascii"));
  };
}
/**
 * Creates a function to handle data received by a target.
 *
 * @param {Array} target - The array where the buffer will be pushed.
 * @param {string} name - The name of the target, used for logging purposes.
 * @param {function} logger - A function to log messages. It should accept a format string and additional arguments.
 * @param {function} output - A function to output the received data. It should accept a format string and additional arguments.
 * @returns {function} - A function that takes a buffer, logs its size, outputs it, and pushes it to the target array.
 */
function onDataReceived(target, name, logger, output) {
  return (buffer) => {
    logger(`%s received %L bytes`, name, buffer);
    output(`%B`, buffer);
    target.push(buffer);
  };
}
var GitExecutorChain;
var init_git_executor_chain = __esm({
  "src/lib/runners/git-executor-chain.ts"() {
    "use strict";
    init_git_error();
    init_task();
    init_utils();
    init_tasks_pending_queue();
    GitExecutorChain = class {
      constructor(_executor, _scheduler, _plugins) {
        this._executor = _executor;
        this._scheduler = _scheduler;
        this._plugins = _plugins;
        this._chain = Promise.resolve();
        this._queue = new TasksPendingQueue();
      }
      get cwd() {
        return this._cwd || this._executor.cwd;
      }
      set cwd(cwd) {
        this._cwd = cwd;
      }
      get env() {
        return this._executor.env;
      }
      get outputHandler() {
        return this._executor.outputHandler;
      }
      chain() {
        return this;
      }
      push(task) {
        this._queue.push(task);
        return this._chain = this._chain.then(() => this.attemptTask(task));
      }
      attemptTask(task) {
        return __async(this, null, function* () {
          const onScheduleComplete = yield this._scheduler.next();
          /**
           * Completes the current task in the queue.
           *
           * This function is called when a task has been successfully processed and can no longer be worked on.
           */
          const onQueueComplete = () => this._queue.complete(task);
          try {
            const { logger } = this._queue.attempt(task);
            return yield isEmptyTask(task) ? this.attemptEmptyTask(task, logger) : this.attemptRemoteTask(task, logger);
          } catch (e) {
            throw this.onFatalException(task, e);
          } finally {
            onQueueComplete();
            onScheduleComplete();
          }
        });
      }
      onFatalException(task, e) {
        const gitError = e instanceof GitError ? Object.assign(e, { task }) : new GitError(task, e && String(e));
        this._chain = Promise.resolve();
        this._queue.fatal(gitError);
        return gitError;
      }
      attemptRemoteTask(task, logger) {
        return __async(this, null, function* () {
          const binary = this._plugins.exec("spawn.binary", "", pluginContext(task, task.commands));
          const args = this._plugins.exec(
            "spawn.args",
            [...task.commands],
            pluginContext(task, task.commands)
          );
          const raw = yield this.gitResponse(
            task,
            binary,
            args,
            this.outputHandler,
            logger.step("SPAWN")
          );
          const outputStreams = yield this.handleTaskData(task, args, raw, logger.step("HANDLE"));
          logger(`passing response to task's parser as a %s`, task.format);
          if (isBufferTask(task)) {
            return callTaskParser(task.parser, outputStreams);
          }
          return callTaskParser(task.parser, outputStreams.asStrings());
        });
      }
      attemptEmptyTask(task, logger) {
        return __async(this, null, function* () {
          logger(`empty task bypassing child process to call to task's parser`);
          return task.parser(this);
        });
      }
      handleTaskData(task, args, result, logger) {
        const { exitCode, rejection, stdOut, stdErr } = result;
        return new Promise((done, fail) => {
          logger(`Preparing to handle process response exitCode=%d stdOut=`, exitCode);
          const { error } = this._plugins.exec(
            "task.error",
            { error: rejection },
            __spreadValues(__spreadValues({}, pluginContext(task, args)), result)
          );
          if (error && task.onError) {
            logger.info(`exitCode=%s handling with custom error handler`);
            return task.onError(
              result,
              error,
              (newStdOut) => {
                logger.info(`custom error handler treated as success`);
                logger(`custom error returned a %s`, objectToString(newStdOut));
                done(
                  new GitOutputStreams(
                    Array.isArray(newStdOut) ? Buffer.concat(newStdOut) : newStdOut,
                    Buffer.concat(stdErr)
                  )
                );
              },
              fail
            );
          }
          if (error) {
            logger.info(
              `handling as error: exitCode=%s stdErr=%s rejection=%o`,
              exitCode,
              stdErr.length,
              rejection
            );
            return fail(error);
          }
          logger.info(`retrieving task output complete`);
          done(new GitOutputStreams(Buffer.concat(stdOut), Buffer.concat(stdErr)));
        });
      }
      gitResponse(task, command, args, outputHandler, logger) {
        return __async(this, null, function* () {
          const outputLogger = logger.sibling("output");
          const spawnOptions = this._plugins.exec(
            "spawn.options",
            {
              cwd: this.cwd,
              env: this.env,
              windowsHide: true
            },
            pluginContext(task, task.commands)
          );
          return new Promise((done) => {
            const stdOut = [];
            const stdErr = [];
            logger.info(`%s %o`, command, args);
            logger("%O", spawnOptions);
            let rejection = this._beforeSpawn(task, args);
            if (rejection) {
              return done({
                stdOut,
                stdErr,
                exitCode: 9901,
                rejection
              });
            }
            this._plugins.exec("spawn.before", void 0, __spreadProps(__spreadValues({}, pluginContext(task, args)), {
              kill(reason) {
                rejection = reason || rejection;
              }
            }));
            const spawned = spawn(command, args, spawnOptions);
            spawned.stdout.on(
              "data",
              onDataReceived(stdOut, "stdOut", logger, outputLogger.step("stdOut"))
            );
            spawned.stderr.on(
              "data",
              onDataReceived(stdErr, "stdErr", logger, outputLogger.step("stdErr"))
            );
            spawned.on("error", onErrorReceived(stdErr, logger));
            if (outputHandler) {
              logger(`Passing child process stdOut/stdErr to custom outputHandler`);
              outputHandler(command, spawned.stdout, spawned.stderr, [...args]);
            }
            this._plugins.exec("spawn.after", void 0, __spreadProps(__spreadValues({}, pluginContext(task, args)), {
              spawned,
              close(exitCode, reason) {
                done({
                  stdOut,
                  stdErr,
                  exitCode,
                  rejection: rejection || reason
                });
              },
              kill(reason) {
                if (spawned.killed) {
                  return;
                }
                rejection = reason;
                spawned.kill("SIGINT");
              }
            }));
          });
        });
      }
      _beforeSpawn(task, args) {
        let rejection;
        this._plugins.exec("spawn.before", void 0, __spreadProps(__spreadValues({}, pluginContext(task, args)), {
          kill(reason) {
            rejection = reason || rejection;
          }
        }));
        return rejection;
      }
    };
  }
});

// src/lib/runners/git-executor.ts
var git_executor_exports = {};
__export(git_executor_exports, {
  GitExecutor: () => GitExecutor
});
var GitExecutor;
var init_git_executor = __esm({
  "src/lib/runners/git-executor.ts"() {
    "use strict";
    init_git_executor_chain();
    GitExecutor = class {
      constructor(cwd, _scheduler, _plugins) {
        this.cwd = cwd;
        this._scheduler = _scheduler;
        this._plugins = _plugins;
        this._chain = new GitExecutorChain(this, this._scheduler, this._plugins);
      }
      chain() {
        return new GitExecutorChain(this, this._scheduler, this._plugins);
      }
      push(task) {
        return this._chain.push(task);
      }
    };
  }
});

// src/lib/task-callback.ts
/**
 * Executes a callback function when a task completes or fails.
 *
 * @param {string} task - The identifier of the task being executed.
 * @param {Promise<any>} response - A promise that resolves with the result of the task or rejects with an error.
 * @param {Function} [callback=NOOP] - A callback function to be called when the task completes. It receives two parameters: an error (if any) and the data from the task.
 * @returns {void}
 *
 * @example
 * taskCallback('task1', someAsyncOperation(), (err, result) => {
 *   if (err) {
 *     console.error('Task failed:', err);
 *   } else {
 *     console.log('Task succeeded with result:', result);
 *   }
 * });
 */
function taskCallback(task, response, callback = NOOP) {
  /**
   * Callback function to handle successful data retrieval.
   *
   * @param {Object} data - The data retrieved successfully.
   */
  const onSuccess = (data) => {
    callback(null, data);
  };
  /**
   * Handles an error if it is related to a specific task.
   *
   * @param {Error} err - The error object that occurred.
   */
  const onError2 = (err) => {
    if ((err == null ? void 0 : err.task) === task) {
      callback(
        err instanceof GitResponseError ? addDeprecationNoticeToError(err) : err,
        void 0
      );
    }
  };
  response.then(onSuccess, onError2);
}
function addDeprecationNoticeToError(err) {
  let log = (name) => {
    console.warn(
      `simple-git deprecation notice: accessing GitResponseError.${name} should be GitResponseError.git.${name}, this will no longer be available in version 3`
    );
    log = NOOP;
  };
  return Object.create(err, Object.getOwnPropertyNames(err.git).reduce(descriptorReducer, {}));
  /**
   * Logs a deprecation notice for accessing GitResponseError properties directly.
   *
   * @param {string} name - The property name being accessed.
   */
  /**
   * Reduces an object to include descriptors for error properties.
   *
   * @param {Object} all - The accumulator object.
   * @param {string} name - The name of the property to process.
   * @returns {Object} - The updated accumulator object with a descriptor added for the specified property.
   */
  function descriptorReducer(all, name) {
    if (name in err) {
      return all;
    }
    all[name] = {
      enumerable: false,
      configurable: false,
      get() {
        log(name);
        return err.git[name];
      }
    };
    return all;
  }
}
var init_task_callback = __esm({
  "src/lib/task-callback.ts"() {
    "use strict";
    init_git_response_error();
    init_utils();
  }
});

// src/lib/tasks/change-working-directory.ts
/**
 * Changes the working directory for an instance of a task.
 *
 * @function changeWorkingDirectoryTask
 * @param {string} directory - The new working directory path.
 * @param {Object} [root] - Optional. The root object or instance to set the cwd property on.
 * @returns {Promise<void>} A promise that resolves when the working directory is changed successfully.
 * @throws {Error} Throws an error if the provided directory does not exist.
 *
 * @example
 * changeWorkingDirectoryTask('/path/to/new/directory').then(() => {
 *   console.log('Working directory changed');
 * }).catch((error) => {
 *   console.error(error.message);
 * });
 */
function changeWorkingDirectoryTask(directory, root) {
  return adhocExecTask((instance) => {
    if (!folderExists(directory)) {
      throw new Error(`Git.cwd: cannot change to non-directory "${directory}"`);
    }
    return (root || instance).cwd = directory;
  });
}
var init_change_working_directory = __esm({
  "src/lib/tasks/change-working-directory.ts"() {
    "use strict";
    init_utils();
    init_task();
  }
});

// src/lib/tasks/checkout.ts
/**
 * Executes a 'checkout' task with the provided arguments.
 *
 * @param {Array} args - An array of strings representing the arguments for the checkout command.
 * @return {Promise<void>} A promise that resolves when the task is completed successfully, or rejects if an error occurs.
 * @throws Will throw an error if the commands array does not contain a valid branch name or contains conflicting options.
 *
 * @example
 * // Checkout a specific branch
 * checkoutTask(["-b", "new-feature"]);
 *
 * // Checkout a specific commit
 * checkoutTask(["commit-hash"]);
 */
function checkoutTask(args) {
  const commands = ["checkout", ...args];
  if (commands[1] === "-b" && commands.includes("-B")) {
    commands[1] = remove(commands, "-B");
  }
  return straightThroughStringTask(commands);
}
/**
 * Creates an object with methods to handle different types of git checkouts.
 *
 * @returns {Object} An object containing methods for checking out default configurations, specific branches, and local branches.
 */
function checkout_default() {
  return {
    checkout() {
      return this._runTask(
        checkoutTask(getTrailingOptions(arguments, 1)),
        trailingFunctionArgument(arguments)
      );
    },
    checkoutBranch(branchName, startPoint) {
      return this._runTask(
        checkoutTask(["-b", branchName, startPoint, ...getTrailingOptions(arguments)]),
        trailingFunctionArgument(arguments)
      );
    },
    checkoutLocalBranch(branchName) {
      return this._runTask(
        checkoutTask(["-b", branchName, ...getTrailingOptions(arguments)]),
        trailingFunctionArgument(arguments)
      );
    }
  };
}
var init_checkout = __esm({
  "src/lib/tasks/checkout.ts"() {
    "use strict";
    init_utils();
    init_task();
  }
});

// src/lib/tasks/count-objects.ts
/**
 * Returns an object with various properties initialized to zero.
 *
 * @returns {Object} An object containing properties like 'count', 'garbage', etc., all set to zero.
 */
function countObjectsResponse() {
  return {
    count: 0,
    garbage: 0,
    inPack: 0,
    packs: 0,
    prunePackable: 0,
    size: 0,
    sizeGarbage: 0,
    sizePack: 0
  };
}
/**
 * Creates an object with a method to count objects using specific commands and options.
 * @returns {Object} An object containing the `countObjects` method.
 *
 * Example usage:
 * const counter = count_objects_default();
 * console.log(counter.countObjects()); // Outputs the result of counting objects
 */
function count_objects_default() {
  return {
    countObjects() {
      return this._runTask({
        commands: ["count-objects", "--verbose"],
        format: "utf-8",
        parser(stdOut) {
          return parseStringResponse(countObjectsResponse(), [parser2], stdOut);
        }
      });
    }
  };
}
var parser2;
var init_count_objects = __esm({
  "src/lib/tasks/count-objects.ts"() {
    "use strict";
    init_utils();
    parser2 = new LineParser(
      /([a-z-]+): (\d+)$/,
      (result, [key, value]) => {
        const property = asCamelCase(key);
        if (result.hasOwnProperty(property)) {
          result[property] = asNumber(value);
        }
      }
    );
  }
});

// src/lib/parsers/parse-commit.ts
/**
 * Parses the commit result from standard output.
 *
 * @param {string} stdOut - The standard output string to parse.
 * @returns {Object} An object containing parsed commit information.
 */
function parseCommitResult(stdOut) {
  const result = {
    author: null,
    branch: "",
    commit: "",
    root: false,
    summary: {
      changes: 0,
      insertions: 0,
      deletions: 0
    }
  };
  return parseStringResponse(result, parsers, stdOut);
}
var parsers;
var init_parse_commit = __esm({
  "src/lib/parsers/parse-commit.ts"() {
    "use strict";
    init_utils();
    parsers = [
      new LineParser(/^\[([^\s]+)( \([^)]+\))? ([^\]]+)/, (result, [branch, root, commit]) => {
        result.branch = branch;
        result.commit = commit;
        result.root = !!root;
      }),
      new LineParser(/\s*Author:\s(.+)/i, (result, [author]) => {
        const parts = author.split("<");
        const email = parts.pop();
        if (!email || !email.includes("@")) {
          return;
        }
        result.author = {
          email: email.substr(0, email.length - 1),
          name: parts.join("<").trim()
        };
      }),
      new LineParser(
        /(\d+)[^,]*(?:,\s*(\d+)[^,]*)(?:,\s*(\d+))/g,
        (result, [changes, insertions, deletions]) => {
          result.summary.changes = parseInt(changes, 10) || 0;
          result.summary.insertions = parseInt(insertions, 10) || 0;
          result.summary.deletions = parseInt(deletions, 10) || 0;
        }
      ),
      new LineParser(
        /^(\d+)[^,]*(?:,\s*(\d+)[^(]+\(([+-]))?/,
        (result, [changes, lines, direction]) => {
          result.summary.changes = parseInt(changes, 10) || 0;
          const count = parseInt(lines, 10) || 0;
          if (direction === "-") {
            result.summary.deletions = count;
          } else if (direction === "+") {
            result.summary.insertions = count;
          }
        }
      )
    ];
  }
});

// src/lib/tasks/commit.ts
/**
 * Commit a task with the specified message and files, using optional custom arguments.
 *
 * @param {string} message - The commit message.
 * @param {Array<string>} files - An array of file paths to include in the commit.
 * @param {Array<string>=} [customArgs=[]] - Optional custom arguments for the commit command.
 * @returns {Object} An object containing an array of commands, the expected output format, and a parser function.
 */
function commitTask(message, files, customArgs) {
  const commands = [
    "-c",
    "core.abbrev=40",
    "commit",
    ...prefixedArray(message, "-m"),
    ...files,
    ...customArgs
  ];
  return {
    commands,
    format: "utf-8",
    parser: parseCommitResult
  };
}
function commit_default() {
  return {
    commit(message, ...rest) {
      const next = trailingFunctionArgument(arguments);
      const task = rejectDeprecatedSignatures(message) || commitTask(
        asArray(message),
        asArray(filterType(rest[0], filterStringOrStringArray, [])),
        [...filterType(rest[1], filterArray, []), ...getTrailingOptions(arguments, 0, true)]
      );
      return this._runTask(task, next);
    }
  };
  /**
   * Rejects deprecated signatures by checking if the commit message is empty or null.
   *
   * @param {string|string[]} message - The commit message to be checked.
   * @return {boolean} - Returns true if the commit message is invalid, false otherwise.
   */
  function rejectDeprecatedSignatures(message) {
    return !filterStringOrStringArray(message) && configurationErrorTask(
      `git.commit: requires the commit message to be supplied as a string/string[]`
    );
  }
}
var init_commit = __esm({
  "src/lib/tasks/commit.ts"() {
    "use strict";
    init_parse_commit();
    init_utils();
    init_task();
  }
});

// src/lib/tasks/first-commit.ts
/**
 * Creates an object with a `firstCommit` method that retrieves the hash of the first commit in the repository.
 *
 * @returns {Object} An object containing the `firstCommit` method.
 */
function first_commit_default() {
  return {
    firstCommit() {
      return this._runTask(
        straightThroughStringTask(["rev-list", "--max-parents=0", "HEAD"], true),
        trailingFunctionArgument(arguments)
      );
    }
  };
}
var init_first_commit = __esm({
  "src/lib/tasks/first-commit.ts"() {
    "use strict";
    init_utils();
    init_task();
  }
});

// src/lib/tasks/hash-object.ts
/**
 * Executes a task to hash an object using Git's `hash-object` command.
 *
 * @param {string} filePath - The path to the file to be hashed.
 * @param {boolean} [write=false] - If true, adds the hashed object to the database.
 * @returns {Promise<string>} A promise that resolves with the hash of the object.
 * @throws {Error} Throws an error if the command execution fails.
 */
function hashObjectTask(filePath, write) {
  const commands = ["hash-object", filePath];
  if (write) {
    commands.push("-w");
  }
  return straightThroughStringTask(commands, true);
}
var init_hash_object = __esm({
  "src/lib/tasks/hash-object.ts"() {
    "use strict";
    init_task();
  }
});

// src/lib/responses/InitSummary.ts
/**
 * Parses initialization responses to extract summary information.
 *
 * @param {boolean} bare - Indicates if the response is in bare format.
 * @param {string} path - The file path associated with the response.
 * @param {string} text - The text content of the response to be parsed.
 * @returns {InitSummary} An instance of InitSummary containing parsed data.
 *
 * @example
 * const summary = parseInit(false, '/path/to/file', 'response text');
 */
function parseInit(bare, path, text) {
  const response = String(text).trim();
  let result;
  if (result = initResponseRegex.exec(response)) {
    return new InitSummary(bare, path, false, result[1]);
  }
  if (result = reInitResponseRegex.exec(response)) {
    return new InitSummary(bare, path, true, result[1]);
  }
  let gitDir = "";
  const tokens = response.split(" ");
  while (tokens.length) {
    const token = tokens.shift();
    if (token === "in") {
      gitDir = tokens.join(" ");
      break;
    }
  }
  return new InitSummary(bare, path, /^re/i.test(response), gitDir);
}
var InitSummary, initResponseRegex, reInitResponseRegex;
var init_InitSummary = __esm({
  "src/lib/responses/InitSummary.ts"() {
    "use strict";
    InitSummary = class {
      constructor(bare, path, existing, gitDir) {
        this.bare = bare;
        this.path = path;
        this.existing = existing;
        this.gitDir = gitDir;
      }
    };
    initResponseRegex = /^Init.+ repository in (.+)$/;
    reInitResponseRegex = /^Rein.+ in (.+)$/;
  }
});

// src/lib/tasks/init.ts
/**
 * Checks if the provided command contains the bare command keyword.
 *
 * @param {string} command - The command to check for the bare command keyword.
 * @returns {boolean} - Returns true if the command includes the bare command, false otherwise.
 */
function hasBareCommand(command) {
  return command.includes(bareCommand);
}
/**
 * Initializes a task with optional parameters and custom arguments.
 *
 * @param {boolean} [bare=false] - Whether to use the bare command.
 * @param {string} path - The path for initialization.
 * @param {Array<string>} [customArgs=[]] - Additional custom arguments for the command.
 * @returns {Object} An object containing commands, format, and a parser function.
 *
 * @example
 * const task = initTask(true, "/path/to/project", ["--option"]);
 * console.log(task.commands); // Output: ['init', '--bare', '--option']
 * console.log(task.format); // Output: 'utf-8'
 * console.log(task.parser("some text")); // Output: parsed result of parseInit function
 */
function initTask(bare = false, path, customArgs) {
  const commands = ["init", ...customArgs];
  if (bare && !hasBareCommand(commands)) {
    commands.splice(1, 0, bareCommand);
  }
  return {
    commands,
    format: "utf-8",
    parser(text) {
      return parseInit(commands.includes("--bare"), path, text);
    }
  };
}
var bareCommand;
var init_init = __esm({
  "src/lib/tasks/init.ts"() {
    "use strict";
    init_InitSummary();
    bareCommand = "--bare";
  }
});

// src/lib/args/log-format.ts
/**
 * Extracts the log format from a command string based on regex pattern.
 *
 * @param {string[]} customArgs - An array of strings representing command arguments.
 * @return {string} The extracted log format, or an empty string if no match is found.
 * @throws {Error} If an unexpected error occurs during extraction.
 *
 * Example:
 * logFormatFromCommand(["--log=verbose", "--info=false"]) returns "--log=verbose"
 */
function logFormatFromCommand(customArgs) {
  for (let i = 0; i < customArgs.length; i++) {
    const format = logFormatRegex.exec(customArgs[i]);
    if (format) {
      return `--${format[1]}`;
    }
  }
  return "" /* NONE */;
}
function isLogFormat(customArg) {
  return logFormatRegex.test(customArg);
}
var logFormatRegex;
var init_log_format = __esm({
  "src/lib/args/log-format.ts"() {
    "use strict";
    logFormatRegex = /^--(stat|numstat|name-only|name-status)(=|$)/;
  }
});

// src/lib/responses/DiffSummary.ts
var DiffSummary;
var init_DiffSummary = __esm({
  "src/lib/responses/DiffSummary.ts"() {
    "use strict";
    DiffSummary = class {
      constructor() {
        this.changed = 0;
        this.deletions = 0;
        this.insertions = 0;
        this.files = [];
      }
    };
  }
});

// src/lib/parsers/parse-diff-summary.ts
/**
 * Retrieves a parser function based on the specified format.
 *
 * @param {string} [format=NONE] - The format of the diff summary. Defaults to NONE if not provided.
 * @returns {Function} A function that takes `stdOut` as input and returns a parsed DiffSummary object.
 * @throws {Error} Throws an error if the specified format is not supported.
 *
 * Example:
 *   const parser = getDiffParser("json");
 *   const result = parser(diffOutput);
 */
function getDiffParser(format = "" /* NONE */) {
  const parser4 = diffSummaryParsers[format];
  return (stdOut) => parseStringResponse(new DiffSummary(), parser4, stdOut, false);
}
var statParser, numStatParser, nameOnlyParser, nameStatusParser, diffSummaryParsers;
var init_parse_diff_summary = __esm({
  "src/lib/parsers/parse-diff-summary.ts"() {
    "use strict";
    init_log_format();
    init_DiffSummary();
    init_diff_name_status();
    init_utils();
    statParser = [
      new LineParser(
        /^(.+)\s+\|\s+(\d+)(\s+[+\-]+)?$/,
        (result, [file, changes, alterations = ""]) => {
          result.files.push({
            file: file.trim(),
            changes: asNumber(changes),
            insertions: alterations.replace(/[^+]/g, "").length,
            deletions: alterations.replace(/[^-]/g, "").length,
            binary: false
          });
        }
      ),
      new LineParser(
        /^(.+) \|\s+Bin ([0-9.]+) -> ([0-9.]+) ([a-z]+)/,
        (result, [file, before, after]) => {
          result.files.push({
            file: file.trim(),
            before: asNumber(before),
            after: asNumber(after),
            binary: true
          });
        }
      ),
      new LineParser(
        /(\d+) files? changed\s*((?:, \d+ [^,]+){0,2})/,
        (result, [changed, summary]) => {
          const inserted = /(\d+) i/.exec(summary);
          const deleted = /(\d+) d/.exec(summary);
          result.changed = asNumber(changed);
          result.insertions = asNumber(inserted == null ? void 0 : inserted[1]);
          result.deletions = asNumber(deleted == null ? void 0 : deleted[1]);
        }
      )
    ];
    numStatParser = [
      new LineParser(
        /(\d+)\t(\d+)\t(.+)$/,
        (result, [changesInsert, changesDelete, file]) => {
          const insertions = asNumber(changesInsert);
          const deletions = asNumber(changesDelete);
          result.changed++;
          result.insertions += insertions;
          result.deletions += deletions;
          result.files.push({
            file,
            changes: insertions + deletions,
            insertions,
            deletions,
            binary: false
          });
        }
      ),
      new LineParser(/-\t-\t(.+)$/, (result, [file]) => {
        result.changed++;
        result.files.push({
          file,
          after: 0,
          before: 0,
          binary: true
        });
      })
    ];
    nameOnlyParser = [
      new LineParser(/(.+)$/, (result, [file]) => {
        result.changed++;
        result.files.push({
          file,
          changes: 0,
          insertions: 0,
          deletions: 0,
          binary: false
        });
      })
    ];
    nameStatusParser = [
      new LineParser(
        /([ACDMRTUXB])([0-9]{0,3})\t(.[^\t]*)(\t(.[^\t]*))?$/,
        (result, [status, similarity, from, _to, to]) => {
          result.changed++;
          result.files.push({
            file: to != null ? to : from,
            changes: 0,
            insertions: 0,
            deletions: 0,
            binary: false,
            status: orVoid(isDiffNameStatus(status) && status),
            from: orVoid(!!to && from !== to && from),
            similarity: asNumber(similarity)
          });
        }
      )
    ];
    diffSummaryParsers = {
      ["" /* NONE */]: statParser,
      ["--stat" /* STAT */]: statParser,
      ["--numstat" /* NUM_STAT */]: numStatParser,
      ["--name-status" /* NAME_STATUS */]: nameStatusParser,
      ["--name-only" /* NAME_ONLY */]: nameOnlyParser
    };
  }
});

// src/lib/parsers/parse-list-log-summary.ts
function lineBuilder(tokens, fields) {
  return fields.reduce(
    (line, field, index) => {
      line[field] = tokens[index] || "";
      return line;
    },
    /* @__PURE__ */ Object.create({ diff: null })
  );
}
/**
 * Creates a parser function for summarizing log entries into list logs.
 *
 * @param {string} [splitter=SPLITTER] - The delimiter used to split the log lines.
 * @param {Array<string>} [fields=defaultFieldNames] - The fields to include in the list log entries.
 * @param {string} [logFormat=""] - The format of the log, determines how diffs are parsed. Use "NONE" for no diffs.
 * @returns {Function} A parser function that takes a standard output string and returns an object with summarized logs.
 *
 * @example
 * const parseLogs = createListLogSummaryParser();
 * const result = parseLogs("line1\nline2");
 * console.log(result.all);
 */
function createListLogSummaryParser(splitter = SPLITTER, fields = defaultFieldNames, logFormat = "" /* NONE */) {
  const parseDiffResult = getDiffParser(logFormat);
  return function(stdOut) {
    const all = toLinesWithContent(
      stdOut.trim(),
      false,
      START_BOUNDARY
    ).map(function(item) {
      const lineDetail = item.split(COMMIT_BOUNDARY);
      const listLogLine = lineBuilder(lineDetail[0].split(splitter), fields);
      if (lineDetail.length > 1 && !!lineDetail[1].trim()) {
        listLogLine.diff = parseDiffResult(lineDetail[1]);
      }
      return listLogLine;
    });
    return {
      all,
      latest: all.length && all[0] || null,
      total: all.length
    };
  };
}
var START_BOUNDARY, COMMIT_BOUNDARY, SPLITTER, defaultFieldNames;
var init_parse_list_log_summary = __esm({
  "src/lib/parsers/parse-list-log-summary.ts"() {
    "use strict";
    init_utils();
    init_parse_diff_summary();
    init_log_format();
    START_BOUNDARY = "\xF2\xF2\xF2\xF2\xF2\xF2 ";
    COMMIT_BOUNDARY = " \xF2\xF2";
    SPLITTER = " \xF2 ";
    defaultFieldNames = ["hash", "date", "message", "refs", "author_name", "author_email"];
  }
});

// src/lib/tasks/diff.ts
var diff_exports = {};
__export(diff_exports, {
  diffSummaryTask: () => diffSummaryTask,
  validateLogFormatConfig: () => validateLogFormatConfig
});
/**
 * Generates a summary task configuration based on custom arguments.
 *
 * @param {Array} customArgs - An array of custom arguments to be passed to the command.
 * @returns {Object} A configuration object for the summary task.
 * @throws {Error} Throws an error if the log format is invalid.
 */
function diffSummaryTask(customArgs) {
  let logFormat = logFormatFromCommand(customArgs);
  const commands = ["diff"];
  if (logFormat === "" /* NONE */) {
    logFormat = "--stat" /* STAT */;
    commands.push("--stat=4096");
  }
  commands.push(...customArgs);
  return validateLogFormatConfig(commands) || {
    commands,
    format: "utf-8",
    parser: getDiffParser(logFormat)
  };
}
/**
 * Validates the log format configuration by checking for mutually exclusive flags and incompatible options.
 *
 * @param {Array} customArgs - An array of command-line arguments related to log format configurations.
 * @return {Function|undefined} - Returns a function that handles the configuration error if conditions are not met, otherwise returns undefined.
 * @throws {Error} - Throws an error if the configuration is invalid and no valid handler can be returned.
 *
 * Example:
 *   const result = validateLogFormatConfig(["-a", "-b"]);
 *   if (result) {
 *     // Handle the error
 *   }
 */
function validateLogFormatConfig(customArgs) {
  const flags = customArgs.filter(isLogFormat);
  if (flags.length > 1) {
    return configurationErrorTask(
      `Summary flags are mutually exclusive - pick one of ${flags.join(",")}`
    );
  }
  if (flags.length && customArgs.includes("-z")) {
    return configurationErrorTask(
      `Summary flag ${flags} parsing is not compatible with null termination option '-z'`
    );
  }
}
var init_diff = __esm({
  "src/lib/tasks/diff.ts"() {
    "use strict";
    init_log_format();
    init_parse_diff_summary();
    init_task();
  }
});

// src/lib/tasks/log.ts
/**
 * Formats an object's keys and values into two arrays based on a specified splitter.
 *
 * @param {Object} format - The object to format.
 * @param {string} splitter - The string used to join the formatted values.
 * @returns {[Array, string]} A tuple containing two arrays. The first array contains the object's keys,
 *                               and the second array contains the object's values joined by the specified splitter.
 *
 * @example
 * // Returns [['name', 'age'], 'John,30']
 * prettyFormat({ name: 'John', age: 30 }, ',');
 */
function prettyFormat(format, splitter) {
  const fields = [];
  const formatStr = [];
  Object.keys(format).forEach((field) => {
    fields.push(field);
    formatStr.push(String(format[field]));
  });
  return [fields, formatStr.join(splitter)];
}
/**
 * Filters out specified options from an input object.
 *
 * @param {Object} input - The input object containing various options.
 * @returns {Object} A new object with all properties except those in `excludeOptions`.
 */
function userOptions(input) {
  return Object.keys(input).reduce((out, key) => {
    if (!(key in excludeOptions)) {
      out[key] = input[key];
    }
    return out;
  }, {});
}
function parseLogOptions(opt = {}, customArgs = []) {
  const splitter = filterType(opt.splitter, filterString, SPLITTER);
  const format = !filterPrimitives(opt.format) && opt.format ? opt.format : {
    hash: "%H",
    date: opt.strictDate === false ? "%ai" : "%aI",
    message: "%s",
    refs: "%D",
    body: opt.multiLine ? "%B" : "%b",
    author_name: opt.mailMap !== false ? "%aN" : "%an",
    author_email: opt.mailMap !== false ? "%aE" : "%ae"
  };
  const [fields, formatStr] = prettyFormat(format, splitter);
  const suffix = [];
  const command = [
    `--pretty=format:${START_BOUNDARY}${formatStr}${COMMIT_BOUNDARY}`,
    ...customArgs
  ];
  const maxCount = opt.n || opt["max-count"] || opt.maxCount;
  if (maxCount) {
    command.push(`--max-count=${maxCount}`);
  }
  if (opt.from || opt.to) {
    const rangeOperator = opt.symmetric !== false ? "..." : "..";
    suffix.push(`${opt.from || ""}${rangeOperator}${opt.to || ""}`);
  }
  if (filterString(opt.file)) {
    command.push("--follow", pathspec(opt.file));
  }
  appendTaskOptions(userOptions(opt), command);
  return {
    fields,
    splitter,
    commands: [...command, ...suffix]
  };
}
/**
 * Generates a task configuration for logging with specific fields and custom arguments.
 *
 * @param {string} splitter - The delimiter used to split the log entries.
 * @param {Array<string>} fields - An array of field names to include in the log summary.
 * @param {Array<string>} customArgs - Additional command-line arguments for customization.
 * @returns {Object} A configuration object for the logging task.
 *   - commands: Array of strings representing the command and its custom arguments.
 *   - format: String specifying the encoding format (default is "utf-8").
 *   - parser: The log summary parser created based on the provided splitter, fields, and log format.
 *
 * @throws {Error} If an error occurs while creating the log format from the custom arguments.
 *
 * @example
 * const taskConfig = logTask(',', ['timestamp', 'level'], ['-v']);
 * console.log(taskConfig);
 * // Output:
 * // {
 * //   commands: ["log", "-v"],
 * //   format: "utf-8",
 * //   parser: <LogSummaryParser instance>
 * // }
 */
function logTask(splitter, fields, customArgs) {
  const parser4 = createListLogSummaryParser(splitter, fields, logFormatFromCommand(customArgs));
  return {
    commands: ["log", ...customArgs],
    format: "utf-8",
    parser: parser4
  };
}
function log_default() {
  return {
    log(...rest) {
      const next = trailingFunctionArgument(arguments);
      const options = parseLogOptions(
        trailingOptionsArgument(arguments),
        filterType(arguments[0], filterArray)
      );
      const task = rejectDeprecatedSignatures(...rest) || validateLogFormatConfig(options.commands) || createLogTask(options);
      return this._runTask(task, next);
    }
  };
  /**
   * Creates a log task using the provided options.
   *
   * @param {Object} options - The configuration options for creating the log task.
   * @param {string} options.splitter - The delimiter used to split log entries.
   * @param {Array<string>} options.fields - An array of fields to extract from each log entry.
   * @param {Array<string>} [options.commands=[]] - Optional commands to execute with the log data.
   *
   * @returns {Function} A function representing the created log task.
   *
   * @example
   * const logTask = createLogTask({
   *   splitter: ',',
   *   fields: ['timestamp', 'message'],
   *   commands: ['echo']
   * });
   */
  function createLogTask(options) {
    return logTask(options.splitter, options.fields, options.commands);
  }
  /**
   * Rejects deprecated signatures of the `git.log` method.
   *
   * @param {string} from - The start date or commit for the log. Deprecated.
   * @param {string} to - The end date or commit for the log. Deprecated.
   * @returns {Error} - A configuration error if deprecated signatures are used.
   * @throws {Error} - Throws an error if both `from` and `to` parameters are provided.
   *
   * @example
   * try {
   *   rejectDeprecatedSignatures('2023-01-01', '2023-02-01');
   * } catch (error) {
   *   console.error(error.message);
   * }
   */
  function rejectDeprecatedSignatures(from, to) {
    return filterString(from) && filterString(to) && configurationErrorTask(
      `git.log(string, string) should be replaced with git.log({ from: string, to: string })`
    );
  }
}
var excludeOptions;
var init_log = __esm({
  "src/lib/tasks/log.ts"() {
    "use strict";
    init_log_format();
    init_pathspec();
    init_parse_list_log_summary();
    init_utils();
    init_task();
    init_diff();
    excludeOptions = /* @__PURE__ */ ((excludeOptions2) => {
      excludeOptions2[excludeOptions2["--pretty"] = 0] = "--pretty";
      excludeOptions2[excludeOptions2["max-count"] = 1] = "max-count";
      excludeOptions2[excludeOptions2["maxCount"] = 2] = "maxCount";
      excludeOptions2[excludeOptions2["n"] = 3] = "n";
      excludeOptions2[excludeOptions2["file"] = 4] = "file";
      excludeOptions2[excludeOptions2["format"] = 5] = "format";
      excludeOptions2[excludeOptions2["from"] = 6] = "from";
      excludeOptions2[excludeOptions2["to"] = 7] = "to";
      excludeOptions2[excludeOptions2["splitter"] = 8] = "splitter";
      excludeOptions2[excludeOptions2["symmetric"] = 9] = "symmetric";
      excludeOptions2[excludeOptions2["mailMap"] = 10] = "mailMap";
      excludeOptions2[excludeOptions2["multiLine"] = 11] = "multiLine";
      excludeOptions2[excludeOptions2["strictDate"] = 12] = "strictDate";
      return excludeOptions2;
    })(excludeOptions || {});
  }
});

// src/lib/responses/MergeSummary.ts
var MergeSummaryConflict, MergeSummaryDetail;
var init_MergeSummary = __esm({
  "src/lib/responses/MergeSummary.ts"() {
    "use strict";
    MergeSummaryConflict = class {
      constructor(reason, file = null, meta) {
        this.reason = reason;
        this.file = file;
        this.meta = meta;
      }
      toString() {
        return `${this.file}:${this.reason}`;
      }
    };
    MergeSummaryDetail = class {
      constructor() {
        this.conflicts = [];
        this.merges = [];
        this.result = "success";
      }
      get failed() {
        return this.conflicts.length > 0;
      }
      get reason() {
        return this.result;
      }
      toString() {
        if (this.conflicts.length) {
          return `CONFLICTS: ${this.conflicts.join(", ")}`;
        }
        return "OK";
      }
    };
  }
});

// src/lib/responses/PullSummary.ts
var PullSummary, PullFailedSummary;
var init_PullSummary = __esm({
  "src/lib/responses/PullSummary.ts"() {
    "use strict";
    PullSummary = class {
      constructor() {
        this.remoteMessages = {
          all: []
        };
        this.created = [];
        this.deleted = [];
        this.files = [];
        this.deletions = {};
        this.insertions = {};
        this.summary = {
          changes: 0,
          deletions: 0,
          insertions: 0
        };
      }
    };
    PullFailedSummary = class {
      constructor() {
        this.remote = "";
        this.hash = {
          local: "",
          remote: ""
        };
        this.branch = {
          local: "",
          remote: ""
        };
        this.message = "";
      }
      toString() {
        return this.message;
      }
    };
  }
});

// src/lib/parsers/parse-remote-objects.ts
/**
 * Initializes or returns the objects property of the remoteMessages object,
 * ensuring it is an object with specific properties.
 *
 * @param {Object} remoteMessages - The object containing messages and their properties.
 * @returns {Object} The initialized or existing objects property of remoteMessages.
 *
 * Example:
 * var messages = {};
 * var result = objectEnumerationResult(messages);
 * console.log(result); // { compressing: 0, counting: 0, enumerating: 0, packReused: 0, reused: { count: 0, delta: 0 }, total: { count: 0, delta: 0 } }
 */
function objectEnumerationResult(remoteMessages) {
  return remoteMessages.objects = remoteMessages.objects || {
    compressing: 0,
    counting: 0,
    enumerating: 0,
    packReused: 0,
    reused: { count: 0, delta: 0 },
    total: { count: 0, delta: 0 }
  };
}
function asObjectCount(source) {
  const count = /^\s*(\d+)/.exec(source);
  const delta = /delta (\d+)/i.exec(source);
  return {
    count: asNumber(count && count[1] || "0"),
    delta: asNumber(delta && delta[1] || "0")
  };
}
var remoteMessagesObjectParsers;
var init_parse_remote_objects = __esm({
  "src/lib/parsers/parse-remote-objects.ts"() {
    "use strict";
    init_utils();
    remoteMessagesObjectParsers = [
      new RemoteLineParser(
        /^remote:\s*(enumerating|counting|compressing) objects: (\d+),/i,
        (result, [action, count]) => {
          const key = action.toLowerCase();
          const enumeration = objectEnumerationResult(result.remoteMessages);
          Object.assign(enumeration, { [key]: asNumber(count) });
        }
      ),
      new RemoteLineParser(
        /^remote:\s*(enumerating|counting|compressing) objects: \d+% \(\d+\/(\d+)\),/i,
        (result, [action, count]) => {
          const key = action.toLowerCase();
          const enumeration = objectEnumerationResult(result.remoteMessages);
          Object.assign(enumeration, { [key]: asNumber(count) });
        }
      ),
      new RemoteLineParser(
        /total ([^,]+), reused ([^,]+), pack-reused (\d+)/i,
        (result, [total, reused, packReused]) => {
          const objects = objectEnumerationResult(result.remoteMessages);
          objects.total = asObjectCount(total);
          objects.reused = asObjectCount(reused);
          objects.packReused = asNumber(packReused);
        }
      )
    ];
  }
});

// src/lib/parsers/parse-remote-messages.ts
/**
 * Parses remote messages from a standard output stream and error stream.
 *
 * @param {string} _stdOut - The standard output stream containing the remote messages.
 * @param {string} stdErr - The standard error stream, which may contain additional information or errors.
 * @returns {RemoteMessageSummary} A summary object containing parsed remote messages.
 * @throws {Error} If there is an issue parsing the remote messages.
 *
 * Example:
 * const result = parseRemoteMessages("message1\nmessage2", "error message");
 * console.log(result);
 */
function parseRemoteMessages(_stdOut, stdErr) {
  return parseStringResponse({ remoteMessages: new RemoteMessageSummary() }, parsers2, stdErr);
}
var parsers2, RemoteMessageSummary;
var init_parse_remote_messages = __esm({
  "src/lib/parsers/parse-remote-messages.ts"() {
    "use strict";
    init_utils();
    init_parse_remote_objects();
    parsers2 = [
      new RemoteLineParser(/^remote:\s*(.+)$/, (result, [text]) => {
        result.remoteMessages.all.push(text.trim());
        return false;
      }),
      ...remoteMessagesObjectParsers,
      new RemoteLineParser(
        [/create a (?:pull|merge) request/i, /\s(https?:\/\/\S+)$/],
        (result, [pullRequestUrl]) => {
          result.remoteMessages.pullRequestUrl = pullRequestUrl;
        }
      ),
      new RemoteLineParser(
        [/found (\d+) vulnerabilities.+\(([^)]+)\)/i, /\s(https?:\/\/\S+)$/],
        (result, [count, summary, url]) => {
          result.remoteMessages.vulnerabilities = {
            count: asNumber(count),
            summary,
            url
          };
        }
      )
    ];
    RemoteMessageSummary = class {
      constructor() {
        this.all = [];
      }
    };
  }
});

// src/lib/parsers/parse-pull.ts
/**
 * Parses pull error results from standard output and standard error.
 *
 * @param {string} stdOut - The standard output string to be parsed.
 * @param {string} stdErr - The standard error string to be parsed.
 * @returns {(PullFailedSummary | null)} - Returns an instance of PullFailedSummary if a pull error is found, otherwise returns null.
 *
 * @example
 * const result = parsePullErrorResult("Error: Failed to pull changes", "Check network connection");
 * console.log(result); // Output: PullFailedSummary object with message and details
 */
function parsePullErrorResult(stdOut, stdErr) {
  const pullError = parseStringResponse(new PullFailedSummary(), errorParsers, [stdOut, stdErr]);
  return pullError.message && pullError;
}
var FILE_UPDATE_REGEX, SUMMARY_REGEX, ACTION_REGEX, parsers3, errorParsers, parsePullDetail, parsePullResult;
var init_parse_pull = __esm({
  "src/lib/parsers/parse-pull.ts"() {
    "use strict";
    init_PullSummary();
    init_utils();
    init_parse_remote_messages();
    FILE_UPDATE_REGEX = /^\s*(.+?)\s+\|\s+\d+\s*(\+*)(-*)/;
    SUMMARY_REGEX = /(\d+)\D+((\d+)\D+\(\+\))?(\D+(\d+)\D+\(-\))?/;
    ACTION_REGEX = /^(create|delete) mode \d+ (.+)/;
    parsers3 = [
      new LineParser(FILE_UPDATE_REGEX, (result, [file, insertions, deletions]) => {
        result.files.push(file);
        if (insertions) {
          result.insertions[file] = insertions.length;
        }
        if (deletions) {
          result.deletions[file] = deletions.length;
        }
      }),
      new LineParser(SUMMARY_REGEX, (result, [changes, , insertions, , deletions]) => {
        if (insertions !== void 0 || deletions !== void 0) {
          result.summary.changes = +changes || 0;
          result.summary.insertions = +insertions || 0;
          result.summary.deletions = +deletions || 0;
          return true;
        }
        return false;
      }),
      new LineParser(ACTION_REGEX, (result, [action, file]) => {
        append(result.files, file);
        append(action === "create" ? result.created : result.deleted, file);
      })
    ];
    errorParsers = [
      new LineParser(/^from\s(.+)$/i, (result, [remote]) => void (result.remote = remote)),
      new LineParser(/^fatal:\s(.+)$/, (result, [message]) => void (result.message = message)),
      new LineParser(
        /([a-z0-9]+)\.\.([a-z0-9]+)\s+(\S+)\s+->\s+(\S+)$/,
        (result, [hashLocal, hashRemote, branchLocal, branchRemote]) => {
          result.branch.local = branchLocal;
          result.hash.local = hashLocal;
          result.branch.remote = branchRemote;
          result.hash.remote = hashRemote;
        }
      )
    ];
    parsePullDetail = (stdOut, stdErr) => {
      return parseStringResponse(new PullSummary(), parsers3, [stdOut, stdErr]);
    };
    parsePullResult = (stdOut, stdErr) => {
      return Object.assign(
        new PullSummary(),
        parsePullDetail(stdOut, stdErr),
        parseRemoteMessages(stdOut, stdErr)
      );
    };
  }
});

// src/lib/parsers/parse-merge.ts
var parsers4, parseMergeResult, parseMergeDetail;
var init_parse_merge = __esm({
  "src/lib/parsers/parse-merge.ts"() {
    "use strict";
    init_MergeSummary();
    init_utils();
    init_parse_pull();
    parsers4 = [
      new LineParser(/^Auto-merging\s+(.+)$/, (summary, [autoMerge]) => {
        summary.merges.push(autoMerge);
      }),
      new LineParser(/^CONFLICT\s+\((.+)\): Merge conflict in (.+)$/, (summary, [reason, file]) => {
        summary.conflicts.push(new MergeSummaryConflict(reason, file));
      }),
      new LineParser(
        /^CONFLICT\s+\((.+\/delete)\): (.+) deleted in (.+) and/,
        (summary, [reason, file, deleteRef]) => {
          summary.conflicts.push(new MergeSummaryConflict(reason, file, { deleteRef }));
        }
      ),
      new LineParser(/^CONFLICT\s+\((.+)\):/, (summary, [reason]) => {
        summary.conflicts.push(new MergeSummaryConflict(reason, null));
      }),
      new LineParser(/^Automatic merge failed;\s+(.+)$/, (summary, [result]) => {
        summary.result = result;
      })
    ];
    parseMergeResult = (stdOut, stdErr) => {
      return Object.assign(parseMergeDetail(stdOut, stdErr), parsePullResult(stdOut, stdErr));
    };
    parseMergeDetail = (stdOut) => {
      return parseStringResponse(new MergeSummaryDetail(), parsers4, stdOut);
    };
  }
});

// src/lib/tasks/merge.ts
/**
 * Creates a task to execute a Git merge command with custom arguments.
 *
 * @param {string[]} customArgs - The array of custom arguments for the merge command. Must not be empty.
 * @returns {Object} A configuration object for the merge task.
 * @throws {Error} If no custom arguments are provided, throws a GitResponseError with a configuration error message.
 */
function mergeTask(customArgs) {
  if (!customArgs.length) {
    return configurationErrorTask("Git.merge requires at least one option");
  }
  return {
    commands: ["merge", ...customArgs],
    format: "utf-8",
    parser(stdOut, stdErr) {
      const merge = parseMergeResult(stdOut, stdErr);
      if (merge.failed) {
        throw new GitResponseError(merge);
      }
      return merge;
    }
  };
}
var init_merge = __esm({
  "src/lib/tasks/merge.ts"() {
    "use strict";
    init_git_response_error();
    init_parse_merge();
    init_task();
  }
});

// src/lib/parsers/parse-push.ts
/**
 * Generates an object representing the status of a pushed item in a version control system.
 *
 * @param {string} local - The local reference (branch or tag) of the pushed item.
 * @param {string} remote - The remote reference (branch or tag) of the pushed item.
 * @param {string} status - The status string indicating various properties about the push, such as whether it is deleted, a tag, new, etc.
 * @returns {Object} An object containing boolean properties indicating the state of the pushed item:
 *   - deleted: True if the push indicates the item was deleted, false otherwise.
 *   - tag: True if the push refers to a tag, false otherwise.
 *   - branch: True if the push refers to a branch, false if it is a tag.
 *   - new: True if the push indicates the item is new, false if it was already updated.
 *   - alreadyUpdated: True if the push does not indicate the item is new, false otherwise.
 *   - local: The local reference of the pushed item.
 *   - remote: The remote reference of the pushed item.
 *
 * @example
 * const status = "tag deleted";
 * const result = pushResultPushedItem("feature-branch", "origin/feature-branch", status);
 * console.log(result); // { deleted: true, tag: true, branch: false, new: false, alreadyUpdated: true, local: 'feature-branch', remote: 'origin/feature-branch' }
 */
function pushResultPushedItem(local, remote, status) {
  const deleted = status.includes("deleted");
  const tag = status.includes("tag") || /^refs\/tags/.test(local);
  const alreadyUpdated = !status.includes("new");
  return {
    deleted,
    tag,
    branch: !tag,
    new: !alreadyUpdated,
    alreadyUpdated,
    local,
    remote
  };
}
var parsers5, parsePushResult, parsePushDetail;
var init_parse_push = __esm({
  "src/lib/parsers/parse-push.ts"() {
    "use strict";
    init_utils();
    init_parse_remote_messages();
    parsers5 = [
      new LineParser(/^Pushing to (.+)$/, (result, [repo]) => {
        result.repo = repo;
      }),
      new LineParser(/^updating local tracking ref '(.+)'/, (result, [local]) => {
        result.ref = __spreadProps(__spreadValues({}, result.ref || {}), {
          local
        });
      }),
      new LineParser(/^[=*-]\s+([^:]+):(\S+)\s+\[(.+)]$/, (result, [local, remote, type]) => {
        result.pushed.push(pushResultPushedItem(local, remote, type));
      }),
      new LineParser(
        /^Branch '([^']+)' set up to track remote branch '([^']+)' from '([^']+)'/,
        (result, [local, remote, remoteName]) => {
          result.branch = __spreadProps(__spreadValues({}, result.branch || {}), {
            local,
            remote,
            remoteName
          });
        }
      ),
      new LineParser(
        /^([^:]+):(\S+)\s+([a-z0-9]+)\.\.([a-z0-9]+)$/,
        (result, [local, remote, from, to]) => {
          result.update = {
            head: {
              local,
              remote
            },
            hash: {
              from,
              to
            }
          };
        }
      )
    ];
    parsePushResult = (stdOut, stdErr) => {
      const pushDetail = parsePushDetail(stdOut, stdErr);
      const responseDetail = parseRemoteMessages(stdOut, stdErr);
      return __spreadValues(__spreadValues({}, pushDetail), responseDetail);
    };
    parsePushDetail = (stdOut, stdErr) => {
      return parseStringResponse({ pushed: [] }, parsers5, [stdOut, stdErr]);
    };
  }
});

// src/lib/tasks/push.ts
var push_exports = {};
__export(push_exports, {
  pushTagsTask: () => pushTagsTask,
  pushTask: () => pushTask
});
/**
 * Appends "--tags" to customArgs and returns the result of calling pushTask with ref and customArgs.
 *
 * @param {Object} [ref={}] - The reference object passed to pushTask. Default is an empty object.
 * @param {Array|string} customArgs - Custom arguments to be modified before passing to pushTask.
 * @returns {*} The result of the call to pushTask with ref and modified customArgs.
 *
 * @example
 * // Example usage:
 * const result = pushTagsTask({}, ["arg1", "arg2"]);
 * console.log(result); // Output depends on the implementation of pushTask
 */
function pushTagsTask(ref = {}, customArgs) {
  append(customArgs, "--tags");
  return pushTask(ref, customArgs);
}
/**
 * Creates a task configuration to push changes to a remote repository.
 *
 * @param {Object} ref - Optional reference object containing branch and/or remote information.
 * @param {Array|string} customArgs - Additional arguments to be passed to the command.
 * @return {{commands: Array, format: string, parser: function}} Configuration object for executing a push task.
 *
 * @example
 * const config = pushTask({ branch: "main", remote: "origin" }, ["-u"]);
 * console.log(config);
 */
function pushTask(ref = {}, customArgs) {
  const commands = ["push", ...customArgs];
  if (ref.branch) {
    commands.splice(1, 0, ref.branch);
  }
  if (ref.remote) {
    commands.splice(1, 0, ref.remote);
  }
  remove(commands, "-v");
  append(commands, "--verbose");
  append(commands, "--porcelain");
  return {
    commands,
    format: "utf-8",
    parser: parsePushResult
  };
}
var init_push = __esm({
  "src/lib/tasks/push.ts"() {
    "use strict";
    init_parse_push();
    init_utils();
  }
});

// src/lib/tasks/show.ts
/**
 * Returns an object with methods to display information.
 *
 * @returns {Object} An object containing two methods: `showBuffer` and `show`.
 */
function show_default() {
  return {
    showBuffer() {
      const commands = ["show", ...getTrailingOptions(arguments, 1)];
      if (!commands.includes("--binary")) {
        commands.splice(1, 0, "--binary");
      }
      return this._runTask(
        straightThroughBufferTask(commands),
        trailingFunctionArgument(arguments)
      );
    },
    show() {
      const commands = ["show", ...getTrailingOptions(arguments, 1)];
      return this._runTask(
        straightThroughStringTask(commands),
        trailingFunctionArgument(arguments)
      );
    }
  };
}
var init_show = __esm({
  "src/lib/tasks/show.ts"() {
    "use strict";
    init_utils();
    init_task();
  }
});

// src/lib/responses/FileStatusSummary.ts
var fromPathRegex, FileStatusSummary;
var init_FileStatusSummary = __esm({
  "src/lib/responses/FileStatusSummary.ts"() {
    "use strict";
    fromPathRegex = /^(.+)\0(.+)$/;
    FileStatusSummary = class {
      constructor(path, index, working_dir) {
        this.path = path;
        this.index = index;
        this.working_dir = working_dir;
        if (index === "R" || working_dir === "R") {
          const detail = fromPathRegex.exec(path) || [null, path, path];
          this.from = detail[2] || "";
          this.path = detail[1] || "";
        }
      }
    };
  }
});

// src/lib/responses/StatusSummary.ts
/**
 * Parses a line to extract 'from' and 'to' language codes.
 *
 * @param {string} line - The input string containing 'from' and 'to' language codes, separated by NULL (e.g., "en-US\0fr-FR").
 * @returns {{from: string, to: string}} An object containing the extracted 'from' and 'to' language codes.
 *
 * Example:
 * // Calling the function with a line
 * const result = renamedFile("en-US\0fr-FR");
 * console.log(result); // Output: { from: 'en-US', to: 'fr-FR' }
 */
function renamedFile(line) {
  const [to, from] = line.split(NULL);
  return {
    from: from || to,
    to
  };
}
/**
 * Parses input indices into a string and associates it with a handler function.
 *
 * @param {number} indexX - The x-coordinate index to be parsed.
 * @param {number} indexY - The y-coordinate index to be parsed.
 * @param {Function} handler - A function that processes the parsed string.
 * @returns {[string, Function]} An array containing the concatenated indices as a string and the provided handler function.
 *
 * @example
 * const result = parser3(10, 20, (str) => console.log(str));
 * console.log(result); // Output: ['1020', [Function]]
 */
function parser3(indexX, indexY, handler) {
  return [`${indexX}${indexY}`, handler];
}
function conflicts(indexX, ...indexY) {
  return indexY.map((y) => parser3(indexX, y, (result, file) => append(result.conflicted, file)));
}
/**
 * Splits a line of text and processes it based on the characters at specific positions.
 *
 * @param {Object} result - The object to store the processed data.
 * @param {string} lineStr - The string representing a line of text to be processed.
 * @returns {void}
 */
function splitLine(result, lineStr) {
  const trimmed2 = lineStr.trim();
  switch (" ") {
    case trimmed2.charAt(2):
      return data(trimmed2.charAt(0), trimmed2.charAt(1), trimmed2.substr(3));
    case trimmed2.charAt(1):
      return data(" " /* NONE */, trimmed2.charAt(0), trimmed2.substr(2));
    default:
      return;
  }
  /**
   * Processes data based on index, working directory, and path.
   *
   * @param {string} index - The index value to be processed.
   * @param {string} workingDir - The working directory string.
   * @param {string} path - The file path to process.
   * @returns {void}
   *
   * This function constructs a raw string from the index and working directory, retrieves a handler
   * from parsers6 based on this raw string, and if a handler exists, it is called with the result and path.
   * If the raw string does not match "##" or "!!", it adds a new FileStatusSummary to result.files array.
   *
   * @throws {Error} - Throws an error if no handler is found for the given index and working directory.
   */
  function data(index, workingDir, path) {
    const raw = `${index}${workingDir}`;
    const handler = parsers6.get(raw);
    if (handler) {
      handler(result, path);
    }
    if (raw !== "##" && raw !== "!!") {
      result.files.push(new FileStatusSummary(path, index, workingDir));
    }
  }
}
var StatusSummary, parsers6, parseStatusSummary;
var init_StatusSummary = __esm({
  "src/lib/responses/StatusSummary.ts"() {
    "use strict";
    init_utils();
    init_FileStatusSummary();
    StatusSummary = class {
      constructor() {
        this.not_added = [];
        this.conflicted = [];
        this.created = [];
        this.deleted = [];
        this.ignored = void 0;
        this.modified = [];
        this.renamed = [];
        this.files = [];
        this.staged = [];
        this.ahead = 0;
        this.behind = 0;
        this.current = null;
        this.tracking = null;
        this.detached = false;
        this.isClean = () => {
          return !this.files.length;
        };
      }
    };
    parsers6 = new Map([
      parser3(
        " " /* NONE */,
        "A" /* ADDED */,
        (result, file) => append(result.created, file)
      ),
      parser3(
        " " /* NONE */,
        "D" /* DELETED */,
        (result, file) => append(result.deleted, file)
      ),
      parser3(
        " " /* NONE */,
        "M" /* MODIFIED */,
        (result, file) => append(result.modified, file)
      ),
      parser3(
        "A" /* ADDED */,
        " " /* NONE */,
        (result, file) => append(result.created, file) && append(result.staged, file)
      ),
      parser3(
        "A" /* ADDED */,
        "M" /* MODIFIED */,
        (result, file) => append(result.created, file) && append(result.staged, file) && append(result.modified, file)
      ),
      parser3(
        "D" /* DELETED */,
        " " /* NONE */,
        (result, file) => append(result.deleted, file) && append(result.staged, file)
      ),
      parser3(
        "M" /* MODIFIED */,
        " " /* NONE */,
        (result, file) => append(result.modified, file) && append(result.staged, file)
      ),
      parser3(
        "M" /* MODIFIED */,
        "M" /* MODIFIED */,
        (result, file) => append(result.modified, file) && append(result.staged, file)
      ),
      parser3("R" /* RENAMED */, " " /* NONE */, (result, file) => {
        append(result.renamed, renamedFile(file));
      }),
      parser3("R" /* RENAMED */, "M" /* MODIFIED */, (result, file) => {
        const renamed = renamedFile(file);
        append(result.renamed, renamed);
        append(result.modified, renamed.to);
      }),
      parser3("!" /* IGNORED */, "!" /* IGNORED */, (_result, _file) => {
        append(_result.ignored = _result.ignored || [], _file);
      }),
      parser3(
        "?" /* UNTRACKED */,
        "?" /* UNTRACKED */,
        (result, file) => append(result.not_added, file)
      ),
      ...conflicts("A" /* ADDED */, "A" /* ADDED */, "U" /* UNMERGED */),
      ...conflicts(
        "D" /* DELETED */,
        "D" /* DELETED */,
        "U" /* UNMERGED */
      ),
      ...conflicts(
        "U" /* UNMERGED */,
        "A" /* ADDED */,
        "D" /* DELETED */,
        "U" /* UNMERGED */
      ),
      [
        "##",
        (result, line) => {
          const aheadReg = /ahead (\d+)/;
          const behindReg = /behind (\d+)/;
          const currentReg = /^(.+?(?=(?:\.{3}|\s|$)))/;
          const trackingReg = /\.{3}(\S*)/;
          const onEmptyBranchReg = /\son\s([\S]+)$/;
          let regexResult;
          regexResult = aheadReg.exec(line);
          result.ahead = regexResult && +regexResult[1] || 0;
          regexResult = behindReg.exec(line);
          result.behind = regexResult && +regexResult[1] || 0;
          regexResult = currentReg.exec(line);
          result.current = regexResult && regexResult[1];
          regexResult = trackingReg.exec(line);
          result.tracking = regexResult && regexResult[1];
          regexResult = onEmptyBranchReg.exec(line);
          result.current = regexResult && regexResult[1] || result.current;
          result.detached = /\(no branch\)/.test(line);
        }
      ]
    ]);
    parseStatusSummary = function(text) {
      const lines = text.split(NULL);
      const status = new StatusSummary();
      for (let i = 0, l = lines.length; i < l; ) {
        let line = lines[i++].trim();
        if (!line) {
          continue;
        }
        if (line.charAt(0) === "R" /* RENAMED */) {
          line += NULL + (lines[i++] || "");
        }
        splitLine(status, line);
      }
      return status;
    };
  }
});

// src/lib/tasks/status.ts
function statusTask(customArgs) {
  const commands = [
    "status",
    "--porcelain",
    "-b",
    "-u",
    "--null",
    ...customArgs.filter((arg) => !ignoredOptions.includes(arg))
  ];
  return {
    format: "utf-8",
    commands,
    parser(text) {
      return parseStatusSummary(text);
    }
  };
}
var ignoredOptions;
var init_status = __esm({
  "src/lib/tasks/status.ts"() {
    "use strict";
    init_StatusSummary();
    ignoredOptions = ["--null", "-z"];
  }
});

// src/lib/tasks/version.ts
/**
 * Creates an object representing a software version with additional properties and methods.
 *
 * @param {number} [major=0] - The major version number.
 * @param {number} [minor=0] - The minor version number.
 * @param {number} [patch=0] - The patch version number.
 * @param {string} [agent=""] - The agent name or identifier.
 * @param {boolean} [installed=true] - Indicates whether the software is installed.
 * @returns {Object} An object with properties `major`, `minor`, `patch`, `agent`, and `installed`. It also has a custom method `toString` that returns the version in semantic format.
 *
 * @example
 * // Create a version response with default values
 * const defaultVersion = versionResponse();
 * console.log(defaultVersion.toString()); // Output: "0.0.0"
 *
 * // Create a version response with custom values
 * const customVersion = versionResponse(1, 2, 3, "alpha", false);
 * console.log(customVersion.toString()); // Output: "1.2.3"
 */
function versionResponse(major = 0, minor = 0, patch = 0, agent = "", installed = true) {
  return Object.defineProperty(
    {
      major,
      minor,
      patch,
      agent,
      installed
    },
    "toString",
    {
      value() {
        return `${this.major}.${this.minor}.${this.patch}`;
      },
      configurable: false,
      enumerable: false
    }
  );
}
/**
 * Generates a version response indicating that the language is not installed.
 *
 * @returns {Object} - A version response object with the following properties:
 *   - major (number): The major version number, always 0 for this response.
 *   - minor (number): The minor version number, always 0 for this response.
 *   - patch (number): The patch version number, always 0 for this response.
 *   - releaseNotes (string): An empty string indicating no release notes.
 *   - installed (boolean): A boolean flag indicating that the language is not installed, set to false.
 *
 * @example
 * // Calling notInstalledResponse will return:
 * {
 *   major: 0,
 *   minor: 0,
 *   patch: 0,
 *   releaseNotes: "",
 *   installed: false
 * }
 */
function notInstalledResponse() {
  return versionResponse(0, 0, 0, "", false);
}
/**
 * Returns an object with a `version` method that retrieves the current version of the software.
 *
 * @returns {Object} - An object containing a `version` method.
 */
function version_default() {
  return {
    version() {
      return this._runTask({
        commands: ["--version"],
        format: "utf-8",
        parser: versionParser,
        onError(result, error, done, fail) {
          if (result.exitCode === -2 /* NOT_FOUND */) {
            return done(Buffer.from(NOT_INSTALLED));
          }
          fail(error);
        }
      });
    }
  };
}
/**
 * Parses the standard output from a language version check.
 *
 * @param {string} stdOut - The standard output string to parse.
 * @returns {Object} - An object containing the parsed version information or an error response.
 * @throws {Error} - If the input is not a valid version format.
 *
 * Example:
 * versionParser("v1.2.3") // Returns { major: 1, minor: 2, patch: 3 }
 * versionParser("not-installed") // Throws Error
 */
function versionParser(stdOut) {
  if (stdOut === NOT_INSTALLED) {
    return notInstalledResponse();
  }
  return parseStringResponse(versionResponse(0, 0, 0, stdOut), parsers7, stdOut);
}
var NOT_INSTALLED, parsers7;
var init_version = __esm({
  "src/lib/tasks/version.ts"() {
    "use strict";
    init_utils();
    NOT_INSTALLED = "installed=false";
    parsers7 = [
      new LineParser(
        /version (\d+)\.(\d+)\.(\d+)(?:\s*\((.+)\))?/,
        (result, [major, minor, patch, agent = ""]) => {
          Object.assign(
            result,
            versionResponse(asNumber(major), asNumber(minor), asNumber(patch), agent)
          );
        }
      ),
      new LineParser(
        /version (\d+)\.(\d+)\.(\D+)(.+)?$/,
        (result, [major, minor, patch, agent = ""]) => {
          Object.assign(result, versionResponse(asNumber(major), asNumber(minor), patch, agent));
        }
      )
    ];
  }
});

// src/lib/simple-git-api.ts
var simple_git_api_exports = {};
__export(simple_git_api_exports, {
  SimpleGitApi: () => SimpleGitApi
});
var SimpleGitApi;
var init_simple_git_api = __esm({
  "src/lib/simple-git-api.ts"() {
    "use strict";
    init_task_callback();
    init_change_working_directory();
    init_checkout();
    init_count_objects();
    init_commit();
    init_config();
    init_first_commit();
    init_grep();
    init_hash_object();
    init_init();
    init_log();
    init_merge();
    init_push();
    init_show();
    init_status();
    init_task();
    init_version();
    init_utils();
    SimpleGitApi = class {
      constructor(_executor) {
        this._executor = _executor;
      }
      _runTask(task, then) {
        const chain = this._executor.chain();
        const promise = chain.push(task);
        if (then) {
          taskCallback(task, promise, then);
        }
        return Object.create(this, {
          then: { value: promise.then.bind(promise) },
          catch: { value: promise.catch.bind(promise) },
          _executor: { value: chain }
        });
      }
      add(files) {
        return this._runTask(
          straightThroughStringTask(["add", ...asArray(files)]),
          trailingFunctionArgument(arguments)
        );
      }
      cwd(directory) {
        const next = trailingFunctionArgument(arguments);
        if (typeof directory === "string") {
          return this._runTask(changeWorkingDirectoryTask(directory, this._executor), next);
        }
        if (typeof (directory == null ? void 0 : directory.path) === "string") {
          return this._runTask(
            changeWorkingDirectoryTask(
              directory.path,
              directory.root && this._executor || void 0
            ),
            next
          );
        }
        return this._runTask(
          configurationErrorTask("Git.cwd: workingDirectory must be supplied as a string"),
          next
        );
      }
      hashObject(path, write) {
        return this._runTask(
          hashObjectTask(path, write === true),
          trailingFunctionArgument(arguments)
        );
      }
      init(bare) {
        return this._runTask(
          initTask(bare === true, this._executor.cwd, getTrailingOptions(arguments)),
          trailingFunctionArgument(arguments)
        );
      }
      merge() {
        return this._runTask(
          mergeTask(getTrailingOptions(arguments)),
          trailingFunctionArgument(arguments)
        );
      }
      mergeFromTo(remote, branch) {
        if (!(filterString(remote) && filterString(branch))) {
          return this._runTask(
            configurationErrorTask(
              `Git.mergeFromTo requires that the 'remote' and 'branch' arguments are supplied as strings`
            )
          );
        }
        return this._runTask(
          mergeTask([remote, branch, ...getTrailingOptions(arguments)]),
          trailingFunctionArgument(arguments, false)
        );
      }
      outputHandler(handler) {
        this._executor.outputHandler = handler;
        return this;
      }
      push() {
        const task = pushTask(
          {
            remote: filterType(arguments[0], filterString),
            branch: filterType(arguments[1], filterString)
          },
          getTrailingOptions(arguments)
        );
        return this._runTask(task, trailingFunctionArgument(arguments));
      }
      stash() {
        return this._runTask(
          straightThroughStringTask(["stash", ...getTrailingOptions(arguments)]),
          trailingFunctionArgument(arguments)
        );
      }
      status() {
        return this._runTask(
          statusTask(getTrailingOptions(arguments)),
          trailingFunctionArgument(arguments)
        );
      }
    };
    Object.assign(
      SimpleGitApi.prototype,
      checkout_default(),
      commit_default(),
      config_default(),
      count_objects_default(),
      first_commit_default(),
      grep_default(),
      log_default(),
      show_default(),
      version_default()
    );
  }
});

// src/lib/runners/scheduler.ts
var scheduler_exports = {};
__export(scheduler_exports, {
  Scheduler: () => Scheduler
});
import { createDeferred } from "@kwsites/promise-deferred";
var createScheduledTask, Scheduler;
var init_scheduler = __esm({
  "src/lib/runners/scheduler.ts"() {
    "use strict";
    init_utils();
    init_git_logger();
    createScheduledTask = (() => {
      let id = 0;
      return () => {
        id++;
        const { promise, done } = createDeferred();
        return {
          promise,
          done,
          id
        };
      };
    })();
    Scheduler = class {
      constructor(concurrency = 2) {
        this.concurrency = concurrency;
        this.logger = createLogger("", "scheduler");
        this.pending = [];
        this.running = [];
        this.logger(`Constructed, concurrency=%s`, concurrency);
      }
      schedule() {
        if (!this.pending.length || this.running.length >= this.concurrency) {
          this.logger(
            `Schedule attempt ignored, pending=%s running=%s concurrency=%s`,
            this.pending.length,
            this.running.length,
            this.concurrency
          );
          return;
        }
        const task = append(this.running, this.pending.shift());
        this.logger(`Attempting id=%s`, task.id);
        task.done(() => {
          this.logger(`Completing id=`, task.id);
          remove(this.running, task);
          this.schedule();
        });
      }
      next() {
        const { promise, id } = append(this.pending, createScheduledTask());
        this.logger(`Scheduling id=%s`, id);
        this.schedule();
        return promise;
      }
    };
  }
});

// src/lib/tasks/apply-patch.ts
var apply_patch_exports = {};
__export(apply_patch_exports, {
  applyPatchTask: () => applyPatchTask
});
/**
 * Applies patches to a project using a specific task.
 *
 * @param {string[]} patches - An array of patch file paths to be applied.
 * @param {string[]} customArgs - Additional arguments to pass to the patching command.
 * @returns {Promise<void>} A promise that resolves when the patches are successfully applied.
 * @throws {Error} If there is an error applying the patches.
 *
 * @example
 * applyPatchTask(["patch1.patch", "patch2.patch"], ["--dry-run"])
 *   .then(() => console.log("Patches applied successfully"))
 *   .catch(error => console.error(`Failed to apply patches: ${error.message}`));
 */
function applyPatchTask(patches, customArgs) {
  return straightThroughStringTask(["apply", ...customArgs, ...patches]);
}
var init_apply_patch = __esm({
  "src/lib/tasks/apply-patch.ts"() {
    "use strict";
    init_task();
  }
});

// src/lib/responses/BranchDeleteSummary.ts
/**
 * Creates an object indicating successful deletion of a branch.
 *
 * @param {string} branch - The name of the branch that was deleted.
 * @param {string} hash - The commit hash of the deletion.
 * @returns {{branch: string, hash: string, success: boolean}} An object with properties `branch`, `hash`, and `success`.
 */
function branchDeletionSuccess(branch, hash) {
  return {
    branch,
    hash,
    success: true
  };
}
/**
 * Creates an object representing a failed branch deletion attempt.
 *
 * @param {string} branch - The name of the branch that could not be deleted.
 * @returns {Object} An object with properties `branch`, `hash`, and `success`.
 *                     `branch`: The name of the branch.
 *                     `hash`: Always `null` as it's a failure.
 *                     `success`: A boolean indicating the operation was not successful (false).
 *
 * @example
 * const result = branchDeletionFailure('feature-branch');
 * console.log(result);
 * // Output: { branch: 'feature-branch', hash: null, success: false }
 */
function branchDeletionFailure(branch) {
  return {
    branch,
    hash: null,
    success: false
  };
}
var BranchDeletionBatch;
var init_BranchDeleteSummary = __esm({
  "src/lib/responses/BranchDeleteSummary.ts"() {
    "use strict";
    BranchDeletionBatch = class {
      constructor() {
        this.all = [];
        this.branches = {};
        this.errors = [];
      }
      get success() {
        return !this.errors.length;
      }
    };
  }
});

// src/lib/parsers/parse-branch-delete.ts
/**
 * Checks if the given data indicates a branch deletion error based on the provided process exit code.
 *
 * @param {string} data - The data to check for a deletion error message.
 * @param {number} processExitCode - The exit code of the process that generated the data.
 * @returns {boolean} - Returns true if the process exit code is 1 (indicating an error) and the data matches the deleteErrorRegex pattern, otherwise false.
 *
 * @example
 * hasBranchDeletionError("Failed to delete branch: 'feature-branch'", 1);
 * // returns true
 *
 * hasBranchDeletionError("Successfully deleted branch: 'feature-branch'", 0);
 * // returns false
 */
function hasBranchDeletionError(data, processExitCode) {
  return processExitCode === 1 /* ERROR */ && deleteErrorRegex.test(data);
}
var deleteSuccessRegex, deleteErrorRegex, parsers8, parseBranchDeletions;
var init_parse_branch_delete = __esm({
  "src/lib/parsers/parse-branch-delete.ts"() {
    "use strict";
    init_BranchDeleteSummary();
    init_utils();
    deleteSuccessRegex = /(\S+)\s+\(\S+\s([^)]+)\)/;
    deleteErrorRegex = /^error[^']+'([^']+)'/m;
    parsers8 = [
      new LineParser(deleteSuccessRegex, (result, [branch, hash]) => {
        const deletion = branchDeletionSuccess(branch, hash);
        result.all.push(deletion);
        result.branches[branch] = deletion;
      }),
      new LineParser(deleteErrorRegex, (result, [branch]) => {
        const deletion = branchDeletionFailure(branch);
        result.errors.push(deletion);
        result.all.push(deletion);
        result.branches[branch] = deletion;
      })
    ];
    parseBranchDeletions = (stdOut, stdErr) => {
      return parseStringResponse(new BranchDeletionBatch(), parsers8, [stdOut, stdErr]);
    };
  }
});

// src/lib/responses/BranchSummary.ts
var BranchSummaryResult;
var init_BranchSummary = __esm({
  "src/lib/responses/BranchSummary.ts"() {
    "use strict";
    BranchSummaryResult = class {
      constructor() {
        this.all = [];
        this.branches = {};
        this.current = "";
        this.detached = false;
      }
      push(status, detached, name, commit, label) {
        if (status === "*" /* CURRENT */) {
          this.detached = detached;
          this.current = name;
        }
        this.all.push(name);
        this.branches[name] = {
          current: status === "*" /* CURRENT */,
          linkedWorkTree: status === "+" /* LINKED */,
          name,
          commit,
          label
        };
      }
    };
  }
});

// src/lib/parsers/parse-branch.ts
/**
 * Determines the status of a given input by returning its first character.
 *
 * @param {string} input - The string from which to retrieve the first character.
 * @returns {string} The first character of the input string, or an empty string if the input is falsy.
 *
 * Example usage:
 * console.log(branchStatus("Open")); // Output: "O"
 * console.log(branchStatus(""));     // Output: ""
 */
function branchStatus(input) {
  return input ? input.charAt(0) : "";
}
/**
 * Parses the branch summary from the provided standard output.
 *
 * @param {string} stdOut - The standard output containing branch summary information.
 * @returns {BranchSummaryResult} - The parsed branch summary result object.
 * @throws {Error} - Throws an error if parsing fails.
 *
 * Example usage:
 * const summary = parseBranchSummary('branch: main, commits: 10');
 * console.log(summary); // BranchSummaryResult object with properties branch and commits
 */
function parseBranchSummary(stdOut) {
  return parseStringResponse(new BranchSummaryResult(), parsers9, stdOut);
}
var parsers9;
var init_parse_branch = __esm({
  "src/lib/parsers/parse-branch.ts"() {
    "use strict";
    init_BranchSummary();
    init_utils();
    parsers9 = [
      new LineParser(
        /^([*+]\s)?\((?:HEAD )?detached (?:from|at) (\S+)\)\s+([a-z0-9]+)\s(.*)$/,
        (result, [current, name, commit, label]) => {
          result.push(branchStatus(current), true, name, commit, label);
        }
      ),
      new LineParser(
        new RegExp("^([*+]\\s)?(\\S+)\\s+([a-z0-9]+)\\s?(.*)$", "s"),
        (result, [current, name, commit, label]) => {
          result.push(branchStatus(current), false, name, commit, label);
        }
      )
    ];
  }
});

// src/lib/tasks/branch.ts
var branch_exports = {};
__export(branch_exports, {
  branchLocalTask: () => branchLocalTask,
  branchTask: () => branchTask,
  containsDeleteBranchCommand: () => containsDeleteBranchCommand,
  deleteBranchTask: () => deleteBranchTask,
  deleteBranchesTask: () => deleteBranchesTask
});
/**
 * Determines if the given array of commands includes any command that deletes a branch.
 *
 * @param {string[]} commands - An array of strings representing commands.
 * @returns {boolean} - Returns true if any command is related to deleting a branch, otherwise false.
 *
 * Example usage:
 * console.log(containsDeleteBranchCommand(["-d", "commit"])); // Output: true
 * console.log(containsDeleteBranchCommand(["checkout", "pull"])); // Output: false
 */
function containsDeleteBranchCommand(commands) {
  const deleteCommands = ["-d", "-D", "--delete"];
  return commands.some((command) => deleteCommands.includes(command));
}
/**
 * Constructs an object containing configuration details for executing branch-related Git commands.
 *
 * @param {string[]} customArgs - An array of strings representing additional arguments to be passed to the branch command.
 * @returns {Object} - An object with the following properties:
 *   - format: A string specifying the expected output format, currently fixed as "utf-8".
 *   - commands: An array of strings representing the complete set of Git commands to execute. This includes a base command ("branch") and any custom arguments provided.
 *   - parser: A function that takes two parameters (stdOut, stdErr) and returns an object based on the content of the output streams:
 *     If the operation is intended to delete branches (determined by customArgs), it parses the output using parseBranchDeletions and returns the first deletion.
 *     Otherwise, it parses the output using parseBranchSummary.
 *
 * @throws {Error} - Throws an error if the parser encounters unexpected output formats or errors during execution.
 */
function branchTask(customArgs) {
  const isDelete = containsDeleteBranchCommand(customArgs);
  const commands = ["branch", ...customArgs];
  if (commands.length === 1) {
    commands.push("-a");
  }
  if (!commands.includes("-v")) {
    commands.splice(1, 0, "-v");
  }
  return {
    format: "utf-8",
    commands,
    parser(stdOut, stdErr) {
      if (isDelete) {
        return parseBranchDeletions(stdOut, stdErr).all[0];
      }
      return parseBranchSummary(stdOut);
    }
  };
}
/**
 * Function to configure the task for branching locally.
 *
 * @returns {Object} - An object containing configuration details for the branch local task.
 * @property {string} format - The file encoding format, set to "utf-8".
 * @property {Array<string>} commands - The array of git commands to execute for branching locally. Contains one command: ["branch", "-v"].
 * @property {function} parser - The function used to parse the branch summary, typically a reference to `parseBranchSummary`.
 */
function branchLocalTask() {
  const parser4 = parseBranchSummary;
  return {
    format: "utf-8",
    commands: ["branch", "-v"],
    parser: parser4
  };
}
/**
 * Deletes specified branches using Git commands.
 *
 * @param {Array<string>} branches - An array of branch names to delete.
 * @param {boolean} [forceDelete=false] - If true, forces the deletion of branches without prompting for confirmation. Defaults to false.
 * @returns {{format: string; commands: Array<string>; parser(stdOut, stdErr): Object; onError({ exitCode, stdOut }, error, done, fail): void}} - An object containing Git command details and error handling functions.
 *
 * Example:
 * const task = deleteBranchesTask(["feature-branch", "old-feature"], true);
 * console.log(task.commands); // ['branch', '-v', '-D', 'feature-branch', 'old-feature']
 */
function deleteBranchesTask(branches, forceDelete = false) {
  return {
    format: "utf-8",
    commands: ["branch", "-v", forceDelete ? "-D" : "-d", ...branches],
    parser(stdOut, stdErr) {
      return parseBranchDeletions(stdOut, stdErr);
    },
    onError({ exitCode, stdOut }, error, done, fail) {
      if (!hasBranchDeletionError(String(error), exitCode)) {
        return fail(error);
      }
      done(stdOut);
    }
  };
}
/**
 * Creates a task to delete a branch in a Git repository.
 *
 * @param {string} branch - The name of the branch to be deleted.
 * @param {boolean} [forceDelete=false] - If true, force deletes the branch even if it has unmerged changes.
 * @returns {object} A task object that can be executed to delete the specified branch.
 */
function deleteBranchTask(branch, forceDelete = false) {
  const task = {
    format: "utf-8",
    commands: ["branch", "-v", forceDelete ? "-D" : "-d", branch],
    parser(stdOut, stdErr) {
      return parseBranchDeletions(stdOut, stdErr).branches[branch];
    },
    onError({ exitCode, stdErr, stdOut }, error, _, fail) {
      if (!hasBranchDeletionError(String(error), exitCode)) {
        return fail(error);
      }
      throw new GitResponseError(
        task.parser(bufferToString(stdOut), bufferToString(stdErr)),
        String(error)
      );
    }
  };
  return task;
}
var init_branch = __esm({
  "src/lib/tasks/branch.ts"() {
    "use strict";
    init_git_response_error();
    init_parse_branch_delete();
    init_parse_branch();
    init_utils();
  }
});

// src/lib/responses/CheckIgnore.ts
var parseCheckIgnore;
var init_CheckIgnore = __esm({
  "src/lib/responses/CheckIgnore.ts"() {
    "use strict";
    parseCheckIgnore = (text) => {
      return text.split(/\n/g).map((line) => line.trim()).filter((file) => !!file);
    };
  }
});

// src/lib/tasks/check-ignore.ts
var check_ignore_exports = {};
__export(check_ignore_exports, {
  checkIgnoreTask: () => checkIgnoreTask
});
/**
 * Generates a task object to check if files are ignored by git.
 *
 * @param {string[]} paths - Array of file paths to check for ignoring.
 * @returns {Object} - A task object containing commands, format, and parser.
 * @example
 * const task = checkIgnoreTask(['file1.txt', 'file2.txt']);
 * console.log(task);
 * // Output: {
 * //   commands: ['check-ignore', 'file1.txt', 'file2.txt'],
 * //   format: 'utf-8',
 * //   parser: parseCheckIgnore
 * // }
 */
function checkIgnoreTask(paths) {
  return {
    commands: ["check-ignore", ...paths],
    format: "utf-8",
    parser: parseCheckIgnore
  };
}
var init_check_ignore = __esm({
  "src/lib/tasks/check-ignore.ts"() {
    "use strict";
    init_CheckIgnore();
  }
});

// src/lib/tasks/clone.ts
var clone_exports = {};
__export(clone_exports, {
  cloneMirrorTask: () => cloneMirrorTask,
  cloneTask: () => cloneTask
});
/**
 * Determines if a command is disallowed because it could potentially lead to security vulnerabilities.
 *
 * @param {string} command - The command to check for being disallowed.
 * @returns {boolean} - True if the command is disallowed, false otherwise.
 * @example
 * disallowedCommand('--upload-pack');
 * // returns true
 */
function disallowedCommand(command) {
  return /^--upload-pack(=|$)/.test(command);
}
/**
 * Clones a repository to a specified directory with custom arguments.
 *
 * @param {string} repo - The URL or path of the repository to clone.
 * @param {string} directory - The target directory where the repository will be cloned.
 * @param {Array<string>} [customArgs=[]] - Additional arguments for git clone command.
 * @returns {Function} - A function that executes the git clone command.
 *
 * @example
 * const task = cloneTask('https://github.com/user/repo.git', '/path/to/clone');
 * await task();
 *
 * @throws {Error} - Throws an error if a disallowed command argument is detected.
 */
function cloneTask(repo, directory, customArgs) {
  const commands = ["clone", ...customArgs];
  filterString(repo) && commands.push(repo);
  filterString(directory) && commands.push(directory);
  const banned = commands.find(disallowedCommand);
  if (banned) {
    return configurationErrorTask(`git.fetch: potential exploit argument blocked.`);
  }
  return straightThroughStringTask(commands);
}
/**
 * Clones a repository into a mirror directory with specified arguments.
 *
 * @param {string} repo - The URL or path of the repository to clone.
 * @param {string} directory - The target directory where the repository will be cloned.
 * @param {Array<string>} customArgs - Custom arguments to pass to the cloning command.
 * @returns {Promise<void>} A promise that resolves when the cloning is complete.
 * @throws {Error} Throws an error if the cloning process fails.
 *
 * Example usage:
 * await cloneMirrorTask('https://github.com/user/repo.git', '/path/to/mirror', ['--depth=1']);
 */
function cloneMirrorTask(repo, directory, customArgs) {
  append(customArgs, "--mirror");
  return cloneTask(repo, directory, customArgs);
}
var init_clone = __esm({
  "src/lib/tasks/clone.ts"() {
    "use strict";
    init_task();
    init_utils();
  }
});

// src/lib/parsers/parse-fetch.ts
/**
 * Parses the result of a fetch operation.
 *
 * @param {string} stdOut - The standard output from the fetch operation.
 * @param {string} stdErr - The standard error from the fetch operation.
 * @return {Object} - An object containing parsed results including raw data, remote status, branches, tags, updated items, and deleted items.
 * @throws {Error} - If an error occurs during parsing.
 */
function parseFetchResult(stdOut, stdErr) {
  const result = {
    raw: stdOut,
    remote: null,
    branches: [],
    tags: [],
    updated: [],
    deleted: []
  };
  return parseStringResponse(result, parsers10, [stdOut, stdErr]);
}
var parsers10;
var init_parse_fetch = __esm({
  "src/lib/parsers/parse-fetch.ts"() {
    "use strict";
    init_utils();
    parsers10 = [
      new LineParser(/From (.+)$/, (result, [remote]) => {
        result.remote = remote;
      }),
      new LineParser(/\* \[new branch]\s+(\S+)\s*-> (.+)$/, (result, [name, tracking]) => {
        result.branches.push({
          name,
          tracking
        });
      }),
      new LineParser(/\* \[new tag]\s+(\S+)\s*-> (.+)$/, (result, [name, tracking]) => {
        result.tags.push({
          name,
          tracking
        });
      }),
      new LineParser(/- \[deleted]\s+\S+\s*-> (.+)$/, (result, [tracking]) => {
        result.deleted.push({
          tracking
        });
      }),
      new LineParser(
        /\s*([^.]+)\.\.(\S+)\s+(\S+)\s*-> (.+)$/,
        (result, [from, to, name, tracking]) => {
          result.updated.push({
            name,
            tracking,
            to,
            from
          });
        }
      )
    ];
  }
});

// src/lib/tasks/fetch.ts
var fetch_exports = {};
__export(fetch_exports, {
  fetchTask: () => fetchTask
});
/**
 * Determines if the given command is disallowed based on a specific pattern.
 *
 * @param {string} command - The command to check for disallowance.
 * @returns {boolean} - True if the command matches the disallowed pattern, false otherwise.
 * @throws {TypeError} - If the input is not a string.
 */
function disallowedCommand2(command) {
  return /^--upload-pack(=|$)/.test(command);
}
/**
 * Fetches updates from a remote repository.
 *
 * @param {string} [remote] - The name of the remote repository to fetch from. If not provided, all remotes will be fetched.
 * @param {string} [branch] - The branch name to fetch. If not provided, all branches will be fetched.
 * @param {Array<string>} [customArgs] - Additional custom arguments for the git fetch command.
 * @returns {Object} An object containing the commands array, format, and parser function.
 * @throws {Error} Throws an error if a disallowed command is detected.
 *
 * Example usage:
 * fetchTask("origin", "main");
 */
function fetchTask(remote, branch, customArgs) {
  const commands = ["fetch", ...customArgs];
  if (remote && branch) {
    commands.push(remote, branch);
  }
  const banned = commands.find(disallowedCommand2);
  if (banned) {
    return configurationErrorTask(`git.fetch: potential exploit argument blocked.`);
  }
  return {
    commands,
    format: "utf-8",
    parser: parseFetchResult
  };
}
var init_fetch = __esm({
  "src/lib/tasks/fetch.ts"() {
    "use strict";
    init_parse_fetch();
    init_task();
  }
});

// src/lib/parsers/parse-move.ts
/**
 * Parses the result of a move operation from standard output.
 *
 * @param {string} stdOut - The standard output string containing the move result.
 * @returns {Object} - An object representing the parsed move results.
 *     {
 *       moves: Array<Object> - An array of objects, each representing a move with properties like 'from', 'to', etc.
 *     }
 *
 * @throws {Error} If the parsing process encounters an invalid format.
 */
function parseMoveResult(stdOut) {
  return parseStringResponse({ moves: [] }, parsers11, stdOut);
}
var parsers11;
var init_parse_move = __esm({
  "src/lib/parsers/parse-move.ts"() {
    "use strict";
    init_utils();
    parsers11 = [
      new LineParser(/^Renaming (.+) to (.+)$/, (result, [from, to]) => {
        result.moves.push({ from, to });
      })
    ];
  }
});

// src/lib/tasks/move.ts
var move_exports = {};
__export(move_exports, {
  moveTask: () => moveTask
});
/**
 * Moves a task from one location to another.
 *
 * @param {string|string[]} from - The source location of the task. Can be a single string or an array of strings.
 * @param {string} to - The destination location for the task.
 * @returns {Object} An object containing the command to execute, output format, and result parser.
 *
 * @example
 * const moveParams = moveTask("task1", "/new/location");
 * // {
 * //   commands: ["mv", "-v", "task1", "/new/location"],
 * //   format: "utf-8",
 * //   parser: parseMoveResult
 * // }
 */
function moveTask(from, to) {
  return {
    commands: ["mv", "-v", ...asArray(from), to],
    format: "utf-8",
    parser: parseMoveResult
  };
}
var init_move = __esm({
  "src/lib/tasks/move.ts"() {
    "use strict";
    init_parse_move();
    init_utils();
  }
});

// src/lib/tasks/pull.ts
var pull_exports = {};
__export(pull_exports, {
  pullTask: () => pullTask
});
/**
 * Executes the 'git pull' command to fetch updates from a remote repository.
 *
 * @param {string} [remote] - The remote repository to pull from. If not provided, it defaults to the configured default remote.
 * @param {string} [branch] - The branch of the remote repository to pull from. If not provided, it pulls from the current branch.
 * @param {Array<string>} [customArgs] - Additional arguments to pass to the 'git pull' command.
 * @returns {Object} An object containing the commands to execute, output format, and error handling functions.
 *
 * @example
 * const task = pullTask("origin", "main");
 * // Execute task.commands using a Git client or library
 */
function pullTask(remote, branch, customArgs) {
  const commands = ["pull", ...customArgs];
  if (remote && branch) {
    commands.splice(1, 0, remote, branch);
  }
  return {
    commands,
    format: "utf-8",
    parser(stdOut, stdErr) {
      return parsePullResult(stdOut, stdErr);
    },
    onError(result, _error, _done, fail) {
      const pullError = parsePullErrorResult(
        bufferToString(result.stdOut),
        bufferToString(result.stdErr)
      );
      if (pullError) {
        return fail(new GitResponseError(pullError));
      }
      fail(_error);
    }
  };
}
var init_pull = __esm({
  "src/lib/tasks/pull.ts"() {
    "use strict";
    init_git_response_error();
    init_parse_pull();
    init_utils();
  }
});

// src/lib/responses/GetRemoteSummary.ts
/**
 * Parses a string to extract remote information.
 *
 * @param {string} text - The input text containing remote data.
 * @returns {Array<{name: string}>} An array of objects, each representing a remote with its name.
 *
 * @example
 * parseGetRemotes("remote1\nremote2");
 * // Returns:
 * // [
 * //   { name: "remote1" },
 * //   { name: "remote2" }
 * // ]
 */
function parseGetRemotes(text) {
  const remotes = {};
  forEach(text, ([name]) => remotes[name] = { name });
  return Object.values(remotes);
}
/**
 * Parses verbose text to extract remote repository information.
 *
 * @param {string} text - The verbose text containing remote repository data.
 * @returns {Array<Object>} An array of objects representing the remotes.
 * @throws {Error} Throws an error if the input text is invalid.
 * @example
 * parseGetRemotesVerbose("remote1 git@github.com:user/repo1.git fetch\nremote2 git@github.com:user/repo2.git push");
 * // Returns:
 * // [
 * //   { name: 'remote1', refs: { fetch: 'git@github.com:user/repo1.git' } },
 * //   { name: 'remote2', refs: { push: 'git@github.com:user/repo2.git' } }
 * // ]
 */
function parseGetRemotesVerbose(text) {
  const remotes = {};
  forEach(text, ([name, url, purpose]) => {
    if (!remotes.hasOwnProperty(name)) {
      remotes[name] = {
        name,
        refs: { fetch: "", push: "" }
      };
    }
    if (purpose && url) {
      remotes[name].refs[purpose.replace(/[^a-z]/g, "")] = url;
    }
  });
  return Object.values(remotes);
}
/**
 * Iterates over each line in the given text that contains content, applying the provided handler function to each line.
 *
 * @param {string} text - The input text to process.
 * @param {function(string[]): void} handler - A callback function that will be invoked for each line. The function receives an array of words in the line.
 */
function forEach(text, handler) {
  forEachLineWithContent(text, (line) => handler(line.split(/\s+/)));
}
var init_GetRemoteSummary = __esm({
  "src/lib/responses/GetRemoteSummary.ts"() {
    "use strict";
    init_utils();
  }
});

// src/lib/tasks/remote.ts
var remote_exports = {};
__export(remote_exports, {
  addRemoteTask: () => addRemoteTask,
  getRemotesTask: () => getRemotesTask,
  listRemotesTask: () => listRemotesTask,
  remoteTask: () => remoteTask,
  removeRemoteTask: () => removeRemoteTask
});
/**
 * Adds a remote repository to the Git project.
 *
 * @param {string} remoteName - The name of the remote repository.
 * @param {string} remoteRepo - The URL or path of the remote repository.
 * @param {Array<string>} [customArgs=[]] - Additional arguments to pass to the 'remote add' command.
 * @returns {Promise<void>} A promise that resolves when the remote is added successfully.
 * @throws {Error} If an error occurs during the execution of the command.
 *
 * @example
 * addRemoteTask("origin", "https://github.com/user/repo.git")
 *   .then(() => console.log('Remote added successfully'))
 *   .catch(err => console.error('Error adding remote:', err));
 */
function addRemoteTask(remoteName, remoteRepo, customArgs) {
  return straightThroughStringTask(["remote", "add", ...customArgs, remoteName, remoteRepo]);
}
/**
 * Constructs a task object to retrieve remote information from a git repository.
 *
 * @param {boolean} verbose - Determines whether the output should include additional details.
 * @return {{
 *   commands: string[],
 *   format: string,
 *   parser: function
 * }}
 * An object containing the command array, output format, and parsing function for the task.
 *
 * Example:
 * getRemotesTask(true);
 * // Returns: {
 * //   commands: ["remote", "-v"],
 * //   format: "utf-8",
 * //   parser: parseGetRemotesVerbose
 * // }
 */
function getRemotesTask(verbose) {
  const commands = ["remote"];
  if (verbose) {
    commands.push("-v");
  }
  return {
    commands,
    format: "utf-8",
    parser: verbose ? parseGetRemotesVerbose : parseGetRemotes
  };
}
/**
 * Executes the 'ls-remote' command with custom arguments passed to it.
 *
 * @function listRemotesTask
 * @param {string[]} customArgs - Array of strings representing custom arguments for the 'ls-remote' command.
 * @returns {Promise} A promise that resolves when the task is completed.
 * @throws {Error} If the first argument is not 'ls-remote'.
 *
 * Example usage:
 * listRemotesTask(["origin"])
 *   .then(result => {
 *     console.log("Remote information:", result);
 *   })
 *   .catch(error => {
 *     console.error("Error fetching remote information:", error);
 *   });
 */
function listRemotesTask(customArgs) {
  const commands = [...customArgs];
  if (commands[0] !== "ls-remote") {
    commands.unshift("ls-remote");
  }
  return straightThroughStringTask(commands);
}
/**
 * Executes a task remotely with the provided arguments.
 *
 * @param {Array|string} customArgs - The arguments to pass to the task. If a string is provided, it will be converted into an array.
 * @returns {Function} - A function that represents the task to be executed.
 *
 * @throws {Error} - Throws an error if the first element of commands is not 'remote'.
 *
 * Example:
 *   const task = remoteTask(['command', 'arg1']);
 *   // This will prepend 'remote' to the command array and execute it
 */
function remoteTask(customArgs) {
  const commands = [...customArgs];
  if (commands[0] !== "remote") {
    commands.unshift("remote");
  }
  return straightThroughStringTask(commands);
}
/**
 * Removes a remote task from the configuration.
 *
 * @param {string} remoteName - The name of the remote to remove.
 * @return {Promise<void>} A promise that resolves when the remote has been successfully removed.
 * @throws {Error} If an error occurs during the removal process.
 */
function removeRemoteTask(remoteName) {
  return straightThroughStringTask(["remote", "remove", remoteName]);
}
var init_remote = __esm({
  "src/lib/tasks/remote.ts"() {
    "use strict";
    init_GetRemoteSummary();
    init_task();
  }
});

// src/lib/tasks/stash-list.ts
var stash_list_exports = {};
__export(stash_list_exports, {
  stashListTask: () => stashListTask
});
/**
 * Stashes the current state of the working directory and generates a log summary for stashed changes.
 *
 * @param {Object} [opt={}] - Optional parameters to customize the task execution.
 * @param {string[]} [customArgs=[]] - Additional arguments to be passed to the command.
 * @returns {Object} An object containing the commands, format, and parser for log summary generation.
 * @throws {Error} If the log format configuration is invalid.
 */
function stashListTask(opt = {}, customArgs) {
  const options = parseLogOptions(opt);
  const commands = ["stash", "list", ...options.commands, ...customArgs];
  const parser4 = createListLogSummaryParser(
    options.splitter,
    options.fields,
    logFormatFromCommand(commands)
  );
  return validateLogFormatConfig(commands) || {
    commands,
    format: "utf-8",
    parser: parser4
  };
}
var init_stash_list = __esm({
  "src/lib/tasks/stash-list.ts"() {
    "use strict";
    init_log_format();
    init_parse_list_log_summary();
    init_diff();
    init_log();
  }
});

// src/lib/tasks/sub-module.ts
var sub_module_exports = {};
__export(sub_module_exports, {
  addSubModuleTask: () => addSubModuleTask,
  initSubModuleTask: () => initSubModuleTask,
  subModuleTask: () => subModuleTask,
  updateSubModuleTask: () => updateSubModuleTask
});
/**
 * Adds a sub-module task to a repository at a specified path.
 *
 * @param {string} repo - The repository where the sub-module will be added.
 * @param {string} path - The path within the repository where the sub-module will be located.
 * @returns {Promise<void>} A promise that resolves when the task has been successfully added.
 * @throws {Error} If adding the sub-module task fails.
 */
function addSubModuleTask(repo, path) {
  return subModuleTask(["add", repo, path]);
}
/**
 * Initializes a submodule task with custom arguments.
 *
 * @param {Array} customArgs - An array of custom arguments to pass to the submodule task.
 * @returns {Promise} A promise that resolves when the submodule task is initialized.
 * @throws {Error} If the initialization fails for any reason.
 */
function initSubModuleTask(customArgs) {
  return subModuleTask(["init", ...customArgs]);
}
/**
 * Prepends "submodule" to the first element of the customArgs array if it is not already present,
 * then passes the modified array to straightThroughStringTask.
 *
 * @param {Array} customArgs - An array of command strings.
 * @returns {Promise<any>} - A promise that resolves with the result of straightThroughStringTask.
 * @throws {Error} - Throws an error if the input is not an array.
 */
function subModuleTask(customArgs) {
  const commands = [...customArgs];
  if (commands[0] !== "submodule") {
    commands.unshift("submodule");
  }
  return straightThroughStringTask(commands);
}
/**
 * Updates a submodule task with custom arguments.
 *
 * @function updateSubModuleTask
 * @param {Array} customArgs - An array of custom arguments to pass to the subModuleTask function.
 * @returns {Array} The result of calling `subModuleTask` with the "update" command and the provided custom arguments.
 * @throws {Error} If an error occurs during the execution of `subModuleTask`.
 *
 * @example
 * // Example usage:
 * const result = updateSubModuleTask(["--force"]);
 * console.log(result); // Output depends on the implementation of subModuleTask
 */
function updateSubModuleTask(customArgs) {
  return subModuleTask(["update", ...customArgs]);
}
var init_sub_module = __esm({
  "src/lib/tasks/sub-module.ts"() {
    "use strict";
    init_task();
  }
});

// src/lib/responses/TagList.ts
/**
 * Compares two values, handling both numeric and non-numeric types. If one value is numeric and the other is not,
 * the function returns a positive number if the first value is non-numeric and a negative number if it's numeric.
 * If both are non-numeric or both are numbers, it uses another sorting function (sorted) to compare them.
 *
 * @param {number|string} a - The first value to compare.
 * @param {number|string} b - The second value to compare.
 * @return {number} Returns -1, 0, or 1 based on the comparison.
 */
function singleSorted(a, b) {
  const aIsNum = isNaN(a);
  const bIsNum = isNaN(b);
  if (aIsNum !== bIsNum) {
    return aIsNum ? 1 : -1;
  }
  return aIsNum ? sorted(a, b) : 0;
}
/**
 * Compares two values to determine their sort order.
 *
 * @param {any} a - The first value to compare.
 * @param {any} b - The second value to compare.
 * @returns {number} - Returns `0` if `a` is equal to `b`, `1` if `a` is greater than `b`, and `-1` if `a` is less than `b`.
 *
 * @example
 * sorted(3, 5); // returns -1
 * sorted('apple', 'banana'); // returns -1
 * sorted(7, 7); // returns 0
 */
function sorted(a, b) {
  return a === b ? 0 : a > b ? 1 : -1;
}
/**
 * Trims whitespace from both ends of a string.
 *
 * @param {string} input - The string to trim.
 * @returns {string} The trimmed string.
 *
 * @example
 * // Returns 'Hello, World!'
 * trimmed('   Hello, World!   ');
 */
function trimmed(input) {
  return input.trim();
}
/**
 * Converts an input value to a number.
 * If the input is a string, it attempts to extract and parse an integer from it.
 * If the input is not a string or cannot be parsed into a number, returns 0.
 *
 * @param {string|number} input - The value to convert to a number.
 * @return {number} The converted number, or 0 if conversion fails.
 * @example
 * toNumber("123abc"); // returns 123
 * toNumber("abc123"); // returns 123
 * toNumber("abc");    // returns 0
 * toNumber(456);      // returns 456
 */
function toNumber(input) {
  if (typeof input === "string") {
    return parseInt(input.replace(/^\D+/g, ""), 10) || 0;
  }
  return 0;
}
var TagList, parseTagList;
var init_TagList = __esm({
  "src/lib/responses/TagList.ts"() {
    "use strict";
    TagList = class {
      constructor(all, latest) {
        this.all = all;
        this.latest = latest;
      }
    };
    parseTagList = function(data, customSort = false) {
      const tags = data.split("\n").map(trimmed).filter(Boolean);
      if (!customSort) {
        tags.sort(function(tagA, tagB) {
          const partsA = tagA.split(".");
          const partsB = tagB.split(".");
          if (partsA.length === 1 || partsB.length === 1) {
            return singleSorted(toNumber(partsA[0]), toNumber(partsB[0]));
          }
          for (let i = 0, l = Math.max(partsA.length, partsB.length); i < l; i++) {
            const diff = sorted(toNumber(partsA[i]), toNumber(partsB[i]));
            if (diff) {
              return diff;
            }
          }
          return 0;
        });
      }
      const latest = customSort ? tags[0] : [...tags].reverse().find((tag) => tag.indexOf(".") >= 0);
      return new TagList(tags, latest);
    };
  }
});

// src/lib/tasks/tag.ts
var tag_exports = {};
__export(tag_exports, {
  addAnnotatedTagTask: () => addAnnotatedTagTask,
  addTagTask: () => addTagTask,
  tagListTask: () => tagListTask
});
/**
 * Creates a task object for listing tags with optional custom arguments.
 *
 * @param {string[]} [customArgs=[]] - An array of strings representing custom arguments. Default is an empty array.
 * @returns {Object} A task object containing format, commands, and a parser function.
 * @property {string} format - The format in which the output should be parsed, currently set to "utf-8".
 * @property {string[]} commands - An array of strings representing the command to list tags, followed by custom arguments.
 * @property {function} parser - A function that takes the text output and returns a parsed result based on whether custom sorting is enabled.
 *
 * Example:
 * ```
 * const task = tagListTask(["--sort=name"]);
 * console.log(task.commands); // Output: ["tag", "-l", "--sort=name"]
 * ```
 */
function tagListTask(customArgs = []) {
  const hasCustomSort = customArgs.some((option) => /^--sort=/.test(option));
  return {
    format: "utf-8",
    commands: ["tag", "-l", ...customArgs],
    parser(text) {
      return parseTagList(text, hasCustomSort);
    }
  };
}
/**
 * Creates a task to add a tag with the specified name.
 *
 * @param {string} name - The name of the tag to be added.
 * @returns {Object} A configuration object for the task, containing format, commands, and parser.
 *
 * @example
 * const tagTask = addTagTask("high-priority");
 * console.log(tagTask);
 * // Output: { format: "utf-8", commands: ["tag", "high-priority"], parser() { return { name: "high-priority" }; } }
 */
function addTagTask(name) {
  return {
    format: "utf-8",
    commands: ["tag", name],
    parser() {
      return { name };
    }
  };
}
/**
 * Creates a task to annotate a tag with a message.
 *
 * @param {string} name - The name of the tag to be annotated.
 * @param {string} tagMessage - The message to associate with the tag.
 * @returns {Object} A configuration object for the tag annotation task.
 * @property {string} format - The file encoding format, always "utf-8".
 * @property {Array<string>} commands - An array of git commands to execute the tag annotation.
 * @property {function} parser - A function that parses the output and returns a configuration object.
 * @property {Object} parser.return - The parsed configuration object.
 * @property {string} parser.return.name - The name of the annotated tag.
 *
 * @example
 * const task = addAnnotatedTagTask("v1.0", "Release version 1.0");
 * console.log(task);
 * // Output: { format: 'utf-8', commands: [ 'tag', '-a', '-m', 'Release version 1.0', 'v1.0' ], parser: [Function] }
 */
function addAnnotatedTagTask(name, tagMessage) {
  return {
    format: "utf-8",
    commands: ["tag", "-a", "-m", tagMessage, name],
    parser() {
      return { name };
    }
  };
}
var init_tag = __esm({
  "src/lib/tasks/tag.ts"() {
    "use strict";
    init_TagList();
  }
});

// src/git.js
var require_git = __commonJS({
  "src/git.js"(exports, module) {
    "use strict";
    var { GitExecutor: GitExecutor2 } = (init_git_executor(), __toCommonJS(git_executor_exports));
    var { SimpleGitApi: SimpleGitApi2 } = (init_simple_git_api(), __toCommonJS(simple_git_api_exports));
    var { Scheduler: Scheduler2 } = (init_scheduler(), __toCommonJS(scheduler_exports));
    var { configurationErrorTask: configurationErrorTask2 } = (init_task(), __toCommonJS(task_exports));
    var {
      asArray: asArray2,
      filterArray: filterArray2,
      filterPrimitives: filterPrimitives2,
      filterString: filterString2,
      filterStringOrStringArray: filterStringOrStringArray2,
      filterType: filterType2,
      getTrailingOptions: getTrailingOptions2,
      trailingFunctionArgument: trailingFunctionArgument2,
      trailingOptionsArgument: trailingOptionsArgument2
    } = (init_utils(), __toCommonJS(utils_exports));
    var { applyPatchTask: applyPatchTask2 } = (init_apply_patch(), __toCommonJS(apply_patch_exports));
    var {
      branchTask: branchTask2,
      branchLocalTask: branchLocalTask2,
      deleteBranchesTask: deleteBranchesTask2,
      deleteBranchTask: deleteBranchTask2
    } = (init_branch(), __toCommonJS(branch_exports));
    var { checkIgnoreTask: checkIgnoreTask2 } = (init_check_ignore(), __toCommonJS(check_ignore_exports));
    var { checkIsRepoTask: checkIsRepoTask2 } = (init_check_is_repo(), __toCommonJS(check_is_repo_exports));
    var { cloneTask: cloneTask2, cloneMirrorTask: cloneMirrorTask2 } = (init_clone(), __toCommonJS(clone_exports));
    var { cleanWithOptionsTask: cleanWithOptionsTask2, isCleanOptionsArray: isCleanOptionsArray2 } = (init_clean(), __toCommonJS(clean_exports));
    var { diffSummaryTask: diffSummaryTask2 } = (init_diff(), __toCommonJS(diff_exports));
    var { fetchTask: fetchTask2 } = (init_fetch(), __toCommonJS(fetch_exports));
    var { moveTask: moveTask2 } = (init_move(), __toCommonJS(move_exports));
    var { pullTask: pullTask2 } = (init_pull(), __toCommonJS(pull_exports));
    var { pushTagsTask: pushTagsTask2 } = (init_push(), __toCommonJS(push_exports));
    var {
      addRemoteTask: addRemoteTask2,
      getRemotesTask: getRemotesTask2,
      listRemotesTask: listRemotesTask2,
      remoteTask: remoteTask2,
      removeRemoteTask: removeRemoteTask2
    } = (init_remote(), __toCommonJS(remote_exports));
    var { getResetMode: getResetMode2, resetTask: resetTask2 } = (init_reset(), __toCommonJS(reset_exports));
    var { stashListTask: stashListTask2 } = (init_stash_list(), __toCommonJS(stash_list_exports));
    var {
      addSubModuleTask: addSubModuleTask2,
      initSubModuleTask: initSubModuleTask2,
      subModuleTask: subModuleTask2,
      updateSubModuleTask: updateSubModuleTask2
    } = (init_sub_module(), __toCommonJS(sub_module_exports));
    var { addAnnotatedTagTask: addAnnotatedTagTask2, addTagTask: addTagTask2, tagListTask: tagListTask2 } = (init_tag(), __toCommonJS(tag_exports));
    var { straightThroughBufferTask: straightThroughBufferTask2, straightThroughStringTask: straightThroughStringTask2 } = (init_task(), __toCommonJS(task_exports));
    /**
     * Constructs an instance of Git2.
     *
     * @constructor
     * @param {Object} options - Configuration options for the Git instance.
     * @param {Array} plugins - Array of plugins to be used with this Git instance.
     */
    function Git2(options, plugins) {
      this._plugins = plugins;
      this._executor = new GitExecutor2(
        options.baseDir,
        new Scheduler2(options.maxConcurrentProcesses),
        plugins
      );
      this._trimmed = options.trimmed;
    }
    (Git2.prototype = Object.create(SimpleGitApi2.prototype)).constructor = Git2;
    Git2.prototype.customBinary = function(command) {
      this._plugins.reconfigure("binary", command);
      return this;
    };
    Git2.prototype.env = function(name, value) {
      if (arguments.length === 1 && typeof name === "object") {
        this._executor.env = name;
      } else {
        (this._executor.env = this._executor.env || {})[name] = value;
      }
      return this;
    };
    Git2.prototype.stashList = function(options) {
      return this._runTask(
        stashListTask2(
          trailingOptionsArgument2(arguments) || {},
          filterArray2(options) && options || []
        ),
        trailingFunctionArgument2(arguments)
      );
    };
    /**
     * Creates a task to clone a repository using the specified Git API.
     *
     * @param {string} api - The Git API method to use for cloning (e.g., 'clone', 'pull').
     * @param {Function} task - The function to be called with the cloned repository path, filtered local path, and trailing options.
     * @param {string} repoPath - The path or URL of the repository to clone.
     * @param {string} localPath - The local path where the repository should be cloned.
     * @returns {Function|Error} - Returns a task function if successful, otherwise throws an error.
     *
     * @throws {Error} If the provided 'repoPath' is not a string.
     */
    function createCloneTask(api, task, repoPath, localPath) {
      if (typeof repoPath !== "string") {
        return configurationErrorTask2(`git.${api}() requires a string 'repoPath'`);
      }
      return task(repoPath, filterType2(localPath, filterString2), getTrailingOptions2(arguments));
    }
    Git2.prototype.clone = function() {
      return this._runTask(
        createCloneTask("clone", cloneTask2, ...arguments),
        trailingFunctionArgument2(arguments)
      );
    };
    Git2.prototype.mirror = function() {
      return this._runTask(
        createCloneTask("mirror", cloneMirrorTask2, ...arguments),
        trailingFunctionArgument2(arguments)
      );
    };
    Git2.prototype.mv = function(from, to) {
      return this._runTask(moveTask2(from, to), trailingFunctionArgument2(arguments));
    };
    Git2.prototype.checkoutLatestTag = function(then) {
      var git = this;
      return this.pull(function() {
        git.tags(function(err, tags) {
          git.checkout(tags.latest, then);
        });
      });
    };
    Git2.prototype.pull = function(remote, branch, options, then) {
      return this._runTask(
        pullTask2(
          filterType2(remote, filterString2),
          filterType2(branch, filterString2),
          getTrailingOptions2(arguments)
        ),
        trailingFunctionArgument2(arguments)
      );
    };
    Git2.prototype.fetch = function(remote, branch) {
      return this._runTask(
        fetchTask2(
          filterType2(remote, filterString2),
          filterType2(branch, filterString2),
          getTrailingOptions2(arguments)
        ),
        trailingFunctionArgument2(arguments)
      );
    };
    Git2.prototype.silent = function(silence) {
      console.warn(
        "simple-git deprecation notice: git.silent: logging should be configured using the `debug` library / `DEBUG` environment variable, this will be an error in version 3"
      );
      return this;
    };
    Git2.prototype.tags = function(options, then) {
      return this._runTask(
        tagListTask2(getTrailingOptions2(arguments)),
        trailingFunctionArgument2(arguments)
      );
    };
    Git2.prototype.rebase = function() {
      return this._runTask(
        straightThroughStringTask2(["rebase", ...getTrailingOptions2(arguments)]),
        trailingFunctionArgument2(arguments)
      );
    };
    Git2.prototype.reset = function(mode) {
      return this._runTask(
        resetTask2(getResetMode2(mode), getTrailingOptions2(arguments)),
        trailingFunctionArgument2(arguments)
      );
    };
    Git2.prototype.revert = function(commit) {
      const next = trailingFunctionArgument2(arguments);
      if (typeof commit !== "string") {
        return this._runTask(configurationErrorTask2("Commit must be a string"), next);
      }
      return this._runTask(
        straightThroughStringTask2(["revert", ...getTrailingOptions2(arguments, 0, true), commit]),
        next
      );
    };
    Git2.prototype.addTag = function(name) {
      const task = typeof name === "string" ? addTagTask2(name) : configurationErrorTask2("Git.addTag requires a tag name");
      return this._runTask(task, trailingFunctionArgument2(arguments));
    };
    Git2.prototype.addAnnotatedTag = function(tagName, tagMessage) {
      return this._runTask(
        addAnnotatedTagTask2(tagName, tagMessage),
        trailingFunctionArgument2(arguments)
      );
    };
    Git2.prototype.deleteLocalBranch = function(branchName, forceDelete, then) {
      return this._runTask(
        deleteBranchTask2(branchName, typeof forceDelete === "boolean" ? forceDelete : false),
        trailingFunctionArgument2(arguments)
      );
    };
    Git2.prototype.deleteLocalBranches = function(branchNames, forceDelete, then) {
      return this._runTask(
        deleteBranchesTask2(branchNames, typeof forceDelete === "boolean" ? forceDelete : false),
        trailingFunctionArgument2(arguments)
      );
    };
    Git2.prototype.branch = function(options, then) {
      return this._runTask(
        branchTask2(getTrailingOptions2(arguments)),
        trailingFunctionArgument2(arguments)
      );
    };
    Git2.prototype.branchLocal = function(then) {
      return this._runTask(branchLocalTask2(), trailingFunctionArgument2(arguments));
    };
    Git2.prototype.raw = function(commands) {
      const createRestCommands = !Array.isArray(commands);
      const command = [].slice.call(createRestCommands ? arguments : commands, 0);
      for (let i = 0; i < command.length && createRestCommands; i++) {
        if (!filterPrimitives2(command[i])) {
          command.splice(i, command.length - i);
          break;
        }
      }
      command.push(...getTrailingOptions2(arguments, 0, true));
      var next = trailingFunctionArgument2(arguments);
      if (!command.length) {
        return this._runTask(
          configurationErrorTask2("Raw: must supply one or more command to execute"),
          next
        );
      }
      return this._runTask(straightThroughStringTask2(command, this._trimmed), next);
    };
    Git2.prototype.submoduleAdd = function(repo, path, then) {
      return this._runTask(addSubModuleTask2(repo, path), trailingFunctionArgument2(arguments));
    };
    Git2.prototype.submoduleUpdate = function(args, then) {
      return this._runTask(
        updateSubModuleTask2(getTrailingOptions2(arguments, true)),
        trailingFunctionArgument2(arguments)
      );
    };
    Git2.prototype.submoduleInit = function(args, then) {
      return this._runTask(
        initSubModuleTask2(getTrailingOptions2(arguments, true)),
        trailingFunctionArgument2(arguments)
      );
    };
    Git2.prototype.subModule = function(options, then) {
      return this._runTask(
        subModuleTask2(getTrailingOptions2(arguments)),
        trailingFunctionArgument2(arguments)
      );
    };
    Git2.prototype.listRemote = function() {
      return this._runTask(
        listRemotesTask2(getTrailingOptions2(arguments)),
        trailingFunctionArgument2(arguments)
      );
    };
    Git2.prototype.addRemote = function(remoteName, remoteRepo, then) {
      return this._runTask(
        addRemoteTask2(remoteName, remoteRepo, getTrailingOptions2(arguments)),
        trailingFunctionArgument2(arguments)
      );
    };
    Git2.prototype.removeRemote = function(remoteName, then) {
      return this._runTask(removeRemoteTask2(remoteName), trailingFunctionArgument2(arguments));
    };
    Git2.prototype.getRemotes = function(verbose, then) {
      return this._runTask(getRemotesTask2(verbose === true), trailingFunctionArgument2(arguments));
    };
    Git2.prototype.remote = function(options, then) {
      return this._runTask(
        remoteTask2(getTrailingOptions2(arguments)),
        trailingFunctionArgument2(arguments)
      );
    };
    Git2.prototype.tag = function(options, then) {
      const command = getTrailingOptions2(arguments);
      if (command[0] !== "tag") {
        command.unshift("tag");
      }
      return this._runTask(straightThroughStringTask2(command), trailingFunctionArgument2(arguments));
    };
    Git2.prototype.updateServerInfo = function(then) {
      return this._runTask(
        straightThroughStringTask2(["update-server-info"]),
        trailingFunctionArgument2(arguments)
      );
    };
    Git2.prototype.pushTags = function(remote, then) {
      const task = pushTagsTask2(
        { remote: filterType2(remote, filterString2) },
        getTrailingOptions2(arguments)
      );
      return this._runTask(task, trailingFunctionArgument2(arguments));
    };
    Git2.prototype.rm = function(files) {
      return this._runTask(
        straightThroughStringTask2(["rm", "-f", ...asArray2(files)]),
        trailingFunctionArgument2(arguments)
      );
    };
    Git2.prototype.rmKeepLocal = function(files) {
      return this._runTask(
        straightThroughStringTask2(["rm", "--cached", ...asArray2(files)]),
        trailingFunctionArgument2(arguments)
      );
    };
    Git2.prototype.catFile = function(options, then) {
      return this._catFile("utf-8", arguments);
    };
    Git2.prototype.binaryCatFile = function() {
      return this._catFile("buffer", arguments);
    };
    Git2.prototype._catFile = function(format, args) {
      var handler = trailingFunctionArgument2(args);
      var command = ["cat-file"];
      var options = args[0];
      if (typeof options === "string") {
        return this._runTask(
          configurationErrorTask2("Git.catFile: options must be supplied as an array of strings"),
          handler
        );
      }
      if (Array.isArray(options)) {
        command.push.apply(command, options);
      }
      const task = format === "buffer" ? straightThroughBufferTask2(command) : straightThroughStringTask2(command);
      return this._runTask(task, handler);
    };
    Git2.prototype.diff = function(options, then) {
      const task = filterString2(options) ? configurationErrorTask2(
        "git.diff: supplying options as a single string is no longer supported, switch to an array of strings"
      ) : straightThroughStringTask2(["diff", ...getTrailingOptions2(arguments)]);
      return this._runTask(task, trailingFunctionArgument2(arguments));
    };
    Git2.prototype.diffSummary = function() {
      return this._runTask(
        diffSummaryTask2(getTrailingOptions2(arguments, 1)),
        trailingFunctionArgument2(arguments)
      );
    };
    Git2.prototype.applyPatch = function(patches) {
      const task = !filterStringOrStringArray2(patches) ? configurationErrorTask2(
        `git.applyPatch requires one or more string patches as the first argument`
      ) : applyPatchTask2(asArray2(patches), getTrailingOptions2([].slice.call(arguments, 1)));
      return this._runTask(task, trailingFunctionArgument2(arguments));
    };
    Git2.prototype.revparse = function() {
      const commands = ["rev-parse", ...getTrailingOptions2(arguments, true)];
      return this._runTask(
        straightThroughStringTask2(commands, true),
        trailingFunctionArgument2(arguments)
      );
    };
    Git2.prototype.clean = function(mode, options, then) {
      const usingCleanOptionsArray = isCleanOptionsArray2(mode);
      const cleanMode = usingCleanOptionsArray && mode.join("") || filterType2(mode, filterString2) || "";
      const customArgs = getTrailingOptions2([].slice.call(arguments, usingCleanOptionsArray ? 1 : 0));
      return this._runTask(
        cleanWithOptionsTask2(cleanMode, customArgs),
        trailingFunctionArgument2(arguments)
      );
    };
    Git2.prototype.exec = function(then) {
      const task = {
        commands: [],
        format: "utf-8",
        parser() {
          if (typeof then === "function") {
            then();
          }
        }
      };
      return this._runTask(task);
    };
    Git2.prototype.clearQueue = function() {
      return this;
    };
    Git2.prototype.checkIgnore = function(pathnames, then) {
      return this._runTask(
        checkIgnoreTask2(asArray2(filterType2(pathnames, filterStringOrStringArray2, []))),
        trailingFunctionArgument2(arguments)
      );
    };
    Git2.prototype.checkIsRepo = function(checkType, then) {
      return this._runTask(
        checkIsRepoTask2(filterType2(checkType, filterString2)),
        trailingFunctionArgument2(arguments)
      );
    };
    module.exports = Git2;
  }
});

// src/lib/api.ts
init_pathspec();

// src/lib/errors/git-construct-error.ts
init_git_error();
var GitConstructError = class extends GitError {
  constructor(config, message) {
    super(void 0, message);
    this.config = config;
  }
};

// src/lib/api.ts
init_git_error();

// src/lib/errors/git-plugin-error.ts
init_git_error();
var GitPluginError = class extends GitError {
  constructor(task, plugin, message) {
    super(task, message);
    this.task = task;
    this.plugin = plugin;
    Object.setPrototypeOf(this, new.target.prototype);
  }
};

// src/lib/api.ts
init_git_response_error();
init_task_configuration_error();
init_check_is_repo();
init_clean();
init_config();
init_diff_name_status();
init_grep();
init_reset();

// src/lib/plugins/abort-plugin.ts
/**
 * Abort a plugin operation by handling the abort signal.
 *
 * @param {AbortSignal} [signal] - The abort signal to handle. If not provided, the function does nothing.
 * @returns {Array} - An array containing two objects: `onSpawnBefore` and `onSpawnAfter`.
 * @throws {GitPluginError} - Throws an error if the abort signal is already received.
 *
 * Example:
 *   const controller = new AbortController();
 *   abortPlugin(controller.signal);
 */
function abortPlugin(signal) {
  if (!signal) {
    return;
  }
  const onSpawnAfter = {
    type: "spawn.after",
    action(_data, context) {
      /**
       * Aborts the current operation by throwing a GitPluginError with the message "abort" and the description "Abort signal received".
       *
       * @throws {GitPluginError} - An error indicating that the operation was aborted.
       */
      function kill() {
        context.kill(new GitPluginError(void 0, "abort", "Abort signal received"));
      }
      signal.addEventListener("abort", kill);
      context.spawned.on("close", () => signal.removeEventListener("abort", kill));
    }
  };
  const onSpawnBefore = {
    type: "spawn.before",
    action(_data, context) {
      if (signal.aborted) {
        context.kill(new GitPluginError(void 0, "abort", "Abort already signaled"));
      }
    }
  };
  return [onSpawnBefore, onSpawnAfter];
}

// src/lib/plugins/block-unsafe-operations-plugin.ts
function isConfigSwitch(arg) {
  return typeof arg === "string" && arg.trim().toLowerCase() === "-c";
}
/**
 * Prevents protocol override if certain conditions are not met.
 *
 * @param {any} arg - The argument to check for configuration switch.
 * @param {string} next - The string to test against the regular expression.
 * @throws {GitPluginError} - Throws an error if configuring protocol.allow is not permitted without enabling allowUnsafeExtProtocol.
 */
function preventProtocolOverride(arg, next) {
  if (!isConfigSwitch(arg)) {
    return;
  }
  if (!/^\s*protocol(.[a-z]+)?.allow/.test(next)) {
    return;
  }
  throw new GitPluginError(
    void 0,
    "unsafe",
    "Configuring protocol.allow is not permitted without enabling allowUnsafeExtProtocol"
  );
}
/**
 * Prevents certain Git operations that could be unsafe if not explicitly allowed.
 *
 * @param {string} arg - The command-line argument to check for unsafe options.
 * @param {string} method - The Git operation being performed (e.g., "clone", "push").
 * @throws {GitPluginError} - Throws an error if the operation is unsafe and 'allowUnsafePack' is not enabled.
 */
function preventUploadPack(arg, method) {
  if (/^\s*--(upload|receive)-pack/.test(arg)) {
    throw new GitPluginError(
      void 0,
      "unsafe",
      `Use of --upload-pack or --receive-pack is not permitted without enabling allowUnsafePack`
    );
  }
  if (method === "clone" && /^\s*-u\b/.test(arg)) {
    throw new GitPluginError(
      void 0,
      "unsafe",
      `Use of clone with option -u is not permitted without enabling allowUnsafePack`
    );
  }
  if (method === "push" && /^\s*--exec\b/.test(arg)) {
    throw new GitPluginError(
      void 0,
      "unsafe",
      `Use of push with option --exec is not permitted without enabling allowUnsafePack`
    );
  }
}
/**
 * Creates a plugin to block unsafe operations during argument processing.
 *
 * @param {Object} options - Configuration options for the plugin.
 * @param {boolean} [options.allowUnsafeProtocolOverride=false] - Flag to allow protocol override.
 * @param {boolean} [options.allowUnsafePack=false] - Flag to allow upload pack operation.
 * @returns {Object} A plugin object with an action method.
 */
function blockUnsafeOperationsPlugin({
  allowUnsafeProtocolOverride = false,
  allowUnsafePack = false
} = {}) {
  return {
    type: "spawn.args",
    action(args, context) {
      args.forEach((current, index) => {
        const next = index < args.length ? args[index + 1] : "";
        allowUnsafeProtocolOverride || preventProtocolOverride(current, next);
        allowUnsafePack || preventUploadPack(current, context.method);
      });
      return args;
    }
  };
}

// src/lib/plugins/command-config-prefixing-plugin.ts
init_utils();
/**
 * Creates a plugin for prefixing command configurations with custom arguments.
 *
 * @param {Object} configuration - The configuration object containing the settings.
 * @returns {Object} A configuration object with a `type` of "spawn.args" and an `action` function.
 * @throws {Error} If the configuration is invalid or missing required properties.
 *
 * @example
 * const config = commandConfigPrefixingPlugin({ customArgs: ["-a", "-b"] });
 * console.log(config);
 * // Output: { type: "spawn.args", action: [Function] }
 */
function commandConfigPrefixingPlugin(configuration) {
  const prefix = prefixedArray(configuration, "-c");
  return {
    type: "spawn.args",
    action(data) {
      return [...prefix, ...data];
    }
  };
}

// src/lib/plugins/completion-detection.plugin.ts
init_utils();
import { deferred } from "@kwsites/promise-deferred";
var never = deferred().promise;
/**
 * Creates a plugin to detect when a process has completed.
 *
 * @param {Object} options - Configuration options for the plugin.
 * @param {boolean} [options.onClose=true] - Whether to wait for the close event. If `false`, the close event will not be waited on.
 * @param {number|boolean} [options.onExit=50] - The timeout in milliseconds to wait for the exit event. If `false`, the exit event will not be waited on.
 *
 * @returns {Object} An object containing the type of plugin and the action function.
 */
function completionDetectionPlugin({
  onClose = true,
  onExit = 50
} = {}) {
  /**
   * Creates an event handling system with close and exit events.
   *
   * @param {boolean} onClose - Whether to listen for the close event.
   * @param {boolean} onExit - Whether to listen for the exit event.
   * @returns {Object} An object containing methods to handle close, exit events,
   *                   a getter for the exit code, and a promise that resolves when
   *                   either close or exit event is triggered within the specified timeout.
   *
   * Example:
   * const events = createEvents(true, true);
   * events.close(0); // Resolve close event with exit code 0
   * events.exit(1); // Resolve exit event with exit code 1
   */
  function createEvents() {
    let exitCode = -1;
    const events = {
      close: deferred(),
      closeTimeout: deferred(),
      exit: deferred(),
      exitTimeout: deferred()
    };
    const result = Promise.race([
      onClose === false ? never : events.closeTimeout.promise,
      onExit === false ? never : events.exitTimeout.promise
    ]);
    configureTimeout(onClose, events.close, events.closeTimeout);
    configureTimeout(onExit, events.exit, events.exitTimeout);
    return {
      close(code) {
        exitCode = code;
        events.close.done();
      },
      exit(code) {
        exitCode = code;
        events.exit.done();
      },
      get exitCode() {
        return exitCode;
      },
      result
    };
  }
  /**
   * Configures the timeout for an event promise based on a flag.
   *
   * @param {boolean} flag - A flag indicating whether to set a timeout immediately or after an event is resolved.
   * @param {{promise: Promise}} event - An object containing a promise that represents the event.
   * @param {Object} timeout - An object with a `done` method that will be called when the timeout completes.
   * @throws {Error} Throws an error if flag is not a boolean.
   */
  function configureTimeout(flag, event, timeout) {
    if (flag === false) {
      return;
    }
    (flag === true ? event.promise : event.promise.then(() => delay(flag))).then(timeout.done);
  }
  return {
    type: "spawn.after",
    action(_0, _1) {
      return __async(this, arguments, function* (_data, { spawned, close }) {
        var _a3, _b;
        const events = createEvents();
        let deferClose = true;
        /**
         * Sets the `deferClose` variable to false, indicating that any pending close operations should not be deferred.
         *
         * @function
         * @returns {void}
         */
        let quickClose = () => void (deferClose = false);
        (_a3 = spawned.stdout) == null ? void 0 : _a3.on("data", quickClose);
        (_b = spawned.stderr) == null ? void 0 : _b.on("data", quickClose);
        spawned.on("error", quickClose);
        spawned.on("close", (code) => events.close(code));
        spawned.on("exit", (code) => events.exit(code));
        try {
          yield events.result;
          if (deferClose) {
            yield delay(50);
          }
          close(events.exitCode);
        } catch (err) {
          close(events.exitCode, err);
        }
      });
    }
  };
}

// src/lib/plugins/custom-binary.plugin.ts
init_utils();
var WRONG_NUMBER_ERR = `Invalid value supplied for custom binary, requires a single string or an array containing either one or two strings`;
var WRONG_CHARS_ERR = `Invalid value supplied for custom binary, restricted characters must be removed or supply the unsafe.allowUnsafeCustomBinary option`;
/**
 * Determines if an argument is considered bad based on specific criteria.
 *
 * @param {string} arg - The argument to be checked.
 * @returns {boolean} True if the argument is bad, otherwise false.
 *
 * This function checks if the provided argument is either null, undefined,
 * or does not match the expected pattern (a valid file path).
 */
function isBadArgument(arg) {
  return !arg || !/^([a-z]:)?([a-z0-9/.\\_-]+)$/i.test(arg);
}
/**
 * Converts an input array containing binary data and a prefix into a configuration object.
 *
 * @param {Array} input - An array containing exactly one binary data element and one prefix element.
 * @param {boolean} allowUnsafe - A flag indicating whether to allow unsafe characters in the input.
 * @returns {Object} A configuration object containing the binary data and its prefix.
 * @throws {GitPluginError} If the input does not contain exactly two elements or contains invalid characters, unless `allowUnsafe` is true.
 *
 * Example usage:
 * toBinaryConfig(['0101', 'bin'], false); // Returns { binary: '0101', prefix: 'bin' }
 */
function toBinaryConfig(input, allowUnsafe) {
  if (input.length < 1 || input.length > 2) {
    throw new GitPluginError(void 0, "binary", WRONG_NUMBER_ERR);
  }
  const isBad = input.some(isBadArgument);
  if (isBad) {
    if (allowUnsafe) {
      console.warn(WRONG_CHARS_ERR);
    } else {
      throw new GitPluginError(void 0, "binary", WRONG_CHARS_ERR);
    }
  }
  const [binary, prefix] = input;
  return {
    binary,
    prefix
  };
}
/**
 * Applies binary plugin configuration to a set of plugins.
 *
 * @param {Array} plugins - The array of plugins to which the binary configuration will be applied.
 * @param {Array|string} input - An array or string specifying the inputs for the binary configuration. Defaults to ["git"].
 * @param {boolean} allowUnsafe - A boolean flag indicating whether unsafe operations are allowed. Defaults to false.
 */
function customBinaryPlugin(plugins, input = ["git"], allowUnsafe = false) {
  let config = toBinaryConfig(asArray(input), allowUnsafe);
  plugins.on("binary", (input2) => {
    config = toBinaryConfig(asArray(input2), allowUnsafe);
  });
  plugins.append("spawn.binary", () => {
    return config.binary;
  });
  plugins.append("spawn.args", (data) => {
    return config.prefix ? [config.prefix, ...data] : data;
  });
}

// src/lib/plugins/error-detection.plugin.ts
init_git_error();
/**
 * Determines if the given result object indicates an error during a task execution.
 *
 * @param {Object} result - The result object from a task execution, expected to have properties 'exitCode' and 'stdErr'.
 * @returns {boolean} - Returns true if there is an exit code and non-empty standard error output, otherwise false.
 *
 * Example:
 * const result = {
 *   exitCode: 1,
 *   stdErr: "Error message"
 * };
 * console.log(isTaskError(result)); // Output: true
 */
function isTaskError(result) {
  return !!(result.exitCode && result.stdErr.length);
}
/**
 * Concatenates standard output and standard error from a result object.
 *
 * @param {Object} result - The result object containing stdOut and stdErr arrays.
 * @param {Buffer[]} result.stdOut - An array of Buffers representing the standard output.
 * @param {Buffer[]} result.stdErr - An array of Buffers representing the standard error.
 * @returns {Buffer} A Buffer containing the concatenated contents of stdOut and stdErr.
 */
function getErrorMessage(result) {
  return Buffer.concat([...result.stdOut, ...result.stdErr]);
}
/**
 * Creates an error detection handler function.
 *
 * @param {boolean} [overwrite=false] - If true, the original error will be returned regardless of other conditions.
 * @param {Function} [isError=isTaskError] - Function to determine if the result is an error. Defaults to `isTaskError`.
 * @param {Function} [errorMessage=getErrorMessage] - Function to generate the error message from the result. Defaults to `getErrorMessage`.
 * @returns {Function} - The error detection handler function.
 *
 * @example
 * const handleErrors = errorDetectionHandler(true, (result) => result.errorCode > 0);
 * const handleErrorResult = handleErrors(new Error('Something went wrong'), { errorCode: 1 });
 * console.log(handleErrorResult); // Output: [Error: Something went wrong]
 */
function errorDetectionHandler(overwrite = false, isError = isTaskError, errorMessage = getErrorMessage) {
  return (error, result) => {
    if (!overwrite && error || !isError(result)) {
      return error;
    }
    return errorMessage(result);
  };
}
/**
 * Creates an error detection plugin that can be used to handle errors during tasks.
 *
 * @param {Object} config - Configuration object for the error detection plugin.
 * @returns {Object} An object representing the task configuration with an action method.
 *
 * @example
 * const plugin = errorDetectionPlugin({
 *   (error, context) => {
 *     // Custom error handling logic here
 *   }
 * });
 */
function errorDetectionPlugin(config) {
  return {
    type: "task.error",
    action(data, context) {
      const error = config(data.error, {
        stdErr: context.stdErr,
        stdOut: context.stdOut,
        exitCode: context.exitCode
      });
      if (Buffer.isBuffer(error)) {
        return { error: new GitError(void 0, error.toString("utf-8")) };
      }
      return {
        error
      };
    }
  };
}

// src/lib/plugins/plugin-store.ts
init_utils();
import { EventEmitter } from "node:events";
var PluginStore = class {
  constructor() {
    this.plugins = /* @__PURE__ */ new Set();
    this.events = new EventEmitter();
  }
  on(type, listener) {
    this.events.on(type, listener);
  }
  reconfigure(type, data) {
    this.events.emit(type, data);
  }
  append(type, action) {
    const plugin = append(this.plugins, { type, action });
    return () => this.plugins.delete(plugin);
  }
  add(plugin) {
    const plugins = [];
    asArray(plugin).forEach((plugin2) => plugin2 && this.plugins.add(append(plugins, plugin2)));
    return () => {
      plugins.forEach((plugin2) => this.plugins.delete(plugin2));
    };
  }
  exec(type, data, context) {
    let output = data;
    const contextual = Object.freeze(Object.create(context));
    for (const plugin of this.plugins) {
      if (plugin.type === type) {
        output = plugin.action(output, contextual);
      }
    }
    return output;
  }
};

// src/lib/plugins/progress-monitor-plugin.ts
init_utils();
function progressMonitorPlugin(progress) {
  const progressCommand = "--progress";
  const progressMethods = ["checkout", "clone", "fetch", "pull", "push"];
  const onProgress = {
    type: "spawn.after",
    action(_data, context) {
      var _a2;
      if (!context.commands.includes(progressCommand)) {
        return;
      }
      (_a2 = context.spawned.stderr) == null ? void 0 : _a2.on("data", (chunk) => {
        const message = /^([\s\S]+?):\s*(\d+)% \((\d+)\/(\d+)\)/.exec(chunk.toString("utf8"));
        if (!message) {
          return;
        }
        progress({
          method: context.method,
          stage: progressEventStage(message[1]),
          progress: asNumber(message[2]),
          processed: asNumber(message[3]),
          total: asNumber(message[4])
        });
      });
    }
  };
  const onArgs = {
    type: "spawn.args",
    action(args, context) {
      if (!progressMethods.includes(context.method)) {
        return args;
      }
      return including(args, progressCommand);
    }
  };
  return [onArgs, onProgress];
}
/**
 * Extracts and returns the first word of a given string in lowercase format.
 *
 * @param {string} input - The string from which the first word is to be extracted.
 * @returns {string} The first word of the input string in lowercase. If no words are found, returns "unknown".
 *
 * Example usage:
 * progressEventStage("JavaScript is awesome"); // Returns: "javascript"
 */
function progressEventStage(input) {
  return String(input.toLowerCase().split(" ", 1)) || "unknown";
}

// src/lib/plugins/spawn-options-plugin.ts
init_utils();
/**
 * Creates a plugin that modifies spawn options by picking specific properties from the input.
 *
 * @param {Object} spawnOptions - The original spawn options object.
 * @returns {Object} A plugin object with a type and an action method.
 * @throws {Error} Throws an error if the input is not an object.
 */
function spawnOptionsPlugin(spawnOptions) {
  const options = pick(spawnOptions, ["uid", "gid"]);
  return {
    type: "spawn.options",
    action(data) {
      return __spreadValues(__spreadValues({}, options), data);
    }
  };
}

// src/lib/plugins/timout-plugin.ts
/**
 * Creates a plugin that applies a timeout to a spawned process.
 *
 * @param {Object} options - The configuration options for the plugin.
 * @param {number} [options.block=0] - The block duration in milliseconds. If greater than 0, the process will be terminated if it exceeds this time.
 * @param {boolean} [options.stdErr=true] - Whether to apply the timeout to stderr data.
 * @param {boolean} [options.stdOut=true] - Whether to apply the timeout to stdout data.
 *
 * @returns {Object} The plugin configuration object with an `action` method.
 *
 * @example
 * const pluginConfig = timeoutPlugin({ block: 5000 });
 * // Use pluginConfig in a process spawning context to apply the timeout.
 */
function timeoutPlugin({
  block,
  stdErr = true,
  stdOut = true
}) {
  if (block > 0) {
    return {
      type: "spawn.after",
      action(_data, context) {
        var _a2, _b;
        let timeout;
        /**
         * Clears any existing timeout and sets a new one to call the 'kill' function after a specified block time.
         *
         * @param {number} [block] - The time in milliseconds to delay before calling the 'kill' function. If not provided, uses a default value.
         */
        function wait() {
          timeout && clearTimeout(timeout);
          timeout = setTimeout(kill, block);
        }
        /**
         * Stops an ongoing process by removing event listeners and clearing any associated timeouts.
         *
         * This function is responsible for cleaning up resources when a spawned process needs to be terminated or the environment needs to be reset.
         *
         * @function
         * @name stop
         * @returns {void} - Does not return anything.
         */
        function stop() {
          var _a3, _b2;
          (_a3 = context.spawned.stdout) == null ? void 0 : _a3.off("data", wait);
          (_b2 = context.spawned.stderr) == null ? void 0 : _b2.off("data", wait);
          context.spawned.off("exit", stop);
          context.spawned.off("close", stop);
          timeout && clearTimeout(timeout);
        }
        /**
         * Terminates the execution by calling the `stop` function and throwing a GitPluginError with a timeout message.
         */
        function kill() {
          stop();
          context.kill(new GitPluginError(void 0, "timeout", `block timeout reached`));
        }
        stdOut && ((_a2 = context.spawned.stdout) == null ? void 0 : _a2.on("data", wait));
        stdErr && ((_b = context.spawned.stderr) == null ? void 0 : _b.on("data", wait));
        context.spawned.on("exit", stop);
        context.spawned.on("close", stop);
        wait();
      }
    };
  }
}

// src/lib/plugins/suffix-paths.plugin.ts
init_pathspec();
function suffixPathsPlugin() {
  return {
    type: "spawn.args",
    action(data) {
      const prefix = [];
      let suffix;
      /**
       * Appends elements to an array. If no array is provided, it initializes one.
       *
       * @param {...*} args - The elements to be appended to the array.
       * @returns {Array} The modified array.
       * @example
       * append2([1, 2], 3); // returns [1, 2, 3]
       * append2([], 4, 5); // returns [4, 5]
       */
      function append2(args) {
        (suffix = suffix || []).push(...args);
      }
      for (let i = 0; i < data.length; i++) {
        const param = data[i];
        if (isPathSpec(param)) {
          append2(toPaths(param));
          continue;
        }
        if (param === "--") {
          append2(
            data.slice(i + 1).flatMap((item) => isPathSpec(item) && toPaths(item) || item)
          );
          break;
        }
        prefix.push(param);
      }
      return !suffix ? prefix : [...prefix, "--", ...suffix.map(String)];
    }
  };
}

// src/lib/git-factory.ts
init_utils();
var Git = require_git();
/**
 * Creates an instance of Git using the provided base directory and options.
 *
 * @param {string|Object} [baseDir] - The path to the Git repository or configuration object.
 * @param {Object} [options] - Configuration options for the Git instance.
 * @param {boolean} [options.unsafe=false] - Allow unsafe operations.
 * @param {Array|string} [options.config=[]] - Additional configuration settings.
 * @param {boolean} [options.completion=true] - Enable completion detection.
 * @param {Function} [options.abort] - Function to handle abort events.
 * @param {Function} [options.progress] - Function to monitor progress events.
 * @param {number} [options.timeout] - Maximum time allowed for operations in milliseconds.
 * @param {Object} [options.spawnOptions] - Options passed to the child process when spawning commands.
 * @param {boolean|Array<Object>} [options.errors=false] - Custom error detection options.
 * @param {string} [options.binary='git'] - Path to the Git binary.
 * @param {boolean} [options.allowUnsafeCustomBinary=false] - Allow unsafe custom binary paths.
 *
 * @returns {Git} An instance of the Git class configured with the provided settings.
 *
 * @throws {GitConstructError} If the base directory does not exist.
 *
 * @example
 * const git = gitInstanceFactory('/path/to/repo', { completion: false, timeout: 5000 });
 */
function gitInstanceFactory(baseDir, options) {
  var _a2;
  const plugins = new PluginStore();
  const config = createInstanceConfig(
    baseDir && (typeof baseDir === "string" ? { baseDir } : baseDir) || {},
    options
  );
  if (!folderExists(config.baseDir)) {
    throw new GitConstructError(
      config,
      `Cannot use simple-git on a directory that does not exist`
    );
  }
  if (Array.isArray(config.config)) {
    plugins.add(commandConfigPrefixingPlugin(config.config));
  }
  plugins.add(blockUnsafeOperationsPlugin(config.unsafe));
  plugins.add(suffixPathsPlugin());
  plugins.add(completionDetectionPlugin(config.completion));
  config.abort && plugins.add(abortPlugin(config.abort));
  config.progress && plugins.add(progressMonitorPlugin(config.progress));
  config.timeout && plugins.add(timeoutPlugin(config.timeout));
  config.spawnOptions && plugins.add(spawnOptionsPlugin(config.spawnOptions));
  plugins.add(errorDetectionPlugin(errorDetectionHandler(true)));
  config.errors && plugins.add(errorDetectionPlugin(config.errors));
  customBinaryPlugin(plugins, config.binary, (_a2 = config.unsafe) == null ? void 0 : _a2.allowUnsafeCustomBinary);
  return new Git(config, plugins);
}

// src/lib/runners/promise-wrapped.ts
init_git_response_error();
var functionNamesBuilderApi = ["customBinary", "env", "outputHandler", "silent"];
var functionNamesPromiseApi = [
  "add",
  "addAnnotatedTag",
  "addConfig",
  "addRemote",
  "addTag",
  "applyPatch",
  "binaryCatFile",
  "branch",
  "branchLocal",
  "catFile",
  "checkIgnore",
  "checkIsRepo",
  "checkout",
  "checkoutBranch",
  "checkoutLatestTag",
  "checkoutLocalBranch",
  "clean",
  "clone",
  "commit",
  "cwd",
  "deleteLocalBranch",
  "deleteLocalBranches",
  "diff",
  "diffSummary",
  "exec",
  "fetch",
  "getRemotes",
  "init",
  "listConfig",
  "listRemote",
  "log",
  "merge",
  "mergeFromTo",
  "mirror",
  "mv",
  "pull",
  "push",
  "pushTags",
  "raw",
  "rebase",
  "remote",
  "removeRemote",
  "reset",
  "revert",
  "revparse",
  "rm",
  "rmKeepLocal",
  "show",
  "stash",
  "stashList",
  "status",
  "subModule",
  "submoduleAdd",
  "submoduleInit",
  "submoduleUpdate",
  "tag",
  "tags",
  "updateServerInfo"
];
/**
 * Creates a promise-based interface for Git commands using a factory function.
 *
 * @function
 * @param {...*} args - Arguments to be passed to the `gitInstanceFactory`.
 * @returns {Object} - An object representing the promise-based API.
 * @throws {Error} - Throws an error if `gitInstanceFactory` fails to create a Git instance.
 *
 * Example usage:
 * const gitP = require('gitp');
 * const git = gitP('/path/to/repo', 'user', 'password');
 * git.add('.').then(() => {
 *   console.log('Files added successfully.');
 * }).catch((error) => {
 *   console.error('Error adding files:', error);
 * });
 */
function gitP(...args) {
  let git;
  let chain = Promise.resolve();
  try {
    git = gitInstanceFactory(...args);
  } catch (e) {
    chain = Promise.reject(e);
  }
  /**
   * Returns the promiseApi object.
   *
   * @returns {PromiseApi} - The promiseApi object that represents the API for handling promises.
   */
  function builderReturn() {
    return promiseApi;
  }
  /**
   * Returns the current chain object.
   *
   * @returns {Chain} The current chain object.
   */
  function chainReturn() {
    return chain;
  }
  const promiseApi = [...functionNamesBuilderApi, ...functionNamesPromiseApi].reduce(
    (api, name) => {
      const isAsync = functionNamesPromiseApi.includes(name);
      const valid = isAsync ? asyncWrapper(name, git) : syncWrapper(name, git, api);
      const alternative = isAsync ? chainReturn : builderReturn;
      Object.defineProperty(api, name, {
        enumerable: false,
        configurable: false,
        value: git ? valid : alternative
      });
      return api;
    },
    {}
  );
  return promiseApi;
  /**
   * Wraps an asynchronous function to return a Promise.
   *
   * This function takes another function `fn` and an object `git2`, then returns a new function that,
   * when called, will execute the original function in a way that returns a Promise. If a trailing
   * callback function is provided, it throws a TypeError as Promises should not use callbacks inline.
   *
   * @param {Function} fn - The asynchronous function to wrap.
   * @param {Object} git2 - The object on which the function `fn` will be called.
   * @returns {Function} A new function that returns a Promise instead of using a callback.
   * @throws {TypeError} If a trailing callback function is provided.
   *
   * @example
   * const wrappedFn = asyncWrapper('someAsyncMethod', git2);
   * wrappedFn(arg1, arg2).then(result => {
   *   console.log(result);
   * }).catch(error => {
   *   console.error(error);
   * });
   */
  function asyncWrapper(fn, git2) {
    return function(...args2) {
      if (typeof args2[args2.length] === "function") {
        throw new TypeError(
          "Promise interface requires that handlers are not supplied inline, trailing function not allowed in call to " + fn
        );
      }
      return chain.then(function() {
        return new Promise(function(resolve, reject) {
          const callback = (err, result) => {
            if (err) {
              return reject(toError(err));
            }
            resolve(result);
          };
          args2.push(callback);
          git2[fn].apply(git2, args2);
        });
      });
    };
  }
  /**
   * Creates a synchronous wrapper function that executes a given method on an instance of `git2` and returns the `api` object.
   *
   * @param {string} fn - The name of the method to be executed on the `git2` instance.
   /**
    * Callback function to handle errors and results.
    *
    * @callback callback
    * @param {Error} [err] - Error object if an error occurred, otherwise undefined.
    * @param {*} result - Result of the operation, if no error occurred.
    */
   * @param {Object} git2 - The instance on which the method will be executed.
   * @param {Object} api - The API object that will be returned after executing the method.
   * @returns {Function} A new function that, when called with arguments, executes `git2[fn]` with those arguments and returns the `api`.
   *
   * @example
   * const gitInstance = {
   *   commit: (message) => console.log(`Committing message: ${message}`)
   * };
   * const apiObject = {};
   * const wrapper = syncWrapper('commit', gitInstance, apiObject);
   * wrapper('Initial commit'); // Outputs: Committing message: Initial commit
   */
  function syncWrapper(fn, git2, api) {
    return (...args2) => {
      git2[fn](...args2);
      return api;
    };
  }
}
/**
 * Converts an input to an instance of Error.
 *
 * @param {Object|string} error - The input that may or may not be an Error instance.
 * @returns {Error} An Error instance representing the original input.
 * @throws {GitResponseError} If the input is neither an Error nor a string.
 */
function toError(error) {
  if (error instanceof Error) {
    return error;
  }
  if (typeof error === "string") {
    return new Error(error);
  }
  return new GitResponseError(error);
}

// src/esm.mjs
var simpleGit = gitInstanceFactory;
var esm_default = gitInstanceFactory;
export {
  CheckRepoActions,
  CleanOptions,
  DiffNameStatus,
  GitConfigScope,
  GitConstructError,
  GitError,
  GitPluginError,
  GitResponseError,
  ResetMode,
  TaskConfigurationError,
  esm_default as default,
  gitP,
  grepQueryBuilder,
  pathspec,
  simpleGit
};
//# sourceMappingURL=index.js.map
