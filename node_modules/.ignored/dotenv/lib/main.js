const fs = require('fs')
const path = require('path')
const os = require('os')
const crypto = require('crypto')
const packageJson = require('../package.json')

const version = packageJson.version

const LINE = /(?:^|^)\s*(?:export\s+)?([\w.-]+)(?:\s*=\s*?|:\s+?)(\s*'(?:\\'|[^'])*'|\s*"(?:\\"|[^"])*"|\s*`(?:\\`|[^`])*`|[^#\r\n]+)?\s*(?:#.*)?(?:$|$)/mg

// Parse src into an Object
/**
 * Parses a source string into an object using a regular expression.
 *
 * @param {string} src - The source string to be parsed.
 * @returns {Object} - An object containing the parsed key-value pairs.
 * @throws {Error} - If the input is not a valid string.
 */
function parse (src) {
  const obj = {}

  // Convert buffer to string
  let lines = src.toString()

  // Convert line breaks to same format
  lines = lines.replace(/\r\n?/mg, '\n')

  let match
  while ((match = LINE.exec(lines)) != null) {
    const key = match[1]

    // Default undefined or null to empty string
    let value = (match[2] || '')

    // Remove whitespace
    value = value.trim()

    // Check if double quoted
    const maybeQuote = value[0]

    // Remove surrounding quotes
    value = value.replace(/^(['"`])([\s\S]*)\1$/mg, '$2')

    // Expand newlines if double quoted
    if (maybeQuote === '"') {
      value = value.replace(/\\n/g, '\n')
      value = value.replace(/\\r/g, '\r')
    }

    // Add to object
    obj[key] = value
  }

  return obj
}

function _parseVault (options) {
  const vaultPath = _vaultPath(options)

  // Parse .env.vault
  const result = DotenvModule.configDotenv({ path: vaultPath })
  if (!result.parsed) {
    const err = new Error(`MISSING_DATA: Cannot parse ${vaultPath} for an unknown reason`)
    err.code = 'MISSING_DATA'
    throw err
  }

  // handle scenario for comma separated keys - for use with key rotation
  // example: DOTENV_KEY="dotenv://:key_1234@dotenvx.com/vault/.env.vault?environment=prod,dotenv://:key_7890@dotenvx.com/vault/.env.vault?environment=prod"
  const keys = _dotenvKey(options).split(',')
  const length = keys.length

  let decrypted
  for (let i = 0; i < length; i++) {
    try {
      // Get full key
      const key = keys[i].trim()

      // Get instructions for decrypt
      const attrs = _instructions(result, key)

      // Decrypt
      decrypted = DotenvModule.decrypt(attrs.ciphertext, attrs.key)

      break
    } catch (error) {
      // last key
      if (i + 1 >= length) {
        throw error
      }
      // try next key
    }
  }

  // Parse decrypted .env string
  return DotenvModule.parse(decrypted)
}

/**
 * Logs a warning message to the console.
 *
 * @param {string} message - The warning message to log.
 */
function _warn (message) {
  console.log(`[dotenv@${version}][WARN] ${message}`)
}

/**
 * Logs a debug message to the console with version information.
 *
 * @param {string} message - The message to log as a debug statement.
 */
function _debug (message) {
  console.log(`[dotenv@${version}][DEBUG] ${message}`)
}

/**
 * Retrieves the value of the DOTENV_KEY environment variable from the provided options or from the process environment.
 *
 * @param {Object} [options] - The options object containing optional configuration settings.
 * @param {string} [options.DOTENV_KEY] - The value to use for the DOTENV_KEY environment variable, if provided.
 * @returns {string} - The value of the DOTENV_KEY environment variable.
 *
 * @example
 * // Using options with explicitly set DOTENV_KEY
 * const dotenvKey = _dotenvKey({ DOTENV_KEY: 'development' });
 * console.log(dotenvKey); // Output: 'development'
 *
 * @example
 * // Using process environment variable for DOTENV_KEY
 * process.env.DOTENV_KEY = 'production';
 * const dotenvKey = _dotenvKey();
 * console.log(dotenvKey); // Output: 'production'
 *
 * @example
 * // Fallback to empty string if neither options nor environment variable is provided
 * delete process.env.DOTENV_KEY;
 * const dotenvKey = _dotenvKey();
 * console.log(dotenvKey); // Output: ''
 */
function _dotenvKey (options) {
  // prioritize developer directly setting options.DOTENV_KEY
  if (options && options.DOTENV_KEY && options.DOTENV_KEY.length > 0) {
    return options.DOTENV_KEY
  }

  // secondary infra already contains a DOTENV_KEY environment variable
  if (process.env.DOTENV_KEY && process.env.DOTENV_KEY.length > 0) {
    return process.env.DOTENV_KEY
  }

  // fallback to empty string
  return ''
}

/**
 * Parses a DOTENV_KEY URI to extract the decryption key, environment, and ciphertext payload.
 *
 * @param {Object} result - The result object containing parsed data.
 * @param {string} dotenvKey - The DOTENV_KEY in URI format (e.g., dotenv://:key_1234@dotenvx.com/vault/.env.vault?environment=development).
 * @returns {Object} An object containing the ciphertext and decryption key.
 * @throws {Error} If the DOTENV_KEY is not in a valid URI format or if the required parts (key, environment) are missing.
 *
 * @example
 * const result = { parsed: { 'DOTENV_VAULT_PRODUCTION': 'ciphertext_value' } };
 * const dotenvKey = 'dotenv://:key_1234@dotenvx.com/vault/.env.vault?environment=development';
 * try {
 *   const { ciphertext, key } = _instructions(result, dotenvKey);
 *   console.log(ciphertext); // 'ciphertext_value'
 *   console.log(key);        // 'key_1234'
 * } catch (error) {
 *   console.error(error.message);
 * }
 */
function _instructions (result, dotenvKey) {
  // Parse DOTENV_KEY. Format is a URI
  let uri
  try {
    uri = new URL(dotenvKey)
  } catch (error) {
    if (error.code === 'ERR_INVALID_URL') {
      const err = new Error('INVALID_DOTENV_KEY: Wrong format. Must be in valid uri format like dotenv://:key_1234@dotenvx.com/vault/.env.vault?environment=development')
      err.code = 'INVALID_DOTENV_KEY'
      throw err
    }

    throw error
  }

  // Get decrypt key
  const key = uri.password
  if (!key) {
    const err = new Error('INVALID_DOTENV_KEY: Missing key part')
    err.code = 'INVALID_DOTENV_KEY'
    throw err
  }

  // Get environment
  const environment = uri.searchParams.get('environment')
  if (!environment) {
    const err = new Error('INVALID_DOTENV_KEY: Missing environment part')
    err.code = 'INVALID_DOTENV_KEY'
    throw err
  }

  // Get ciphertext payload
  const environmentKey = `DOTENV_VAULT_${environment.toUpperCase()}`
  const ciphertext = result.parsed[environmentKey] // DOTENV_VAULT_PRODUCTION
  if (!ciphertext) {
    const err = new Error(`NOT_FOUND_DOTENV_ENVIRONMENT: Cannot locate environment ${environmentKey} in your .env.vault file.`)
    err.code = 'NOT_FOUND_DOTENV_ENVIRONMENT'
    throw err
  }

  return { ciphertext, key }
}

/**
 * Determines the path to the vault file based on the provided options.
 *
 * @param {Object} options - The options object containing the path to the vault.
 * @param {string|string[]} [options.path] - The path(s) to check for the vault file. If not provided, defaults to '.env.vault' in the current working directory.
 * @returns {string|null} - The path to the vault file if found; otherwise, null.
 *
 * @throws {Error} - Throws an error if the path provided is invalid or not accessible.
 */
function _vaultPath (options) {
  let possibleVaultPath = null

  if (options && options.path && options.path.length > 0) {
    if (Array.isArray(options.path)) {
      for (const filepath of options.path) {
        if (fs.existsSync(filepath)) {
          possibleVaultPath = filepath.endsWith('.vault') ? filepath : `${filepath}.vault`
        }
      }
    } else {
      possibleVaultPath = options.path.endsWith('.vault') ? options.path : `${options.path}.vault`
    }
  } else {
    possibleVaultPath = path.resolve(process.cwd(), '.env.vault')
  }

  if (fs.existsSync(possibleVaultPath)) {
    return possibleVaultPath
  }

  return null
}

/**
 * Resolves a path that starts with '~' to the user's home directory.
 *
 * @param {string} envPath - The environment path to resolve. If it starts with '~', it will be replaced with the user's home directory path.
 * @returns {string} - The resolved path.
 *
 * @example
 * // Example usage:
 * const resolvedPath = _resolveHome('~/.config');
 * console.log(resolvedPath); // '/home/username/.config'
 */
function _resolveHome (envPath) {
  return envPath[0] === '~' ? path.join(os.homedir(), envPath.slice(1)) : envPath
}

/**
 * Configures vault by loading environment variables from an encrypted .env.vault file.
 *
 * @param {Object} options - Options object containing configuration settings.
 * @param {boolean} [options.debug=false] - Enables debug mode to log loading information.
 * @param {Object} [options.processEnv=process.env] - Environment variables object to populate.
 * @returns {Object} An object containing the parsed environment variables.
 * @throws {Error} If there is an issue parsing the .env.vault file.
 */
function _configVault (options) {
  const debug = Boolean(options && options.debug)
  if (debug) {
    _debug('Loading env from encrypted .env.vault')
  }

  const parsed = DotenvModule._parseVault(options)

  let processEnv = process.env
  if (options && options.processEnv != null) {
    processEnv = options.processEnv
  }

  DotenvModule.populate(processEnv, parsed, options)

  return { parsed }
}

/**
 * Configures dotenv to load environment variables from specified files into `process.env`.
 *
 * @param {Object} [options={}] - Optional configuration object.
 * @param {string} [options.encoding='utf8'] - Encoding for reading the `.env` file. Defaults to 'utf8'.
 * @param {boolean} [options.debug=false] - Whether to enable debug mode for logging detailed information. Defaults to false.
 * @param {Array|string} [options.path='.env'] - Path(s) to the `.env` file(s). If not provided, defaults to '.env' in the current working directory.
 * @param {Object} [options.processEnv=process.env] - Custom environment object to populate with parsed values. Defaults to `process.env`.
 *
 * @returns {Object} An object containing the parsed environment variables and an optional error if loading fails.
 * @property {Object} parsed - The final parsed environment variables, merged from all specified files.
 * @property {Error} [error] - Error object if any file fails to load, otherwise undefined.
 *
 * @example
 * const result = configDotenv({ path: ['.env', '.env.local'], debug: true });
 * console.log(result.parsed);
 */
function configDotenv (options) {
  const dotenvPath = path.resolve(process.cwd(), '.env')
  let encoding = 'utf8'
  const debug = Boolean(options && options.debug)

  if (options && options.encoding) {
    encoding = options.encoding
  } else {
    if (debug) {
      _debug('No encoding is specified. UTF-8 is used by default')
    }
  }

  let optionPaths = [dotenvPath] // default, look for .env
  if (options && options.path) {
    if (!Array.isArray(options.path)) {
      optionPaths = [_resolveHome(options.path)]
    } else {
      optionPaths = [] // reset default
      for (const filepath of options.path) {
        optionPaths.push(_resolveHome(filepath))
      }
    }
  }

  // Build the parsed data in a temporary object (because we need to return it).  Once we have the final
  // parsed data, we will combine it with process.env (or options.processEnv if provided).
  let lastError
  const parsedAll = {}
  for (const path of optionPaths) {
    try {
      // Specifying an encoding returns a string instead of a buffer
      const parsed = DotenvModule.parse(fs.readFileSync(path, { encoding }))

      DotenvModule.populate(parsedAll, parsed, options)
    } catch (e) {
      if (debug) {
        _debug(`Failed to load ${path} ${e.message}`)
      }
      lastError = e
    }
  }

  let processEnv = process.env
  if (options && options.processEnv != null) {
    processEnv = options.processEnv
  }

  DotenvModule.populate(processEnv, parsedAll, options)

  if (lastError) {
    return { parsed: parsedAll, error: lastError }
  } else {
    return { parsed: parsedAll }
  }
}

// Populates process.env from .env file
/**
 * Configures the environment using either the default dotenv module or a vault file based on the options provided.
 *
 * @param {Object} options - Configuration options for the dotenv setup.
 * @param {string} [options.DOTENV_KEY] - The key used to access the vault file. If not set, the default dotenv module will be used.
 * @returns {Promise<Object>} - A promise that resolves with the configuration object or rejects with an error if something goes wrong.
 *
 * @throws {Error} - Throws an error if the DOTENV_KEY is provided but the .env.vault file does not exist at the specified path.
 */
function config (options) {
  // fallback to original dotenv if DOTENV_KEY is not set
  if (_dotenvKey(options).length === 0) {
    return DotenvModule.configDotenv(options)
  }

  const vaultPath = _vaultPath(options)

  // dotenvKey exists but .env.vault file does not exist
  if (!vaultPath) {
    _warn(`You set DOTENV_KEY but you are missing a .env.vault file at ${vaultPath}. Did you forget to build it?`)

    return DotenvModule.configDotenv(options)
  }

  return DotenvModule._configVault(options)
}

/**
 * Decrypts an encrypted string using AES-256-GCM algorithm with provided key.
 *
 * @param {string} encrypted - The base64 encoded encrypted string to be decrypted.
 * @param {string} keyStr - The hex string representation of the encryption key. Must be at least 64 characters long.
 * @returns {string} The decrypted string.
 * @throws {Error} If the key length is invalid or decryption fails, throws a specific error with code and message.
 *
 * Example:
 * const encryptedString = 'your_encrypted_string_here';
 * const dotenvKey = 'your_dotenv_key_here';
 * try {
 *   const decryptedString = decrypt(encryptedString, dotenvKey);
 *   console.log(decryptedString);
 * } catch (error) {
 *   console.error('Decryption error:', error.message);
 * }
 */
function decrypt (encrypted, keyStr) {
  const key = Buffer.from(keyStr.slice(-64), 'hex')
  let ciphertext = Buffer.from(encrypted, 'base64')

  const nonce = ciphertext.subarray(0, 12)
  const authTag = ciphertext.subarray(-16)
  ciphertext = ciphertext.subarray(12, -16)

  try {
    const aesgcm = crypto.createDecipheriv('aes-256-gcm', key, nonce)
    aesgcm.setAuthTag(authTag)
    return `${aesgcm.update(ciphertext)}${aesgcm.final()}`
  } catch (error) {
    const isRange = error instanceof RangeError
    const invalidKeyLength = error.message === 'Invalid key length'
    const decryptionFailed = error.message === 'Unsupported state or unable to authenticate data'

    if (isRange || invalidKeyLength) {
      const err = new Error('INVALID_DOTENV_KEY: It must be 64 characters long (or more)')
      err.code = 'INVALID_DOTENV_KEY'
      throw err
    } else if (decryptionFailed) {
      const err = new Error('DECRYPTION_FAILED: Please check your DOTENV_KEY')
      err.code = 'DECRYPTION_FAILED'
      throw err
    } else {
      throw error
    }
  }
}

// Populate process.env with parsed values
/**
 * Populates `process.env` with values from the parsed object.
 *
 * @param {Object} processEnv - The `process.env` object to be populated.
 * @param {Object} parsed - The object containing the new environment variables to set.
 * @param {Object} [options={}] - Options for the population process.
 * @param {boolean} [options.debug=false] - If true, logs debug information about the population process.
 * @param {boolean} [options.override=false] - If true, overrides existing environment variables with new values.
 * @returns {void}
 * @throws {Error} Throws an error if `processEnv` is not an object.
 *
 * Example:
 * populate(process.env, { NODE_ENV: 'development' }, { debug: true });
 */
function populate (processEnv, parsed, options = {}) {
  const debug = Boolean(options && options.debug)
  const override = Boolean(options && options.override)

  if (typeof parsed !== 'object') {
    const err = new Error('OBJECT_REQUIRED: Please check the processEnv argument being passed to populate')
    err.code = 'OBJECT_REQUIRED'
    throw err
  }

  // Set process.env
  for (const key of Object.keys(parsed)) {
    if (Object.prototype.hasOwnProperty.call(processEnv, key)) {
      if (override === true) {
        processEnv[key] = parsed[key]
      }

      if (debug) {
        if (override === true) {
          _debug(`"${key}" is already defined and WAS overwritten`)
        } else {
          _debug(`"${key}" is already defined and was NOT overwritten`)
        }
      }
    } else {
      processEnv[key] = parsed[key]
    }
  }
}

const DotenvModule = {
  configDotenv,
  _configVault,
  _parseVault,
  config,
  decrypt,
  parse,
  populate
}

module.exports.configDotenv = DotenvModule.configDotenv
module.exports._configVault = DotenvModule._configVault
module.exports._parseVault = DotenvModule._parseVault
module.exports.config = DotenvModule.config
module.exports.decrypt = DotenvModule.decrypt
module.exports.parse = DotenvModule.parse
module.exports.populate = DotenvModule.populate

module.exports = DotenvModule
