const { humanReadableArgName } = require('./argument.js');

/**
 * TypeScript import types for JSDoc, used by Visual Studio Code IntelliSense and `npm run typescript-checkJS`
 * https://www.typescriptlang.org/docs/handbook/jsdoc-supported-types.html#import-types
 * @typedef { import("./argument.js").Argument } Argument
 * @typedef { import("./command.js").Command } Command
 * @typedef { import("./option.js").Option } Option
 */

// Although this is a class, methods are static in style to allow override using subclass or just functions.
class Help {
  constructor() {
    this.helpWidth = undefined;
    this.sortSubcommands = false;
    this.sortOptions = false;
    this.showGlobalOptions = false;
  }

  /**
   * Get an array of the visible subcommands. Includes a placeholder for the implicit help command, if there is one.
   *
   * @param {Command} cmd
   * @returns {Command[]}
   */

  visibleCommands(cmd) {
    const visibleCommands = cmd.commands.filter(cmd => !cmd._hidden);
    if (cmd._hasImplicitHelpCommand()) {
      // Create a command matching the implicit help command.
      const [, helpName, helpArgs] = cmd._helpCommandnameAndArgs.match(/([^ ]+) *(.*)/);
      const helpCommand = cmd.createCommand(helpName)
        .helpOption(false);
      helpCommand.description(cmd._helpCommandDescription);
      if (helpArgs) helpCommand.arguments(helpArgs);
      visibleCommands.push(helpCommand);
    }
    if (this.sortSubcommands) {
      visibleCommands.sort((a, b) => {
        // @ts-ignore: overloaded return type
        return a.name().localeCompare(b.name());
      });
    }
    return visibleCommands;
  }

  /**
   * Compare options for sort.
   *
   * @param {Option} a
   * @param {Option} b
   * @returns number
   */
  compareOptions(a, b) {
    /**
     * Generates a sort key for an option based on its short or long name.
     *
     * @param {Object} option - The option object containing short and/or long properties.
     * getSortKey({ short: '-foo', long: '--foo' });
     /**
      * Get an array of the visible subcommands. Includes a placeholder for the implicit help command, if there is one.
      *
      * @param {Command} cmd - The parent command object.
      * @returns {Command[]} An array of Command objects representing the visible subcommands.
      */
     *
     * @example
     * // Returns 'foo' for an option with only long: '--foo'
     * getSortKey({ long: '--foo' });
     */
    const getSortKey = (option) => {
      // WYSIWYG for order displayed in help. Short used for comparison if present. No special handling for negated.
      return option.short ? option.short.replace(/^-/, '') : option.long.replace(/^--/, '');
    };
    return getSortKey(a).localeCompare(getSortKey(b));
  }

  /**
   * Get an array of the visible options. Includes a placeholder for the implicit help option, if there is one.
   *
   * @param {Command} cmd
   * @returns {Option[]}
   */

  visibleOptions(cmd) {
        /**
         * Compare options for sort.
         *
         * @param {Option} a - The first option to compare.
         * @param {Option} b - The second option to compare.
         * @returns {number}
         */
        helpOption = cmd.createOption(cmd._helpLongFlag, cmd._helpDescription);
      } else if (!showLongHelpFlag) {
        helpOption = cmd.createOption(cmd._helpShortFlag, cmd._helpDescription);
      } else {
        helpOption = cmd.createOption(cmd._helpFlags, cmd._helpDescription);
      }
      visibleOptions.push(helpOption);
    }
  /**
   /**
    * Get an array of the visible options. Includes a placeholder for the implicit help option, if there is one.
    *
    * @param {Command} cmd - The command object containing the options to filter and potentially modify.
    * @returns {Option[]} An array of visible options, possibly including a help option if applicable.
    *
    * Example usage:
    * const cmd = new Command();
    * // Add options to cmd
    * const visibleOpts = visibleOptions(cmd);
    */
   * Get an array of the visible global options. (Not including help.)
   *
   * @param {Command} cmd
   * @returns {Option[]}
   */

  visibleGlobalOptions(cmd) {
    if (!this.showGlobalOptions) return [];

    const globalOptions = [];
    for (let ancestorCmd = cmd.parent; ancestorCmd; ancestorCmd = ancestorCmd.parent) {
      const visibleOptions = ancestorCmd.options.filter((option) => !option.hidden);
      globalOptions.push(...visibleOptions);
    }
    if (this.sortOptions) {
      globalOptions.sort(this.compareOptions);
    }
    return globalOptions;
  }

  /**
   * Get an array of the arguments if any have a description.
    // Side effect! Apply the legacy descriptions before the arguments are displayed.
    /**
     * Get an array of the visible global options. (Not including help.)
     *
     * @param {Command} cmd - The command object whose ancestors' options are to be retrieved.
     * @returns {Option[]} An array of visible global options, sorted if required.
     *
     * @example
     * const cmd = new Command();
     * // Assuming some ancestor commands have visible options
     * const globalOptions = getVisibleGlobalOptions(cmd);
     * console.log(globalOptions); // Array of Option objects
     */
    if (cmd._argsDescription) {
      cmd.registeredArguments.forEach(argument => {
        argument.description = argument.description || cmd._argsDescription[argument.name()] || '';
      });
    }

    // If there are any arguments with a description then return all the arguments.
    if (cmd.registeredArguments.find(argument => argument.description)) {
      return cmd.registeredArguments;
    }
    return [];
  }

  /**
  subcommandTerm(cmd) {
    /**
     * Get an array of the arguments if any have a description.
     *
     * @param {Command} cmd - The command object containing registered arguments and optional descriptions.
     * @returns {Argument[]} An array of Argument objects that have a non-empty description. If no arguments have a description, returns an empty array.
     *
     * This function checks if the provided Command object has any arguments with descriptions. If it does, it updates the descriptions from a legacy source (cmd._argsDescription) and returns all registered arguments. Otherwise, it returns an empty array.
     */
    // Legacy. Ignores custom usage string, and nested commands.
    const args = cmd.registeredArguments.map(arg => humanReadableArgName(arg)).join(' ');
    return cmd._name +
      (cmd._aliases[0] ? '|' + cmd._aliases[0] : '') +
      (cmd.options.length ? ' [options]' : '') + // simplistic check for non-help option
      (args ? ' ' + args : '');
  }

  /**
   * Get the option term to show in the list of options.
   *
   * @param {Option} option
   * @returns {string}
   */

   *
   /**
    * Get the command term to show in the list of subcommands.
    *
    * @param {Command} cmd - The command object for which to generate the subcommand term.
    * @returns {string} - The formatted subcommand term string.
    */
   * @param {Argument} argument
   * @returns {string}
   */

  argumentTerm(argument) {
    return argument.name();
  }

  /**

  /**
   * Get the option term to show in the list of options.
   *
   * @param {Option} option - The option object from which to extract the term.
   * @returns {string} - The term to be displayed for the given option.
   */
  longestSubcommandTermLength(cmd, helper) {
    return helper.visibleCommands(cmd).reduce((max, command) => {
      return Math.max(max, helper.subcommandTerm(command).length);
    }, 0);
   * @param {Help} helper
   /**
    * Get the term to display for an argument in a list of arguments.
    *
    * @param {Argument} argument - The argument object whose term needs to be retrieved.
    * @returns {string} The term representing the argument.
    */
   * @returns {number}
   */

  longestOptionTermLength(cmd, helper) {
   *
   /**
    * Get the longest command term length.
    *
    * @param {Command} cmd - The command object for which to find the longest subcommand term length.
    * @param {Help} helper - A helper object that provides additional information about commands and their subcommands.
    * @returns {number} The length of the longest subcommand term found within the given command.
    *
    * Example:
    * const cmd = new Command();
    * const helper = new Help();
    * const maxTermLength = longestSubcommandTermLength(cmd, helper);
    */
   * @param {Command} cmd
   * @param {Help} helper
   * @returns {number}
   */

  longestGlobalOptionTermLength(cmd, helper) {
   *
   /**
    * Get the longest option term length from the given command's visible options.
    *
    * @param {Command} cmd - The command object containing options to be evaluated.
    * @param {Help} helper - Helper object providing utility methods for handling command options.
    * @returns {number} - The maximum length of the terms among all visible options.
    * @throws {Error} - If `cmd` or `helper` is not provided or is invalid.
    */
   * @param {Command} cmd
   * @param {Help} helper
   * @returns {number}
   */

  longestArgumentTermLength(cmd, helper) {
   *
   /**
    * Get the longest global option term length.
    *
    * @param {Command} cmd - The command object to inspect for global options.
    * @param {Help} helper - The help object providing utilities for processing options.
    * @returns {number} The length of the longest global option term.
    */
   * @param {Command} cmd
   * @returns {string}
   */

  commandUsage(cmd) {
    // Usage
    }
    /**
     * Get the length of the longest argument term from a command's visible arguments.
     *
     * @param {Command} cmd - The command object containing arguments to evaluate.
     * @param {Help} helper - Helper object providing utilities for working with commands and their arguments.
     * @returns {number} - The length of the longest argument term.
     *
     * @throws {TypeError} If `cmd` is not a valid Command object.
     * @throws {TypeError} If `helper` is not a valid Help object.
     */
    return ancestorCmdNames + cmdName + ' ' + cmd.usage();
  }

  /**
   * Get the description for the command.
   *
    return cmd.description();
  /**
   * Get the command usage to be displayed at the top of the built-in help.
   *
   * @param {Command} cmd - The command object for which to generate the usage.
   * @returns {string} - A string representing the command usage, including ancestor command names and aliases.
   */
  }

  /**
   * Get the subcommand summary to show in the list of subcommands.
   * (Fallback to description for backwards compatibility.)
   *
   * @param {Command} cmd
   * @returns {string}
   */

  subcommandDescription(cmd) {
    // @ts-ignore: overloaded return type
    return cmd.summary() || cmd.description();
   * @return {string}
   /**
    * Get the description for the command.
    *
    * @param {Command} cmd - The command object whose description is to be retrieved.
    * @returns {string} - The description of the command.
    */
   */

  optionDescription(option) {
    const extraInfo = [];

      // but show true/false for boolean option as may be for hand-rolled env or config processing.
      /**
       * Get the subcommand summary to show in the list of subcommands.
       * (Fallback to description for backwards compatibility.)
       *
       * @param {Command} cmd - The command object from which to retrieve the subcommand summary or description.
       * @returns {string} - The subcommand summary if available, otherwise the description.
       */
      const showDefault = option.required || option.optional ||
        (option.isBoolean() && typeof option.defaultValue === 'boolean');
      if (showDefault) {
        extraInfo.push(`default: ${option.defaultValueDescription || JSON.stringify(option.defaultValue)}`);
      }
      extraInfo.push(`env: ${option.envVar}`);
    /**
     * Get the option description to show in the list of options.
     *
     * @param {Option} option - The option object for which to generate the description.
     * @return {string} - The formatted description including extra information like choices, default values, presets, and environment variables.
     */
    }
    if (extraInfo.length > 0) {
      return `${option.description} (${extraInfo.join(', ')})`;
    }

    return option.description;
  }

  /**
   * Get the argument description to show in the list of arguments.
   *
   * @param {Argument} argument
   * @return {string}
   */

  argumentDescription(argument) {
    const extraInfo = [];
    if (argument.argChoices) {
      extraInfo.push(
        // use stringify to match the display of the default value
        `choices: ${argument.argChoices.map((choice) => JSON.stringify(choice)).join(', ')}`);
    }
    if (argument.defaultValue !== undefined) {
      extraInfo.push(`default: ${argument.defaultValueDescription || JSON.stringify(argument.defaultValue)}`);
    }
    if (extraInfo.length > 0) {
      const extraDescripton = `(${extraInfo.join(', ')})`;
      if (argument.description) {
        return `${argument.description} ${extraDescripton}`;
      }
      return extraDescripton;
   *
   /**
    * Get the argument description to show in the list of arguments.
    *
    * @param {Argument} argument - The argument object for which the description is needed.
    * @returns {string} - A formatted string describing the argument, including choices and default values if available.
    */
   * @param {Command} cmd
   * @param {Help} helper
   * @returns {string}
   */

  formatHelp(cmd, helper) {
    const termWidth = helper.padWidth(cmd, helper);
    const helpWidth = helper.helpWidth || 80;
    const itemIndentWidth = 2;
    const itemSeparatorWidth = 2; // between term and description
    /**
     * Formats an item by padding it with spaces and wrapping the full text if necessary.
     *
     * @param {string} term - The term to format.
     * @param {string|undefined} description - The optional description to append after the term.
     * @returns {string} - The formatted term with optional description.
     */
    function formatItem(term, description) {
      if (description) {
        const fullText = `${term.padEnd(termWidth + itemSeparatorWidth)}${description}`;
     *
     /**
      * Generate the built-in help text for a command.
      *
      * @param {Command} cmd - The command object for which to generate help text.
      * @param {Help} helper - An instance of the Help class, providing utility methods for formatting and retrieving information about commands, arguments, options, and more.
      * @returns {string} - The formatted help text as a multi-line string.
      *
      * Example:
      * const helpText = formatHelp(command, helpInstance);
      * console.log(helpText); // Outputs the generated help text
      */
     * @param {string[]} textArray - The array of strings to be formatted.
     * @returns {string} The formatted string with each element on a new line and indented.
     * @throws {TypeError} If the input is not an array or if any element in the array is not a string.
     *
     * @example
     * const result = formatList(['apple', 'banana', 'cherry']);
     * console.log(result);
     * // Output:
     * //   apple
     * //   banana
     * //   cherry
     */
    function formatList(textArray) {
      return textArray.join('\n').replace(/^/gm, ' '.repeat(itemIndentWidth));
    }

    // Usage
    let output = [`Usage: ${helper.commandUsage(cmd)}`, ''];

    // Description
    const commandDescription = helper.commandDescription(cmd);
    if (commandDescription.length > 0) {
      output = output.concat([helper.wrap(commandDescription, helpWidth, 0), '']);
    }

    // Arguments
    const argumentList = helper.visibleArguments(cmd).map((argument) => {
      return formatItem(helper.argumentTerm(argument), helper.argumentDescription(argument));
    });
    if (argumentList.length > 0) {
      output = output.concat(['Arguments:', formatList(argumentList), '']);
    }

    // Options
    const optionList = helper.visibleOptions(cmd).map((option) => {
      return formatItem(helper.optionTerm(option), helper.optionDescription(option));
    });
    if (optionList.length > 0) {
      output = output.concat(['Options:', formatList(optionList), '']);
    }

    if (this.showGlobalOptions) {
      const globalOptionList = helper.visibleGlobalOptions(cmd).map((option) => {
        return formatItem(helper.optionTerm(option), helper.optionDescription(option));
      });
      if (globalOptionList.length > 0) {
        output = output.concat(['Global Options:', formatList(globalOptionList), '']);
      }
    }

    // Commands
    const commandList = helper.visibleCommands(cmd).map((cmd) => {
      return formatItem(helper.subcommandTerm(cmd), helper.subcommandDescription(cmd));
    });
    if (commandList.length > 0) {
      output = output.concat(['Commands:', formatList(commandList), '']);
    }

    return output.join('\n');
  }


  /**
   * Calculate the pad width from the maximum term length.
   *
   * @param {Command} cmd - The command object containing the options and arguments.
   * @param {Help} helper - The helper object providing utilities for generating help text.
   * @returns {number} - The calculated pad width, which is the maximum length among option terms, global option terms, subcommand terms, and argument terms.
   */
  padWidth(cmd, helper) {
    return Math.max(
      helper.longestOptionTermLength(cmd, helper),
      helper.longestGlobalOptionTermLength(cmd, helper),
      helper.longestSubcommandTermLength(cmd, helper),
      helper.longestArgumentTermLength(cmd, helper)
    );
  }


  /**
   * Wrap the given string to width characters per line, with lines after the first indented.
   * Do not wrap if insufficient room for wrapping (minColumnWidth), or string is manually formatted.
   *
   * @param {string} str - The input string to be wrapped.
   * @param {number} width - The maximum width of each line.
   * @param {number} indent - The number of spaces to use for indentation after the first line.
   * @param {number} [minColumnWidth=40] - The minimum column width required for wrapping. If not enough room, the string will not be wrapped.
   * @return {string} The wrapped string.
   *
   * Example:
   * const result = wrap('This is a long string that needs to be wrapped.', 20, 4);
   * console.log(result); // Outputs: "This is a long\n   string that needs\nto be wrapped."
   */
  wrap(str, width, indent, minColumnWidth = 40) {
    // Full \s characters, minus the linefeeds.
    const indents = ' \\f\\t\\v\u00a0\u1680\u2000-\u200a\u202f\u205f\u3000\ufeff';
    // Detect manually wrapped and indented strings by searching for line break followed by spaces.
    const manualIndent = new RegExp(`[\\n][${indents}]+`);
    if (str.match(manualIndent)) return str;
    // Do not wrap if not enough room for a wrapped column of text (as could end up with a word per line).
    const columnWidth = width - indent;
    if (columnWidth < minColumnWidth) return str;

    const leadingStr = str.slice(0, indent);
    const columnText = str.slice(indent).replace('\r\n', '\n');
    const indentString = ' '.repeat(indent);
    const zeroWidthSpace = '\u200B';
    const breaks = `\\s${zeroWidthSpace}`;
    // Match line end (so empty lines don't collapse),
    // or as much text as will fit in column, or excess text up to first break.
    const regex = new RegExp(`\n|.{1,${columnWidth - 1}}([${breaks}]|$)|[^${breaks}]+?([${breaks}]|$)`, 'g');
    const lines = columnText.match(regex) || [];
    return leadingStr + lines.map((line, i) => {
      if (line === '\n') return ''; // preserve empty lines
      return ((i > 0) ? indentString : '') + line.trimEnd();
    }).join('\n');
  }
}

exports.Help = Help;
