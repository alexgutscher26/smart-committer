const { InvalidArgumentError } = require('./error.js');

class Option {
  /**
   * Initialize a new `Option` with the given `flags` and `description`.
   *
   * @param {string} flags
   * @param {string} [description]
   */

  constructor(flags, description) {
    this.flags = flags;
    this.description = description || '';

    this.required = flags.includes('<'); // A value must be supplied when the option is specified.
    this.optional = flags.includes('['); // A value is optional when the option is specified.
    // variadic test ignores <value,...> et al which might be used to describe custom splitting of single argument
    this.variadic = /\w\.\.\.[>\]]$/.test(flags); // The option can take multiple values.
    this.mandatory = false; // The option must have a value after parsing, which usually means it must be specified on command line.
    const optionFlags = splitOptionFlags(flags);
    this.short = optionFlags.shortFlag;
    this.long = optionFlags.longFlag;
    this.negate = false;
    if (this.long) {
      this.negate = this.long.startsWith('--no-');
    }
    this.defaultValue = undefined;
    this.defaultValueDescription = undefined;
    this.presetArg = undefined;
    this.envVar = undefined;
    this.parseArg = undefined;
    this.hidden = false;
    this.argChoices = undefined;
    this.conflictsWith = [];
    this.implied = undefined;
  }

  /**
   * Set the default value, and optionally supply the description to be displayed in the help.
   *
   * @param {*} value
   * @param {string} [description]
   * @return {Option}

  /**
   * Set the default value, and optionally supply the description to be displayed in the help.
   *
   * @param {*} value - The default value for the option.
   * @param {string} [description] - Optional description to be shown in the help output.
   * @return {Option} - Returns the current Option object for method chaining.
   */
  /**
   * Preset to use when option used without option-argument, especially optional but also boolean and negated.
   * The custom processing (parseArg) is called.
   *
   * @example
   * new Option('--color').default('GREYSCALE').preset('RGB');
  /**
   /**
    * Sets a default value or processing logic when an option is used without an argument.
    *
    * This method allows for customization of how the option should be handled when no value is provided.
    * It supports setting a preset value, boolean options, negated options, and custom parsing functions.
    *
    * @param {*} arg - The default value or processing logic to apply when the option is used without an argument.
    * @return {Option} - The current instance of the Option for method chaining.
    */
   * Add option name(s) that conflict with this option.
   * An error will be displayed if conflicting options are found during parsing.
   *
   * @example
   * new Option('--rgb').conflicts('cmyk');
  /**
   /**
    * Add option name(s) that conflict with this option.
    * An error will be displayed if conflicting options are found during parsing.
    *
    * @param {string | string[]} names - The name or array of names of options that conflict with the current option.
    * @return {Option} - Returns the current Option object, allowing for method chaining.
    */
   * Specify implied option values for when this option is set and the implied options are not.
   *
   * The custom processing (parseArg) is not called on the implied values.
   *
   * @example
    /**
     * Specify implied option values for when this option is set and the implied options are not.
     *
     * The custom processing (parseArg) is not called on the implied values.
     *
     * @param {Object|string} impliedOptionValues - An object where keys are option names and values are their implied values, or a string representing a single option name which will be implied with a value of `true`.
     * @return {Option} The current instance of the Option class to allow method chaining.
     *
     * @example
     * program
     *   .addOption(new Option('--log', 'write logging information to file'))
     *   .addOption(new Option('--trace', 'log extra details').implies({ log: 'trace.txt' }));
     */
    this.implied = Object.assign(this.implied || {}, newImplied);
    return this;
  }

  /**
   * Set environment variable to check for option value.
   *
   * An environment variable is only used if when processed the current option value is
   * undefined, or the source of the current value is 'default' or 'config' or 'env'.
   *
  /**
   /**
    * Set environment variable to check for option value.
    *
    * An environment variable is only used if when processed the current option value is
    * undefined, or the source of the current value is 'default' or 'config' or 'env'.
    *
    * @param {string} name - The name of the environment variable to set.
    * @return {Option}
    */
   * Set the custom handler for processing CLI option arguments into option values.
   *
   * @param {Function} [fn]
   * @return {Option}
   */
  /**
   /**
    * Set the custom handler for processing CLI option arguments into option values.
    *
    * @param {Function} [fn] - A function that takes an array of CLI arguments and returns an object of parsed options. If not provided, the default argument parser will be used.
    * @return {Option} - The current instance of the Option class to allow method chaining.
    *
    * Example:
    * const option = new Option();
    * option.argParser((args) => {
    *   return args.reduce((acc, arg) => {
    *     if (arg.startsWith('--')) {
    *       acc[arg.substring(2)] = true;
    *     } else if (acc._.length > 0) {
    *       acc[acc._.pop()] = arg;
    *     } else {
    *       acc._.push(arg);
    *     }
    *     return acc;
    *   }, { _: [] });
    * });
    */
   * Whether the option is mandatory and must have a value after parsing.
   *
   * @param {boolean} [mandatory=true]
   * @return {Option}
   */
  /**
   /**
    * Sets whether the option is mandatory and must have a value after parsing.
    *
    * @param {boolean} [mandatory=true] - Indicates if the option must be provided with a value. Defaults to true.
    * @return {Option} - The current Option object, allowing for method chaining.
    *
    * Example:
    *   const option = new Option().makeOptionMandatory(false);
    */
   * Hide option in help.
   *
   * @param {boolean} [hide=true]
   * @return {Option}
   */
  /**
   /**
    * Hide option in help.
    *
    * @param {boolean} [hide=true] - Whether to hide the help option. Defaults to true.
    * @return {Option} - The current Option instance, allowing method chaining.
    */
   * @api private
   */

  _concatValue(value, previous) {
    if (previous === this.defaultValue || !Array.isArray(previous)) {
    return previous.concat(value);
  /**
   * Concatenates a new value to an existing array or returns a new array containing the value if the previous value is not an array.
   *
   * @private
   * @param {any} value - The new value to be concatenated.
   * @param {any} previous - The previous value, which should ideally be an array. If it's not, a new array with the value will be returned.
   * @returns {Array<any>} A new array containing the concatenated values or just the value if the previous value was not an array.
   *
   * Example usage:
   * _concatValue(42, [1, 2, 3]); // returns [1, 2, 3, 42]
   * _concatValue('a', 'b'); // returns ['b', 'a']
   */
  }

  /**
   * Only allow option value to be one of choices.
   *
   * @param {string[]} values
   * @return {Option}
   */
      }
      /**
       * Only allow option value to be one of choices.
       *
       * @param {string[]} values - An array of strings representing the allowed options.
       * @return {Option} The current instance of Option, allowing method chaining.
       * @throws {InvalidArgumentError} If the provided argument is not in the list of allowed choices.
       *
       * Example:
       *   const option = new Option();
       *   option.choices(['option1', 'option2']);
       *   // Throws an error if arg is not 'option1' or 'option2'
       */
      if (this.variadic) {
        return this._concatValue(arg, previous);
      }
      return arg;
    };
    return this;
  }

  /**
   * Return option name.
   *
   * @return {string}
   */

  }
/**
 * Returns the option name.
 *
 * @return {string} - The parsed option name without leading '--' for long options or '-' for short options.
 */

  /**
   * Return option name, in a camelcase format that can be used
   * as a object attribute key.
   *
   * @return {string}
   * @api private
   * Check if `arg` matches the short or long flag.
   /**
    * Return option name, in a camelcase format that can be used as a object attribute key.
    *
    * @return {string} - The attribute name in camelcase format.
    * @api private
    */
   *
   * @param {string} arg
   * @return {boolean}
   * @api private
   * Return whether a boolean option.
   /**
    * Check if `arg` matches the short or long flag.
    *
    * @param {string} arg - The argument to check against the short or long flag.
    * @return {boolean} - Returns true if `arg` matches either the short or long flag, otherwise false.
    * @api private
    */
   *
   * Options are one of boolean, negated, required argument, or optional argument.
   *
   * @return {boolean}
/**
 /**
  * Determines if an option is of type boolean.
  *
  * This method checks whether the option does not require any arguments and is not negated,
  * indicating it is a simple boolean flag. It returns true if all these conditions are met, otherwise false.
  *
  * @return {boolean} - True if the option is a boolean flag, false otherwise.
  * @api private
  */
 * This class is to make it easier to work with dual options, without changing the existing
 * implementation. We support separate dual options for separate positive and negative options,
 * like `--build` and `--no-build`, which share a single option value. This works nicely for some
 * use cases, but is tricky for others where we want separate behaviours despite
 * the single shared option value.
 */
class DualOptions {
  /**
   * @param {Option[]} options
   */
  constructor(options) {
    this.positiveOptions = new Map();
    this.negativeOptions = new Map();
    this.dualOptions = new Set();
    options.forEach(option => {
      if (option.negate) {
        this.negativeOptions.set(option.attributeName(), option);
      } else {
        this.positiveOptions.set(option.attributeName(), option);
      }
    });
    this.negativeOptions.forEach((value, key) => {
      if (this.positiveOptions.has(key)) {
        this.dualOptions.add(key);
      }
    });
  }

  /**
   * Did the value come from the option, and not from possible matching dual option?
   *
   * @param {*} value
   * @param {Option} option
   * @returns {boolean}
    /**
     * Determines if the given value originated from the specified option,
     * rather than from a potential dual option match.
     *
     * @param {*} value - The value to be checked.
     * @param {Option} option - The option associated with the value.
     * @returns {boolean} - Returns true if the value came from the option, false otherwise.
     */
    const negativeValue = (preset !== undefined) ? preset : false;
    return option.negate === (negativeValue === value);
  }
}


/**
 * Convert string from kebab-case to camelCase.
 *
 * @param {string} str - The input string in kebab-case format.
 * @return {string} The converted string in camelCase format.
 * @api private
 */
function camelcase(str) {
  return str.split('-').reduce((str, word) => {
    return str + word[0].toUpperCase() + word.slice(1);
  });
}


/**
 * Split the short and long flag out of something like '-m,--mixed <value>'
 *
 * @api private
 * @param {string} flags - The string containing the option flags to be split.
 * @returns {{shortFlag: ?string, longFlag: ?string}} An object containing the short and long flags. If no short flag is present, `shortFlag` will be `undefined`.
 *
 * @example
 * const result = splitOptionFlags('-m,--mixed <value>');
 * console.log(result); // { shortFlag: '-m', longFlag: '--mixed' }
 */
function splitOptionFlags(flags) {
  let shortFlag;
  let longFlag;
  // Use original very loose parsing to maintain backwards compatibility for now,
  // which allowed for example unintended `-sw, --short-word` [sic].
  const flagParts = flags.split(/[ |,]+/);
  if (flagParts.length > 1 && !/^[[<]/.test(flagParts[1])) shortFlag = flagParts.shift();
  longFlag = flagParts.shift();
  // Add support for lone short flag without significantly changing parsing!
  if (!shortFlag && /^-[^-]$/.test(longFlag)) {
    shortFlag = longFlag;
    longFlag = undefined;
  }
  return { shortFlag, longFlag };
}

exports.Option = Option;
exports.splitOptionFlags = splitOptionFlags;
exports.DualOptions = DualOptions;
