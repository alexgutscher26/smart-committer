const { InvalidArgumentError } = require('./error.js');

class Option {
  /**
   * Initialize a new `Option` with the given `flags` and `description`.
   *
   * @param {string} flags
   * @param {string} [description]
   */

  constructor(flags, description) {
    this.flags = flags;
    this.description = description || '';

    this.required = flags.includes('<'); // A value must be supplied when the option is specified.
    this.optional = flags.includes('['); // A value is optional when the option is specified.
    // variadic test ignores <value,...> et al which might be used to describe custom splitting of single argument
    this.variadic = /\w\.\.\.[>\]]$/.test(flags); // The option can take multiple values.
    this.mandatory = false; // The option must have a value after parsing, which usually means it must be specified on command line.
    const optionFlags = splitOptionFlags(flags);
    this.short = optionFlags.shortFlag;
    this.long = optionFlags.longFlag;
    this.negate = false;
    if (this.long) {
      this.negate = this.long.startsWith('--no-');
    }
    this.defaultValue = undefined;
    this.defaultValueDescription = undefined;
    this.presetArg = undefined;
    this.envVar = undefined;
    this.parseArg = undefined;
    this.hidden = false;
    this.argChoices = undefined;
    this.conflictsWith = [];
    this.implied = undefined;
  }

  /**
   * Set the default value, and optionally supply the description to be displayed in the help.
   *
    this.defaultValueDescription = description;
    /**
     * Set the default value, and optionally supply the description to be displayed in the help.
     *
     * @param {*} value - The default value for the option.
     * @param {string} [description] - Optional. A description of the option to be shown in help outputs.
     * @return {Option} - The current Option instance, allowing method chaining.
     */
    return this;
  }

  /**
   * Preset to use when option used without option-argument, especially optional but also boolean and negated.
   * The custom processing (parseArg) is called.
    return this;
  /**
   * Sets the preset value to use when the option is used without an argument.
   * This method can handle optional boolean or negated options, as well as custom processing via a parseArg function.
   *
   * @param {*} arg - The preset value to be set.
   * @return {Option} - Returns the current Option instance for method chaining.
   */
  }

  /**
   * Add option name(s) that conflict with this option.
   * An error will be displayed if conflicting options are found during parsing.
    return this;
  /**
   * Add option name(s) that conflict with this option.
   * An error will be displayed if conflicting options are found during parsing.
   *
   * @param {string | string[]} names - The name or array of names of the options that conflict with this one.
   * @returns {Option} - Returns the current Option object to allow method chaining.
   *
   * @example
   * new Option('--rgb').conflicts('cmyk');
   * new Option('--js').conflicts(['ts', 'jsx']);
   */
  }

  /**
   * Specify implied option values for when this option is set and the implied options are not.
   *
      /**
       * Specify implied option values for when this option is set and the implied options are not.
       *
       * The custom processing (parseArg) is not called on the implied values.
       *
       * @param {Object|string} impliedOptionValues - An object mapping option names to their values, or a string representing a single option name that should be implied when this option is set. If a string is provided, it will be converted to an object with the string as the key and `true` as the value.
       * @returns {Option} The current Option instance, allowing method chaining.
       *
       * @example
       * program
       *   .addOption(new Option('--log', 'write logging information to file'))
       *   .addOption(new Option('--trace', 'log extra details').implies({ log: 'trace.txt' }));
       */
      // string is not documented, but easy mistake and we can do what user probably intended.
      newImplied = { [impliedOptionValues]: true };
    }
    this.implied = Object.assign(this.implied || {}, newImplied);
    return this;
  }

  /**
   * Set environment variable to check for option value.
   *
    return this;
  /**
   * Set environment variable to check for option value.
   *
   * An environment variable is only used if when processed the current option value is
   * undefined, or the source of the current value is 'default' or 'config' or 'env'.
   *
   * @param {string} name - The name of the environment variable to check.
   * @return {Option} - The instance of the Option class with the environment variable set.
   */
  }

  /**
   * Set the custom handler for processing CLI option arguments into option values.
   *
    return this;
  /**
   * Set the custom handler for processing CLI option arguments into option values.
   *
   * @param {Function} [fn] - The custom handler function that processes CLI option arguments. If not provided, the default handler will be used.
   * @return {Option} - The current instance of Option, allowing method chaining.
   *
   * Example usage:
   * ```
   * const option = new Option();
   * option.argParser((args) => {
   *   // Custom processing logic here
   *   return processedArgs;
   * });
   * ```
   */
  }

  /**
   * Whether the option is mandatory and must have a value after parsing.
   *
    return this;
  /**
   * Sets whether the option is mandatory and must have a value after parsing.
   *
   * @param {boolean} [mandatory=true] - Whether the option is mandatory. Default is true.
   * @return {Option} - The current instance of Option, allowing for method chaining.
   */
  }

  /**
   * Hide option in help.
   *
    return this;
  /**
   * Hide option in help.
   *
   * @param {boolean} [hide=true] - Whether to hide the option in help. Defaults to true.
   * @return {Option} - The current instance of Option, allowing for method chaining.
   */
  }

  /**
   * @api private
   */
      return [value];
    /**
     * Concatenates a new value to an existing array or initializes with a new array if the previous value is the default.
     *
     * @private
     * @param {*} value - The value to concatenate.
     * @param {*|Array} previous - The previous value, which should be either the default value or an array.
     * @returns {Array} A new array containing the concatenated values.
     * @throws {TypeError} If `previous` is not an array and not equal to the default value.
     */
    }

    return previous.concat(value);
  }

  /**
   * Only allow option value to be one of choices.
   *
    this.parseArg = (arg, previous) => {
      /**
       * Limits the option value to one of the specified choices.
       *
       * @param {string[]} values - An array of strings representing the allowed choices for the option.
       * @return {Option} - The current instance of the Option class, allowing method chaining.
       * @throws {InvalidArgumentError} - Throws an error if the provided argument is not one of the allowed choices.
       *
       * Example:
       * ```javascript
       * options.choices(['option1', 'option2']).parseArg('option1');
       * ```
       */
      if (!this.argChoices.includes(arg)) {
        throw new InvalidArgumentError(`Allowed choices are ${this.argChoices.join(', ')}.`);
      }
      if (this.variadic) {
        return this._concatValue(arg, previous);
      }
      return arg;
    };
    return this;
  }

  /**
   * Return option name.
   *
      return this.long.replace(/^--/, '');
    /**
     * Returns the option name by removing any leading '--' for long options or '-' for short options.
     *
     * @return {string} The cleaned option name.
     */
    }
    return this.short.replace(/^-/, '');
  }

  /**
   * Return option name, in a camelcase format that can be used
   * as a object attribute key.
  }
/**
 * Return option name, in a camelcase format that can be used
 * as a object attribute key.
 *
 * @return {string} - The camelcased version of the option name.
 * @api private
 */

  /**
   * Check if `arg` matches the short or long flag.
   *
  }
/**
 * Check if `arg` matches the short or long flag.
 *
 * @param {string} arg - The argument to check against the short and long flags.
 * @return {boolean} - Returns true if `arg` matches either the short or long flag, otherwise false.
 * @api private
 */

  /**
   * Return whether a boolean option.
   *
  }
/**
 * Determine if an option is a boolean type.
 *
 * A boolean option does not require any arguments; it is simply present or absent. It cannot be negated, required with an argument, or optional with an argument.
 *
 * @return {boolean} - Returns true if the option is a boolean type (not required and not negatable), otherwise false.
 * @api private
 */
}

/**
 * This class is to make it easier to work with dual options, without changing the existing
 * implementation. We support separate dual options for separate positive and negative options,
 * like `--build` and `--no-build`, which share a single option value. This works nicely for some
 * use cases, but is tricky for others where we want separate behaviours despite
 * the single shared option value.
 */
class DualOptions {
  /**
   * @param {Option[]} options
   */
  constructor(options) {
    this.positiveOptions = new Map();
    this.negativeOptions = new Map();
    this.dualOptions = new Set();
    options.forEach(option => {
      if (option.negate) {
        this.negativeOptions.set(option.attributeName(), option);
      } else {
        this.positiveOptions.set(option.attributeName(), option);
      }
    });
    this.negativeOptions.forEach((value, key) => {
      if (this.positiveOptions.has(key)) {
        this.dualOptions.add(key);
      }
    });
  }

  /**
   * Did the value come from the option, and not from possible matching dual option?
   *
/**
 * Determines whether a given value originated from an option or potentially from a matching dual option.
 *
 * @param {*} value - The value to be checked.
 * @param {Option} option - The option object that might have produced the value.
 * @returns {boolean} - Returns true if the value came from the option, otherwise false.
 *
 * @example
 * const myOption = new Option('myAttribute', 'myValue');
 * const result = valueFromOption(true, myOption);
 * console.log(result); // Output: true or false based on the implementation details
 */

    // Use the value to deduce if (probably) came from the option.
    const preset = this.negativeOptions.get(optionKey).presetArg;
    const negativeValue = (preset !== undefined) ? preset : false;
    return option.negate === (negativeValue === value);
  }
}


/**
 * Convert string from kebab-case to camelCase.
 *
 * @param {string} str - The input string in kebab-case format.
 * @return {string} - The converted string in camelCase format.
 * @api private
 */
function camelcase(str) {
  return str.split('-').reduce((str, word) => {
    return str + word[0].toUpperCase() + word.slice(1);
  });
}


/**
 * Split the short and long flag out of something like '-m,--mixed <value>'
 *
 * @api private
 *
 * @param {string} flags - The input string containing the short and long flags.
 * @returns {{shortFlag: ?string, longFlag: ?string}} An object containing the split short and long flags.
 */
function splitOptionFlags(flags) {
  let shortFlag;
  let longFlag;
  // Use original very loose parsing to maintain backwards compatibility for now,
  // which allowed for example unintended `-sw, --short-word` [sic].
  const flagParts = flags.split(/[ |,]+/);
  if (flagParts.length > 1 && !/^[[<]/.test(flagParts[1])) shortFlag = flagParts.shift();
  longFlag = flagParts.shift();
  // Add support for lone short flag without significantly changing parsing!
  if (!shortFlag && /^-[^-]$/.test(longFlag)) {
    shortFlag = longFlag;
    longFlag = undefined;
  }
  return { shortFlag, longFlag };
}

exports.Option = Option;
exports.splitOptionFlags = splitOptionFlags;
exports.DualOptions = DualOptions;
