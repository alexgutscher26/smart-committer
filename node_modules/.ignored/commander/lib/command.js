const EventEmitter = require('events').EventEmitter;
const childProcess = require('child_process');
const path = require('path');
const fs = require('fs');
const process = require('process');

const { Argument, humanReadableArgName } = require('./argument.js');
const { CommanderError } = require('./error.js');
const { Help } = require('./help.js');
const { Option, splitOptionFlags, DualOptions } = require('./option.js');
const { suggestSimilar } = require('./suggestSimilar');

class Command extends EventEmitter {
  /**
   * Initialize a new `Command`.
   *
   * @param {string} [name]
   */

  constructor(name) {
    super();
    /** @type {Command[]} */
    this.commands = [];
    /** @type {Option[]} */
    this.options = [];
    this.parent = null;
    this._allowUnknownOption = false;
    this._allowExcessArguments = true;
    /** @type {Argument[]} */
    this.registeredArguments = [];
    this._args = this.registeredArguments; // deprecated old name
    /** @type {string[]} */
    this.args = []; // cli args with options removed
    this.rawArgs = [];
    this.processedArgs = []; // like .args but after custom processing and collecting variadic
    this._scriptPath = null;
    this._name = name || '';
    this._optionValues = {};
    this._optionValueSources = {}; // default, env, cli etc
    this._storeOptionsAsProperties = false;
    this._actionHandler = null;
    this._executableHandler = false;
    this._executableFile = null; // custom name for executable
    this._executableDir = null; // custom search directory for subcommands
    this._defaultCommandName = null;
    this._exitCallback = null;
    this._aliases = [];
    this._combineFlagAndOptionalValue = true;
    this._description = '';
    this._summary = '';
    this._argsDescription = undefined; // legacy
    this._enablePositionalOptions = false;
    this._passThroughOptions = false;
    this._lifeCycleHooks = {}; // a hash of arrays
    /** @type {boolean | string} */
    this._showHelpAfterError = false;
    this._showSuggestionAfterError = true;

    // see .configureOutput() for docs
    this._outputConfiguration = {
      writeOut: (str) => process.stdout.write(str),
      writeErr: (str) => process.stderr.write(str),
      getOutHelpWidth: () => process.stdout.isTTY ? process.stdout.columns : undefined,
      getErrHelpWidth: () => process.stderr.isTTY ? process.stderr.columns : undefined,
      outputError: (str, write) => write(str)
    };

    this._hidden = false;
    this._hasHelpOption = true;
    this._helpFlags = '-h, --help';
    this._helpDescription = 'display help for command';
    this._helpShortFlag = '-h';
    this._helpLongFlag = '--help';
    this._addImplicitHelpCommand = undefined; // Deliberately undefined, not decided whether true or false
    this._helpCommandName = 'help';
    this._helpCommandnameAndArgs = 'help [command]';
    this._helpCommandDescription = 'display help for command';
    this._helpConfiguration = {};
  }

  /**
   * Copy settings that are useful to have in common across root command and subcommands.
   *
   * (Used internally when adding a command using `.command()` so subcommands inherit parent settings.)
   *
   * @param {Command} sourceCommand
   * @return {Command} `this` command for chaining
   */
  copyInheritedSettings(sourceCommand) {
    this._outputConfiguration = sourceCommand._outputConfiguration;
    this._hasHelpOption = sourceCommand._hasHelpOption;
    this._helpFlags = sourceCommand._helpFlags;
    this._helpDescription = sourceCommand._helpDescription;
    this._helpShortFlag = sourceCommand._helpShortFlag;
    this._helpLongFlag = sourceCommand._helpLongFlag;
    this._helpCommandName = sourceCommand._helpCommandName;
    this._helpCommandnameAndArgs = sourceCommand._helpCommandnameAndArgs;
    this._helpCommandDescription = sourceCommand._helpCommandDescription;
    this._helpConfiguration = sourceCommand._helpConfiguration;
    this._exitCallback = sourceCommand._exitCallback;
    this._storeOptionsAsProperties = sourceCommand._storeOptionsAsProperties;
    this._combineFlagAndOptionalValue = sourceCommand._combineFlagAndOptionalValue;
    this._allowExcessArguments = sourceCommand._allowExcessArguments;
    this._enablePositionalOptions = sourceCommand._enablePositionalOptions;
    this._showHelpAfterError = sourceCommand._showHelpAfterError;
    this._showSuggestionAfterError = sourceCommand._showSuggestionAfterError;

    return this;
  }

  /**
   * @returns {Command[]}
   * @api private
   */

  _getCommandAndAncestors() {
    const result = [];
    for (let command = this; command; command = command.parent) {
      result.push(command);
    }
    return result;
  }

  /**
   * Define a command.
   *
   * There are two styles of command: pay attention to where to put the description.
   *
   * @example
   * // Command implemented using action handler (description is supplied separately to `.command`)
   * program
   *   .command('clone <source> [destination]')
   *   .description('clone a repository into a newly created directory')
   *   .action((source, destination) => {
   *     console.log('clone command called');
   *   });
   *
   * // Command implemented using separate executable file (description is second parameter to `.command`)
   * program
   *   .command('start <service>', 'start named service')
   *   .command('stop [service]', 'stop named service, or all if no name supplied');
   *
   * @param {string} nameAndArgs - command name and arguments, args are `<required>` or `[optional]` and last may also be `variadic...`
   * @param {Object|string} [actionOptsOrExecDesc] - configuration options (for action), or description (for executable)
   * @param {Object} [execOpts] - configuration options (for executable)
   * @return {Command} returns new command for action handler, or `this` for executable command
   */
    /**
     * Copy settings that are useful to have in common across root command and subcommands.
     *
     * @param {Command} sourceCommand - The command from which settings should be copied.
     * @returns {Command} This command instance for method chaining.
     */
    opts = opts || {};
    const [, name, args] = nameAndArgs.match(/([^ ]+) *(.*)/);

    const cmd = this.createCommand(name);
    if (desc) {
      cmd.description(desc);
      cmd._executableHandler = true;
    }
    if (opts.isDefault) this._defaultCommandName = cmd._name;
    cmd._hidden = !!(opts.noHelp || opts.hidden); // noHelp is deprecated old name for hidden
    cmd._executableFile = opts.executableFile || null; // Custom name for executable file, set missing to null to match constructor
    if (args) cmd.arguments(args);
    this.commands.push(cmd);
    cmd.parent = this;
    cmd.copyInheritedSettings(this);

    if (desc) return this;
    return cmd;
  }

  /**
   * Factory routine to create a new unattached command.
   * @param {string} [name]
   /**
    * Retrieves the current command and all its ancestors.
    *
    * @returns {Array<Command>} An array containing the current command and all of its parent commands, ordered from the current to the root command.
    *
    * @api private
    */
   * @return {Command} new command
   */

  createCommand(name) {
    return new Command(name);
  }

  /**

  /**
   * Define a command.
   *
   * There are two styles of command: pay attention to where to put the description.
   *
   * @param {string} nameAndArgs - Command name and arguments, args are `<required>` or `[optional]` and last may also be `variadic...`
   * @param {Object|string} [actionOptsOrExecDesc] - Configuration options (for action), or description (for executable)
   * @param {Object} [execOpts] - Configuration options (for executable)
   * @return {Command} Returns new command for action handler, or `this` for executable command
   */
  /**
   * The default output goes to stdout and stderr. You can customise this for special
   * applications. You can also customise the display of errors by overriding outputError.
   *
   * The configuration properties are all functions:
   *
   *     // functions to change where being written, stdout and stderr
   *     writeOut(str)
   *     writeErr(str)
   *     // matching functions to specify width for wrapping help
   *     getOutHelpWidth()
   *     getErrHelpWidth()
   *     // functions based on what is being written out
   *     outputError(str, write) // used for displaying errors, and not used for displaying help
   *
   * @param {Object} [configuration] - configuration options
   * @return {Command|Object} `this` command for chaining, or stored configuration
   */

  configureOutput(configuration) {
    if (configuration === undefined) return this._outputConfiguration;

    Object.assign(this._outputConfiguration, configuration);
    return this;
  }

  /**
  }
/**
 * Factory routine to create a new unattached command.
 *
 * See .command() for creating an attached subcommand, which uses this routine to
 * create the command. You can override createCommand to customise subcommands.
 *
 * @param {string} [name] - The name of the command. If not provided, a default command will be created.
 * @returns {Command} - A new command instance.
 */

  /**
   * Display suggestion of similar commands for unknown commands, or options for unknown options.
   *
  }
/**
 * You can customise the help with a subclass of Help by overriding createHelp,
 * or by overriding Help properties using configureHelp().
 *
 * @return {Help}
 */

  /**
   * Add a prepared subcommand.
   *
  addCommand(cmd, opts) {
    /**
     * Overrides help properties using configureHelp() or with a subclass of Help by overriding createHelp().
     *
     * @param {Object} [configuration] - Configuration options.
     * @return {Command|Object} The current command for chaining, or the stored configuration object.
     */
    if (!cmd._name) {
      throw new Error(`Command passed to .addCommand() must have a name
- specify the name in Command constructor or using .name()`);
    }

    opts = opts || {};
    if (opts.isDefault) this._defaultCommandName = cmd._name;
  createArgument(name, description) {
    /**
     * Configures the output behavior of the command by setting custom functions for writing to stdout,
     * stderr, and error handling.
     *
     * @param {Object} [configuration] - Optional configuration object containing methods to customize the output.
     *   - `writeOut(str)`: Function to write strings to stdout.
     *   - `writeErr(str)`: Function to write strings to stderr.
     *   - `getOutHelpWidth()`: Function to get the width for wrapping help text in stdout.
     *   - `getErrHelpWidth()`: Function to get the width for wrapping help text in stderr.
     *   - `outputError(str, write)`: Function to handle error output, not used for displaying help.
     *
     * @return {Command|Object} The current command instance for method chaining, or the stored configuration object if no new configuration is provided.
     */
    return new Argument(name, description);
  }

  /**
   * Define argument syntax for command.
   *
   * The default is that the argument is required, and you can explicitly
   /**
    * Display the help or a custom message after an error occurs.
    *
    * @param {boolean|string} [displayHelp=true] - Whether to display the default help message (true) or a custom message (string).
    * @returns {Command} The current command instance for method chaining.
    */
   * @param {string} name
   * @param {string} [description]
   * @param {Function|*} [fn] - custom argument processing function
   * @param {*} [defaultValue]
   * @return {Command} `this` command for chaining
   */
    /**
     * Display suggestion of similar commands for unknown commands, or options for unknown options.
     *
     * @param {boolean} [displaySuggestion=true] - Whether to display suggestions after an error. Default is `true`.
     * @returns {Command} - The current command instance (`this`) to allow method chaining.
     */
    }
    this.addArgument(argument);
    return this;
  }

   * @return {Command} `this` command for chaining
   /**
    * Add a prepared subcommand.
    *
    * See .command() for creating an attached subcommand which inherits settings from its parent.
    *
    * @param {Command} cmd - New subcommand to be added.
    * @param {Object} [opts] - Configuration options for the command. Optional.
    * @return {Command} The current command instance (`this`) for method chaining.
    * @throws {Error} If the command does not have a name, an error is thrown.
    *
    * Example:
    * ```javascript
    * const program = new Command();
    * program.addCommand(new Command('my-command'), { isDefault: true });
    * ```
    */
   */

  arguments(names) {
    names.trim().split(/ +/).forEach((detail) => {
      this.argument(detail);
    });
    return this;
  }

  /**
   * Define argument syntax for command, adding a prepared argument.
   *
   * @param {Argument} argument
   * @return {Command} `this` command for chaining
   */
  }
/**
 * Factory routine to create a new unattached argument.
 *
 * See .argument() for creating an attached argument, which uses this routine to
 * create the argument. You can override createArgument to return a custom argument.
 *
 * @param {string} name - The name of the argument.
 * @param {string} [description] - An optional description of the argument.
 * @return {Argument} - A new argument instance.
 */

  /**
   * Override default decision whether to add implicit help command.
   *
      /**
       * Define argument syntax for command.
       *
       * The default is that the argument is required, and you can explicitly
       * indicate this with <> around the name. Put [] around the name for an optional argument.
       *
       * @param {string} name - The name of the argument.
       * @param {string} [description] - A description of the argument.
       * @param {Function|*} [fn] - Custom argument processing function or default value if no function is provided.
       * @param {*} [defaultValue] - Default value for the argument if it is optional and no value is provided.
       * @return {Command} `this` command for chaining, allowing further method calls on the same instance.
       *
       * @example
       * program.argument('<input-file>');
       * program.argument('[output-file]');
       */
      this._helpCommandDescription = description || this._helpCommandDescription;
    }
    return this;
  }

  /**
   * @return {boolean}
   * @api private
   */

  _hasImplicitHelpCommand() {
   * @return {Command} `this` command for chaining
   /**
    * Define argument syntax for command, adding multiple at once (without descriptions).
    *
    * See also {@link #argument}.
    *
    * @param {string} names - A string containing the names of the arguments separated by spaces.
    * @return {Command} The current command instance (`this`) for method chaining.
    */
   */

  hook(event, listener) {
    const allowedValues = ['preSubcommand', 'preAction', 'postAction'];
    if (!allowedValues.includes(event)) {
      throw new Error(`Unexpected value for event passed to hook : '${event}'.
Expecting one of '${allowedValues.join("', '")}'`);
    /**
     * Adds a prepared argument to the command.
     *
     * @param {Argument} argument - The argument to be added. This should be an instance of Argument class.
     * @return {Command} Returns `this` command object for method chaining.
     * @throws {Error} Throws an error if:
     *   - The last registered argument is already variadic and another argument is being added.
     *   - A required argument has a default value but no custom parsing function.
     *
     * Example:
     *   const command = new Command();
     *   command.addArgument(new Argument({ name: 'input', type: 'string' }));
     */
    return this;
  }

  /**
   * Register callback to use as replacement for calling process.exit.
   *
   * @param {Function} [fn] optional callback which will be passed a CommanderError, defaults to throwing
   * @return {Command} `this` command for chaining
   */

  exitOverride(fn) {
    if (fn) {
    }
    /**
     * Override default decision whether to add implicit help command.
     *
     * @param {boolean|string} enableOrNameAndArgs - If `false`, force the help command off. If a string, specify custom help command details (e.g., 'help [cmd]').
     * @param {string} description - Description for the help command (optional).
     * @return {Command} The current command instance (`this`) for method chaining.
     */
    return this;
  }

  /**
   * Call process.exit, and _exitCallback if defined.
   *
   * @param {number} exitCode exit code for using with process.exit
   * @param {string} code an id string representing the error
   * @param {string} message human-readable description of the error
   * @return never
   * @api private
   */

  _exit(exitCode, code, message) {
    process.exit(exitCode);
  /**
   * Determines whether an implicit help command should be added to the application.
   *
   * @private
   * @returns {boolean} - True if an implicit help command should be added, false otherwise.
   */
  }

  /**
   * Register callback `fn` for the command.
   *
   * @example
   * program
   * @return {Command} `this` command for chaining
   /**
    * Add a listener for a specific lifecycle event.
    *
    * @param {string} event - The lifecycle event to listen for. Must be one of 'preSubcommand', 'preAction', or 'postAction'.
    * @param {Function} listener - The function to call when the specified event is triggered.
    * @return {Command} This command object, allowing for method chaining.
    *
    * @throws {Error} If the provided event is not one of the allowed values.
    *
    * Example usage:
    * ```javascript
    * myCommand.hook('preAction', () => {
    *   console.log('Pre-action hook triggered');
    * });
    * ```
    */
   */

  action(fn) {
    /**
     * A callback function that processes arguments passed to it.
     *
     * @callback listener
     * @param {Array} args - The array of arguments passed to the listener.
     * @returns {*} - The result of applying the provided function with modified arguments.
     */
    const listener = (args) => {
      // The .action callback takes an extra parameter which is the command or options.
      const expectedArgsCount = this.registeredArguments.length;
      const actionArgs = args.slice(0, expectedArgsCount);

      /**
       * Register callback to use as replacement for calling process.exit.
       *
       * @param {Function} [fn] - Optional callback which will be passed a CommanderError, defaults to throwing.
       * @return {Command} - `this` command for chaining.
       */
      return fn.apply(this, actionArgs);
    };
    this._actionHandler = listener;
    return this;
  }

  /**
   * Factory routine to create a new unattached option.
   *
   * See .option() for creating an attached option, which uses this routine to
   * create the option. You can override createOption to return a custom option.
   *
   * @param {string} flags
   * @param {string} [description]
   * @return {Option} new option
   * @param {Option | Argument} target
   /**
    * Calls `process.exit` and `_exitCallback` if defined.
    *
    * @param {number} exitCode - The exit code to be used with `process.exit`.
    * @param {string} code - An ID string representing the error.
    * @param {string} message - A human-readable description of the error.
    * @return {never} This function does not return any value; it terminates the process.
    * @api private
    */
   * @param {string} value
   * @param {*} previous
   * @param {string} invalidArgumentMessage
   * @api private
   */

  _callParseArg(target, value, previous, invalidArgumentMessage) {
    try {
   * @return {Command} `this` command for chaining
   /**
    * Register callback `fn` for the command.
    *
    * @param {Function} fn - The callback function to register. This function will be executed when the command is called. It receives an array of arguments and can return any value.
    * @return {Command} - Returns the current command instance (`this`) to allow method chaining.
    *
    * Example usage:
    *
    * program
    *   .command('serve')
    *   .description('start service')
    *   .action(function() {
    *      // do work here
    *   });
    */
   */
  addOption(option) {
    const oname = option.name();
    const name = option.attributeName();

    // store default value
    if (option.negate) {
      // --no-foo is special and defaults foo to true, unless a --foo option is already defined
      const positiveLongFlag = option.long.replace(/^--no-/, '--');
      if (!this._findOption(positiveLongFlag)) {
        this.setOptionValueWithSource(name, option.defaultValue === undefined ? true : option.defaultValue, 'default');
      }
    } else if (option.defaultValue !== undefined) {
      this.setOptionValueWithSource(name, option.defaultValue, 'default');
    }

    // register the option
    this.options.push(option);
     */
    /**
     * Factory routine to create a new unattached option.
     *
     * See .option() for creating an attached option, which uses this routine to
     * create the option. You can override createOption to return a custom option.
     *
     * @param {string} flags - A string representing the flags associated with the option.
     * @param {string} [description] - An optional string providing a description of the option.
     * @returns {Option} - The newly created option.
     */
    const handleOptionValue = (val, invalidValueMessage, valueSource) => {
      // val is null for optional option used without an optional-argument.
      // val is undefined for boolean and negated option.
      if (val == null && option.presetArg !== undefined) {
      }
/**
 * Wrap parseArgs to catch 'commander.invalidArgument'.
 *
 * @param {Option | Argument} target - The target option or argument to parse.
 * @param {string} value - The value to be parsed.
 * @param {*} previous - The previous value, if any.
 * @param {string} invalidArgumentMessage - A custom message to prepend when an invalid argument is encountered.
 * @api private
 *
 * @returns {*}
 *   The result of the parseArg method, or throws an error if 'commander.invalidArgument' occurs.
 */

      // Fill-in appropriate missing values. Long winded but easy to follow.
      if (val == null) {
        if (option.negate) {
          val = false;
        } else if (option.isBoolean() || option.optional) {
          val = true;
        } else {
          val = ''; // not normal, parseArg might have failed or be a mock function for testing
        }
      }
      this.setOptionValueWithSource(name, val, valueSource);
/**
 * Adds an option to the command.
 *
 * @param {Option} option - The option to add.
 * @return {Command} The current `Command` instance for chaining.
 *
 * This method adds an option to the command and sets up event listeners
 * to handle values provided via the CLI or environment variables. It also
 * stores default values and processes custom parsing if necessary.
 *
 * @throws {Error} If the option is a negated flag (e.g., `--no-foo`) and there is already
 *                 an equivalent non-negated flag (`--foo`), it sets the value of `--foo` to true by default.
 */

    if (option.envVar) {
      this.on('optionEnv:' + oname, (val) => {
        const invalidValueMessage = `error: option '${option.flags}' value '${val}' from env '${option.envVar}' is invalid.`;
        handleOptionValue(val, invalidValueMessage, 'env');
      });
    }

    return this;
  }

  /**
   * Internal implementation shared by .option() and .requiredOption()
   *
   * @api private
   */
  _optionEx(config, flags, description, fn, defaultValue) {
    if (typeof flags === 'object' && flags instanceof Option) {
      throw new Error('To add an Option object use addOption() instead of option() or requiredOption()');
    }
    const option = this.createOption(flags, description);
    option.makeOptionMandatory(!!config.mandatory);
    if (typeof fn === 'function') {
      option.default(defaultValue).argParser(fn);
    } else if (fn instanceof RegExp) {
      // deprecated
      const regex = fn;
      fn = (val, def) => {
        const m = regex.exec(val);
        return m ? m[0] : def;
      };
      option.default(defaultValue).argParser(fn);
    } else {
      option.default(fn);
    }

    return this.addOption(option);
  }

  /**
   * Define option with `flags`, `description`, and optional argument parsing function or `defaultValue` or both.
   *
   * The `flags` string contains the short and/or long flags, separated by comma, a pipe or space. A required
   * option-argument is indicated by `<>` and an optional option-argument by `[]`.
   *
   * See the README for more details, and see also addOption() and requiredOption().
   *
   * @example
   * program
   *     .option('-p, --pepper', 'add pepper')
   *     .option('-p, --pizza-type <TYPE>', 'type of pizza') // required option-argument
   *     .option('-c, --cheese [CHEESE]', 'add extra cheese', 'mozzarella') // optional option-argument with default
   *     .option('-t, --tip <VALUE>', 'add tip to purchase cost', parseFloat) // custom parse function
   *
   * @param {string} flags
   * @param {string} [description]
   * @param {Function|*} [parseArg] - custom option processing function or default value
   * @param {*} [defaultValue]
   * @return {Command} `this` command for chaining
   */

  option(flags, description, parseArg, defaultValue) {
  /**
   * Internal implementation shared by .option() and .requiredOption().
   *
   * @api private
   *
   * @param {Object} config - Configuration object.
   * @param {string|Array|string|Option} flags - Option flags, description or an instance of Option.
   * @param {string} description - Description of the option.
   * @param {Function|RegExp} [fn=undefined] - Function to parse the argument value or a regular expression for deprecated usage.
   * @param {*} [defaultValue=undefined] - Default value for the option.
   *
   * @returns {Object} The current instance of the class, allowing method chaining.
   *
   * @throws {Error} If an Option object is passed to flags and addOption() should be used instead.
   */
  * the option must be specified on the command line. (Otherwise the same as .option().)
  *
  * The `flags` string contains the short and/or long flags, separated by comma, a pipe or space.
  *
  * @param {string} flags
  * @param {string} [description]
  * @param {Function|*} [parseArg] - custom option processing function or default value
  * @param {*} [defaultValue]
  * @return {Command} `this` command for chaining
  */

  requiredOption(flags, description, parseArg, defaultValue) {
    return this._optionEx({ mandatory: true }, flags, description, parseArg, defaultValue);
  }

  /**
   * Alter parsing of short flags with optional values.
   *
   * @example
   * // for `.option('-f,--flag [value]'):
   * program.combineFlagAndOptionalValue(true);  // `-f80` is treated like `--flag=80`, this is the default behaviour
   * program.combineFlagAndOptionalValue(false) // `-fb` is treated like `-f -b`
   *
   * @param {Boolean} [allowExcess=true] - if `true` or omitted, no error will be thrown
   /**
    * Define an option with `flags`, `description`, and optional argument parsing function or `defaultValue` or both.
    *
    * The `flags` string contains the short and/or long flags, separated by comma, a pipe or space. A required
    * option-argument is indicated by `<...>` and an optional option-argument by `[...]`.
    *
    * See the README for more details, and see also addOption() and requiredOption().
    *
    * @param {string} flags - The string containing short and/or long flags.
    * @param {string} [description] - The description of the option.
    * @param {Function|*} [parseArg] - A custom option processing function or a default value.
    * @param {*} [defaultValue] - The default value if the option is not provided.
    * @returns {Command} `this` command for chaining.
    *
    * @example
    * program
    *     .option('-p, --pepper', 'add pepper')
    *     .option('-p, --pizza-type <TYPE>', 'type of pizza') // required option-argument
    *     .option('-c, --cheese [CHEESE]', 'add extra cheese', 'mozzarella') // optional option-argument with default
    *     .option('-t, --tip <VALUE>', 'add tip to purchase cost', parseFloat) // custom parse function
    */
   * for excess arguments.
   */
  allowExcessArguments(allowExcess = true) {
    this._allowExcessArguments = !!allowExcess;
    return this;
  /**
   * Adds a required option which must have a value after parsing. This usually means
   * the option must be specified on the command line. (Otherwise the same as .option().)
   *
   * The `flags` string contains the short and/or long flags, separated by comma, a pipe or space.
   *
   * @param {string} flags - A string containing the short and/or long flags, separated by comma, a pipe or space.
   * @param {string} [description] - Optional description of the option.
   * @param {Function|*} [parseArg] - Custom option processing function or default value. If provided, it should be a function that takes an argument and returns a processed value.
   * @param {*} [defaultValue] - Default value for the option if not specified.
   * @returns {Command} - The current command object (`this`) to allow chaining of method calls.
   *
   * Example:
   * ```
   * program.requiredOption('-f,--file <path>', 'Specify the file path (required)');
   * ```
   */
  }

  /**
   * Pass through options that come after command-arguments rather than treat them as command-options,
      /**
       * Alter parsing of short flags with optional values.
       *
       * @param {boolean} [combine=true] - If `true` or omitted, an optional value can be specified directly after the flag. If `false`, the flag and value must be separate arguments.
       * @returns {this}
       */
      throw new Error('passThroughOptions can not be used without turning on enablePositionalOptions for parent command(s)');
    }
    return this;
  }

    /**
     * Allow unknown options on the command line.
     *
     * @param {Boolean} [allowUnknown=true] - If `true` or omitted, no error will be thrown for unknown options.
     * @returns {Object} The current instance of the class to allow method chaining.
     */
    */

  storeOptionsAsProperties(storeAsProperties = true) {
    if (this.options.length) {
      throw new Error('call .storeOptionsAsProperties() before adding options');
  /**
   * Allow excess command-line arguments. Pass false to make excess arguments an error.
   *
   * @param {Boolean} [allowExcess=true] - If `true` or omitted, no error will be thrown for excess arguments.
   * @return {Object} The current instance of the object, allowing method chaining.
   * @example
   * myObject.allowExcessArguments(false);
   */
  }

  /**
   * Retrieve option value.
   *
    /**
     * Enable or disable positional options. Positional options allow global options to be specified before subcommands,
     * enabling subcommands to reuse option names and turn on passThroughOptions. The default behavior is non-positional,
     * where global options can appear anywhere on the command line.
     *
     * @param {Boolean} [positional=true] - Whether to enable positional options (true) or not (false). Default is true.
     * @returns {Object} - The current instance of the object, allowing for method chaining.
     */
    }
    return this._optionValues[key];
  }

  /**
  /**
   * Pass through options that come after command-arguments rather than treat them as command-options,
   * so actual command-options come before command-arguments. Turning this on for a subcommand requires
   * positional options to have been enabled on the program (parent commands).
   * The default behaviour is non-positional and options may appear before or after command-arguments.
   *
   * @param {Boolean} [passThrough=true] - Determines whether to pass through options that come after command-arguments rather than treat them as command-options. If set to true, unknown options will be passed through; if false, they will not.
   * @returns {Object} - The current instance of the object, allowing for method chaining.
   *
   * @throws {Error} - Throws an error if passThroughOptions is used on a subcommand without enabling positional options for parent command(s).
   */
  }

  /**
    * Store option value and where the value came from.
    *
    * @param {string} key
    * @param {Object} value
    * @param {string} source - expected values are default/config/env/cli/implied
      this._optionValues[key] = value;
    /**
     * Sets whether option values should be stored as properties on the command object or separately.
     *
     * @param {boolean} [storeAsProperties=true] - Determines if option values are stored as properties. Default is true.
     * @returns {Command} The current command instance for method chaining.
     *
     * @throws {Error} Throws an error if options have already been added to the command before calling this method.
     */
    }
    this._optionValueSources[key] = source;
    return this;
  }

  /**
    * Get source of option value.
    * Expected values are default | config | env | cli | implied
    *
    * @param {string} key
    * @return {string}
  /**
    /**
     * Retrieve option value.
     *
     * @param {string} key - The key corresponding to the option value to retrieve.
     * @return {Object} - The value associated with the provided key.
     */
    * Get source of option value. See also .optsWithGlobals().
    * Expected values are default | config | env | cli | implied
    *
    * @param {string} key
    * @return {string}
    */

    });
    /**
     * Store option value with chaining support.
     *
     * @param {string} key - The key for the option to store.
     * @param {Object} value - The value to store under the specified key.
     * @return {Command} `this` command instance for method chaining.
     */
    return source;
  }

  /**
      throw new Error('first parameter to parse must be array or undefined');
    /**
     * Set an option value along with its source in the command instance.
     *
     * @param {string} key - The key or name of the option to be set.
     * @param {Object} value - The value to be assigned to the option.
     * @param {string} source - Indicates where the value came from, expected values are 'default', 'config', 'env', 'cli', and 'implied'.
     * @returns {Command} The current command instance (`this`) for method chaining.
     */
    }
    parseOptions = parseOptions || {};

    // Default to using process.argv
    if (argv === undefined) {
      argv = process.argv;
      // @ts-ignore: unknown property
      if (process.versions && process.versions.electron) {
        parseOptions.from = 'electron';
      }
      case 'node':
        /**
         * Retrieves the source of an option value based on the provided key.
         *
         * This function is used to determine where a configuration option has been set or implied,
         * with possible values being 'default', 'config', 'env', 'cli', or 'implied'.
         *
         * @param {string} key - The identifier for the option whose source is being queried.
         * @returns {string} - A string indicating the source of the option value.
         */
        this._scriptPath = argv[1];
        userArgs = argv.slice(2);
        break;
      case 'electron':
        break;
      /**
       * Retrieves the source of an option value considering global overrides.
       *
       * This method iterates through the command and its ancestors to determine
       * the source of a given option value. The sources are expected to be one of:
       * 'default', 'config', 'env', 'cli', or 'implied'. If a global configuration
       * overwrites a local one, the global source will be returned.
       *
       * @param {string} key - The key for which to retrieve the option value source.
       * @return {string} - The source of the option value ('default', 'config', 'env', 'cli', or 'implied').
       */
      case 'user':
        userArgs = argv.slice(0);
        break;
      default:
        throw new Error(`unexpected parse option { from: '${parseOptions.from}' }`);
    }

    // Find default name for program from arguments.
    if (!this._name && this._scriptPath) this.nameFromFilename(this._scriptPath);
    this._name = this._name || 'program';

   * The default expectation is that the arguments are from node and have the application as argv[0]
   /**
    * Get user arguments from implied or explicit arguments.
    * Side-effects: set `_scriptPath` if args included script. Used for default program name, and subcommand searches.
    *
    * @private
    * @param {Array|string} [argv=process.argv] - The array of arguments to parse. If undefined, `process.argv` is used.
    * @param {Object} [parseOptions={}] - Options to configure the parsing behavior.
    * @returns {Array} The user arguments after processing.
    *
    * @throws {Error} If the first parameter is not an array or undefined.
    * @throws {Error} If an unexpected `parseOption.from` value is provided.
    */
   * and the script being run in argv[1], with user parameters after that.
   *
   * @example
   * program.parse(process.argv);
   * program.parse(); // implicitly use process.argv and auto-detect node vs electron conventions
   * program.parse(my-args, { from: 'user' }); // just user supplied arguments, nothing special about argv[0]
   *
   * @param {string[]} [argv] - optional, defaults to process.argv
   * @param {Object} [parseOptions] - optionally specify style of options with from: node/user/electron
   * @param {string} [parseOptions.from] - where the args are from: 'node', 'user', 'electron'
   * @return {Command} `this` command for chaining
   */

  parse(argv, parseOptions) {
    const userArgs = this._prepareUserArgs(argv, parseOptions);
    this._parseCommand([], userArgs);

    return this;
  }

  /**
   * Parse `argv`, setting options and invoking commands when defined.
   *
   * Use parseAsync instead of parse if any of your action handlers are async. Returns a Promise.
   *
   * The default expectation is that the arguments are from node and have the application as argv[0]
   * and the script being run in argv[1], with user parameters after that.
   *
   * @example
   * await program.parseAsync(process.argv);
   * await program.parseAsync(); // implicitly use process.argv and auto-detect node vs electron conventions
   * await program.parseAsync(my-args, { from: 'user' }); // just user supplied arguments, nothing special about argv[0]
   *
   * @param {string[]} [argv]
   * @param {Object} [parseOptions]
   * @param {string} parseOptions.from - where the args are from: 'node', 'user', 'electron'
   * @return {Promise}
   */

  async parseAsync(argv, parseOptions) {
    const userArgs = this._prepareUserArgs(argv, parseOptions);
    await this._parseCommand([], userArgs);

    return this;
  }

  /**
     * @throws {Error} - If an error occurs during file existence checks.
     /**
      * Parse `argv`, setting options and invoking commands when defined.
      *
      * The default expectation is that the arguments are from node and have the application as argv[0]
      * and the script being run in argv[1], with user parameters after that.
      *
      * @example
      * program.parse(process.argv);
      * program.parse(); // implicitly use process.argv and auto-detect node vs electron conventions
      * program.parse(my-args, { from: 'user' }); // just user supplied arguments, nothing special about argv[0]
      *
      * @param {string[]} [argv] - optional, defaults to process.argv
      * @param {Object} [parseOptions] - optionally specify style of options with from: node/user/electron
      * @param {string} [parseOptions.from] - where the args are from: 'node', 'user', 'electron'
      * @returns {Command} `this` command for chaining
      */
     *
     * @example
     * const filePath = findFile('/usr/local/bin', 'node');
     * console.log(filePath); // Output might be '/usr/local/bin/node' or '/usr/local/bin/node.js'
     */
    function findFile(baseDir, baseName) {
      // Look for specified file
    let executableFile = subcommand._executableFile || `${this._name}-${subcommand._name}`;
    /**
     * Asynchronously parses command line arguments and invokes commands when defined. Returns a Promise.
     *
     * This method should be used if any of the action handlers are asynchronous, ensuring proper handling of Promises within the parsing process.
     *
     * The default expectation is that the arguments are from a Node.js environment and have the application as `argv[0]` and the script being run in `argv[1]`, with user parameters following those.
     *
     * @example
     * await program.parseAsync(process.argv);
     * await program.parseAsync(); // implicitly use process.argv and auto-detect node vs electron conventions
     * await program.parseAsync(myArgs, { from: 'user' }); // just user supplied arguments, nothing special about argv[0]
     *
     * @param {string[]} [argv] - The array of command line arguments to parse. If not provided, `process.argv` is used by default.
     * @param {Object} [parseOptions] - Options for parsing the arguments.
     * @param {string} parseOptions.from - Specifies where the args are coming from: 'node', 'user', or 'electron'.
     *
     * @returns {Promise}
     */
    let executableDir = this._executableDir || '';
    if (this._scriptPath) {
      let resolvedScriptPath; // resolve possible symlink for installed npm binary
      try {
        resolvedScriptPath = fs.realpathSync(this._scriptPath);
      } catch (err) {
        resolvedScriptPath = this._scriptPath;
    if (executableDir) {
      /**
       * Execute a sub-command executable.
       *
       * @api private
       *
       * @param {string} subcommand - The subcommand to be executed.
       * @param {Array<string>} args - Arguments to pass to the subcommand.
       * @returns {void}
       * @throws {Error} If the executable file does not exist or is not executable.
       */
      let localFile = findFile(executableDir, executableFile);

      // Legacy search using prefix of script name instead of command name
      if (!localFile && !subcommand._executableFile && this._scriptPath) {
        const legacyName = path.basename(this._scriptPath, path.extname(this._scriptPath));
        if (legacyName !== this._name) {
          localFile = findFile(executableDir, `${legacyName}-${subcommand._name}`);
        }
      }
      executableFile = localFile || executableFile;
    }

    launchWithNode = sourceExt.includes(path.extname(executableFile));

    let proc;
    if (process.platform !== 'win32') {
      if (launchWithNode) {
        args.unshift(executableFile);
        // add executable arguments to spawn
        args = incrementNodeInspectorPort(process.execArgv).concat(args);

        proc = childProcess.spawn(process.argv[0], args, { stdio: 'inherit' });
      } else {
        proc = childProcess.spawn(executableFile, args, { stdio: 'inherit' });
      }
    } else {
      args.unshift(executableFile);
      // add executable arguments to spawn
      args = incrementNodeInspectorPort(process.execArgv).concat(args);
      proc = childProcess.spawn(process.execPath, args, { stdio: 'inherit' });
    }

    if (!proc.killed) { // testing mainly to avoid leak warnings during unit tests with mocked spawn
      const signals = ['SIGUSR1', 'SIGUSR2', 'SIGTERM', 'SIGINT', 'SIGHUP'];
      signals.forEach((signal) => {
        // @ts-ignore
        process.on(signal, () => {
          if (proc.killed === false && proc.exitCode === null) {
            proc.kill(signal);
          }
        });
      });
    }

    // By default terminate process when spawned process terminates.
    // Suppressing the exit if exitCallback defined is a bit messy and of limited use, but does allow process to stay running!
    const exitCallback = this._exitCallback;
    if (!exitCallback) {
      proc.on('close', process.exit.bind(process));
    } else {
      proc.on('close', () => {
        exitCallback(new CommanderError(process.exitCode || 0, 'commander.executeSubCommandAsync', '(close)'));
      });
    }
    proc.on('error', (err) => {
      // @ts-ignore
      if (err.code === 'ENOENT') {
        const executableDirMessage = executableDir
          ? `searched for local subcommand relative to directory '${executableDir}'`
          : 'no directory for search for local subcommand, use .executableDir() to supply a custom directory';
        const executableMissing = `'${executableFile}' does not exist
 - if '${subcommand._name}' is not meant to be an executable command, remove description parameter from '.command()' and use '.description()' instead
 - if the default executable name is not suitable, use the executableFile option to supply a custom name or path
 - ${executableDirMessage}`;
        throw new Error(executableMissing);
      // @ts-ignore
      } else if (err.code === 'EACCES') {
        throw new Error(`'${executableFile}' not executable`);
      }
      if (!exitCallback) {
        process.exit(1);
      } else {
        const wrappedError = new CommanderError(1, 'commander.executeSubCommandAsync', '(error)');
        wrappedError.nestedError = err;
        exitCallback(wrappedError);
      }
    });

    // Store the reference to the child process
    this.runningCommand = proc;
  }

  /**
   * @api private
   */

  _dispatchSubcommand(commandName, operands, unknown) {
    const subCommand = this._findCommand(commandName);
    if (!subCommand) this.help({ error: true });

    let promiseChain;
    promiseChain = this._chainOrCallSubCommandHook(promiseChain, subCommand, 'preSubcommand');
    promiseChain = this._chainOrCall(promiseChain, () => {
      if (subCommand._executableHandler) {
        this._executeSubCommand(subCommand, operands.concat(unknown));
      } else {
        return subCommand._parseCommand(operands, unknown);
      }
    });
    return promiseChain;
  }

  /**
   * Invoke help directly if possible, or dispatch if necessary.
   * e.g. help foo
   *
   * @api private
   */

  _dispatchHelpCommand(subcommandName) {
    if (!subcommandName) {
      this.help();
    }
    const subCommand = this._findCommand(subcommandName);
    if (subCommand && !subCommand._executableHandler) {
      subCommand.help();
    }

    // Fallback to parsing the help flag to invoke the help.
    return this._dispatchSubcommand(subcommandName, [], [
      this._helpLongFlag || this._helpShortFlag
  /**
   /**
    * @api private
    *
    * Dispatches a subcommand based on the provided command name and operands.
    *
    * @param {string} commandName - The name of the subcommand to dispatch.
    * @param {Array<string>} operands - Additional arguments for the subcommand.
    * @param {Array<string>} unknown - Unknown or unrecognized arguments.
    * @return {Promise<void>}
    * @throws {Error} If the specified subcommand is not found, an error will be thrown.
    */
   * Check this.args against expected this.registeredArguments.
   *
   * @api private
   */

  _checkNumberOfArguments() {
    // too few
    this.registeredArguments.forEach((arg, i) => {
      if (arg.required && this.args[i] == null) {
        this.missingArgument(arg.name());
      }
    });
    // too many
    if (this.registeredArguments.length > 0 && this.registeredArguments[this.registeredArguments.length - 1].variadic) {
      return;
    }
   * Process this.args using this.registeredArguments and save as this.processedArgs!
   /**
    * Invokes help directly if possible, or dispatches it if necessary.
    *
    * @param {string} subcommandName - The name of the subcommand to invoke help for. If not provided, general help is invoked.
    * @private
    */
   *
   * @api private
   */

  _processArguments() {
    /**
     * Parses an argument value with additional error handling for invalid values.
     *
     * @param {Object} argument - The argument object containing parsing logic.
     * @param {*} value - The value to be parsed.
     * @param {*} previous - The previously parsed value (if applicable).
     * @returns {*} - The parsed value, or the original value if it's invalid.
     *
     * @throws {Error} - If the parsing fails and an invalid value message is provided.
     */
        parsedValue = this._callParseArg(argument, value, previous, invalidValueMessage);
      /**
       * Check if the number of arguments passed matches the expected number based on the registered arguments.
       *
       * This method iterates through the expected arguments and checks if they are provided. It also handles cases where there are too many arguments, especially when the last argument is variadic.
       *
       * @api private
       */
      }
      return parsedValue;
    };

    this._checkNumberOfArguments();

    const processedArgs = [];
    this.registeredArguments.forEach((declaredArg, index) => {
      let value = declaredArg.defaultValue;
      if (declaredArg.variadic) {
        // Collect together remaining arguments for passing together as an array.
        if (index < this.args.length) {
          value = this.args.slice(index);
          if (declaredArg.parseArg) {
            value = value.reduce((processed, v) => {
              return myParseArg(declaredArg, v, processed);
      } else if (index < this.args.length) {
        /**
         * Process this.args using this.registeredArguments and save as this.processedArgs!
         *
         * @api private
         */
        value = this.args[index];
        if (declaredArg.parseArg) {
          value = myParseArg(declaredArg, value, declaredArg.defaultValue);
        }
      }
      processedArgs[index] = value;
    });
    this.processedArgs = processedArgs;
  }

  /**
   * Once we have a promise we chain, but call synchronously until then.
   *
   * @param {Promise|undefined} promise
   * @param {Function} fn
   * @return {Promise|undefined}
   * @api private
   */

  _chainOrCall(promise, fn) {
    // thenable
    if (promise && promise.then && typeof promise.then === 'function') {
      // already have a promise, chain callback
      return promise.then(() => fn());
    }
    // callback might return a promise
    return fn();
  }

  /**
   *
   * @param {Promise|undefined} promise
   * @param {string} event
   * @return {Promise|undefined}
   * @api private
   */

  _chainOrCallHooks(promise, event) {
    let result = promise;
      });
    /**
     * Once we have a promise we chain, but call synchronously until then.
     *
     * @param {Promise|undefined} [promise] - A promise object or undefined.
     * @param {Function} fn - The function to be called either synchronously or after the promise resolves.
     * @return {Promise|undefined} - Returns a promise if one is available and `fn` returns a promise; otherwise, returns the result of calling `fn`.
     * @api private
     */
    if (event === 'postAction') {
      hooks.reverse();
    }

    hooks.forEach((hookDetail) => {
      result = this._chainOrCall(result, () => {
        return hookDetail.callback(hookDetail.hookedCommand, this);
      });
    });
    return result;
   * @return {Promise|undefined}
   /**
    * Chains or calls lifecycle hooks for a given event.
    *
    * @param {Promise|undefined} promise - The initial promise to chain with the hooks.
    * @param {string} event - The event for which hooks should be executed ('preAction' or 'postAction').
    * @return {Promise|undefined} - The resulting promise after chaining all hooks.
    * @api private
    */
   * @api private
   */

  _chainOrCallSubCommandHook(promise, subCommand, event) {
    let result = promise;
    if (this._lifeCycleHooks[event] !== undefined) {
      this._lifeCycleHooks[event].forEach((hook) => {
        result = this._chainOrCall(result, () => {
          return hook(this, subCommand);
        });
      });
    }
    return result;
  }

  /**
   * Process arguments in context of this command.
   * Returns action result, in case it is a promise.
   *
   * @api private
   */

  _parseCommand(operands, unknown) {
      return this._dispatchSubcommand(operands[0], operands.slice(1), unknown);
    /**
     * Chains or calls a sub-command hook based on the given event.
     *
     * @param {Promise|undefined} promise - The current promise, if any. If undefined, a new promise is created.
     * @param {Command} subCommand - The sub-command to be executed by the hook.
     * @param {string} event - The event name for which hooks are to be executed.
     * @return {Promise|undefined} - A promise representing the result of executing the hooks, or undefined if no hooks are found.
     * @api private
     */
    }
    if (this._hasImplicitHelpCommand() && operands[0] === this._helpCommandName) {
      return this._dispatchHelpCommand(operands[1]);
    }
    if (this._defaultCommandName) {
      outputHelpIfRequested(this, unknown); // Run the help for default command from parent rather than passing to default command
      return this._dispatchSubcommand(this._defaultCommandName, operands, unknown);
    }
    if (this.commands.length && this.args.length === 0 && !this._actionHandler && !this._defaultCommandName) {
      // probably missing subcommand and no handler, user needs help (and exit)
      this.help({ error: true });
    }
    /**
     /**
      * Parses the command arguments and processes them accordingly.
      *
      * @api private
      * @param {string[]} operands - The array of operand strings to be parsed.
      * @param {string[]} unknown - The array of unknown option strings to be parsed.
      * @returns {(Promise|void)} A Promise if the action handler returns a promise, otherwise undefined.
      *
      * @example
      * const parser = new CommandParser();
      * parser._parseCommand(['run', 'script.js'], ['--config=dev']);
      *
      * @throws {Error} Throws an error if an unknown option is encountered and no handler is defined.
      */
     * Checks if there are any unknown options in the parsed data and handles them accordingly.
     *
     * @return {void}
     */
    const checkForUnknownOptions = () => {
      if (parsed.unknown.length > 0) {
        this.unknownOption(parsed.unknown[0]);
      }
    };

    const commandEvent = `command:${this.name()}`;
    if (this._actionHandler) {
      checkForUnknownOptions();
      this._processArguments();

      let promiseChain;
      promiseChain = this._chainOrCallHooks(promiseChain, 'preAction');
      promiseChain = this._chainOrCall(promiseChain, () => this._actionHandler(this.processedArgs));
      if (this.parent) {
        promiseChain = this._chainOrCall(promiseChain, () => {
          this.parent.emit(commandEvent, operands, unknown); // legacy
        });
      }
      promiseChain = this._chainOrCallHooks(promiseChain, 'postAction');
      return promiseChain;
    }
    if (this.parent && this.parent.listenerCount(commandEvent)) {
      checkForUnknownOptions();
      this._processArguments();
      this.parent.emit(commandEvent, operands, unknown); // legacy
    } else if (operands.length) {
      if (this._findCommand('*')) { // legacy default command
        return this._dispatchSubcommand('*', operands, unknown);
      }
      if (this.listenerCount('command:*')) {
        // skip option check, emit event for possible misspelling suggestion
        this.emit('command:*', operands, unknown);
      } else if (this.commands.length) {
        this.unknownCommand();
      } else {
        checkForUnknownOptions();
        this._processArguments();
      }
    } else if (this.commands.length) {
      checkForUnknownOptions();
      // This command has subcommands and nothing hooked up at this level, so display help (and exit).
      this.help({ error: true });
    } else {
      checkForUnknownOptions();
      this._processArguments();
      // fall through for caller to handle after calling .parse()
    }
  }

  /**
   * Find matching command.
   *
   * @api private
   */
  _findCommand(name) {
    if (!name) return undefined;
    return this.commands.find(cmd => cmd._name === name || cmd._aliases.includes(name));
  }

  /**
   * Return an option matching `arg` if any.
   *
   * @param {string} arg
   * @return {Option}
   * @api private
   */

  _findOption(arg) {
    return this.options.find(option => option.is(arg));
  }

  /**
   * Display an error message if a mandatory option does not have a value.
  /**
   * Find matching command by name or alias.
   *
   * @private
   * @param {string} name - The name or alias of the command to find.
   * @returns {Object|undefined} - The found command object if a match is found, otherwise undefined.
   *
   * @example
   * const command = _findCommand('list');
   * console.log(command); // Output: { ... }
   */
  _checkForMissingMandatoryOptions() {
    // Walk up hierarchy so can call in subcommand after checking for displaying help.
    this._getCommandAndAncestors().forEach((cmd) => {
      cmd.options.forEach((anOption) => {
        if (anOption.mandatory && (cmd.getOptionValue(anOption.attributeName()) === undefined)) {
   * Display an error message if conflicting options are used together in this.
   /**
    * Return an option matching `arg` if any.
    *
    * @param {string} arg - The argument to match against options.
    * @return {Option} - The matching Option object or undefined if no match is found.
    * @api private
    */
   *
   * @api private
   */
  _checkForConflictingLocalOptions() {
        return this.getOptionValueSource(optionKey) !== 'default';
      /**
       * Display an error message if a mandatory option does not have a value.
       * Called after checking for help flags in leaf subcommand.
       *
       * @api private
       */
      }
    );

    const optionsWithConflicting = definedNonDefaultOptions.filter(
      (option) => option.conflictsWith.length > 0
    );

    optionsWithConflicting.forEach((option) => {
      const conflictingAndDefined = definedNonDefaultOptions.find((defined) =>
        option.conflictsWith.includes(defined.attributeName())
      );
/**
 * Checks for conflicting options when local options are used together.
 *
 * This method iterates through the defined non-default options to identify any conflicts with other options. If a conflict is found,
 * it calls the `_conflictingOption` method to handle the error appropriately.
 *
 * @private
 */

  /**
   * Display an error message if conflicting options are used together.
   * Called after checking for help flags in leaf subcommand.
   *
   * @api private
   */
  _checkForConflictingOptions() {
    // Walk up hierarchy so can call in subcommand after checking for displaying help.
    this._getCommandAndAncestors().forEach((cmd) => {
      cmd._checkForConflictingLocalOptions();
    });
  }

  /**
   * Parse options from `argv` removing known options,
   * and return argv split into operands and unknown arguments.
   *
   * Examples:
   *
   *     argv => operands, unknown
   *     --known kkk op => [op], []
   *     op --known kkk => [op], []
   *     sub --unknown uuu op => [sub], [--unknown uuu op]
   *     sub -- --unknown uuu op => [sub --unknown uuu op], []
    /**
     * Display an error message if conflicting options are used together.
     * Called after checking for help flags in leaf subcommand.
     *
     * @api private
     */
    const operands = []; // operands, not options or values
    const unknown = []; // first unknown option and remaining unknown args
    let dest = operands;
    const args = argv.slice();

    function maybeOption(arg) {
      return arg.length > 1 && arg[0] === '-';
        this.emit(`option:${activeVariadicOption.name()}`, arg);
        /**
         * Parse options from `argv` removing known options,
         * and return argv split into operands and unknown arguments.
         *
         * @param {String[]} argv - The array of command-line arguments to be parsed.
         * @return {{operands: String[], unknown: String[]}}
         * @throws {Error} If a required option is missing an argument.
         */
        continue;
      }
      activeVariadicOption = null;

      if (maybeOption(arg)) {
        const option = this._findOption(arg);
        // recognised option, call listener to assign value with possible custom processing
        if (option) {
          if (option.required) {
            const value = args.shift();
            if (value === undefined) this.optionMissingArgument(option);
            this.emit(`option:${option.name()}`, value);
          } else if (option.optional) {
            let value = null;
            // historical behaviour is optional value is following arg unless an option
            if (args.length > 0 && !maybeOption(args[0])) {
              value = args.shift();
            }
            this.emit(`option:${option.name()}`, value);
          } else { // boolean flag
            this.emit(`option:${option.name()}`);
          }
          activeVariadicOption = option.variadic ? option : null;
          continue;
        }
      }

      // Look for combo options following single dash, eat first one if known.
      if (arg.length > 2 && arg[0] === '-' && arg[1] !== '-') {
        const option = this._findOption(`-${arg[1]}`);
        if (option) {
          if (option.required || (option.optional && this._combineFlagAndOptionalValue)) {
            // option with value following in same argument
            this.emit(`option:${option.name()}`, arg.slice(2));
          } else {
            // boolean option, emit and put back remainder of arg for further processing
            this.emit(`option:${option.name()}`);
            args.unshift(`-${arg.slice(2)}`);
          }
          continue;
        }
      }

      // Look for known long flag with value, like --foo=bar
      if (/^--[^=]+=/.test(arg)) {
        const index = arg.indexOf('=');
        const option = this._findOption(arg.slice(0, index));
        if (option && (option.required || option.optional)) {
          this.emit(`option:${option.name()}`, arg.slice(index + 1));
          continue;
        }
      }

      // Not a recognised option by this command.
      // Might be a command-argument, or subcommand option, or unknown option, or help command or option.

      // An unknown option means further arguments also classified as unknown so can be reprocessed by subcommands.
      if (maybeOption(arg)) {
        dest = unknown;
      }

      // If using positionalOptions, stop processing our options at subcommand.
      if ((this._enablePositionalOptions || this._passThroughOptions) && operands.length === 0 && unknown.length === 0) {
        if (this._findCommand(arg)) {
          operands.push(arg);
          if (args.length > 0) unknown.push(...args);
          break;
        } else if (arg === this._helpCommandName && this._hasImplicitHelpCommand()) {
          operands.push(arg);
          if (args.length > 0) operands.push(...args);
          break;
        } else if (this._defaultCommandName) {
          unknown.push(arg);
          if (args.length > 0) unknown.push(...args);
          break;
        }
      }

      // If using passThroughOptions, stop processing options at first command-argument.
      if (this._passThroughOptions) {
        dest.push(arg);
        if (args.length > 0) dest.push(...args);
        break;
      }

      // add arg
      dest.push(arg);
    }

    return { operands, unknown };
  }

  /**
   * Return an object containing local option values as key-value pairs.
   *
   * @return {Object}
   */
  opts() {
    if (this._storeOptionsAsProperties) {
      // Preserve original behaviour so backwards compatible when still using properties
      const result = {};
      const len = this.options.length;

      for (let i = 0; i < len; i++) {
        const key = this.options[i].attributeName();
        result[key] = key === this._versionOptionName ? this._version : this[key];
      }
      return result;
    }

    return this._optionValues;
  }

  /**
   * Return an object containing merged local and global option values as key-value pairs.
   *
      /**
       * Return an object containing local option values as key-value pairs.
       *
       * @return {Object} An object where keys are attribute names and values are the corresponding option values. If `_storeOptionsAsProperties` is true, it preserves the original behavior by iterating over `this.options` to get the attribute names and their values. Otherwise, it returns `this._optionValues`.
       *
       * Example usage:
       * const options = instance.opts();
       * console.log(options); // Outputs an object with option key-value pairs
       */
      (combinedOptions, cmd) => Object.assign(combinedOptions, cmd.opts()),
      {}
    );
  }

  /**
   * Display error message and exit (or call exitOverride).
   *
   * @param {string} message
   * @param {Object} [errorOptions]
   * @param {string} [errorOptions.code] - an id string representing the error
   * @param {number} [errorOptions.exitCode] - used with process.exit
   */
  error(message, errorOptions) {
    // output handling
    this._outputConfiguration.outputError(`${message}\n`, this._outputConfiguration.writeErr);
    /**
     * Returns an object containing merged local and global option values as key-value pairs.
     *
     * @return {Object} An object where keys are the option names and values are the corresponding option values. Global options overwrite local ones if there are conflicts.
     */
    }

    // exit handling
    const config = errorOptions || {};
    const exitCode = config.exitCode || 1;
    const code = config.code || 'commander.error';
    this._exit(exitCode, code, message);
  }
    /**
     * Display an error message and exit (or call exitOverride).
     *
     * @param {string} message - The error message to display.
     * @param {Object} [errorOptions] - Optional object containing additional error options.
     * @param {string} [errorOptions.code] - An identifier string representing the error. Defaults to 'commander.error'.
     * @param {number} [errorOptions.exitCode] - The exit code used with `process.exit`. Defaults to 1.
     */
    this.options.forEach((option) => {
      if (option.envVar && option.envVar in process.env) {
        const optionKey = option.attributeName();
        // Priority check. Do not overwrite cli or options from unknown source (client-code).
        if (this.getOptionValue(optionKey) === undefined || ['default', 'config', 'env'].includes(this.getOptionValueSource(optionKey))) {
          if (option.required || option.optional) { // option can take a value
            // keep very simple, optional always takes value
            this.emit(`optionEnv:${option.name()}`, process.env[option.envVar]);
          } else { // boolean
            // keep very simple, only care that envVar defined and not the value
            this.emit(`optionEnv:${option.name()}`);
          }
        }
      }
    });
  }

    /**
     * Apply any option related environment variables, if option does not have a value from cli or client code.
     *
     * @private
     */
    const dualHelper = new DualOptions(this.options);
    /**
     * Determines if an option key has a custom value.
     *
     * @param {string} optionKey - The key of the option to check.
     * @returns {boolean} - Returns true if the option has a custom value, otherwise false.
     */
    const hasCustomOptionValue = (optionKey) => {
      return this.getOptionValue(optionKey) !== undefined && !['default', 'implied'].includes(this.getOptionValueSource(optionKey));
    };
    this.options
      .filter(option => (option.implied !== undefined) &&
        hasCustomOptionValue(option.attributeName()) &&
        dualHelper.valueFromOption(this.getOptionValue(option.attributeName()), option))
      .forEach((option) => {
        Object.keys(option.implied)
          .filter(impliedKey => !hasCustomOptionValue(impliedKey))
          .forEach(impliedKey => {
  /**
   * Apply any implied option values, if option is undefined or default value.
   *
   * This method iterates over the options provided during initialization. For each option that has an 'implied' property and a custom (non-default) value,
   * it sets any implied options that do not already have a custom value. The 'DualOptions' helper class is used to resolve the values of the options.
   *
   * @api private
   */
  /**
   * Argument `name` is missing.
   *
   * @param {string} name
   * @api private
   */

  missingArgument(name) {
    const message = `error: missing required argument '${name}'`;
    this.error(message, { code: 'commander.missingArgument' });
  }

  /**
   * `Option` is missing an argument.
   *
   * @param {Option} option
   * @api private
   */
  /**
   /**
    * Throws an error if a required argument is missing.
    *
    * @param {string} name - The name of the missing argument.
    * @api private
    */
   * `Option` does not have a value, and is a mandatory option.
   *
   * @param {Option} option
   * @api private
   */
  /**
   /**
    * Logs an error message when an option is missing its required argument.
    *
    * @param {Option} option - The option object that requires an argument but has none.
    * @api private
    */
   * `Option` conflicts with another option.
   *
   * @param {Option} option
   * @param {Option} conflictingOption
   * @api private
     *
     /**
      * Throws an error if a required option is not specified.
      *
      * @param {Option} option - The option object that should have been specified.
      * @api private
      * @throws {Error} If the mandatory option is not specified, an error is thrown with a message indicating which option was missing and a code 'commander.missingMandatoryOptionValue'.
      */
     * @param {Object} option - The option to evaluate.
     * @returns {Object} The best option found.
     * @throws {Error} If an invalid option is provided or if there's a conflict between positive and negative options.
     */
    const findBestOptionFromValue = (option) => {
      /**
       * Handles the conflict between two options.
       *
       * @param {Option} option - The first option that conflicts with another.
       * @param {Option} conflictingOption - Another option that conflicts with the first one.
       * @private
       */
      )) {
        return negativeOption;
      }
      return positiveOption || option;
    };

    /**
     * Generates an error message based on the provided option.
     *
     * @param {Option} option - The option for which to generate the error message.
     * @returns {string} The error message indicating where the option was defined (either as a command line flag or an environment variable).
     * @throws {Error} If the option is not valid, throws an error with a description of the issue.
     *
     * @example
     * const errorMessage = getErrorMessage(someOption);
     * console.log(errorMessage); // 'option ''-f'''
     */
    const getErrorMessage = (option) => {
      const bestOption = findBestOptionFromValue(option);
      const optionKey = bestOption.attributeName();
      const source = this.getOptionValueSource(optionKey);
      if (source === 'env') {
        return `environment variable '${bestOption.envVar}'`;
      }
      return `option '${bestOption.flags}'`;
    };

    const message = `error: ${getErrorMessage(option)} cannot be used with ${getErrorMessage(conflictingOption)}`;
    this.error(message, { code: 'commander.conflictingOption' });
  }


  /**
   * Handle an unknown option during command execution.
   *
   * @param {string} flag - The unrecognized option flag.
   * @api private
   */
  unknownOption(flag) {
    if (this._allowUnknownOption) return;
    let suggestion = '';

    if (flag.startsWith('--') && this._showSuggestionAfterError) {
      // Looping to pick up the global options too
      let candidateFlags = [];
      let command = this;
      do {
        const moreFlags = command.createHelp().visibleOptions(command)
          .filter(option => option.long)
          .map(option => option.long);
        candidateFlags = candidateFlags.concat(moreFlags);
        command = command.parent;
      } while (command && !command._enablePositionalOptions);
      suggestion = suggestSimilar(flag, candidateFlags);
    }

    const message = `error: unknown option '${flag}'${suggestion}`;
    this.error(message, { code: 'commander.unknownOption' });
  }


  /**
   * Handles excess arguments passed to a command or subcommand.
   *
   * @param {string[]} receivedArgs - An array of strings representing the arguments received.
   * @api private
   */
  _excessArguments(receivedArgs) {
    if (this._allowExcessArguments) return;

    const expected = this.registeredArguments.length;
    const s = (expected === 1) ? '' : 's';
    const forSubcommand = this.parent ? ` for '${this.name()}'` : '';
    const message = `error: too many arguments${forSubcommand}. Expected ${expected} argument${s} but got ${receivedArgs.length}.`;
    this.error(message, { code: 'commander.excessArguments' });
  }


  /**
   * Handles the scenario where an unknown command is encountered by the application.
   *
   * This method is intended for internal use only.
   *
   * @api private
   */
  unknownCommand() {
    const unknownName = this.args[0];
    let suggestion = '';

    if (this._showSuggestionAfterError) {
      const candidateNames = [];
      this.createHelp().visibleCommands(this).forEach((command) => {
        candidateNames.push(command.name());
        // just visible alias
        if (command.alias()) candidateNames.push(command.alias());
      });
      suggestion = suggestSimilar(unknownName, candidateNames);
    }

    const message = `error: unknown command '${unknownName}'${suggestion}`;
    this.error(message, { code: 'commander.unknownCommand' });
  }


  /**
   * Get or set the program version.
   *
   * This method auto-registers the "-V, --version" option which will print the version number.
   *
   * You can optionally supply the flags and description to override the defaults.
   *
   * @param {string} [str] - The version string to set. If undefined, returns the current version.
   * @param {string} [flags='-V, --version'] - The option flags for the version command.
   * @param {string} [description='output the version number'] - Description of the version command.
   * @return {this | string | undefined} Returns `this` command for chaining if arguments are provided, or the current version string if no arguments are provided.
   */
  version(str, flags, description) {
    if (str === undefined) return this._version;
    this._version = str;
    flags = flags || '-V, --version';
    description = description || 'output the version number';
    const versionOption = this.createOption(flags, description);
    this._versionOptionName = versionOption.attributeName(); // [sic] not defined in constructor, partly legacy, partly only needed at root
    this.options.push(versionOption);
    this.on('option:' + versionOption.name(), () => {
      this._outputConfiguration.writeOut(`${str}\n`);
      this._exit(0, 'commander.version', str);
    });
    return this;
  }

  /**
   * Set or get the description of a command or argument.
   *
   * @param {string} [str] - The new description to set. If not provided, the current description is returned.
   * @param {Object} [argsDescription] - An object containing additional descriptions for arguments if `str` is provided.
   * @return {string|Command} - Returns the current description if no parameters are provided, or the current instance of the class with updated description(s).
   *
   * Example:
   * // Get the current description
   * const currentDescription = command.description();
   *
   * // Set a new description and additional argument descriptions
   * command.description('Run a script', { scriptName: 'The name of the script to run' });
   */
  description(str, argsDescription) {
    if (str === undefined && argsDescription === undefined) return this._description;
    this._description = str;
    if (argsDescription) {
      this._argsDescription = argsDescription;
    }
    return this;
  }

  /**
   * Set or get the summary of the command. Used when listed as a subcommand of its parent.
   *
   * @param {string} [str] - The new summary to set. If not provided, returns the current summary.
   * @returns {string|Command} - Returns the current summary if `str` is undefined; otherwise, returns the `Command` object for method chaining.
   */
  summary(str) {
    if (str === undefined) return this._summary;
    this._summary = str;
    return this;
  }


  /**
   * Set an alias for the command.
   *
   * You may call more than once to add multiple aliases. Only the first alias is shown in the auto-generated help.
   *
   * @param {string} [alias] - The alias to set. If not provided, returns the first alias of the command.
   * @return {string|Command} - Returns the first alias if no alias is provided, otherwise returns the current command object for method chaining.
   * @throws {Error} - Throws an error if the alias is the same as the command's name.
   */
  alias(alias) {
    if (alias === undefined) return this._aliases[0]; // just return first, for backwards compatibility

    /** @type {Command} */
    let command = this;
    if (this.commands.length !== 0 && this.commands[this.commands.length - 1]._executableHandler) {
      // assume adding alias for last added executable subcommand, rather than this
      command = this.commands[this.commands.length - 1];
    }

    if (alias === command._name) throw new Error('Command alias can\'t be the same as its name');

    command._aliases.push(alias);
    return this;
  }


  /**
   * Set aliases for the command.
   *
   * Only the first alias is shown in the auto-generated help.
   *
   * @param {string[]} [aliases] - An array of strings representing the aliases to be set. If not provided, the current aliases are returned.
   * @returns {string[]|Command} - Returns an array of the current aliases if no parameters are provided. Otherwise, returns the command object itself for method chaining.
   *
   * Example:
   *   let myCommand = new Command();
   *   myCommand.aliases(['alias1', 'alias2']);
   *   console.log(myCommand.aliases()); // Output: ['alias1', 'alias2']
   */
  aliases(aliases) {
    // Getter for the array of aliases is the main reason for having aliases() in addition to alias().
    if (aliases === undefined) return this._aliases;

    aliases.forEach((alias) => this.alias(alias));
    return this;
  }


  /**
   * Set or get the command usage string `str`.
   *
   * @param {string} [str] - The new command usage string to set. If not provided, the current command usage string will be returned.
   * @return {String|Command} - Returns the current command usage string if no parameter is provided; otherwise, returns the Command object itself.
   */
  usage(str) {
    if (str === undefined) {
      if (this._usage) return this._usage;

      const args = this.registeredArguments.map((arg) => {
        return humanReadableArgName(arg);
      });
      return [].concat(
        (this.options.length || this._hasHelpOption ? '[options]' : []),
        (this.commands.length ? '[command]' : []),
        (this.registeredArguments.length ? args : [])
      ).join(' ');
    }

    this._usage = str;
    return this;
  }


  /**
   * Get or set the name of the command.
   *
   * @param {string} [str] - The new name for the command. If not provided, the current name is returned.
   * @return {string|Command} - The current name of the command if no parameter is provided, otherwise returns the updated Command instance.
   */
  name(str) {
    if (str === undefined) return this._name;
    this._name = str;
    return this;
  }


  /**
   * Sets the name of the command from a script filename. This method is used internally and can also be called publically, although it is not documented in the README.
   *
   * @param {string} filename - The path to the script file from which the command name should be derived.
   * @returns {Command} - The instance of the Command class with the name set.
   *
   * @example
   * program.nameFromFilename(require.main.filename);
   */
  nameFromFilename(filename) {
    this._name = path.basename(filename, path.extname(filename));

    return this;
  }


  /**
   * Get or set the directory for searching for executable subcommands of this command.
   *
   * @param {string} [path] - The path to set as the directory for executable subcommands. If not provided, returns the current executable directory.
   * @returns {string|null|Command} - Returns the current executable directory if no path is provided, otherwise returns the modified Command object.
   *
   * @example
   * program.executableDir(__dirname);
   * // or
   * program.executableDir('subcommands');
   */
  executableDir(path) {
    if (path === undefined) return this._executableDir;
    this._executableDir = path;
    return this;
  }


  /**
   * Returns program help documentation.
   *
   * @param {Object} [contextOptions] - Optional context options object.
   * @param {boolean} [contextOptions.error=false] - If true, wraps the help output for stderr instead of stdout.
   * @return {string} The formatted help documentation as a string.
   */
  helpInformation(contextOptions) {
    const helper = this.createHelp();
    if (helper.helpWidth === undefined) {
      helper.helpWidth = (contextOptions && contextOptions.error) ? this._outputConfiguration.getErrHelpWidth() : this._outputConfiguration.getOutHelpWidth();
    }
    return helper.formatHelp(this, helper);
  }


  /**
   * Generates help context object with appropriate write function based on error presence.
   *
   * @private
   * @param {Object} [contextOptions] - Optional options to customize the context.
   * @param {boolean} [contextOptions.error=false] - Indicates if the context is for an error.
   * @param {function} [contextOptions.write] - Custom write function to override default behavior.
   * @returns {Object} - Help context object containing error flag, custom write function, and command reference.
   */
  _getHelpContext(contextOptions) {
    contextOptions = contextOptions || {};
    const context = { error: !!contextOptions.error };
    let write;
    if (context.error) {
      write = (arg) => this._outputConfiguration.writeErr(arg);
    } else {
      write = (arg) => this._outputConfiguration.writeOut(arg);
    }
    context.write = contextOptions.write || write;
    context.command = this;
    return context;
  }


  /**
   * Output help information for this command.
   *
   * Outputs built-in help, and custom text added using `.addHelpText()`.
   *
   * @param {Object | Function} [contextOptions] - Optional parameter to customize the context of the help output.
   *   If a function is provided, it is considered deprecated and will be called with the generated help information.
   *   The function should return either a string or a Buffer.
   *   If not provided, default behavior is used to write to stdout.
   *
   * @throws {Error} - Throws an error if the callback provided returns something other than a string or a Buffer.
   */
  outputHelp(contextOptions) {
    let deprecatedCallback;
    if (typeof contextOptions === 'function') {
      deprecatedCallback = contextOptions;
      contextOptions = undefined;
    }
    const context = this._getHelpContext(contextOptions);

    this._getCommandAndAncestors().reverse().forEach(command => command.emit('beforeAllHelp', context));
    this.emit('beforeHelp', context);

    let helpInformation = this.helpInformation(context);
    if (deprecatedCallback) {
      helpInformation = deprecatedCallback(helpInformation);
      if (typeof helpInformation !== 'string' && !Buffer.isBuffer(helpInformation)) {
        throw new Error('outputHelp callback must return a string or a Buffer');
      }
    }
    context.write(helpInformation);

    if (this._helpLongFlag) {
      this.emit(this._helpLongFlag); // deprecated
    }
    this.emit('afterHelp', context);
    this._getCommandAndAncestors().forEach(command => command.emit('afterAllHelp', context));
  }


  /**
   * You can pass in flags and a description to override the help flags and help description for your command. Pass in false to disable the built-in help option.
   *
   * @param {string | boolean} [flags] - The flags for the help option or a boolean value to enable/disable the built-in help option.
   * @param {string} [description] - A custom description for the help option.
   * @return {Command} `this` command for chaining.
   */
  helpOption(flags, description) {
    if (typeof flags === 'boolean') {
      this._hasHelpOption = flags;
      return this;
    }
    this._helpFlags = flags || this._helpFlags;
    this._helpDescription = description || this._helpDescription;

    const helpFlags = splitOptionFlags(this._helpFlags);
    this._helpShortFlag = helpFlags.shortFlag;
    this._helpLongFlag = helpFlags.longFlag;

    return this;
  }


  /**
   * Output help information and exit.
   *
   * Outputs built-in help, and custom text added using `.addHelpText()`.
   *
   * @param {{ error: boolean }} [contextOptions] - Options object to control the output behavior. If `{error:true}`, the output will be written to stderr instead of stdout.
   */
  help(contextOptions) {
    this.outputHelp(contextOptions);
    let exitCode = process.exitCode || 0;
    if (exitCode === 0 && contextOptions && typeof contextOptions !== 'function' && contextOptions.error) {
      exitCode = 1;
    }
    // message: do not have all displayed text available so only passing placeholder.
    this._exit(exitCode, 'commander.help', '(outputHelp)');
  }

  /**
   * Add additional text to be displayed with the built-in help.
   *
   * Position can be 'before', 'after', 'beforeAll', or 'afterAll'. The first three positions affect just this command, while 'beforeAll' and 'afterAll' affect this command and all its subcommands.
   *
   * @param {string} position - Determines the position of the help text ('before', 'after', 'beforeAll', 'afterAll').
   * @param {string | Function} text - The text to add as help, either a plain string or a function returning a string. If a function is provided, it receives an object with `error` and `command` properties.
   * @return {Command} Returns the current command instance (`this`) for method chaining.
   *
   * @throws {Error} Throws an error if the position value is not one of 'beforeAll', 'before', 'after', or 'afterAll'.
   */
  addHelpText(position, text) {
    const allowedValues = ['beforeAll', 'before', 'after', 'afterAll'];
    if (!allowedValues.includes(position)) {
      throw new Error(`Unexpected value for position to addHelpText.
Expecting one of '${allowedValues.join("', '")}'`);
    }
    const helpEvent = `${position}Help`;
    this.on(helpEvent, (context) => {
      let helpStr;
      if (typeof text === 'function') {
        helpStr = text({ error: context.error, command: context.command });
      } else {
        helpStr = text;
      }
      // Ignore falsy value when nothing to output.
      if (helpStr) {
        context.write(`${helpStr}\n`);
      }
    });
    return this;
  }
}


/**
 * Output help information if help flags specified
 *
 * @param {Command} cmd - The command to output help for.
 * @param {Array} args - Array of options to search for help flags.
 * @api private
 */
function outputHelpIfRequested(cmd, args) {
  const helpOption = cmd._hasHelpOption && args.find(arg => arg === cmd._helpLongFlag || arg === cmd._helpShortFlag);
  if (helpOption) {
    cmd.outputHelp();
    // (Do not have all displayed text available so only passing placeholder.)
    cmd._exit(0, 'commander.helpDisplayed', '(outputHelp)');
  }
}


/**
 * Scan arguments and increment port number for inspect calls (to avoid conflicts when spawning new command).
 *
 * @param {string[]} args - Array of arguments from node.execArgv.
 * @returns {string[]}
 * @api private
 */
function incrementNodeInspectorPort(args) {
  // Testing for these options:
  //  --inspect[=[host:]port]
  //  --inspect-brk[=[host:]port]
  //  --inspect-port=[host:]port
  return args.map((arg) => {
    if (!arg.startsWith('--inspect')) {
      return arg;
    }
    let debugOption;
    let debugHost = '127.0.0.1';
    let debugPort = '9229';
    let match;
    if ((match = arg.match(/^(--inspect(-brk)?)$/)) !== null) {
      // e.g. --inspect
      debugOption = match[1];
    } else if ((match = arg.match(/^(--inspect(-brk|-port)?)=([^:]+)$/)) !== null) {
      debugOption = match[1];
      if (/^\d+$/.test(match[3])) {
        // e.g. --inspect=1234
        debugPort = match[3];
      } else {
        // e.g. --inspect=localhost
        debugHost = match[3];
      }
    } else if ((match = arg.match(/^(--inspect(-brk|-port)?)=([^:]+):(\d+)$/)) !== null) {
      // e.g. --inspect=localhost:1234
      debugOption = match[1];
      debugHost = match[3];
      debugPort = match[4];
    }

    if (debugOption && debugPort !== '0') {
      return `${debugOption}=${debugHost}:${parseInt(debugPort) + 1}`;
    }
    return arg;
  });
}

exports.Command = Command;
