const EventEmitter = require('events').EventEmitter;
const childProcess = require('child_process');
const path = require('path');
const fs = require('fs');
const process = require('process');

const { Argument, humanReadableArgName } = require('./argument.js');
const { CommanderError } = require('./error.js');
const { Help } = require('./help.js');
const { Option, splitOptionFlags, DualOptions } = require('./option.js');
const { suggestSimilar } = require('./suggestSimilar');

class Command extends EventEmitter {
  /**
   * Initialize a new `Command`.
   *
   * @param {string} [name]
   */

  constructor(name) {
    super();
    /** @type {Command[]} */
    this.commands = [];
    /** @type {Option[]} */
    this.options = [];
    this.parent = null;
    this._allowUnknownOption = false;
    this._allowExcessArguments = true;
    /** @type {Argument[]} */
    this.registeredArguments = [];
    this._args = this.registeredArguments; // deprecated old name
    /** @type {string[]} */
    this.args = []; // cli args with options removed
    this.rawArgs = [];
    this.processedArgs = []; // like .args but after custom processing and collecting variadic
    this._scriptPath = null;
    this._name = name || '';
    this._optionValues = {};
    this._optionValueSources = {}; // default, env, cli etc
    this._storeOptionsAsProperties = false;
    this._actionHandler = null;
    this._executableHandler = false;
    this._executableFile = null; // custom name for executable
    this._executableDir = null; // custom search directory for subcommands
    this._defaultCommandName = null;
    this._exitCallback = null;
    this._aliases = [];
    this._combineFlagAndOptionalValue = true;
    this._description = '';
    this._summary = '';
    this._argsDescription = undefined; // legacy
    this._enablePositionalOptions = false;
    this._passThroughOptions = false;
    this._lifeCycleHooks = {}; // a hash of arrays
    /** @type {boolean | string} */
    this._showHelpAfterError = false;
    this._showSuggestionAfterError = true;

    // see .configureOutput() for docs
    this._outputConfiguration = {
      writeOut: (str) => process.stdout.write(str),
      writeErr: (str) => process.stderr.write(str),
      getOutHelpWidth: () => process.stdout.isTTY ? process.stdout.columns : undefined,
      getErrHelpWidth: () => process.stderr.isTTY ? process.stderr.columns : undefined,
      outputError: (str, write) => write(str)
    };

    this._hidden = false;
    this._hasHelpOption = true;
    this._helpFlags = '-h, --help';
    this._helpDescription = 'display help for command';
    this._helpShortFlag = '-h';
    this._helpLongFlag = '--help';
    this._addImplicitHelpCommand = undefined; // Deliberately undefined, not decided whether true or false
    this._helpCommandName = 'help';
    this._helpCommandnameAndArgs = 'help [command]';
    this._helpCommandDescription = 'display help for command';
    this._helpConfiguration = {};
  }

  /**
   * Copy settings that are useful to have in common across root command and subcommands.
   *
   * (Used internally when adding a command using `.command()` so subcommands inherit parent settings.)
   *
   * @param {Command} sourceCommand
   * @return {Command} `this` command for chaining
   */
  copyInheritedSettings(sourceCommand) {
    this._outputConfiguration = sourceCommand._outputConfiguration;
    this._hasHelpOption = sourceCommand._hasHelpOption;
    this._helpFlags = sourceCommand._helpFlags;
    this._helpDescription = sourceCommand._helpDescription;
    this._helpShortFlag = sourceCommand._helpShortFlag;
    this._helpLongFlag = sourceCommand._helpLongFlag;
    this._helpCommandName = sourceCommand._helpCommandName;
    this._helpCommandnameAndArgs = sourceCommand._helpCommandnameAndArgs;
    this._helpCommandDescription = sourceCommand._helpCommandDescription;
    this._helpConfiguration = sourceCommand._helpConfiguration;
    this._exitCallback = sourceCommand._exitCallback;
    this._storeOptionsAsProperties = sourceCommand._storeOptionsAsProperties;
    this._combineFlagAndOptionalValue = sourceCommand._combineFlagAndOptionalValue;
    this._allowExcessArguments = sourceCommand._allowExcessArguments;
    this._enablePositionalOptions = sourceCommand._enablePositionalOptions;
    this._showHelpAfterError = sourceCommand._showHelpAfterError;
    this._showSuggestionAfterError = sourceCommand._showSuggestionAfterError;

    return this;
  }

  /**
   * @returns {Command[]}
   * @api private
   */

  _getCommandAndAncestors() {
    const result = [];
    for (let command = this; command; command = command.parent) {
      result.push(command);
    }
    return result;
  }

  /**
   * Define a command.
   *
   * There are two styles of command: pay attention to where to put the description.
   *
   * @example
   * // Command implemented using action handler (description is supplied separately to `.command`)
   * program
   *   .command('clone <source> [destination]')
   *   .description('clone a repository into a newly created directory')
   *   .action((source, destination) => {
   *     console.log('clone command called');
   *   });
   *
   * // Command implemented using separate executable file (description is second parameter to `.command`)
   * program
   *   .command('start <service>', 'start named service')
   *   .command('stop [service]', 'stop named service, or all if no name supplied');
   *
   * @param {string} nameAndArgs - command name and arguments, args are `<required>` or `[optional]` and last may also be `variadic...`
   * @param {Object|string} [actionOptsOrExecDesc] - configuration options (for action), or description (for executable)
   * @param {Object} [execOpts] - configuration options (for executable)
   * @return {Command} returns new command for action handler, or `this` for executable command
   */

  command(nameAndArgs, actionOptsOrExecDesc, execOpts) {
    let desc = actionOptsOrExecDesc;
    let opts = execOpts;
    if (typeof desc === 'object' && desc !== null) {
      opts = desc;
      /**
       * Copies settings that are useful to have in common across root command and subcommands.
       *
       * @param {Command} sourceCommand - The source command from which settings will be copied.
       * @returns {Command} - This command for chaining purposes.
       */
      cmd._executableHandler = true;
    }
    if (opts.isDefault) this._defaultCommandName = cmd._name;
    cmd._hidden = !!(opts.noHelp || opts.hidden); // noHelp is deprecated old name for hidden
    cmd._executableFile = opts.executableFile || null; // Custom name for executable file, set missing to null to match constructor
    if (args) cmd.arguments(args);
    this.commands.push(cmd);
    cmd.parent = this;
    cmd.copyInheritedSettings(this);

    if (desc) return this;
    return cmd;
  }

  /**
   * Factory routine to create a new unattached command.
   *
   * See .command() for creating an attached subcommand, which uses this routine to
   * create the command. You can override createCommand to customise subcommands.
   *
   * @param {string} [name]
   * @return {Command} new command
  }
/**
 * Returns an array of commands starting from the current command and moving up to its ancestors.
 *
 * @api private
 * @returns {Command[]} - An array of Command objects representing the current command and its ancestors.
 */

  /**
   * You can customise the help with a subclass of Help by overriding createHelp,
   * or by overriding Help properties using configureHelp().
   *
   * @return {Help}
   */

   *
   /**
    * Define a command.
    *
    * There are two styles of command: pay attention to where to put the description.
    *
    * @example
    * // Command implemented using action handler (description is supplied separately to `.command`)
    * program
    *   .command('clone <source> [destination]')
    *   .description('clone a repository into a newly created directory')
    *   .action((source, destination) => {
    *     console.log('clone command called');
    *   });
    *
    * // Command implemented using separate executable file (description is second parameter to `.command`)
    * program
    *   .command('start <service>', 'start named service')
    *   .command('stop [service]', 'stop named service, or all if no name supplied');
    *
    * @param {string} nameAndArgs - command name and arguments, args are `<required>` or `[optional]` and last may also be `variadic...`
    * @param {Object|string} [actionOptsOrExecDesc] - configuration options (for action), or description (for executable)
    * @param {Object} [execOpts] - configuration options (for executable)
    * @return {Command} returns new command for action handler, or `this` for executable command
    */
   *     // functions to change where being written, stdout and stderr
   *     writeOut(str)
   *     writeErr(str)
   *     // matching functions to specify width for wrapping help
   *     getOutHelpWidth()
   *     getErrHelpWidth()
   *     // functions based on what is being written out
   *     outputError(str, write) // used for displaying errors, and not used for displaying help
   *
   * @param {Object} [configuration] - configuration options
   * @return {Command|Object} `this` command for chaining, or stored configuration
   */

  configureOutput(configuration) {
    if (configuration === undefined) return this._outputConfiguration;

    Object.assign(this._outputConfiguration, configuration);
    return this;
  }

  /**
   * Display the help or a custom message after an error occurs.
   *
   * @param {boolean|string} [displayHelp]
   * @return {Command} `this` command for chaining
   */
  showHelpAfterError(displayHelp = true) {
   * @return {Command} `this` command for chaining
   /**
    * Factory routine to create a new unattached command.
    *
    * See .command() for creating an attached subcommand, which uses this routine to
    * create the command. You can override createCommand to customise subcommands.
    *
    * @param {string} [name] - The name of the command to be created.
    * @return {Command} - A new unattached command instance.
    */
   */
  showSuggestionAfterError(displaySuggestion = true) {
    this._showSuggestionAfterError = !!displaySuggestion;
    return this;
   *
   /**
    * Creates an instance of Help customized with properties configured through configureHelp().
    *
    * @returns {Help} - A new instance of Help with custom configurations applied.
    */
   * @param {Command} cmd - new subcommand
   * @param {Object} [opts] - configuration options
   * @return {Command} `this` command for chaining
   */
    opts = opts || {};
    /**
     * Customizes the help by overriding Help properties using configureHelp(), or with a subclass of Help by overriding createHelp().
     *
     * @param {Object} [configuration] - Configuration options.
     * @return {Command|Object} `this` command for chaining, or stored configuration.
     */
    if (opts.isDefault) this._defaultCommandName = cmd._name;
    if (opts.noHelp || opts.hidden) cmd._hidden = true; // modifying passed command due to existing implementation

    this.commands.push(cmd);
    cmd.parent = this;
    return this;
  }
   *
   /**
    * Configures the output of the command. This method allows customization of where the output is being written, such as stdout and stderr. It also provides options to specify the width for wrapping help messages and to handle custom error outputs.
    *
    * The configuration parameter is an object containing functions that define how the output should be handled:
    *
    * - `writeOut(str)`: Function to write a string to the standard output.
    * - `writeErr(str)`: Function to write a string to the standard error.
    * - `getOutHelpWidth()`: Function to get the width for wrapping help messages on stdout.
    * - `getErrHelpWidth()`: Function to get the width for wrapping help messages on stderr.
    * - `outputError(str, write)`: Function to handle error output. This function is used exclusively for displaying errors and should not be used for displaying help messages.
    *
    * @param {Object} [configuration] - Configuration options for customizing output behavior.
    * @return {Command|Object} The current command instance for method chaining, or the stored configuration object if no new configuration was provided.
    */
   * The default is that the argument is required, and you can explicitly
   * indicate this with <> around the name. Put [] around the name for an optional argument.
   *
   * @example
   * program.argument('<input-file>');
   * program.argument('[output-file]');
   *
  /**
   * Display the help or a custom message after an error occurs.
   *
   * @param {boolean|string} [displayHelp=true] - Determines whether to display help. If a string is provided, it will be displayed instead of the default help message.
   * @return {Command} The command instance for method chaining.
   */
  argument(name, description, fn, defaultValue) {
    const argument = this.createArgument(name, description);
    if (typeof fn === 'function') {
      argument.default(defaultValue).argParser(fn);
    } else {
      argument.default(fn);
   /**
    * Enable or disable the display of suggestion for similar commands when an unknown command is encountered,
    * or for options when an unknown option is specified.
    *
    * @param {boolean} [displaySuggestion=true] - Whether to enable (true) or disable (false) the suggestion feature. Default is true.
    * @returns {Command} The current command instance, allowing method chaining.
    *
    * Example:
    *   myCommand.showSuggestionAfterError(true); // Enable suggestion
    *   myCommand.showSuggestionAfterError(false); // Disable suggestion
    */
   * Define argument syntax for command, adding multiple at once (without descriptions).
   *
   * See also .argument().
   *
   * @example
    });
    /**
     * Add a prepared subcommand.
     *
     * See .command() for creating an attached subcommand which inherits settings from its parent.
     *
     * @param {Command} cmd - The new subcommand to be added. The command must have a name, which can be specified in the Command constructor or using the .name() method.
     * @param {Object} [opts] - Optional configuration options for the subcommand.
     * @param {boolean} [opts.isDefault=false] - If true, sets this command as the default subcommand.
     * @param {boolean} [opts.noHelp=false] - If true, hides this command from help output.
     * @param {boolean} [opts.hidden=false] - If true, makes this command hidden from regular command lists.
     * @returns {Command} The current command instance (`this`), allowing for method chaining.
     * @throws {Error} Throws an error if the provided command does not have a name.
     * @example
     * // Create a new command and add it with default options
     * myCommand.addCommand(new Command('mySubCmd'));
     *
     * // Add a subcommand with additional configuration options
     * myCommand.addCommand(new Command('myHiddenCmd'), { hidden: true });
     */
    return this;
  }

  /**
   * Define argument syntax for command, adding a prepared argument.
   *
   * @param {Argument} argument
   * @return {Command} `this` command for chaining
   */
  addArgument(argument) {
    const previousArgument = this.registeredArguments.slice(-1)[0];
    if (previousArgument && previousArgument.variadic) {
      throw new Error(`only the last argument can be variadic '${previousArgument.name()}'`);
    }
    if (argument.required && argument.defaultValue !== undefined && argument.parseArg === undefined) {
   *    addHelpCommand(false); // force off
   /**
    * Factory routine to create a new unattached argument.
    *
    * See .argument() for creating an attached argument, which uses this routine to
    * create the argument. You can override createArgument to return a custom argument.
    *
    * @param {string} name - The name of the argument.
    * @param {string} [description] - Optional description of the argument.
    * @return {Argument} new argument - The newly created argument object.
    */
   *    addHelpCommand('help [cmd]', 'display help for [cmd]'); // force on with custom details
   *
   * @return {Command} `this` command for chaining
   */
   /**
    * Define argument syntax for command.
    *
    * The default is that the argument is required. You can explicitly indicate this with <> around the name. Put [] around the name for an optional argument.
    *
    * @param {string} name - The name of the argument.
    * @param {string} [description] - A description of the argument.
    * @param {Function|*} [fn] - A custom argument processing function or a default value.
    * @param {*} [defaultValue] - A default value for the argument if it is optional.
    * @return {Command} The current command object for method chaining.
    */
   * @return {boolean}
   * @api private
   */

  _hasImplicitHelpCommand() {
    if (this._addImplicitHelpCommand === undefined) {
      return this.commands.length && !this._actionHandler && !this._findCommand('help');
    }
    return this._addImplicitHelpCommand;
  }

      throw new Error(`Unexpected value for event passed to hook : '${event}'.
/**
 * Define argument syntax for command, adding multiple at once (without descriptions).
 *
 * See also .argument().
 *
 * @example
 * program.arguments('<cmd> [env]');
 *
 * @param {string} names - A string containing the names of the arguments separated by spaces.
 * @return {Command} `this` command for chaining.
 */
Expecting one of '${allowedValues.join("', '")}'`);
    }
    if (this._lifeCycleHooks[event]) {
      this._lifeCycleHooks[event].push(listener);
    } else {
      this._lifeCycleHooks[event] = [listener];
    }
   /**
    * Adds a prepared argument to the command.
    *
    * @param {Argument} argument - The argument to be added.
    * @return {Command} The current command instance for method chaining.
    *
    * @throws {Error} Throws an error if the previous argument is variadic and this one is not.
    * @throws {Error} Throws an error if a required argument has a default value but no parseArg function.
    */
   * @param {Function} [fn] optional callback which will be passed a CommanderError, defaults to throwing
   * @return {Command} `this` command for chaining
   */

  exitOverride(fn) {
    if (fn) {
      this._exitCallback = fn;
    } else {
      this._exitCallback = (err) => {
        if (err.code !== 'commander.executeSubCommandAsync') {
          throw err;
        } else {
   *
   /**
    * Override default decision whether to add implicit help command.
    *
    * @param {boolean|string} enableOrNameAndArgs - If `false`, disables the implicit help command. If a string, sets custom details for the help command.
    * @param {string} [description] - Optional description for the custom help command.
    * @return {Command} The current command object for method chaining.
    *
    * Examples:
    *   addHelpCommand() // Enables the default implicit help command.
    *   addHelpCommand(false); // Disables the implicit help command.
    *   addHelpCommand('help [cmd]', 'display help for [cmd]'); // Enables custom help command with description.
    */
   * @param {number} exitCode exit code for using with process.exit
   * @param {string} code an id string representing the error
   * @param {string} message human-readable description of the error
   * @return never
   * @api private
   */

  _exit(exitCode, code, message) {
    if (this._exitCallback) {
      this._exitCallback(new CommanderError(exitCode, code, message));
      // Expecting this line is not reached.
    }
    process.exit(exitCode);
  }
   * @example
   /**
    * Determines whether an implicit help command should be added to the application.
    *
    * @return {boolean} - Returns `true` if an implicit help command is to be added, otherwise `false`.
    * @api private
    */
   * program
   *   .command('serve')
   *   .description('start service')
   *   .action(function() {
   *      // do work here
   *   });
   *
     *
     /**
      * Adds a listener function to a lifecycle event.
      *
      * @param {string} event - The lifecycle event to listen for. Must be one of 'preSubcommand', 'preAction', or 'postAction'.
      * @param {Function} listener - The listener function that will be called when the specified event occurs.
      * @returns {Command} Returns `this` command instance, allowing for method chaining.
      *
      * @throws {Error} If an invalid event value is provided.
      *
      * @example
      * myCommand.hook('preAction', () => {
      *   console.log('Pre-action hook executed');
      * });
      */
     * @callback ListenerCallback
     * @param {Array} args - The arguments passed to the action.
     * @returns {*} - The result of applying the `fn` function with the modified arguments.
     */
    const listener = (args) => {
      // The .action callback takes an extra parameter which is the command or options.
      const expectedArgsCount = this.registeredArguments.length;
      const actionArgs = args.slice(0, expectedArgsCount);
      if (this._storeOptionsAsProperties) {
        actionArgs[expectedArgsCount] = this; // backwards compatible "options"
      } else {
        actionArgs[expectedArgsCount] = this.opts();
      }
      actionArgs.push(this);

  /**
   * Register callback to use as replacement for calling process.exit.
   *
   * @param {Function} [fn] - Optional callback which will be passed a CommanderError. If not provided, defaults to throwing an error.
   * @returns {Command} `this` command for chaining
   */
  /**
   * Factory routine to create a new unattached option.
   *
   * See .option() for creating an attached option, which uses this routine to
   * create the option. You can override createOption to return a custom option.
   *
   * @param {string} flags
   * @param {string} [description]
   * @return {Option} new option
   */

  createOption(flags, description) {
    return new Option(flags, description);
  }


  /**
   * Call process.exit, and _exitCallback if defined.
   *
   * @param {number} exitCode - The exit code for using with `process.exit`.
   * @param {string} code - An id string representing the error.
   * @param {string} message - Human-readable description of the error.
   * @return {never} - This function does not return; it exits the process.
   * @api private
   */
  _callParseArg(target, value, previous, invalidArgumentMessage) {
    try {
      return target.parseArg(value, previous);
    } catch (err) {
      if (err.code === 'commander.invalidArgument') {
        const message = `${invalidArgumentMessage} ${err.message}`;
        this.error(message, { exitCode: err.exitCode, code: err.code });
      }
    // store default value
    /**
     * Register callback `fn` for the command.
     *
     * @param {Function} fn - The callback function to execute when the command is invoked. This function receives arguments that are specific to the command and an additional parameter containing the command or options.
     * @returns {Command} Returns this command object (`this`) for chaining purposes.
     *
     * @example
     * program
     *   .command('serve')
     *   .description('start service')
     *   .action(function() {
     *      // do work here
     *   });
     */
    if (option.negate) {
      // --no-foo is special and defaults foo to true, unless a --foo option is already defined
      const positiveLongFlag = option.long.replace(/^--no-/, '--');
      if (!this._findOption(positiveLongFlag)) {
        this.setOptionValueWithSource(name, option.defaultValue === undefined ? true : option.defaultValue, 'default');
      }
    } else if (option.defaultValue !== undefined) {
      this.setOptionValueWithSource(name, option.defaultValue, 'default');
    }

    // register the option
    this.options.push(option);

    // handler for cli and env supplied values
    /**
     * Handles the value of an option by applying various processing steps such as setting a preset argument,
     * parsing arguments, handling variadic options, and filling in missing values.
     *
      }
/**
 * Factory routine to create a new unattached option.
 *
 * See .option() for creating an attached option, which uses this routine to
 * create the option. You can override createOption to return a custom option.
 *
 * @param {string} flags - A string representing the flag(s) associated with the option.
 * @param {string} [description] - An optional description of the option.
 * @returns {Option} - The newly created Option object.
 */

      // custom processing
      const oldValue = this.getOptionValue(name);
      if (val !== null && option.parseArg) {
        } else if (option.isBoolean() || option.optional) {
          /**
           * Wrap parseArgs to catch 'commander.invalidArgument'.
           *
           * @param {Option | Argument} target - The target option or argument.
           * @param {string} value - The value to be parsed.
           * @param {*} previous - The previous value, if any.
           * @param {string} invalidArgumentMessage - The message to prepend in case of an invalid argument error.
           * @throws {Error} Throws the original error if it's not a 'commander.invalidArgument'.
           */
          val = true;
        } else {
          val = ''; // not normal, parseArg might have failed or be a mock function for testing
        }
      }
      this.setOptionValueWithSource(name, val, valueSource);
    };

    this.on('option:' + oname, (val) => {
      const invalidValueMessage = `error: option '${option.flags}' argument '${val}' is invalid.`;
      handleOptionValue(val, invalidValueMessage, 'cli');
    });
    /**
     * Adds an option to the command.
     *
     * @param {Option} option - The option to add. This should include details such as the name, flags, and other attributes of the option.
     * @returns {Command} - Returns `this` command object for method chaining.
     *
     * @example
     * const myCommand = new Command();
     * myCommand.addOption(new Option('--verbose', 'Enable verbose mode'));
     */
    }

    return this;
  }

  /**
   * Internal implementation shared by .option() and .requiredOption()
   *
   * @api private
   */
  _optionEx(config, flags, description, fn, defaultValue) {
    if (typeof flags === 'object' && flags instanceof Option) {
      throw new Error('To add an Option object use addOption() instead of option() or requiredOption()');
    }
    const option = this.createOption(flags, description);
    option.makeOptionMandatory(!!config.mandatory);
    if (typeof fn === 'function') {
      option.default(defaultValue).argParser(fn);
    } else if (fn instanceof RegExp) {
      // deprecated
      const regex = fn;
      fn = (val, def) => {
        const m = regex.exec(val);
        return m ? m[0] : def;
      };
      option.default(defaultValue).argParser(fn);
    } else {
      option.default(fn);
    }

    return this.addOption(option);
  }

  /**
   * Define option with `flags`, `description`, and optional argument parsing function or `defaultValue` or both.
   *
   * The `flags` string contains the short and/or long flags, separated by comma, a pipe or space. A required
   * option-argument is indicated by `<>` and an optional option-argument by `[]`.
   *
   * See the README for more details, and see also addOption() and requiredOption().
   *
   * @example
   * program
   *     .option('-p, --pepper', 'add pepper')
   *     .option('-p, --pizza-type <TYPE>', 'type of pizza') // required option-argument
   *     .option('-c, --cheese [CHEESE]', 'add extra cheese', 'mozzarella') // optional option-argument with default
   *     .option('-t, --tip <VALUE>', 'add tip to purchase cost', parseFloat) // custom parse function
   *
   * @param {string} flags
   * @param {string} [description]
   * @param {Function|*} [parseArg] - custom option processing function or default value
   * @param {*} [defaultValue]
   * @return {Command} `this` command for chaining
   */

  option(flags, description, parseArg, defaultValue) {
    return this._optionEx({}, flags, description, parseArg, defaultValue);
  }

  /**
  * Add a required option which must have a value after parsing. This usually means
  * the option must be specified on the command line. (Otherwise the same as .option().)
  /**
   * Internal implementation shared by .option() and .requiredOption()
   *
   * @api private
   * @param {Object} config - Configuration object containing mandatory flag.
   * @param {string|Option} flags - A string representing the option name or an Option object.
   * @param {string} description - Description of the option.
   * @param {Function|RegExp} fn - Function to parse the argument value or a regular expression.
   * @param {*} defaultValue - Default value for the option.
   * @returns {Option} The created and configured Option instance.
   * @throws {Error} If an Option object is passed directly to flags instead of using addOption().
   */
  * @param {Function|*} [parseArg] - custom option processing function or default value
  * @param {*} [defaultValue]
  * @return {Command} `this` command for chaining
  */

  requiredOption(flags, description, parseArg, defaultValue) {
    return this._optionEx({ mandatory: true }, flags, description, parseArg, defaultValue);
  }

  /**
   * Alter parsing of short flags with optional values.
   *
   * @example
   * // for `.option('-f,--flag [value]'):
   * program.combineFlagAndOptionalValue(true);  // `-f80` is treated like `--flag=80`, this is the default behaviour
   * program.combineFlagAndOptionalValue(false) // `-fb` is treated like `-f -b`
   *
   * @param {Boolean} [combine=true] - if `true` or omitted, an optional value can be specified directly after the flag.
   */
  combineFlagAndOptionalValue(combine = true) {
    this._combineFlagAndOptionalValue = !!combine;
    return this;
  }
  }
/**
 * Define option with `flags`, `description`, and optional argument parsing function or `defaultValue` or both.
 *
 * The `flags` string contains the short and/or long flags, separated by comma, a pipe or space. A required
 * option-argument is indicated by `<>` and an optional option-argument by `[]`.
 *
 * See the README for more details, and see also addOption() and requiredOption().
 *
 * @example
 * program
 *     .option('-p, --pepper', 'add pepper')
 *     .option('-p, --pizza-type <TYPE>', 'type of pizza') // required option-argument
 *     .option('-c, --cheese [CHEESE]', 'add extra cheese', 'mozzarella') // optional option-argument with default
 *     .option('-t, --tip <VALUE>', 'add tip to purchase cost', parseFloat) // custom parse function
 *
 * @param {string} flags - The string containing the short and/or long flags for the option.
 * @param {string} [description] - The description of the option.
 * @param {Function|*} [parseArg] - A custom option processing function or a default value.
 * @param {*} [defaultValue] - The default value for the option if it is not provided.
 * @return {Command} `this` command for chaining.
 */

  /**
   * Enable positional options. Positional means global options are specified before subcommands which lets
   * subcommands reuse the same option names, and also enables subcommands to turn on passThroughOptions.
   * positional options to have been enabled on the program (parent commands).
   /**
    * Adds a required option which must have a value after parsing. This usually means
    * the option must be specified on the command line.
    *
    * The `flags` string contains the short and/or long flags, separated by comma, a pipe or space.
    *
    * @param {string} flags - A string containing the short and/or long flags for the option,
    *                        separated by comma, a pipe or space. For example: "-p, --port"
    * @param {string} [description] - An optional description of the option to be displayed in help messages.
    * @param {Function|*} [parseArg] - An optional custom function to parse the argument value for this option,
    *                                or a default value if no function is provided. The function signature
    *                                should be (value, previousValue) => newValue.
    * @param {*} [defaultValue] - An optional default value for the option if it's not provided by the user.
    * @returns {Command} `this` command for chaining methods.
    *
    * @example
    * // Adds a required option with a custom parse function
    * program.requiredOption('-p, --port <number>', 'set port', (value) => parseInt(value), 3000);
    *
    * @example
    * // Adds a required option with a default value
    * program.requiredOption('--debug [boolean]', 'enable debug mode', true);
    */
   * The default behaviour is non-positional and options may appear before or after command-arguments.
   *
   * @param {Boolean} [passThrough=true]
   * for unknown options.
    /**
     * Alter parsing of short flags with optional values.
     *
     * @param {Boolean} [combine=true] - if `true` or omitted, an optional value can be specified directly after the flag. If `false`, options must be specified as separate arguments.
     * @returns {Object} The current instance of the program for method chaining.
     *
     * @example
     * // for `.option('-f,--flag [value]'):
     * program.combineFlagAndOptionalValue(true);  // `-f80` is treated like `--flag=80`, this is the default behaviour
     * program.combineFlagAndOptionalValue(false) // `-fb` is treated like `-f -b`
     */
    * Whether to store option values as properties on command object,
    * or store separately (specify false). In both cases the option values can be accessed using .opts().
    *
    * @param {boolean} [storeAsProperties=true]
    * @return {Command} `this` command for chaining
    /**
     * Allow unknown options on the command line.
     *
     * @param {Boolean} [allowUnknown=true] - if `true` or omitted, no error will be thrown for unknown options.
     * @return {Object} The current instance of the class to allow chaining methods.
     */
    // if (Object.keys(this._optionValues).length) {
    //   throw new Error('call .storeOptionsAsProperties() before setting option values');
    // }
    this._storeOptionsAsProperties = !!storeAsProperties;
    return this;
   /**
    * Allow excess command-arguments on the command line. Pass false to make excess arguments an error.
    *
    * @param {Boolean} [allowExcess=true] - If `true` or omitted, no error will be thrown for excess arguments.
    * @returns {Object} - Returns the current instance of the object, allowing method chaining.
    */
   * @return {Object} value
   */

  getOptionValue(key) {
    if (this._storeOptionsAsProperties) {
   /**
    * Enable or disable positional options. Positional means global options are specified before subcommands,
    * allowing subcommands to reuse the same option names and enabling passThroughOptions for subcommands.
    *
    * @param {Boolean} [positional=true] - Whether to enable (true) or disable (false) positional options. The default is true.
    * @returns {Object} - The current instance of the object, allowing method chaining.
    *
    * Example:
    * ```javascript
    * myObject.enablePositionalOptions(false);
    * ```
    */
   *
   * @param {string} key
   * @param {Object} value
   * @return {Command} `this` command for chaining
   */
    /**
     * Pass through options that come after command-arguments rather than treat them as command-options,
     * so actual command-options come before command-arguments. Turning this on for a subcommand requires
     * positional options to have been enabled on the program (parent commands).
     * The default behaviour is non-positional and options may appear before or after command-arguments.
     *
     * @param {Boolean} [passThrough=true] - A boolean indicating whether to pass through unknown options. Defaults to true.
     * @returns {Object} The current object instance for method chaining.
     * @throws {Error} Throws an error if `passThroughOptions` is used without enabling positional options on parent command(s).
     *
     * Example:
     * ```javascript
     * myCommand.passThroughOptions(false);
     * ```
     */
    * @param {Object} value
    * @param {string} source - expected values are default/config/env/cli/implied
    * @return {Command} `this` command for chaining
    */

  setOptionValueWithSource(key, value, source) {
    if (this._storeOptionsAsProperties) {
      this[key] = value;
  /**
    /**
     * Sets whether option values should be stored as properties on the command object or separately.
     *
     * @param {boolean} [storeAsProperties=true] - Determines if option values are stored as properties (true) or separately (false). If true, you can access option values using `.opts()`.
     * @returns {Command} The current command instance for method chaining.
     * @throws {Error} Throws an error if called after adding options or setting option values.
     *
     * Example usage:
     * const cmd = new Command();
     * try {
     *   cmd.storeOptionsAsProperties(false);
     * } catch (e) {
     *   console.error(e.message); // Output: call .storeOptionsAsProperties() before adding options
     * }
     */
    * Get source of option value.
    * Expected values are default | config | env | cli | implied
    *
    * @param {string} key
    * @return {string}
    */

  getOptionValueSource(key) {
    return this._optionValueSources[key];
  }

    */
/**
 * Retrieve option value from an object's properties or internal store.
 *
 * @param {string} key - The key corresponding to the desired option.
 * @return {Object} - The value associated with the provided key. Returns `undefined` if the key does not exist.
 * @throws {Error} - Throws an error if `key` is not a string or if `_storeOptionsAsProperties` is false and `_optionValues` is undefined.
 */

  getOptionValueSourceWithGlobals(key) {
    // global overwrites local, like optsWithGlobals
    let source;
    this._getCommandAndAncestors().forEach((cmd) => {
      if (cmd.getOptionValueSource(key) !== undefined) {
        source = cmd.getOptionValueSource(key);
   * Side-effects: set _scriptPath if args included script. Used for default program name, and subcommand searches.
   /**
    * Store option value.
    *
    * @param {string} key - The key for the option to store.
    * @param {Object} value - The value to store for the given key.
    * @return {Command} `this` command for chaining.
    */
   *
   * @api private
   */

      argv = process.argv;
      /**
       * Store option value and where the value came from.
       *
       * @param {string} key - The unique identifier for the option.
       * @param {Object} value - The value of the option to be stored.
       * @param {string} source - The source of the option value, expected values are 'default', 'config', 'env', 'cli', 'implied'.
       * @return {Command} - Returns the current command instance for method chaining.
       */
      // @ts-ignore: unknown property
      if (process.versions && process.versions.electron) {
        parseOptions.from = 'electron';
      }
    }
    this.rawArgs = argv.slice();

    // make it a little easier for callers by supporting various argv conventions
    let userArgs;
    switch (parseOptions.from) {
        if (process.defaultApp) {
          /**
           * Retrieve the source of an option value based on the provided key.
           *
           * @param {string} key - The unique identifier for the option whose source is to be retrieved.
           * @return {string} - The source of the option value. Expected values are 'default', 'config', 'env', 'cli', or 'implied'.
           * @throws {Error} - Throws an error if the provided key does not exist in the option value sources.
           */
          this._scriptPath = argv[1];
          userArgs = argv.slice(2);
        } else {
          userArgs = argv.slice(1);
    }
/**
 * Get source of option value, considering global overwrites. See also .optsWithGlobals().
 *
 * @param {string} key - The key for the option whose source is to be retrieved.
 * @return {string} The source of the option value. Expected values are 'default', 'config', 'env', 'cli', or 'implied'.
 */

    // Find default name for program from arguments.
    if (!this._name && this._scriptPath) this.nameFromFilename(this._scriptPath);
    this._name = this._name || 'program';

    return userArgs;
  }

  /**
   * Parse `argv`, setting options and invoking commands when defined.
   *
   * program.parse(my-args, { from: 'user' }); // just user supplied arguments, nothing special about argv[0]
   /**
    * Get user arguments from implied or explicit arguments. Set _scriptPath if args include script. Used for default program name, and subcommand searches.
    *
    * @api private
    * @param {Array|string|undefined} argv - The array of command-line arguments or a string to be parsed. If undefined, defaults to process.argv.
    * @param {Object} parseOptions - Options to customize the parsing behavior.
    * @param {string} [parseOptions.from] - Specifies the source of the arguments.
    * @returns {Array|string} The user arguments after processing.
    *
    * @throws {Error} If the first parameter is not an array or undefined.
    * @throws {Error} If an unexpected parse option is provided.
    */
   *
   * @param {string[]} [argv] - optional, defaults to process.argv
   * @param {Object} [parseOptions] - optionally specify style of options with from: node/user/electron
   * @param {string} [parseOptions.from] - where the args are from: 'node', 'user', 'electron'
   * @return {Command} `this` command for chaining
   */

  parse(argv, parseOptions) {
    const userArgs = this._prepareUserArgs(argv, parseOptions);
    this._parseCommand([], userArgs);

    return this;
  }

  /**
   * Parse `argv`, setting options and invoking commands when defined.
   *
   * Use parseAsync instead of parse if any of your action handlers are async. Returns a Promise.
   *
   * The default expectation is that the arguments are from node and have the application as argv[0]
   * and the script being run in argv[1], with user parameters after that.
   *
   * @example
   * await program.parseAsync(process.argv);
   * await program.parseAsync(); // implicitly use process.argv and auto-detect node vs electron conventions
   * await program.parseAsync(my-args, { from: 'user' }); // just user supplied arguments, nothing special about argv[0]
   *
   * @param {string[]} [argv]
   * @param {Object} [parseOptions]
   * @param {string} parseOptions.from - where the args are from: 'node', 'user', 'electron'
   * @return {Promise}
   */

  async parseAsync(argv, parseOptions) {
    const userArgs = this._prepareUserArgs(argv, parseOptions);
    await this._parseCommand([], userArgs);

    return this;
  }

  /**
   * Execute a sub-command executable.
   *
   * @api private
   */

  _executeSubCommand(subcommand, args) {
    function findFile(baseDir, baseName) {
      /**
       * Parse `argv`, setting options and invoking commands when defined.
       *
       * The default expectation is that the arguments are from node and have the application as argv[0]
       * and the script being run in argv[1], with user parameters after that.
       *
       * @example
       * program.parse(process.argv);
       * program.parse(); // implicitly use process.argv and auto-detect node vs electron conventions
       * program.parse(my-args, { from: 'user' }); // just user supplied arguments, nothing special about argv[0]
       *
       * @param {string[]} [argv] - optional, defaults to process.argv
       * @param {Object} [parseOptions] - optionally specify style of options with from: node/user/electron
       * @param {string} [parseOptions.from] - where the args are from: 'node', 'user', 'electron'
       * @return {Command} `this` command for chaining
       */
      // Look for specified file
      const localBin = path.resolve(baseDir, baseName);
      if (fs.existsSync(localBin)) return localBin;

      // Stop looking if candidate already has an expected extension.
      if (sourceExt.includes(path.extname(baseName))) return undefined;

      } catch (err) {
        /**
         * Parse `argv`, setting options and invoking commands when defined.
         *
         * Use parseAsync instead of parse if any of your action handlers are async. Returns a Promise.
         *
         * The default expectation is that the arguments are from node and have the application as argv[0]
         * and the script being run in argv[1], with user parameters after that.
         *
         * @param {string[]} [argv] - Array of command-line arguments to parse. If not provided, uses process.argv by default.
         * @param {Object} [parseOptions] - Options for parsing.
         * @param {string} [parseOptions.from='node'] - Where the args are from: 'node', 'user', or 'electron'. Default is 'node'.
         * @return {Promise<void>} - A Promise that resolves when parsing is complete.
         */
        resolvedScriptPath = this._scriptPath;
      }
      executableDir = path.resolve(path.dirname(resolvedScriptPath), executableDir);
    }

    // Look for a local file in preference to a command in PATH.
    if (executableDir) {
        if (legacyName !== this._name) {
          /**
           * Execute a sub-command executable.
           *
           * @api private
           *
           * @param {string} subcommand - The subcommand to execute.
           * @param {Array<string>} args - Arguments to pass to the subcommand.
           */
          localFile = findFile(executableDir, `${legacyName}-${subcommand._name}`);
        }
      }
      executableFile = localFile || executableFile;
    }

    launchWithNode = sourceExt.includes(path.extname(executableFile));

    let proc;
    if (process.platform !== 'win32') {
      if (launchWithNode) {
        args.unshift(executableFile);
        // add executable arguments to spawn
        args = incrementNodeInspectorPort(process.execArgv).concat(args);

        proc = childProcess.spawn(process.argv[0], args, { stdio: 'inherit' });
      } else {
        proc = childProcess.spawn(executableFile, args, { stdio: 'inherit' });
      }
    } else {
      args.unshift(executableFile);
      // add executable arguments to spawn
      args = incrementNodeInspectorPort(process.execArgv).concat(args);
      proc = childProcess.spawn(process.execPath, args, { stdio: 'inherit' });
    }

    if (!proc.killed) { // testing mainly to avoid leak warnings during unit tests with mocked spawn
      const signals = ['SIGUSR1', 'SIGUSR2', 'SIGTERM', 'SIGINT', 'SIGHUP'];
      signals.forEach((signal) => {
        // @ts-ignore
        process.on(signal, () => {
          if (proc.killed === false && proc.exitCode === null) {
            proc.kill(signal);
          }
        });
      });
    }

    // By default terminate process when spawned process terminates.
    // Suppressing the exit if exitCallback defined is a bit messy and of limited use, but does allow process to stay running!
    const exitCallback = this._exitCallback;
    if (!exitCallback) {
      proc.on('close', process.exit.bind(process));
    } else {
      proc.on('close', () => {
        exitCallback(new CommanderError(process.exitCode || 0, 'commander.executeSubCommandAsync', '(close)'));
      });
    }
    proc.on('error', (err) => {
      // @ts-ignore
      if (err.code === 'ENOENT') {
        const executableDirMessage = executableDir
          ? `searched for local subcommand relative to directory '${executableDir}'`
          : 'no directory for search for local subcommand, use .executableDir() to supply a custom directory';
        const executableMissing = `'${executableFile}' does not exist
 - if '${subcommand._name}' is not meant to be an executable command, remove description parameter from '.command()' and use '.description()' instead
 - if the default executable name is not suitable, use the executableFile option to supply a custom name or path
 - ${executableDirMessage}`;
        throw new Error(executableMissing);
      // @ts-ignore
      } else if (err.code === 'EACCES') {
        throw new Error(`'${executableFile}' not executable`);
      }
      if (!exitCallback) {
        process.exit(1);
      } else {
        const wrappedError = new CommanderError(1, 'commander.executeSubCommandAsync', '(error)');
        wrappedError.nestedError = err;
        exitCallback(wrappedError);
      }
    });

    // Store the reference to the child process
    this.runningCommand = proc;
  }

  /**
   * @api private
   */

  _dispatchSubcommand(commandName, operands, unknown) {
    const subCommand = this._findCommand(commandName);
    if (!subCommand) this.help({ error: true });

    let promiseChain;
    promiseChain = this._chainOrCallSubCommandHook(promiseChain, subCommand, 'preSubcommand');
    promiseChain = this._chainOrCall(promiseChain, () => {
      if (subCommand._executableHandler) {
        this._executeSubCommand(subCommand, operands.concat(unknown));
      } else {
        return subCommand._parseCommand(operands, unknown);
      }
    });
    return promiseChain;
  }

  /**
   * Invoke help directly if possible, or dispatch if necessary.
   * e.g. help foo
   *
   * @api private
   */

  _dispatchHelpCommand(subcommandName) {
    if (!subcommandName) {
      this.help();
    }
    const subCommand = this._findCommand(subcommandName);
    if (subCommand && !subCommand._executableHandler) {
      subCommand.help();
    }

    // Fallback to parsing the help flag to invoke the help.
    return this._dispatchSubcommand(subcommandName, [], [
      this._helpLongFlag || this._helpShortFlag
    ]);
  }

  /**
   * Check this.args against expected this.registeredArguments.
   *
  _checkNumberOfArguments() {
    /**
     * Dispatches a subcommand based on the provided command name.
     *
     * @private
     * @param {string} commandName - The name of the subcommand to dispatch.
     * @param {Array} operands - Additional arguments passed to the subcommand.
     * @param {Array} unknown - Unknown or additional operands not handled by the subcommand.
     * @returns {Promise} - A promise chain that resolves once the subcommand has been executed.
     *
     * @throws {Error} If no matching subcommand is found, an error will be thrown and help information will be displayed.
     */
    // too few
    this.registeredArguments.forEach((arg, i) => {
      if (arg.required && this.args[i] == null) {
        this.missingArgument(arg.name());
      }
    });
    // too many
    if (this.registeredArguments.length > 0 && this.registeredArguments[this.registeredArguments.length - 1].variadic) {
      return;
    }
    if (this.args.length > this.registeredArguments.length) {
      this._excessArguments(this.args);
    }
  }

  /**
    /**
     /**
      * Dispatches a help command based on the provided subcommand name.
      *
      * @private
      * @param {string} subcommandName - The name of the subcommand to help with. If not provided, invokes general help.
      * @returns {Promise<void>} A promise that resolves when the help has been dispatched or fallback actions have been taken.
      *
      * @example
      * // Invokes general help if no subcommand is specified
      * instance._dispatchHelpCommand();
      *
      * // Dispatches help for a specific subcommand
      * instance._dispatchHelpCommand('foo');
      */
     * Parses an argument value using the specified parser function.
     *
     * @param {Object} argument - The command argument object.
     * @param {*} value - The value to be parsed.
     * @param {*} previous - The previous value before parsing (if any).
     * @returns {*} The parsed value or the original value if parsing fails.
     * @throws {Error} If the parsing function throws an error and no custom invalid value message is provided.
     */
    const myParseArg = (argument, value, previous) => {
      // Extra processing for nice error message on parsing failure.
      let parsedValue = value;
      if (value !== null && argument.parseArg) {
        const invalidValueMessage = `error: command-argument value '${value}' is invalid for argument '${argument.name()}'.`;
        parsedValue = this._callParseArg(argument, value, previous, invalidValueMessage);
      }
    const processedArgs = [];
    /**
     * Check if the number of arguments provided matches the expected number based on the registered arguments.
     *
     * @api private
     */
    this.registeredArguments.forEach((declaredArg, index) => {
      let value = declaredArg.defaultValue;
      if (declaredArg.variadic) {
        // Collect together remaining arguments for passing together as an array.
        if (index < this.args.length) {
          value = this.args.slice(index);
          if (declaredArg.parseArg) {
            value = value.reduce((processed, v) => {
              return myParseArg(declaredArg, v, processed);
            }, declaredArg.defaultValue);
          }
        } else if (value === undefined) {
          value = [];
        }
      } else if (index < this.args.length) {
        value = this.args[index];
    });
    /**
     * Processes the arguments using the registered arguments and saves them as processedArgs.
     *
     * @api private
     */
    this.processedArgs = processedArgs;
  }

  /**
   * Once we have a promise we chain, but call synchronously until then.
   *
   * @param {Promise|undefined} promise
   * @param {Function} fn
   * @return {Promise|undefined}
   * @api private
   */

  _chainOrCall(promise, fn) {
    // thenable
    if (promise && promise.then && typeof promise.then === 'function') {
      // already have a promise, chain callback
      return promise.then(() => fn());
    }
    // callback might return a promise
    return fn();
  }

  /**
   *
   * @param {Promise|undefined} promise
   * @param {string} event
   * @return {Promise|undefined}
   * @api private
   */

  _chainOrCallHooks(promise, event) {
    let result = promise;
    const hooks = [];
    this._getCommandAndAncestors()
      .reverse()
      .filter(cmd => cmd._lifeCycleHooks[event] !== undefined)
      .forEach(hookedCommand => {
        hookedCommand._lifeCycleHooks[event].forEach((callback) => {
          hooks.push({ hookedCommand, callback });
        return hookDetail.callback(hookDetail.hookedCommand, this);
      /**
       * Once we have a promise we chain, but call synchronously until then.
       *
       * @param {Promise|undefined} promise - The promise to chain or undefined if no promise is available.
       * @param {Function} fn - The function to call either synchronously or after the promise resolves.
       * @return {Promise|undefined} - A new promise that will resolve when the original promise (if any) has resolved, or undefined if no promise was provided.
       * @api private
       */
      });
    });
    return result;
  }

  /**
   *
   * @param {Promise|undefined} promise
   * @param {Command} subCommand
   * @param {string} event
      this._lifeCycleHooks[event].forEach((hook) => {
        /**
         * Chains or calls hooks for a given event.
         *
         * @param {Promise|undefined} promise - The initial promise to chain with.
         * @param {string} event - The event for which hooks are to be executed.
         * @return {Promise|undefined} - Returns the modified promise if hooks are chained, otherwise returns the original promise.
         * @api private
         */
        result = this._chainOrCall(result, () => {
          return hook(this, subCommand);
        });
      });
    }
    return result;
  }

  /**
   * Process arguments in context of this command.
   * Returns action result, in case it is a promise.
   *
   * @api private
   */

  _parseCommand(operands, unknown) {
    const parsed = this.parseOptions(unknown);
    this._parseOptionsEnv(); // after cli, so parseArg not called on both cli and env
    this._parseOptionsImplied();
    operands = operands.concat(parsed.operands);
    unknown = parsed.unknown;
    this.args = operands.concat(unknown);

      return this._dispatchSubcommand(this._defaultCommandName, operands, unknown);
    /**
     * Chains or calls the lifecycle hook associated with the given event.
     *
     * @param {Promise|undefined} promise - The current promise to chain with, or undefined if no chaining is needed.
     * @param {Command} subCommand - The sub-command instance for which the hook should be executed.
     * @param {string} event - The lifecycle event for which the hook should be called.
     * @return {Promise|undefined} - The resulting promise after chaining the hooks, or undefined if no hooks are present.
     * @api private
     */
    }
    if (this.commands.length && this.args.length === 0 && !this._actionHandler && !this._defaultCommandName) {
      // probably missing subcommand and no handler, user needs help (and exit)
      this.help({ error: true });
    }

    outputHelpIfRequested(this, parsed.unknown);
    this._checkForMissingMandatoryOptions();
    this._checkForConflictingOptions();

    // We do not always call this check to avoid masking a "better" error, like unknown command.
    /**
     * @returns {void}
     /**
      * Processes arguments in the context of this command.
      * Returns an action result if it is a promise.
      *
      * @private
      * @param {string[]} operands - The operands to be processed.
      * @param {string[]} unknown - Unknown options or commands.
      * @returns {Promise|undefined} - A promise if the action handler returns a promise, otherwise undefined.
      */
     *
     * @example
     * checkForUnknownOptions({ unknown: ['option1', 'option2'] });
     * // Calls this.unknownOption('option1');
     */
    const checkForUnknownOptions = () => {
      if (parsed.unknown.length > 0) {
        this.unknownOption(parsed.unknown[0]);
      }
    };

    const commandEvent = `command:${this.name()}`;
    if (this._actionHandler) {
      checkForUnknownOptions();
      this._processArguments();

      let promiseChain;
      promiseChain = this._chainOrCallHooks(promiseChain, 'preAction');
      promiseChain = this._chainOrCall(promiseChain, () => this._actionHandler(this.processedArgs));
      if (this.parent) {
        promiseChain = this._chainOrCall(promiseChain, () => {
          this.parent.emit(commandEvent, operands, unknown); // legacy
        });
      }
      promiseChain = this._chainOrCallHooks(promiseChain, 'postAction');
      return promiseChain;
    }
    if (this.parent && this.parent.listenerCount(commandEvent)) {
      checkForUnknownOptions();
      this._processArguments();
      this.parent.emit(commandEvent, operands, unknown); // legacy
    } else if (operands.length) {
      if (this._findCommand('*')) { // legacy default command
        return this._dispatchSubcommand('*', operands, unknown);
      }
      if (this.listenerCount('command:*')) {
        // skip option check, emit event for possible misspelling suggestion
        this.emit('command:*', operands, unknown);
      } else if (this.commands.length) {
        this.unknownCommand();
      } else {
        checkForUnknownOptions();
        this._processArguments();
      }
    } else if (this.commands.length) {
      checkForUnknownOptions();
      // This command has subcommands and nothing hooked up at this level, so display help (and exit).
      this.help({ error: true });
    } else {
      checkForUnknownOptions();
      this._processArguments();
      // fall through for caller to handle after calling .parse()
    }
  }

  /**
   * Find matching command.
   *
   * @api private
   */
  _findCommand(name) {
    if (!name) return undefined;
    return this.commands.find(cmd => cmd._name === name || cmd._aliases.includes(name));
  }

  /**
   * Return an option matching `arg` if any.
   *
   * @param {string} arg
   * @return {Option}
   * @api private
   */

  _findOption(arg) {
    return this.options.find(option => option.is(arg));
  }

  /**
/**
 * Find matching command.
 *
 * @private
 * @param {string} name - The name or alias of the command to find.
 * @returns {Object|undefined} - The found command object if a match is found, otherwise undefined.
 *
 * @example
 * const command = _findCommand('ls');
 * console.log(command); // Output: { ... }
 */

  _checkForMissingMandatoryOptions() {
    // Walk up hierarchy so can call in subcommand after checking for displaying help.
    this._getCommandAndAncestors().forEach((cmd) => {
      cmd.options.forEach((anOption) => {
  /**
   /**
    * Searches for an option that matches the provided argument.
    *
    * @param {string} arg - The argument to match against options.
    * @return {Option} - The matching Option object, or undefined if no match is found.
    * @api private
    */
   * Display an error message if conflicting options are used together in this.
   *
   * @api private
   */
        }
        /**
         * Checks if any mandatory options are missing values and displays an error message if so.
         *
         * This method is intended to be called after checking for help flags in leaf subcommands. It traverses up the command hierarchy,
         * examining each option's value. If a mandatory option does not have a value, it calls the `missingMandatoryOptionValue` method
         * on the current command.
         *
         * @api private
         */
        return this.getOptionValueSource(optionKey) !== 'default';
      }
    );

    const optionsWithConflicting = definedNonDefaultOptions.filter(
      (option) => option.conflictsWith.length > 0
    );

    optionsWithConflicting.forEach((option) => {
      const conflictingAndDefined = definedNonDefaultOptions.find((defined) =>
        option.conflictsWith.includes(defined.attributeName())
  /**
   * Check for and display error messages if conflicting options are used together.
   *
   * This method iterates through the defined non-default options and checks for any that conflict with other options. If a conflict is found, it calls the `_conflictingOption` method to handle the error.
   *
   * @private
   * @return {void}
   * @throws {Error} If conflicting options are detected and no handler is available.
   */
  }

  /**
   * Display an error message if conflicting options are used together.
   * Called after checking for help flags in leaf subcommand.
   *
   * @api private
   */
  _checkForConflictingOptions() {
    // Walk up hierarchy so can call in subcommand after checking for displaying help.
    this._getCommandAndAncestors().forEach((cmd) => {
      cmd._checkForConflictingLocalOptions();
    });
  }

  /**
   * Parse options from `argv` removing known options,
   * and return argv split into operands and unknown arguments.
   *
   * Examples:
   *
   *     argv => operands, unknown
   *     --known kkk op => [op], []
   *     op --known kkk => [op], []
   *     sub --unknown uuu op => [sub], [--unknown uuu op]
  /**
   * Display an error message if conflicting options are used together.
   * Called after checking for help flags in leaf subcommand.
   *
   * @api private
   */
  parseOptions(argv) {
    const operands = []; // operands, not options or values
    const unknown = []; // first unknown option and remaining unknown args
    let dest = operands;
    const args = argv.slice();

    /**
      if (arg === '--') {
        /**
         * Parse options from `argv` removing known options,
         * and return argv split into operands and unknown arguments.
         *
         * @param {String[]} argv - The array of command-line arguments to be parsed.
         * @return {{operands: String[], unknown: String[]}}
         * @throws {Error} If a required option is missing a value.
         *
         * @example
         * parseOptions(["--known", "kkk", "op"]) // => { operands: ["op"], unknown: [] }
         * @example
         * parseOptions(["op", "--known", "kkk"]) // => { operands: ["op"], unknown: [] }
         * @example
         * parseOptions(["sub", "--unknown", "uuu", "op"]) // => { operands: ["sub"], unknown: ["--unknown", "uuu", "op"] }
         * @example
         * parseOptions(["sub", "--", "--unknown", "uuu", "op"]) // => { operands: ["sub", "--unknown", "uuu", "op"], unknown: [] }
         */
        if (dest === unknown) dest.push(arg);
        dest.push(...args);
        break;
      }

      if (activeVariadicOption && !maybeOption(arg)) {
        this.emit(`option:${activeVariadicOption.name()}`, arg);
        continue;
      }
      activeVariadicOption = null;

      if (maybeOption(arg)) {
        const option = this._findOption(arg);
        // recognised option, call listener to assign value with possible custom processing
        if (option) {
          if (option.required) {
            const value = args.shift();
            if (value === undefined) this.optionMissingArgument(option);
            this.emit(`option:${option.name()}`, value);
          } else if (option.optional) {
            let value = null;
            // historical behaviour is optional value is following arg unless an option
            if (args.length > 0 && !maybeOption(args[0])) {
              value = args.shift();
            }
            this.emit(`option:${option.name()}`, value);
          } else { // boolean flag
            this.emit(`option:${option.name()}`);
          }
          activeVariadicOption = option.variadic ? option : null;
          continue;
        }
      }

      // Look for combo options following single dash, eat first one if known.
      if (arg.length > 2 && arg[0] === '-' && arg[1] !== '-') {
        const option = this._findOption(`-${arg[1]}`);
        if (option) {
          if (option.required || (option.optional && this._combineFlagAndOptionalValue)) {
            // option with value following in same argument
            this.emit(`option:${option.name()}`, arg.slice(2));
          } else {
            // boolean option, emit and put back remainder of arg for further processing
            this.emit(`option:${option.name()}`);
            args.unshift(`-${arg.slice(2)}`);
          }
          continue;
        }
      }

      // Look for known long flag with value, like --foo=bar
      if (/^--[^=]+=/.test(arg)) {
        const index = arg.indexOf('=');
        const option = this._findOption(arg.slice(0, index));
        if (option && (option.required || option.optional)) {
          this.emit(`option:${option.name()}`, arg.slice(index + 1));
          continue;
        }
      }

      // Not a recognised option by this command.
      // Might be a command-argument, or subcommand option, or unknown option, or help command or option.

      // An unknown option means further arguments also classified as unknown so can be reprocessed by subcommands.
      if (maybeOption(arg)) {
        dest = unknown;
      }

      // If using positionalOptions, stop processing our options at subcommand.
      if ((this._enablePositionalOptions || this._passThroughOptions) && operands.length === 0 && unknown.length === 0) {
        if (this._findCommand(arg)) {
          operands.push(arg);
          if (args.length > 0) unknown.push(...args);
          break;
        } else if (arg === this._helpCommandName && this._hasImplicitHelpCommand()) {
          operands.push(arg);
          if (args.length > 0) operands.push(...args);
          break;
        } else if (this._defaultCommandName) {
          unknown.push(arg);
          if (args.length > 0) unknown.push(...args);
          break;
        }
      }

      // If using passThroughOptions, stop processing options at first command-argument.
      if (this._passThroughOptions) {
        dest.push(arg);
        if (args.length > 0) dest.push(...args);
        break;
      }

      // add arg
      dest.push(arg);
    }

    return { operands, unknown };
  }

  /**
   * Return an object containing local option values as key-value pairs.
   *
   * @return {Object}
   */
  opts() {
    if (this._storeOptionsAsProperties) {
      // Preserve original behaviour so backwards compatible when still using properties
      const result = {};
      const len = this.options.length;

      for (let i = 0; i < len; i++) {
        const key = this.options[i].attributeName();
        result[key] = key === this._versionOptionName ? this._version : this[key];
      }
      return result;
    }
   /**
    * Return an object containing local option values as key-value pairs.
    *
    * @returns {Object} An object where keys are attribute names and values are the corresponding option values.
    */
   * Return an object containing merged local and global option values as key-value pairs.
   *
   * @return {Object}
   */
  optsWithGlobals() {
    // globals overwrite locals
    return this._getCommandAndAncestors().reduce(
      (combinedOptions, cmd) => Object.assign(combinedOptions, cmd.opts()),
      {}
    );
  }

  /**
   * Display error message and exit (or call exitOverride).
   *
   * @param {string} message
    /**
     * Merges local and global option values into a single object, with global options
     * overwriting local options.
     *
     * @return {Object}
     *   An object containing merged local and global option values as key-value pairs.
     *
     * @throws {Error} - Throws an error if any of the commands in the ancestor chain have invalid options.
     */
    // output handling
    this._outputConfiguration.outputError(`${message}\n`, this._outputConfiguration.writeErr);
    if (typeof this._showHelpAfterError === 'string') {
      this._outputConfiguration.writeErr(`${this._showHelpAfterError}\n`);
    } else if (this._showHelpAfterError) {
      this._outputConfiguration.writeErr('\n');
      this.outputHelp({ error: true });
    }
  /**
   * Display error message and exit (or call exitOverride).
   *
   * @param {string} message - The error message to display.
   * @param {Object} [errorOptions] - Optional configuration options for the error.
   * @param {string} [errorOptions.code='commander.error'] - An identifier string representing the error. Default is 'commander.error'.
   * @param {number} [errorOptions.exitCode=1] - The exit code to use with `process.exit`. Default is 1.
   */
  /**
   * Apply any option related environment variables, if option does
   * not have a value from cli or client code.
   *
   * @api private
   */
  _parseOptionsEnv() {
    this.options.forEach((option) => {
      if (option.envVar && option.envVar in process.env) {
        const optionKey = option.attributeName();
        // Priority check. Do not overwrite cli or options from unknown source (client-code).
        if (this.getOptionValue(optionKey) === undefined || ['default', 'config', 'env'].includes(this.getOptionValueSource(optionKey))) {
          if (option.required || option.optional) { // option can take a value
            // keep very simple, optional always takes value
            this.emit(`optionEnv:${option.name()}`, process.env[option.envVar]);
          } else { // boolean
            // keep very simple, only care that envVar defined and not the value
/**
 * Apply any option related environment variables, if option does not have a value from cli or client code.
 *
 * @private
 */

  /**
   * Apply any implied option values, if option is undefined or default value.
   *
   * @api private
   */
  _parseOptionsImplied() {
    const dualHelper = new DualOptions(this.options);
    const hasCustomOptionValue = (optionKey) => {
      return this.getOptionValue(optionKey) !== undefined && !['default', 'implied'].includes(this.getOptionValueSource(optionKey));
    };
    this.options
      .filter(option => (option.implied !== undefined) &&
        hasCustomOptionValue(option.attributeName()) &&
        dualHelper.valueFromOption(this.getOptionValue(option.attributeName()), option))
      .forEach((option) => {
        Object.keys(option.implied)
          .filter(impliedKey => !hasCustomOptionValue(impliedKey))
/**
 * Applies any implied option values if the option is undefined or has a default value.
 *
 * This method processes each option in the instance's options list. If an option is marked as 'implied',
 * and it has a custom value (not derived from 'default' or 'implied'), it checks its implied properties.
 * For each implied property that does not have a custom value, it sets the implied property to the implied
 * value, marking it as an implied option.
 *
 * @api private
 */

  /**
   * Argument `name` is missing.
   *
   * @param {string} name
   * @api private
   */

  missingArgument(name) {
    const message = `error: missing required argument '${name}'`;
    this.error(message, { code: 'commander.missingArgument' });
  }

  /**
   * `Option` is missing an argument.
   *
   * @param {Option} option
   * @api private

  /**
   * Logs an error message indicating that a required argument is missing.
   *
   * @param {string} name - The name of the missing argument.
   * @api private
   */
  /**
   * `Option` does not have a value, and is a mandatory option.
   *
   * @param {Option} option
   * @api private

  /**
   * Handles the scenario where an `Option` is missing its required argument.
   *
   * @param {Option} option - The Option instance that is missing its argument.
   * @private
   */
  /**
   * `Option` conflicts with another option.
   *
   * @param {Option} option
   * @param {Option} conflictingOption
     * Determines the best option based on its value and the current options configuration.
     /**
      * Throws an error if a mandatory option is not specified.
      *
      * @param {Option} option - The option to check for a value.
      * @throws {Error} - Throws an error with a message indicating that the required option was not specified, and includes an error code 'commander.missingMandatoryOptionValue'.
      * @api private
      */
     *
     * @param {Object} option - The option object to evaluate.
     * @returns {Object} The best option found, or the original option if no better one is found.
     */
    const findBestOptionFromValue = (option) => {
      /**
       * Handles the conflict between two options.
       *
       * @param {Option} option - The first option that is conflicting.
       * @param {Option} conflictingOption - The second option that conflicts with the first.
       * @api private
       */
      )) {
        return negativeOption;
      }
      return positiveOption || option;
    };

    /**
     * Generates an error message based on the provided option.
     *
     * @param {Option} option - The option object for which to generate the error message.
     * @returns {string} The error message describing the source of the option.
     * @throws {Error} If the option does not have a valid source.
     *
     * Example:
     * const errorMessage = getErrorMessage(option);
     * console.log(errorMessage); // Outputs: 'environment variable 'MY_ENV_VAR'' or 'option '--my-flag''
     */
    const getErrorMessage = (option) => {
      const bestOption = findBestOptionFromValue(option);
      const optionKey = bestOption.attributeName();
      const source = this.getOptionValueSource(optionKey);
      if (source === 'env') {
        return `environment variable '${bestOption.envVar}'`;
      }
      return `option '${bestOption.flags}'`;
    };

    const message = `error: ${getErrorMessage(option)} cannot be used with ${getErrorMessage(conflictingOption)}`;
    this.error(message, { code: 'commander.conflictingOption' });
  }


  /**
   * Handles an unknown option by throwing an error or suggesting a similar option.
   *
   * @param {string} flag - The unknown option flag that was encountered.
   * @api private
   * @throws {Error} If the `_allowUnknownOption` is not set and no suggestion can be provided.
   */
  unknownOption(flag) {
    if (this._allowUnknownOption) return;
    let suggestion = '';

    if (flag.startsWith('--') && this._showSuggestionAfterError) {
      // Looping to pick up the global options too
      let candidateFlags = [];
      let command = this;
      do {
        const moreFlags = command.createHelp().visibleOptions(command)
          .filter(option => option.long)
          .map(option => option.long);
        candidateFlags = candidateFlags.concat(moreFlags);
        command = command.parent;
      } while (command && !command._enablePositionalOptions);
      suggestion = suggestSimilar(flag, candidateFlags);
    }

    const message = `error: unknown option '${flag}'${suggestion}`;
    this.error(message, { code: 'commander.unknownOption' });
  }


  /**
   * Handles excess arguments that are received by the command handler.
   *
   * @param {string[]} receivedArgs - An array of strings representing the arguments that were received.
   * @api private
   */
  _excessArguments(receivedArgs) {
    if (this._allowExcessArguments) return;

    const expected = this.registeredArguments.length;
    const s = (expected === 1) ? '' : 's';
    const forSubcommand = this.parent ? ` for '${this.name()}'` : '';
    const message = `error: too many arguments${forSubcommand}. Expected ${expected} argument${s} but got ${receivedArgs.length}.`;
    this.error(message, { code: 'commander.excessArguments' });
  }


  /**
   * Handles an unknown command by suggesting similar commands if enabled.
   *
   * @api private
   */
  unknownCommand() {
    const unknownName = this.args[0];
    let suggestion = '';

    if (this._showSuggestionAfterError) {
      const candidateNames = [];
      this.createHelp().visibleCommands(this).forEach((command) => {
        candidateNames.push(command.name());
        // just visible alias
        if (command.alias()) candidateNames.push(command.alias());
      });
      suggestion = suggestSimilar(unknownName, candidateNames);
    }

    const message = `error: unknown command '${unknownName}'${suggestion}`;
    this.error(message, { code: 'commander.unknownCommand' });
  }


  /**
   * Get or set the program version.
   *
   * This method auto-registers the "-V, --version" option which will print the version number.
   *
   * You can optionally supply the flags and description to override the defaults.
   *
   * @param {string} [str] - The version string to set. If not provided, returns the current version string.
   * @param {string} [flags='-V, --version'] - The option flags to use for the version option.
   * @param {string} [description='output the version number'] - The description of the version option.
   * @returns {this | string | undefined} If `str` is not provided, returns the current version string. Otherwise, returns `this` command for chaining.
   */
  version(str, flags, description) {
    if (str === undefined) return this._version;
    this._version = str;
    flags = flags || '-V, --version';
    description = description || 'output the version number';
    const versionOption = this.createOption(flags, description);
    this._versionOptionName = versionOption.attributeName(); // [sic] not defined in constructor, partly legacy, partly only needed at root
    this.options.push(versionOption);
    this.on('option:' + versionOption.name(), () => {
      this._outputConfiguration.writeOut(`${str}\n`);
      this._exit(0, 'commander.version', str);
    });
    return this;
  }

  /**
   * Set or retrieve the description of the current object.
   *
   * @param {string} [str] - The new description string. If not provided, the current description is returned.
   * @param {Object} [argsDescription] - An optional object containing descriptions for arguments.
   * @returns {string|Command} - Returns the current description if no parameters are provided; otherwise, returns the modified object instance.
   *
   * Example:
   *   let command = new Command();
   *   command.description('This is a command', { arg1: 'Description of arg1' });
   *   console.log(command.description()); // Outputs: This is a command
   */
  description(str, argsDescription) {
    if (str === undefined && argsDescription === undefined) return this._description;
    this._description = str;
    if (argsDescription) {
      this._argsDescription = argsDescription;
    }
    return this;
  }

  /**
   * Set the summary. Used when listed as subcommand of parent.
   *
   * @param {string} [str] - The new summary string to set. If not provided, returns the current summary.
   * @return {string|Command}
   *   - Returns the current summary if no parameter is provided.
   *   - Returns the modified command instance if a parameter is provided.
   *
   * Example:
   * ```javascript
   * // Set the summary and get the command instance
   * const command = new Command().summary('This is a summary');
   *
   * // Get the current summary
   * const summary = command.summary();
   * ```
   */
  summary(str) {
    if (str === undefined) return this._summary;
    this._summary = str;
    return this;
  }


  /**
   * Set an alias for the command.
   *
   * You may call more than once to add multiple aliases. Only the first alias is shown in the auto-generated help.
   *
   * @param {string} [alias] - The alias to be set for the command. If not provided, the method returns the first alias of the command.
   * @return {string|Command} - Returns either the first alias of the command or the command itself if an alias is set.
   * @throws {Error} - Throws an error if the provided alias is the same as the command's name.
   *
   * @example
   * // Set a single alias for the command
   * myCommand.alias('short');
   *
   * // Get the first alias of the command
   * const firstAlias = myCommand.alias();
   */
  alias(alias) {
    if (alias === undefined) return this._aliases[0]; // just return first, for backwards compatibility

    /** @type {Command} */
    let command = this;
    if (this.commands.length !== 0 && this.commands[this.commands.length - 1]._executableHandler) {
      // assume adding alias for last added executable subcommand, rather than this
      command = this.commands[this.commands.length - 1];
    }

    if (alias === command._name) throw new Error('Command alias can\'t be the same as its name');

    command._aliases.push(alias);
    return this;
  }


  /**
   * Set aliases for the command.
   *
   * Only the first alias is shown in the auto-generated help.
   *
   * @param {string[]} [aliases] - An array of strings representing the aliases to be set. If not provided, the current array of aliases will be returned.
   * @return {string[]|Command} - Returns an array of aliases if `aliases` is undefined, otherwise returns the Command object itself for method chaining.
   */
  aliases(aliases) {
    // Getter for the array of aliases is the main reason for having aliases() in addition to alias().
    if (aliases === undefined) return this._aliases;

    aliases.forEach((alias) => this.alias(alias));
    return this;
  }


  /**
   * Set or get the command usage string.
   *
   * @param {string} [str] - The usage string to set. If not provided, the current usage string is returned.
   * @return {String|Command}
   *   - Returns the current usage string if no parameter is provided.
   *   - Returns the Command instance for method chaining if a parameter is provided.
   *
   * @example
   * // Get the current command usage
   * const currentUsage = command.usage();
   *
   * @example
   * // Set the command usage
   * command.usage('[options] [command] <arg>');
   */
  usage(str) {
    if (str === undefined) {
      if (this._usage) return this._usage;

      const args = this.registeredArguments.map((arg) => {
        return humanReadableArgName(arg);
      });
      return [].concat(
        (this.options.length || this._hasHelpOption ? '[options]' : []),
        (this.commands.length ? '[command]' : []),
        (this.registeredArguments.length ? args : [])
      ).join(' ');
    }

    this._usage = str;
    return this;
  }


  /**
   * Get or set the name of the command.
   *
   * @param {string} [str] - The new name for the command. If not provided, returns the current name.
   * @return {string|Command} - Returns the current name if no new name is provided; otherwise, returns the Command object itself to allow method chaining.
   */
  name(str) {
    if (str === undefined) return this._name;
    this._name = str;
    return this;
  }


  /**
   * Sets the name of the command from a script filename.
   *
   * This method is used internally and is also exposed publicly, though it is not documented in the README.
   *
   * @param {string} filename - The path to the script file whose base name will be set as the command's name.
   * @returns {Command} - The current instance of the Command object, allowing for method chaining.
   *
   * @example
   * program.nameFromFilename(require.main.filename);
   */
  nameFromFilename(filename) {
    this._name = path.basename(filename, path.extname(filename));

    return this;
  }


  /**
   * Get or set the directory for searching for executable subcommands of this command.
   *
   * @param {string} [path] - The path to the directory. If not provided, the current value is returned.
   * @returns {string|null|Command}
   *
   * @example
   * program.executableDir(__dirname);
   * // or
   * program.executableDir('subcommands');
   */
  executableDir(path) {
    if (path === undefined) return this._executableDir;
    this._executableDir = path;
    return this;
  }


  /**
   * Return program help documentation.
   *
   * @param {{ error: boolean }} [contextOptions] - Optional parameter to specify the context in which the help information should be formatted. If {error:true} is provided, the help information will be wrapped for stderr instead of stdout.
   * @return {string} The formatted help documentation as a string.
   */
  helpInformation(contextOptions) {
    const helper = this.createHelp();
    if (helper.helpWidth === undefined) {
      helper.helpWidth = (contextOptions && contextOptions.error) ? this._outputConfiguration.getErrHelpWidth() : this._outputConfiguration.getOutHelpWidth();
    }
    return helper.formatHelp(this, helper);
  }


  /**
   * Generates the context object for help messages.
   *
   * @private
   * @param {Object} [contextOptions={}] - The options for the context.
   * @param {boolean} [contextOptions.error=false] - Indicates if the context is for an error message.
   * @param {Function} [contextOptions.write] - Custom write function for output.
   * @returns {Object} The configured context object.
   */
  _getHelpContext(contextOptions) {
    contextOptions = contextOptions || {};
    const context = { error: !!contextOptions.error };
    let write;
    if (context.error) {
      write = (arg) => this._outputConfiguration.writeErr(arg);
    } else {
      write = (arg) => this._outputConfiguration.writeOut(arg);
    }
    context.write = contextOptions.write || write;
    context.command = this;
    return context;
  }


  /**
   * Outputs help information for this command.
   *
   * Outputs built-in help, and custom text added using `.addHelpText()`.
   *
   * @param {Object|Function} [contextOptions] - Options or a callback function to customize the help output.
   *   - {boolean} error - Set to true to write to stderr instead of stdout.
   *   - {Function} contextOptions - A function that can modify the help information before it is written.
   *
   * @throws {Error} If the callback function does not return a string or a Buffer.
   */
  outputHelp(contextOptions) {
    let deprecatedCallback;
    if (typeof contextOptions === 'function') {
      deprecatedCallback = contextOptions;
      contextOptions = undefined;
    }
    const context = this._getHelpContext(contextOptions);

    this._getCommandAndAncestors().reverse().forEach(command => command.emit('beforeAllHelp', context));
    this.emit('beforeHelp', context);

    let helpInformation = this.helpInformation(context);
    if (deprecatedCallback) {
      helpInformation = deprecatedCallback(helpInformation);
      if (typeof helpInformation !== 'string' && !Buffer.isBuffer(helpInformation)) {
        throw new Error('outputHelp callback must return a string or a Buffer');
      }
    }
    context.write(helpInformation);

    if (this._helpLongFlag) {
      this.emit(this._helpLongFlag); // deprecated
    }
    this.emit('afterHelp', context);
    this._getCommandAndAncestors().forEach(command => command.emit('afterAllHelp', context));
  }


  /**
   * You can pass in flags and a description to override the help flags and help description for your command. Pass in false to disable the built-in help option.
   *
   * @param {string | boolean} [flags] - The flags to be used for the help option, or a boolean indicating whether the help option is enabled.
   * @param {string} [description] - The description of the help option.
   * @return {Command} `this` command for chaining.
   */
  helpOption(flags, description) {
    if (typeof flags === 'boolean') {
      this._hasHelpOption = flags;
      return this;
    }
    this._helpFlags = flags || this._helpFlags;
    this._helpDescription = description || this._helpDescription;

    const helpFlags = splitOptionFlags(this._helpFlags);
    this._helpShortFlag = helpFlags.shortFlag;
    this._helpLongFlag = helpFlags.longFlag;

    return this;
  }


  /**
   * Output help information and exit.
   *
   * Outputs built-in help, and custom text added using `.addHelpText()`.
   *
   * @param {Object} [contextOptions] - Options object for the help context.
   * @param {boolean} [contextOptions.error=false] - If true, writes to stderr instead of stdout.
   */
  help(contextOptions) {
    this.outputHelp(contextOptions);
    let exitCode = process.exitCode || 0;
    if (exitCode === 0 && contextOptions && typeof contextOptions !== 'function' && contextOptions.error) {
      exitCode = 1;
    }
    // message: do not have all displayed text available so only passing placeholder.
    this._exit(exitCode, 'commander.help', '(outputHelp)');
  }

  /**
   * Add additional text to be displayed with the built-in help.
   *
   * Position is 'before' or 'after' to affect just this command,
   * and 'beforeAll' or 'afterAll' to affect this command and all its subcommands.
   *
   * @param {string} position - The position where the help text should be added. Must be one of 'beforeAll', 'before', 'after', 'afterAll'.
   * @param {string | Function} text - The text to add, or a function that returns a string. If a function is provided, it will receive an object with `error` and `command` properties.
   * @return {Command} Returns the current command instance for chaining.
   * @throws {Error} Throws an error if the `position` parameter is not one of 'beforeAll', 'before', 'after', 'afterAll'.
   *
   * @example
   * // Add static text before help
   * myCommand.addHelpText('before', 'This is additional help text');
   *
   * @example
   * // Add dynamic text based on error and command
   * myCommand.addHelpText('after', (context) => {
   *   if (context.error) {
   *     return `Error occurred: ${context.error.message}`;
   *   }
   *   return 'No errors.';
   * });
   */
  addHelpText(position, text) {
    const allowedValues = ['beforeAll', 'before', 'after', 'afterAll'];
    if (!allowedValues.includes(position)) {
      throw new Error(`Unexpected value for position to addHelpText.
Expecting one of '${allowedValues.join("', '")}'`);
    }
    const helpEvent = `${position}Help`;
    this.on(helpEvent, (context) => {
      let helpStr;
      if (typeof text === 'function') {
        helpStr = text({ error: context.error, command: context.command });
      } else {
        helpStr = text;
      }
      // Ignore falsy value when nothing to output.
      if (helpStr) {
        context.write(`${helpStr}\n`);
      }
    });
    return this;
  }
}


/**
 * Output help information if help flags specified
 *
 * @param {Command} cmd - command to output help for
 * @param {Array} args - array of options to search for help flags
 * @api private
 */
function outputHelpIfRequested(cmd, args) {
  const helpOption = cmd._hasHelpOption && args.find(arg => arg === cmd._helpLongFlag || arg === cmd._helpShortFlag);
  if (helpOption) {
    cmd.outputHelp();
    // (Do not have all displayed text available so only passing placeholder.)
    cmd._exit(0, 'commander.helpDisplayed', '(outputHelp)');
  }
}


/**
 * Scan arguments and increment port number for inspect calls (to avoid conflicts when spawning new command).
 *
 * @param {string[]} args - array of arguments from node.execArgv
 * @returns {string[]}
 * @api private
 */
function incrementNodeInspectorPort(args) {
  // Testing for these options:
  //  --inspect[=[host:]port]
  //  --inspect-brk[=[host:]port]
  //  --inspect-port=[host:]port
  return args.map((arg) => {
    if (!arg.startsWith('--inspect')) {
      return arg;
    }
    let debugOption;
    let debugHost = '127.0.0.1';
    let debugPort = '9229';
    let match;
    if ((match = arg.match(/^(--inspect(-brk)?)$/)) !== null) {
      // e.g. --inspect
      debugOption = match[1];
    } else if ((match = arg.match(/^(--inspect(-brk|-port)?)=([^:]+)$/)) !== null) {
      debugOption = match[1];
      if (/^\d+$/.test(match[3])) {
        // e.g. --inspect=1234
        debugPort = match[3];
      } else {
        // e.g. --inspect=localhost
        debugHost = match[3];
      }
    } else if ((match = arg.match(/^(--inspect(-brk|-port)?)=([^:]+):(\d+)$/)) !== null) {
      // e.g. --inspect=localhost:1234
      debugOption = match[1];
      debugHost = match[3];
      debugPort = match[4];
    }

    if (debugOption && debugPort !== '0') {
      return `${debugOption}=${debugHost}:${parseInt(debugPort) + 1}`;
    }
    return arg;
  });
}

exports.Command = Command;
